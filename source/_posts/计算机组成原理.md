---
title: 计算机组成原理教程
date: 2022-07-22 15:43:20
tags: 计算机基础
description: 该文章图片比较多注意流量消耗
mathjax: true
categories: 计算机基础
cover: "https://s2.loli.net/2022/11/21/IQmvSdtKfOAjikn.webp"
top_group_index: 1
---

# 第一章：计算机系统概述

## 计算机的发展

{% tip %}什么是计算机系统{% endtip %}

计算机系统 = 硬件 + 软件

计算机性能的好坏取决于“软”“硬”件的总和 

软件：

{% tabs 软件 %}

<!--tab 系统软件 -->

- 用来管理整个计算机系统
- 操作系统，数据库管理系统(DBMS）、标准程序库，网络软件、语言处理程序、服务程序

<!-- endtab -->

<!--tab 应用软件 -->

- 按任务需编制成各种程序
- 抖音，王者荣耀，迅雷....

<!-- endtab -->

{% endtabs %}



{% tip %}硬件的发展{% endtip %}

| 发展阶段 |   时间    |         逻辑元件         | 速度（次/秒） |      内存      |              外存              | 影响                                                         |
| :------: | :-------: | :----------------------: | :-----------: | :------------: | :----------------------------: | ------------------------------------------------------------ |
|  第一代  | 1946-1957 |          电子管          |   几千-几万   | 汞延迟线，磁鼓 |         穿孔卡带，纸袋         | 体积超大，耗电量超大<br />使用纸带机编程                     |
|  第二代  | 1958-1964 |          晶体管          |  几万-几十万  |   磁芯存储器   |              磁带              | 体积、功耗降低<br/>出现面向过程的程序设计语言:FORTRAN<br />有了操作系统维形 |
|  第三代  | 1964-1971 |     中小规模集成电路     | 几十万-几百万 |  半导体存储器  |           磁带，磁盘           | 计算机主要用于科学计算等专业用途<br />高级语言迅速发展<br/>开始有了分时操作系统 |
|  第四代  | 1972-现在 | 大规模，超大规模集成电路 |  上千万-万亿  |  半导体存储器  | 磁带，磁盘，光盘，半导体存储器 | 出现许多微处理器，微型计算机                                 |



- 1947年，贝尔实验室，发明了“{% span red, 晶体管 %}”
- 1955年，肖克利在硅谷创建肖克利实验室股份有限公司
- 1957年，八叛徒(traitorous eight)创立仙童半导体公司.
- 1959年，仙童半导体公司发明“{% span red, 集成电路 %}”
- 1968年，摩尔筹人离开仙童，创立Intel
- 1969年，仙童销售部负责人桑德斯离开仙童，创立AMD



摩尔定律：

- 揭示了信息技术进步的速度
- 集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍



半导体存储器的发展：

- 1970年，仙童公司生产出第一个较大容量的半导体存储器
- 半导体存储器单芯片容量:1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB、1GB...



{% tip %}软件的发展{% endtip %}

语言的发展：

- 机器语言
- 汇编语言
- FORTRAN
- PASCAL
- C++
- JAVA

操作系统的发展

- dos
- windows



{% tip %}目前发展趋势{% endtip %}

“两极”分化:

- 一极是微型计算机向更微型化、网络化、高性能、多用途方向发展;
- 另一极是巨型机向更巨型化、超高速、并行处理、智能化方向发展。



![image-20220920102154067](https://s2.loli.net/2022/11/06/hToKM9aCJOqi67E.png)



## 计算机硬件的基本组成

### 早期冯诺依曼机的结构

原先早期的计算机是ENIAC（手动接线来控制计算）

冯诺依曼提出{% span red, 存储程序 %}的概念：

- “存储程序”的概念是指{% span red, 将指令以二进制代码的形式事先输入计算机的主存储器 %}，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。
- 第一台冯诺依曼计算机：EDVAC

![image-20220722155311901](https://s2.loli.net/2022/11/06/caxv4KM9EAjeypk.png)

冯诺依曼计算机的特点：

1. 计算机有5大部件组成
2. 指令和数据以同等地位存于存储器并且可以按照地址寻访
3. 指令和数据用二进制表示
4. 指令由操作码和地址码组成
5. 存储程序
6. {% span red, 以运算器为中心 %}.

### 现代计算机的结构

现代计算机的结构：

![image-20220722160620869](https://s2.loli.net/2022/11/06/Fn8f1BZQVbmsJEr.png)

以{% span red, 存储器为中心 %}，解放运算器

- {% label CPU red %} = 运算器 + 控制器

![image-20220920103700234](https://s2.loli.net/2022/11/06/d4iBTeqDmVwPX2S.png)





![image-20220920103722028](https://s2.loli.net/2022/11/06/YDdmjSlK29qEVpe.png)



## 各个硬件的工作原理

![image-20220920103958342](https://s2.loli.net/2022/11/06/tE4xcTYDL8g5QaO.png)

### 主存储器的基本组成

 ![image-20220920104744889](https://s2.loli.net/2022/11/06/rn1bqNPF4EBiVAM.png)

Memory Address Register(存储{% span red, 地址寄存器 %})

Memory Data Register(存储{% span red, 数据存储器 %})

- 使用CPU从存储区中读取数据
  - 首先需要把想要读取的数据地址放到 MAR 地址寄存器中
  - 主存储器，用MAR中的地址，从存储体中找到数据，并将数据放到MDR寄存器中
  - CPU从MDR中获取数据
- 使用CPU向存储区写入数据
  - 首先需要把想要写入的数据地址放到 MAR 地址寄存器中，并将想要写入的数据放到MDR寄存器中
  - 主存储器，用MAR中的地址，将MDR中的数据存放到MAR中



存储体的结构：

![image-20220920144139183](https://s2.loli.net/2022/11/06/2YGvL1XBiUWpR6m.png)

- {% span red, 存储单元 %}:每个存储单元存放一串二进制代码

- {% span red, 存储字(word) %}:存储单元中二进制代码的组合

- {% span red, 存储字长 %}:存储单元中二进制代码的位数

- {% span red, 存储元 %}:即存储二进制的电子元件，每个存储元可存1bit

例子：

-  MAR = 4位 ，总共有 $2^4$ 个存储单元
- MDR=16位，每个存储单元可以存放16bit， 一个字的大小为16bit
- 一个{% span red, 字节（Byte）%} = 8bit， 1B = 1个字节， 1b = 1bit
- 字的大小由机器决定



### 运算器的基本组成

![image-20220920145908988](https://s2.loli.net/2022/11/06/zRskxtZDXPKaeY6.png)

运算器:用于实现算术运算（如{% span red, :加减乘除 %}）、逻辑运算（如:与或非)

- {% span red, ACC:累加器 %}，用于存放操作数，或运算结果。
- {% span red, MQ:乘商寄存器 %}，在乘、除运算时，用于存放操作数或运算结果。

- {% span red, X：通用的操作数寄存器 %}，用于存放操作数
- {% span red, ALU:算术逻辑单元 %}，通过内部复杂的电路实现算数运算、逻辑运算

|                                   |     加     |     减     |       乘       |      除      |
| :-------------------------------: | :--------: | :--------: | :------------: | :----------: |
|         Accumulator(ACC)          | 被加数，和 | 被减数，差 |    乘积高位    | 被除数，余数 |
|  Multiple-Quotient Register(MQ)   |            |            | 乘数，乘积低位 |      商      |
| Arithmetic and Logic Unit(X, ALU) |    加数    |    减数    |     被乘数     |     除数     |



### 控制器的基本组成

![image-20220920150610647](https://s2.loli.net/2022/11/06/XJeTchS2jNI7Bd5.png)

- {% span red, CU(Control Unit) %}:控制单元，分析指令，给出控制信号

- {% span red, lR(Instruction Register) %}:指令寄存器,存放当前执行的指令

- {% span red, PC(Program Counter) %}:程序计数器,存放下一条指令地址，有自动加1功能

完成一条指令的过程（{% span red, 前两步统称为取值,第三步为执行 %} ）

- 取指令		PC	
- 分析指令     IR
- 执行指令     CU



### 计算机的工作过程

![image-20220921082336364](https://s2.loli.net/2022/11/06/reJmUTwltHgvoKu.png)

![image-20220921083017708](https://s2.loli.net/2022/11/06/VpFIdh7i8o9w6AB.png)

 

![image-20220921082942675](https://s2.loli.net/2022/11/06/XfW3wMa5qpIiRxt.png)

![image-20220921083255543](https://s2.loli.net/2022/11/06/FVMURQIjGgo4i1e.png)

![image-20220921083523352](https://s2.loli.net/2022/11/06/dmT7lZkpLc1uJRo.png)



![image-20220921083641397](https://s2.loli.net/2022/11/06/lApBF4dxy5PtmfE.png)



## 计算机系统的层次结构

从上到下越来越基础

- 虚拟机器M4（高级语言程序）
  - 用{% span red, 汇编程序翻译 %}成汇编语言程序
  - y = a*b+c
- 虚拟机器M3（汇编语言程序）
  - 用{% span red, 用汇编程序 %}翻译成机器语言程序
  - 和机器语言是一一对应的
  - LOAD 5
  - MUL 6
- 虚拟机器M2（操作系统机器）
  - 向上提供“广义指令”（系统调用）
- 传统机器M1（用机器语言的 程序）
  - 执行二进制指令
- 微程序机器M0（微指令系统）
  - 由硬件直接执行微指令

M0-M1 是硬件

M2-M4 是软件

- {% span red, 下层是上层的基础，上层是下层的扩展 %}



{% tip %}三种级别的语言{%  endtip %}

- 机器语言：二进制代码
  - 00010101011101
- 汇编语言：助记符
  - LOAD 5
  - MUL 6
- 高级语言：C、C++
  - y = a*b+c

高级语言需要通过{%span red, 编译程序（编译器）%} 翻译成汇编语言。

汇编语言通过{% span red, 汇编程序（汇编器）%}翻译成机器语言

有的高级语言也通过{% span red, 编译程序（编译器） %}直接翻译成机器语言，或者通过{% span red, 解释程序（解释器） %}翻译成机器语言

- 编译程序:将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（只需翻译一次)
- 解释程序:将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句(每次执行都要翻译)

![image-20220921092210422](https://s2.loli.net/2022/11/06/mbHW9UZVO5I83Gi.png)

计算机体系结构：

- 机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性(指令系统、数据类型、寻址技术、I/O机理）
- 如何设计硬件与软件之间的接口
- 有无乘法指令

计算机组成原理：

- 实现计算机体系结构所体现的属性，对程序员“透明”(具体指令的实现）
- 如何用硬件实现所定义的接口
- 如何实现乘法指令



## 计算机性能指标

### 存储器性能指标

![image-20220920104744889](https://s2.loli.net/2022/11/06/rn1bqNPF4EBiVAM.png)

MAR：

- 地址寄存器
- MAR的位数，反应存储单元的个数（最多支持多少个）

MDR

- 数据存储器
- MDR的位数“存储字长”，每个存储单元的大小

总容量

- 存储单元个数x存储字长bit 1Byte = 8bit
- 存储单元个数×存储字长/8 Byte

Eg：MAR为32位，MDR为8位， 总容量： $2^{32}*8bit=4G$



|  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   | 10   |  11  |  12  |  13  |  14   |  15   |  16   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | ---- | :--: | :--: | :--: | :---: | :---: | :---: |
|  2   |  4   |  8   |  16  |  32  |  64  | 128  | 256  | 512  | 1024 | 2048 | 4096 | 8192 | 16384 | 32768 | 65536 |

$2^{10}:k, 2^{20}:M, 2^{30}:G, 2^{40}:T$



### CPU性能指标

CPU主频：CPU内数字脉冲信号振荡的频率

![image-20220921095601648](https://s2.loli.net/2022/11/06/PBkiROQ4FYcEzwZ.png)

- {% span red, CPU主频(时钟频率) %} = 1/CPU时钟周期， 单位：赫兹， Hz
- {% span red, CPI (Clock cycle Per Instruction) %}:执行一条指令所需要的周期数
  - 不同指令，CPI不同，甚至相同的指令，CPI也可能出现变化
- {% span red, 执行一条指令的耗时 %}=CPI*CPU时钟周期

{% tip warning %}$1Khz=10^3hz,1Mhz=10^6hz,1Ghz=10^9hz,1Thz=10^{12}hz,1Phz=10^{15}hz,1Ehz=10^{18}hz${% endtip %}

{% tip warning %}$1s=10^3ms(毫秒)=10^6μs(微秒)=10^9ns(纳秒)=10^{12}ps(皮秒)=10^{15}fs(飞秒)=10^{18}as(阿秒)=10^{21}zm(仄秒)=10^{24}ym(幺秒)${% endtip %}

Eg:某CPU主频为1000Hz，某程序包含100条指令，平均来看指令的CPI=3，该程序在该CPU上执行需要多久?

- $100\times3\times1\div1000=0.3s$

- {% span red, CPU执行时间 %}（整个程序的耗时）=CPU时钟周期数/主频=(指令条数*CPI)/主频

- {% span red, IPS(Instructions Per Second) %}: 每秒执行多少指令      IPS = 主频/平均CPI

  - KIPS
  - MIPS

- {% span red, FLOPS (Floating-point Operations Per Second) %}: 每秒执行多少次浮点运算

  - KFLOPS
  - MFLOPS
  - GFLOPS
  - TFLOPS
  - 此处K、M、G、工为数量单位K=Kilo=千=$10^3$，M=Million=百万=$10^6$，G=Giga=十亿=$10^9$，T=Tera=万亿=$10^{12}$

  



### 系统整体性能指标

- {% span red, 数据通路带宽 %}:数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据)

![image-20220921103004467](https://s2.loli.net/2022/11/06/litwW21IHa5JBPq.png)

- {% span red, 吞吐量 %}:指系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。
- {% span red, 响应时向 %}:指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。
  - 通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O操作、操作系统开销等时间)。
- {% span red, 基准程序 %}:是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。

Eg:

- 问:主频高的CPU一定比主频低的CPU快吗?
  不一定，如两个CPU，A的主频为2GHz，平均CPI=10;B的主频1GHz，平均CPI=1...
- 问:若A、B两个CPU的平均CPI相同，那么A一定更快吗?
  也不一定，还要看指令系统，如A不支持乘法指令，只能用多次加法实现乘法;而B支持乘法指令。
- 问:基准程序执行得越快说明机器性能越好吗?
  基准程序中的语句存在频度差异，运行结果也不能完全说明问题

![image-20220921103612021](https://s2.loli.net/2022/11/06/onztDuFceCi8ahj.png)





# 第二章：数据的表示和运算

## 进位计数制

古印度人发明了阿拉伯数字：1,2,3,4,5,6,7,8,9,0，反应了符号位的权重

- {% span red, 基数 %}：每个数码位所用到的不同符号的个数，r进制的基数为r
- 二进制: 0,1
- 八进制：0,1,2,3,4,5,6,7
- 十进制：0,1,2,3,4,5,6,7,8,9
- 十六进制：0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F

计算机一般使用二进制来表示：

- 可使用两个稳定状态的物理器件表示
- 0，1正好对应逻辑值假、真。方便实现逻辑运算
- 可很方便地使用逻辑门电路实现算术运算



{% tip %}任意进制转换成10进制{% endtip %}

- 每一位的数据乘上该位的位权
- 二进制:10010010.110                 $1 \times 2^7 +1 \times 2^4+1 \times2^1+1\times 2^{-1}+1 \times 2^{-2}=146.75$
  八进制:251.5                                $2\times8^2 +5\times8^1+1\times8^0+5\times8^{-1} = 168.625$
  十六进制: AE86.1                         $10\times16^3+ 14\times16^2+8\times16^1+6\times16^0+1\times16^{-1} = 44678.0625$



|  -3   |  -2  |  -1  |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   | 10   |  11  |  12  |  13  |  14   |  15   |  16   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | ---- | :--: | :--: | :--: | :---: | :---: | :---: |
| 0.125 | 0.25 | 0.5  |  1   |  2   |  4   |  8   |  16  |  32  |  64  | 128  | 256  | 512  | 1024 | 2048 | 4096 | 8192 | 16384 | 32768 | 65536 |



{% tip %}二进制 <-> 八进制，十六进制{% endtip %}

- {% label 二进制→八进制 red %}
  - 如: 1111000010.01101二进制→八进制
  - 3位一组，每组转换成对应的八进制符号

| 二进制 | 001  | 111  | 000  | 010  |  .   | 011  | 010  |
| :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 八进制 |  1   |  7   |  0   |  2   |  .   |  3   |  2   |

- {% label 二进制→十六进制 red %}
  - 如: 1111000010.01101二进制→十六进制
  - 4位一组，每组转换成对应的十六进制符号

|  二进制  | 0011 | 1100 | 0010 |  .   | 0110 | 1000 |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: |
| 十六进制 |  3   |  C   |  2   |  .   |  6   |  8   |

- {% label 八进制→二进制 red %}
  - 如: $251.5_8$→二进制
  - 3位一组，每组转换成对应的八进制符号

| 八进制 |  2   |  5   |  1   |  .   |  5   |
| :----: | :--: | :--: | :--: | :--: | :--: |
| 二进制 | 010  | 101  | 001  |  .   | 101  |

- {% label 十六进制→二进制 red %}
  - 如: $AE86.1_{16}$→二进制
  - 4位一组，每组转换成对应的十六进制符号

| 十六进制 |  A   |  E   |  8   |  6   |  .   |  1   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: |
|  二进制  | 1010 | 1110 | 1000 | 0110 |  .   | 0001 |



{% tip %}十进制→任意进制{% endtip %}

- 基本方法
  - 整数：{% span red, 除基取余法 %}
  - 小数：{% span red, 乘基取整法 %}
- 进阶方法：
  - 拼凑法
  - 260.75 = 256 + 4  + 0.5 + 0.25   => 100000100.11



{% tip %}真值和机器数{% endtip %}

+15 = 0   1111  真值  机器数

-8  =   1   1000

真值：符合人类习惯的数字
机器数：数字实际存到机器里的形式，正负号需要被“数字化”



![image-20220921150806305](https://s2.loli.net/2022/11/06/olJ9z2vQLxykUsd.png)



## BCD码 （Binary-Coded Decimal）

{% tip %} 用二进制编码的十进制 {% endtip %}

### 8421码

二进制：0，1，														方便计算机处理

十进制：0，1，2，3，4，5，6，7，8，9			符合人类习惯
$$
K_n \times r^n + K_{n-1} \times r^{n-1}+\cdot\cdot\cdot+K_2 \times r^2+ K_1 \times r^1+ K0 \times r^0
$$
转换麻烦

快速转换:一一对应			BCD : Binary-Coded Decimal

- {% label 8421码的映射关系 red%}

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |

![image-20220921161044764](https://s2.loli.net/2022/11/06/28U7IA6L3tdFmPx.png)

 



### 余三码

- {% label 余三码8421+$0011_2$ red%}

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |



### 2421码

{% label 2421码改变权值定义 red%}

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0000 | 0001 | 0010 | 0011 | 0100 | 1011 | 1100 | 1101 | 1110 | 1111 |



![image-20220921161538749](https://s2.loli.net/2022/11/06/6NiHQWRCc2kZlaU.png)





## 字符与字符串

### 英文字符在计算机内的表示

{% tip %}ASCII码{% endtip %}

数字，字母，符号 →  一共128个字符  → 7位二进制编码即可

![image-20220921163034679](https://s2.loli.net/2022/11/06/17sGHFMADfpXuWn.png)



{% tip %}例题{% endtip %}

例1:已知‘A’的ASCII码值为65，字符‘H’存放在某存储单元M中，求M中存放的内容。

- 首先明确，M中存放的是‘H’的ASCIlI码(二进制形式)。
- 再由‘A’的码值推出‘H’的码值:
- 思路1.
  - A是第1个字母，H是第8个字母，则H的码值=65+(8-1)= 72
  - 72对应二进制为100 1000，故M中存放的内容为0100 1000
- 思路2.
  - A的码值65写成二进制为0100 0001，A是第1个字母
  - H是第8个字母，故对应0100 1000，M中存放内容为0100 1000

例2:已知‘h’的ASCI码值为104，字符‘a’存放在存储单元M1中，字符‘z’存放在存储单元M2中，求M1、M2中存放的内容。

- a : 104-(8-1)=97—>M1中内容为0110 0001
- z : 104+(26-8)=122→M2中内容为0111 1010

### 中文字符在计算机内的表示

GB 2312-80：汉字 + 各种符号共7445个

- {% span green, 区位码 %} 直观，方便人类理解
  - 94个区，每区94个位置
  - 啊 ： 16      01，表明“啊”这个汉字在区位码中的第16个区，第一个位置
- {% span red, 国标码  %}， 防止信息交换的时候与“控制/通讯字符”冲突
  - 将区位码转换成16进制
  - 都加上20H，防止信息交换的时候与“控制/通讯字符”冲突，因为ASCII码前32个为“控制/通讯字符”
  - 16    01  → 10H   01H   →(+20H)   30H   21H
- {% span red, 机内码 %}
  - 在国标码之上加上80H
- 汉字的输入
  - 通过输入法软件将我们{% span red, 输入编码 %}转换成国标码，然后通过系统或者应用软件将国标码转换成汉字内码

- 汉字的输出
  - 将汉字内码转换成字形码
  - 或者将汉字内码转换成国标码，然后再有国标码转换成汉字形码


### 字符串的存储

{% tip %}英文字符{% endtip %}

某计算机按字节编址，从地址为2的单元开始，存储字符串“abc”

- 各字符的ASCII编码

  - a: 0110 0001 = 61H
  - b: 0110 0010= 62H
  - c: 0110 0011= 63H
  - \0: 0000 0000= O0H      很多语言中，’\0'作为字符串结尾标志

  ![image-20220922085342804](https://s2.loli.net/2022/11/07/fDlO8UoXH1kYdJy.png)

{% tip %}中文字符{% endtip %}

某计算机按字节编址，从地址为2的单元开始，存储字符串“abc啊”

- 各字符的ASCII编码
  - a: 0110 0001 = 61H
  - b: 0110 0010= 62H
  - c: 0110 0011= 63H
  - 啊: 机内码=B0 A1 H
  - \0: 0000 0000= O0H      很多语言中，’\0'作为字符串结尾标志
- 在所有计算机中，{% span red, 多字节数据 %}都被{% span red, 存放在连续的字节序列 %}中。根据数据中各字节的排列顺序不同，可能有“大端模式”、“小端模式”

![image-20220922085943593](https://s2.loli.net/2022/11/06/i7xyV9sogvY2OK1.png)





![image-20220922085602634](https://s2.loli.net/2022/11/06/AGnRCgIDvtr3aPX.png)



## 数据校验码

### 校验原理

在两台计算机发送文件的时候，可能由于某种环境影响，导致某个二进制为发生突变

Eg1：	码距为1

| 信息 |  A   |  B   |  C   |  D   |
| :--: | :--: | :--: | :--: | :--: |
| 编码 |  00  |  01  |  10  |  11  |

如果我们再发送A的时候，第一位二进制码发生突变，变成了1，那么{% span red, 接收方接收到的字符是C %}这样就会出现错误



Eg2： 码距为2

| 信息 |  A   |  B   |  C   |  D   |
| :--: | :--: | :--: | :--: | :--: |
| 编码 | 100  | 001  | 010  | 111  |

如果我们在原先的基础上加上一个字符，那么我们在传送A的时候，不管哪一位发生突变，{% span red, 我们都能发现这个数据错误了%}.



由若干位代码组成的一个字叫{% span red, 码字 %}。

将两个码字逐位进行对比，具有不同的位的个数称为{% span red, 两个码字间的距离 %}。

一种编码方案可能有若干个合法码字，各合法码字间的最小距离称为"{% span red, 码距 %}"。

当d=1时，无检错能力;当d=2时，有检错能力;当d≥3时，若设计合理，可能具有检错、纠错能力



### 奇偶校验码

奇校验码:整个校验码（有效信息位和校验位）中“1"的个数为奇数。

偶校验码:整个校验码（有效信息位和校验位）中“1”的个数为偶数。

![image-20220922091957008](https://s2.loli.net/2022/11/06/Qbwms4yTtcB2S8r.png)

Eg：

给出两个编码1001101和1010111的奇校验码和偶校验码。设最高位为校验位，余7位是信息位，则对应的奇偶校验码为:

- 奇校验:
  - {% span red, 1 %}1001101
  - {% span red, 0 %}1010111
- 偶校验:
  - {% span red, 0 %}1001101
  - {% span red, 1 %}1010111
- 偶校验的硬件实现:
  - 各信息进行异或（模2加）运算，得到的结果即为偶校验位
  - 异或 ⊕
    - 0⊕0 = 0
    - 0⊕1 = 1
    - 1⊕0 = 1
    - 1⊕1 = 0
  - 求偶校验位:
    - 1⊕0⊕0⊕1⊕1⊕0⊕1=0
    - 1⊕0⊕1⊕0⊕1⊕1⊕1=1
  - 进行偶校验（所有位进行异或，若结果为1说明出错)
    - 0⊕1⊕0⊕0⊕1⊕1⊕0⊕1=0
    - 1⊕1⊕0⊕1⊕0⊕1⊕1⊕0=1 {% span red, 错误 %}

![image-20220922092856685](https://s2.loli.net/2022/11/06/e1CsxXEwau3YKqQ.png)





### 海明校验码

理查德·卫斯里·汉明	Richard Hamming	{%span red, 图灵奖 %}

{% tip %}设计思路{% endtip %}

将信息位{% span red, 分组 %}进行{% span red, 偶校验 %}→多个校验位→多个校验位标注出错位置

多个校验位能携带多种状态信息，(对/错，错在哪)

- {%span red, 校验位数的确定 %}
  - 设我们有 n 个信息位， k 个检验位  一共有$2^k$种状态
  - 信息位 + 校验位 = n+k，其中每一位都可能出错
  - $2^k≥n+k+1$ 



{% tip %}海明码的求解步骤{% endtip %}

信息位：1010

1. 确定海明码的位数$2^k≥n+k+1$ ， n = 4，k = 3

   设信息位$D_4D_3D_2D_1(1010)$，共4位，校验位$P_3P_3P_1$，共3位，对应的海明码为$H_7H_6H_5H_4H_3H_2H_1$。

2. 确定校验位的分布


|  H7  |  H6  |  H5  |  H4  |  H3  |  H2  |  H1  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  D4  |  D3  |  D2  |  P3  |  D1  |  P2  |  P1  |
|  1   |  0   |  1   |      |  0   |      |      |

校验位$P_i$，放在海明位号为$2^{i-1}$的位置上

信息位按顺序放到其余位置

3. 求校验位的值

   先把数据位的下表改成二进制：

   D1: H3	→ 011

   D2: H5	→ 101

   D3: H6	→ 110

   D4: H7	→ 111

   三个分组,分别进行偶校验

   P1代表2进制中的第一位 P1 = $H_3H_5H_7$ = $D_1D_2D_4$ = 0⊕1⊕1 = 0

   P2代表2进制中的第二位 P2 = $H_3H_6H_7$ = $D_1D_3D_4$ = 0⊕0⊕1 = 1

   P3代表2进制中的第三位 P3 = $H_5H_6H_7$ = $D_2D_3D_4$ = 1⊕0⊕1 = 0

|  H7  |  H6  |  H5  |  H4  |  H3  |  H2  |  H1  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  D4  |  D3  |  D2  |  P3  |  D1  |  P2  |  P1  |
|  1   |  0   |  1   |  0   |  0   |  1   |  0   |

4. 纠错

​		校验方程：

​		$S_1 = P_1D_1D_2D_4$ 

​		$S_2 = P_2D_1D_3D_4$ 

​		$S_3 = P_3D_2D_3D_4$ 

​		接收到：1010010

​		 $S_1 = P_1D_1D_2D_3$ = 0⊕0⊕1⊕1 = 0

​		$S_2 = P_2D_1D_3D_4$ = 1⊕0⊕0⊕1 = 0

​		$S_3 = P_3D_2D_3D_4$ = 0⊕1⊕0⊕1 = 0

​		接收到：10100{% span red, 0 %}0

​		 $S_1 = P_1D_1D_2D_3$ = 0⊕0⊕1⊕1 = 0

​		$S_2 = P_2D_1D_3D_4$ = {% span red, 0 %}⊕0⊕0⊕1 = {% span red, 1 %}.

​		$S_3 = P_3D_2D_3D_4$ = 0⊕1⊕0⊕1 = 0

​		010出错 我们从表中得到010(2)这个位置出错

![image-20220922101725547](https://s2.loli.net/2022/11/06/KvWbJ8BatHGId5f.png)

 {% tip %}全校验位{% endtip %}

海明码的检错、纠错能力:

- 纠错能力—(1位)
- 检错能力一(2位)



|  H7  |  H6  |  H5  |  H4  |  H3  |  H2  |  H1  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  D4  |  D3  |  D2  |  P3  |  D1  |  P2  |  P1  |
|  1   |  0   |  1   |  0   |  0   |  1   |  0   |

校验方程：

$S_1 = P_1D_1D_2D_3$ 

$S_2 = P_2D_1D_3D_4$ 

$S_3 = P_3D_2D_3D_4$ 

如果P1和P2同时出错的话 最后得到的结果为 011 但是011指向的数据是D1，但是这时候并不是D1出错了，{% span red, 无法区分是一位错还是两位错 %}

需加上“{% label 全校验位 red %}”，对整体进行偶校验

|  H8  |  H7  |  H6  |  H5  |  H4  |  H3  |  H2  |  H1  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| P全  |  D4  |  D3  |  D2  |  P3  |  D1  |  P2  |  P1  |
|  1   |  1   |  0   |  1   |  0   |  0   |  1   |  0   |

P全 = 前几位进行偶校验的结果

$S_3S_2S_1$=000 且全体偶校验{% span red, 成功 %}→无错误
$S_3S_2S_1$≠000 且全体偶校验{% span red, 失败 %}→有1位错，纠正即可

$S_3S_2S_1$≠000 且全体偶校验{% span red, 成功 %}→有2位错，需重传

![image-20220922102816653](https://s2.loli.net/2022/11/06/6iB4ma3RcFeMxgX.png)



### 循环冗余校验码

 Cyclic Redundancy Check，CRC

循环冗余校验码的思想:

- 数据发送、接受方约定一个“{% span red, 除数 %}”

- {% span red, K个信息位+R个校验位 %}作为“{% span red, 被除数 %}”，添加校验位后需保证{% span red, 除法 %}的余数为0

- 收到数据后，进行{% span red, 除法 %}检查余数是否为
- 0若余数非0说明出错，则进行重传或纠错

![image-20220922145715874](https://s2.loli.net/2022/11/06/ZJaP4kYdtKfseGL.png)



Eg : 

设生成多项式为G(x)=x3+x2+1，信息码为101001，求对应的CRC码。

1. 确定K、R以及生成多项式对应的二进制码

   K={% span red, 信息码的长度 %}= 6，R={% span red, 生成多项式最高次幂 %}=3→{% span red, 校验码位数 %}N=K+R=9

   生成多项式Gx = $1\times X^3 + 1\times X^2 + 0\times X^1 + 1\times X^0$，对应二进制码{% span  red, 1101 %}.

2. 移位：

   信息码左移R位，低位补零      结果：{% span  red, 101001000 %}

3. 相除：

   对移位后的信息码，用生成多项式就行{% span red, 模2除 %}法，产生余数

   模2除， 模2减：

   ![image-20220922155041924](https://s2.loli.net/2022/11/06/CWOLxtFfzubArMG.png)

   

   - {% span red, 对应的CRC码101001001 %}

   4. 检查和纠错

      发送:101001001   记为$C_9C_8C_7C_6C_5C_4C_3C_2C_1$

      接收:101001001    用1101进行模2除, 余数为000，代表没有出错

      接收:101001011     用1101进行模2除，余数为010，{% del 代表C2出错 %}.


   5. 为什么010不代表C2出错

|   接受    | 余数 | 出错位 |
| :-------: | :--: | :----: |
| 101001000 | 001  |   1    |
| 101001011 | 010  |   2    |
| 101001101 | 100  |   3    |
| 101000001 | 101  |   4    |
| 101011001 | 111  |   5    |
| 101101001 | 011  |   6    |
| 100001001 | 110  |   7    |
| 111001001 | 001  |   8    |
| 001001001 | 010  |   9    |

从上面这个表得出，如果出现010的话可能是第二位，也可能是第9位


{% tip warning %}但是上面这种情况，并不代表循环冗余校验码没有纠错的能力{% endtip %}

-  上面这种情况的出现只是代表了{% span red, 信息位 %}太长，所以循环冗余校验码失去了它校验的能力

- 如果我们的信息位变成了：0100， 生成多项式是：Gx = $1\times X^3 + 1\times X^2 + 0\times X^1 + 1\times X^0$ 

- 使用010000对1101进行模二除法，得出余数为011

- CRC码为：0100011


|  接受   | 余数 | 出错位 |
| :-----: | :--: | :----: |
| 0100010 | 001  |   1    |
| 0100001 | 010  |   2    |
| 0100111 | 100  |   3    |
| 0101011 | 101  |   4    |
| 0110011 | 111  |   5    |
| 0000011 | 011  |   6    |
| 1100011 | 110  |   7    |

上面这种情况下，循环冗余校验码就可以实现纠错功能

- {% span red, K个信息位，R个校验位，若生成多项式选择得当，且$2^R≥K+R+1$，则CRC码可以纠正1位错误 %}

理论上可以证明循环冗余校验码的检错能力有以下特点:

1. 可检测出所有奇数个错误;
2. 可检测出所有双比特的错误;
3. 可检测出所有小于等于校验位长度的连续错误;

循环冗余校验码：{% span red, 为什么循环 %}

|   接受    | 余数 | 出错位 |
| :-------: | :--: | :----: |
| 101001000 | 001  |   1    |
| 101001011 | 010  |   2    |
| 101001101 | 100  |   3    |
| 101000001 | 101  |   4    |
| 101011001 | 111  |   5    |
| 101101001 | 011  |   6    |
| 100001001 | 110  |   7    |
| 111001001 | 001  |   8    |
| 001001001 | 010  |   9    |

使用上一位余数对生成多项式进行模二除法（前提是需要将余数扩充为和生乘多项式位数一样的数据），发现最后结果就是{% span red, 下一位余数 %}，这就是循环冗余



![image-20220922152847298](https://s2.loli.net/2022/11/06/MjSxPaiCdHB5fRk.png)





## 定点数的表示

### 无符号数的表示

- {% span red, 无符号数 %}:整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。
- n位的无符号数{% span red, 表示范围 %}为：0 ~ $2^n-1$ 
- {% span red, 通常只有无符号整数，而没有无符号小数 %}

![image-20220923091243501](https://s2.loli.net/2022/11/06/G5AaxLE2vlY9wFz.png)

### 原码

- {% label 原码 red %}：用尾数表示真值的绝对值，符号位“0/1”对应“正/负”

若机器字长n+1位，{% span red, 原码整数 %}的表示范围:$-(2^n-1) ≤x≤2^n-1$(关于原点对称)

真值0有+0和-0两种形式

![image-20220923093448693](https://s2.loli.net/2022/11/06/2FeEl9wNjcO1ka6.png)



若机械字长n+1位，{% span red, 原码小数 %}的表示范围：$-(1-2^{-n}) ≤x≤1-2^{-n}$ 关于原点对称  

真值0有+0和-0两种形式

![image-20220923094246118](https://s2.loli.net/2022/11/06/qMEBL3k49tcynVU.png)

### 反码

反码:

- 若符号位为0，{% span red,  则反码与原码相同 %}
- 若符号位为1，{% span red, 则数值位全部取反 %}

若机器字长n+1位，{% span red, 反码整数 %}的表示范围:$-(2^n-1) ≤x≤2^n-1$(关于原点对称)

真值0有+0和-0两种形式

若机器字长n+1位，{% span red, 反码小数 %}的表示范围:$-(1-2^n) ≤x≤1-2^n$(关于原点对称)

真值0有+0和-0两种形式

- {% label “反码”只是“原码”转变为“补码”的一个中间状态，实际中并没什么卵用 red %}

### 补码

补码: 

- 正数的补码=原码
- 负数的补码=反码末位+1（要考虑进位)

![image-20220923145127171](https://s2.loli.net/2022/11/06/Vyd3e2lXY9QhTMf.png)

$[+0]_原 = 00000000$  $[-0]_原 = 10000000$

$[+0]_反 = 00000000$  $[-0]_反 = 11111111$

$[+0]_补 = [-0]_补 = 00000000$

- {% label 注意!补码的真值0只有一种表示形式 red %}.

- 定点整数补码$[x_补]$=1,0000000表示$x=-2^7$若机器字长n+1位，补码整数的表示范围:$-2^n\leq x \leq 2^n-1$ （比原码多表示一个$-2^n$ )
  定点小数补码$[x_补]$=1.0000000表示x=-1 若机器字长n+1位，补码小数的表示范围:$-1 ≤x≤1-2^{-n}$(比原码多表示一个-1 )



### 移码

- {% span red, 移码 %}:(补码的基础上将符号位取反。{% span red, 注意:移码只能用于表示整数 %}.

技巧:由[x]补快速求[-x]补的方法：符号位、数值位全部取反，末位+1

![image-20220923151212544](https://s2.loli.net/2022/11/06/3o6WeHjnOCqdhgu.png)



## 定点数的运算

{% tip warning %}计算机中采用1位符号位判断时，为了节省时间，通常将符号位产生的进位与最高有效位产生的进位异或结果作为判断，结果为0则不溢出，为1则溢出。{% endtip %}

### 移位运算

{% tip %}算数移位{% endtip %}

{% tabs 移位运算 %}

<!-- tab 原码算数位移 -->

{% span red, 原码 %}的算数移位―—符号位保持不变，仅对数值位进行移位。

- 右移：{% span red, 高位补0 %}，低位舍弃。若舍弃的位=0，则相当于÷2; 若舍弃的位≠0，则会丢失精度
  - ![image-20220923210422812](https://s2.loli.net/2022/11/06/xdJnuhGl1eOS8mX.png)
- 左移：{% span red,  低位补0  %}，高位舍弃。若舍弃的位=0，则相当于×2; 若舍弃的位≠0，则会出现{% span red, 严重误差 %}
  - ![image-20220923210347437](https://s2.loli.net/2022/11/06/p8PeIhCbAw1RrMx.png)

<!-- endtab -->

<!-- tab 反码算数位移 -->

反码的算数移位：

- 正数的反码{% span red, 与原码相同 %},因此对正数反码的移位运算也和原码相同。
  - 右移:高位补0，低位舍弃， 算数位不变。
  - 左移:低位补0，高位舍弃，算数位不变。
- 负数的反码{% span red, 数值位与原码相反 %}，因此负数反码的移位运算规则如下
  - 右移:{% span red, 高位补1 %}，低位舍弃，算数位不变。
  - 左移:{% span red, 低位补1 %}，高位舍弃，算数位不变。

<!-- endtab -->

<!-- tab 补码算数位移 -->

补码的算数移位

- 正数的补码与原码相同,因此对正数补码的移位运算也和原码相同。
  - 右移:高位补0，低位舍弃。
  - 左移:低位补0，高位舍弃。
- 负数补码=反码末位+1导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。
  - 规律: 负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码
  - 负数补码的算数移位规则如下:
  - {% span red, 右移（同反码）:高位补1，低位舍弃 %}。
  - {% span red, 左移（同原码）:低位补0，高位舍弃 %} 。
  - ![image-20220923211148379](https://s2.loli.net/2022/11/06/bH3ERzFWC6u9UMd.png)

<!-- endtab -->

{% endtabs %}

![image-20220923211356838](https://s2.loli.net/2022/11/06/in8k4JveTVMoOuz.png)

Eg:

20*7 ====> 

7D = 111B = $2^0+2^1+2^2$ 

20 * ($2^0+2^1+2^2$ ) 最后结果为：20不左移 + 20左移一位 + 20左移两位



{% tip %}逻辑移位{% endtip %}

逻辑右移:高位补0，低位舍弃。

逻辑左移:低位补0，高位舍弃。

可以把逻辑移位看作是对“无符号数”的算数移位

![image-20220923211752706](https://s2.loli.net/2022/11/06/V9KiYIE5Uv4q7yz.png)



{% tip %}循环移位{% endtip %}

左移的时候将最高位的数据放到最低位

右移的时候将最低位的数据放到最高位

![image-20220923212220317](https://s2.loli.net/2022/11/06/Sm6B8qcntlez2KQ.png)





![image-20220923212456792](https://s2.loli.net/2022/11/06/cyik9lNSQP26XGT.png)



### 加法运算

{% tip %}原码的加减法{% endtip %}

原码的加法运算:

- 正+正→绝对值做加法，结果为负   {% span red, 可能会溢出负+负 %}.
- 负+负→绝对值做加法，结果为负  {% span red, 可能会溢出负+负 %}.
- 正+负→绝对值大的减绝对值小的，符号同绝对值大的数
- 负+正→绝对值大的减绝对值小的，符号同绝对值大的数

原码的减法运算，“减数”符号取反，转变为加法:

- 正-负→正+正
- 负-正→负+负
- 正-正→正+负
- 负+正→负-负

{% tip %}补码的加减法{% endtip %}

设机器字长为8位（含1位符号位），A= 15, B=-24,求$[A+B]_补$和$[A-B]_补$

|      |        |   原码    |   补码    |
| :--: | :----: | :-------: | :-------: |
|  A   | +1111  | 0,0001111 | 0,0001111 |
|  B   | -11000 | 1,0011000 | 1,1101000 |

负数{% span red, 补→原 %}:

- 数值位取反+1;
- 负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码

$[A+B]_补=[A]_补+[B]_补=0,0001111+ 1,1101000 = 1,1110111$	原码:1,0001001真值-9

$[A-B]_补=[A]_补+[-B]_补=0,0001111+ 0,0011000= 0,0100111$	真值+39

$[-B]_补:[B]_补$连同符号位一起取反加1

对于补码来说，无论加法还是减法，{% span red, 最后都会转变成加法 %}，由加法器实现运算，符号位也参与运算

{% tip %}溢出判断{% endtip %}

只有“{% span red, 正数+正数 %}”才会上溢―正+正=负

只有“{% span red, 负数+负数 %}”才会下溢―负+负=正

$[A+C]_补=0,0001111+0,1111100= 1,0001011$

$[B-C]_补=1,1101000+ 1,0000100=0,1101100$

- 方法一:采用一位符号位
  - 设A的符号为As，B的符号为Bs，运算结果的符号为Ss，则溢出逻辑表达式为
  - ![image-20220923223548303](https://s2.loli.net/2022/11/06/3sphrCPvZfneMXd.png)
  - 其中各个部分内部采用与运算，部分之间采用或运算
  - 若V=0，表示无溢出;
  - 若V=1，表示有溢出。
  - 逻辑表达式
    - {% span red, 与 %}:如ABC，表示A与B与C仅当A、B、C均为1时，ABC为1
    - A、B、C中有一个或多个为0，则ABC为0
    - {% span red, 或 %}:如A+B+C，表示A或B或C
    - 仅当A、B、C均为0时，A+B+C为0
    - A、B、C中有一个或多个为1，则A+B+C为1

- 方法二:采用一位符号位，根据数据位进位情况判断溢出，符号位的进位Cs最高数值位的进位C1
  - ​	![image-20220923224326106](https://s2.loli.net/2022/11/06/hAjol17pzkI3ZDs.png)
  - 01 表示上溢
  - 10 表示下溢
  - 即:C与C不同时有溢出
  - 处理“不同”的逻辑符号:异或
  - 溢出逻辑判断表达式为V=Cs⊕C1
  - 若V=0，表示无溢出;
  - V=1，表示有溢出。
- 方法三：双符号位
  - 正数符号为00，负数符号为11
  - $[A+C]_补=00,0001111+00,1111100= 01,0001011$
  - $[B-C]_补=11,1101000+ 11,0000100=10,1101100$
  - 01 表示上溢
  - 10 表示下溢
- 双符号位补码又称:模4补码，大于等于$2^2$的都舍去
- 单符号位补码又称:模2补码，大于等于$2^1$的都舍去

{% tip %}符号扩展{% endtip %}

|      | 正整数<br />（原，反，补码的表示都一样） |                    | 正小数<br />（原，反，补码的表示都一样） |                    |
| :--: | :--------------------------------------: | :----------------: | :--------------------------------------: | :----------------: |
|      |                0,1011010                 | 0,00000000 1011010 |                0.1011010                 | 0.1011010 00000000 |
|      |                  负整数                  |                    |                  负小数                  |                    |
| 原码 |                1,1011010                 | 1,00000000 1011010 |                1.1011010                 | 1.1011010 00000000 |
| 反码 |                1,0100101                 | 1,11111111 0100101 |                1.0100101                 | 1.0100101 11111111 |
| 补码 |                1,0100110                 | 1,11111111 0100110 |                1.0100110                 | 1.0100110 00000000 |

- 定点整数的符号扩展:
  - 在原符号位和数值位中间添加新位，正数都添0;负数原码添o，负数反、补码添1
- 定点小数的符号扩展:
  - 在原符号位和数值位后面添加新位，正数都添0;负数原、补码添0，负数反码添1

![image-20220923230213654](https://s2.loli.net/2022/11/06/l5zpajhrJcsN9UI.png)



### 乘法运算

#### 原码的乘法运算



![image-20220924085053830](https://s2.loli.net/2022/11/06/e5Dmqsi6QbSNWao.png)

考虑用机器实现:

- 实际数字有正负，符号位如何处理?·
- 乘积的位数扩大一倍，如何处理?
- 4个位积都要保存下来最后统一相加?

|                                   |     加     |     减     |       乘       |      除      |
| :-------------------------------: | :--------: | :--------: | :------------: | :----------: |
|         Accumulator(ACC)          | 被加数，和 | 被减数，差 |    乘积高位    | 被除数，余数 |
|  Multiple-Quotient Register(MQ)   |            |            | 乘数，乘积低位 |      商      |
| Arithmetic and Logic Unit(X, ALU) |    加数    |    减数    |     被乘数     |     除数     |

{% tip %}原码一位乘法{% endtip %}

其中乘法中 ACC存放的是乘积的高位， MQ 乘积，乘积的低位，ALU被乘数

符号位单独处理：符号位：{% span red, 两位数据异或得到的 %},{% label 数值位取绝对值进行乘法运算 red %}.

设机器字长为n+1=5位(含1位符号位），[x]原= 1.1101，[y]原=0.1011，采用原码一位乘法求x*y

![image-20221108103402061](https://s2.loli.net/2022/11/08/sOB96tlqGdMbfir.png)

- 在进行运算的时候先让ACC清零
- 然后判断MQ中的低位
  - 如果是1的话，就让寄存区X中的数据和ACC相加，运算结果放到ACC中，然后让ACC和MQ中的所有数据进行逻辑右移
  - 如果是0的话，就让ACC中的数据加上零
- 最后一个是符号位不用参与运算

![image-20221108204512327](https://s2.loli.net/2022/11/08/WVm5RodlIcLKBCM.png)



![image-20220924085820145](https://s2.loli.net/2022/11/06/GqbvlF6uNH7xaA5.png)

#### 补码的乘法运算

- .{% span red, 补码 %}一位乘法:
  - 进行n轮加法、移位，{% span red, 最后再多来一次加法 %}.
  - 每次加法可能+0、+[x]补、+[-x]补
  - 每次移位是“补码的{% span red, 算数右移 %}”
  - {% span red, 符号位参与运算 %}

设机器字长为5位（含1位符号位，n=4), x=-0.1101，y= +0.1011，采用Booth算法求x*y

- [x]补=1.0011，[-x]补=0.1101，[y]补=0.1011
- ALU和MQ中存放的是被乘数和乘数的{%span red, 带符号位的%}补码

![image-20221112115252751](https://s2.loli.net/2022/11/12/usRvJ6BnWNEOD53.png)

![image-20220924090814344](https://s2.loli.net/2022/11/06/1vd4BtPASVaN7EL.png)

- {% span red, n轮加法、算数右移 %}，加法规则如下:
  - {% span red, 辅助位 %}- {% span green, MQ中最低位 %}=1时，(ACC)+[x]补
  - {% span green, 辅助位 %}-{% span red, MQ中最低位 %}=0时，(ACC)+0
  - {% span red, 辅助位 %} - {% span green,  MQ中最低位 %}=-1时，(ACC)+[-x]补
- 补码的{% span red, 算数右移 %}:
  - {% span red, 符号位不动，数值位右移，正数右移补0,负数右移补1（符号位是啥就补啥) %}.

![image-20220924091310808](https://s2.loli.net/2022/11/06/agkK481hBCxT2zq.png)



### 除法运算

#### 除法运算思想

![image-20220924101317507](https://s2.loli.net/2022/11/06/2eo8cI1xDLl5PK9.png)



|                                   |     加     |     减     |       乘       |      除      |
| :-------------------------------: | :--------: | :--------: | :------------: | :----------: |
|         Accumulator(ACC)          | 被加数，和 | 被减数，差 |    乘积高位    | 被除数，余数 |
|  Multiple-Quotient Register(MQ)   |            |            | 乘数，乘积低位 |      商      |
| Arithmetic and Logic Unit(X, ALU) |    加数    |    减数    |     被乘数     |     除数     |

- 除法操作：
  - ACC：被除数，余数
  - MQ：商
  - ALU：除数

#### 恢复余数法

{% tip %}恢复余数法机械算法{% endtip %}

计算机默认商1，{% span red, 如果算出来的余数为负数的话，我们需要恢复原来的数据 %}，然后在进行商零，所以称为恢复余数法

![image-20220924110635816](https://s2.loli.net/2022/11/06/aOd1H6lsBTXQNtA.png)

{% tip %}恢复余数法手算法{% endtip %}

在进行除法的时候 需要先算出来，除数的绝对值，被除数的绝对值，被除数绝对值的补码，被除数绝对值的负数的补码

![image-20221112131742773](https://s2.loli.net/2022/11/12/XygSKjxdW4ZFTtE.png)

- 恢复余数法:当余数为负时商0,并+|除数|，再左移，再-|除数|

#### 加减交替法(不恢复余数法)

加减交替法:当余数为负时商0,并左移，再+|除数|

![image-20221112132550286](https://s2.loli.net/2022/11/12/tBWia5AyHoXSgIU.png)

![image-20220924214236129](https://s2.loli.net/2022/11/06/YGdyCEkB9KgnV6L.png)

定点小数的除法前提：{% span red, 被除数一定要小于除数 %}，因为如果被除数大于除数的话，最后的结果就会是 大于1的数据，定点小数无法表示大于一的数据 ，



#### 补码的除法运算：

{% tip warning %}符号位参与运算{% endtip %}

设机器字长为5位（含1位符号位，n=4),x=+0.1000，y=-0.1011，采用补码加减交替除法求x/y

- [x]补-00.1000，[y]补-11.0101，[-y]补=00.1011

![image-20220924225949057](https://s2.loli.net/2022/11/06/9eQ3luczIDRFZ4g.png)

补码除法:

- 符号位参与运算
- 被除数/余数、除数采用双符号位

第一步的时候：

- 被除数和除数{% span red, 同号 %}，则{% span red, 被除数减去除数 %};

- {% span red, 异号 %}则{% span red, 被除数加上除数 %}。

余数和除数{% span red, 同号 %}， 商1，{% span red, 余数左移一位减去除数 %};

余数和除数{% span red, 异号 %}，商0，{% span red, 余数左移一位加上除数 %}。

重复n次

![image-20220924230249343](https://s2.loli.net/2022/11/06/UcZbLG4SBDqFXVg.png)

## 数据强制转换

![image-20220924230821618](https://s2.loli.net/2022/11/06/P8dgLkpN6tu9CfD.png)





## 数据的存储和排列

 ### 大小端模式

大端模式，低地址放高位数据，高地址放低位数据，{% span red, 开始的时候放大数据，所以称为大端 %},

小端模式，低地址放低位数据，高地址放高位数据， {% span red, 开始的时候放小数据，所以称为小端 %},

![image-20220924231544709](https://s2.loli.net/2022/11/06/7eijyBE5YbHCot9.png)



### 边界对齐

现代计算机通常是按字节编址，即每个字节对应1个地址

通常也支持按字、按半字、按字节寻址。

假设存储字长为32位，则1个字=32bit，半字=16bit。每次访存只能读/写1个字

边界对齐方式：

![image-20220924232738237](https://s2.loli.net/2022/11/06/pl2rhy3PnLwXERD.png)

边界不对齐方式：

![image-20220924232753616](https://s2.loli.net/2022/11/06/nb5XQI1sx3TLpve.png)

Eg：我们在C语言中定义一个结构体的时候，我们定一个3个char型数据，一个short型变量，一个int型变量

- 如果不使用边界对齐方式的话，先存放三个char型数组，然后在存放半个short型变量，第二行第一个存放半个short行变量，{% span red, 不浪费空间 %}，但是读取的时候需要读取两次。
- 如果采用边界对齐的话，可以浪费空间，但是可以节约读取速度



## 浮点数的表示

{% tip %}定点数的局限性{% endtip %}

- 如果我们想要表示8056这个数据的话我们是用一个{% span red, short型定点整数 %}表示即可
- 如果我们想要表示301256987235这个数据的话我们是用一个{% span red, long int 型定点整数 %}表示
- 但是如果我们想要表示一个长度为 2,3十位的数据的话，那么long int也无法表示这个数据
- {% span red, 如果超出整形表示范围的话，我们就需要使用浮点数来表示 %}

{% tip %}浮点数的表示{% endtip %}

$301256987235 = 3.012\times10^{12}$ 其中12是阶码， 3.012是尾数

![image-20220925091455547](https://s2.loli.net/2022/11/06/t3FfmgwJqOaxbkQ.png)

阶码:常用{% span red, 补码或移码 %}表示的定点整数

尾数:常用{% span red, 原码或补码 %}表示的定点小数

阶码：反应浮点数的表示范围以及小数点的实际位置

尾数：数值部分的位数n反应浮点数的精度

{% tip %}浮点数尾数规格化{% endtip %}

规格化浮点数:{% span red, 规定尾数的最高数值位必须是一个有效值 %}。

左规: 当浮点数运算的结果为非规格化时要进行规格化处理，{% span red, 将尾数算数左移一位，阶码减1 %}。

- 就像科学计数法中，我们需要保证最高位的数据位有意义，不能够是0，所以如果位数的最高位（非符号位）为零的话需要左规

右规:当浮点数运算的结果尾数出现溢出（双符号位为01或10）时,{% span red, 将尾数算数右移一位，阶码加1 %}。

规格化特点：

用{% span red, 原码 %}表示的尾数进往规格化

- 正数为0.1xxxxx的形式，其最大值表示为0.11.1；最小值表示为0.10.0。尾数的表示范围为$1/2\leq M\leq (1-2^{-n})$。

- 负数为1.1xxxxx的形式，其最大值表示为1.10...0;最小值表示为1.11...1。尾数的表示范围为$-(1-2^{-n})≤M<-1/2$。
- 规格化的原码尾数，{% span red, 最高数值一定是1 %}.

用{% span red, 补码 %}表示的尾数进行规格化：

- 正数为0.1xxxxx的形式，其最大值表示为0.11.1；最小值表示为0.10.0。尾数的表示范围为$1/2\leq M\leq (1-2^{-n})$
- 负数为1.0xxxxx的形式，其最大值表示为1.01.1；最小值表示为1.00.0。尾数的表示范围为$-1\leq M\leq -(1/2+2^{-n})$。
- 规格化的补码尾数，{% span red, 符号位与最高数值位一定相反 %}

![image-20220925100233622](https://s2.loli.net/2022/11/06/W9notGJI2LaumRO.png)

## 浮点数表示标准IEEE754

移码的表示：

- {% span red, 一般情况下是让补码数值为取反得到移码 %}
- 但是真实的移码运算规则是：真实值 + 偏置值

- {% span red, 正常情况下偏置值为 %}$2^{n-1}$

![image-20220925101435280](https://s2.loli.net/2022/11/06/LHtaA87yn1gNx62.png)

- {% span red, IEEE754这种情况下偏置值为 %}$2^{n-1}-1$

![image-20220925101508041](https://s2.loli.net/2022/11/06/QzXnHDfecZAhxMN.png) 



{% tip %}IEEE754{% endtip %}

![image-20220925101926979](https://s2.loli.net/2022/11/06/AGLqa8BYbH31OPM.png)



![image-20220925102108034](https://s2.loli.net/2022/11/06/K8JWH2Xb7QSdNC1.png)



Eg:IEEE 754的单精度浮点数C0 A0 00 00H的值时多少。

C0 A0 00 00H→1100 0000 1010 0000 0000 0000 0000 0000

数符=1→是个负数

尾数部分=.0100....(隐含最高位1）→尾数真值=$(1.01)_2$

移码= 10000001，若看作无符号数=129D

单精度浮点型偏移量=127D

阶码真值=移码-偏移量=1000 0001-111 1111 = (0000 0010)2 =$(2)_{10}$

浮点数真值=$(-1.01)_2× 2^2= -1.25 ×2^2= -5.0$

 

{% tip %}IEEE 754单精度浮点型能表示的最小绝对值、最大绝对值是多少?{% endtip %}

最小绝对值:{% label 尾数全为0 red %}，阶码真值最小-126，对应移码机器数0000 0001此时整体的真值为$(1.0)_2×2^{-126}$

- 为什么阶码最小值是-126，因为-128，-127，表示全零，和全1，{% span  red, 需要用来表示特殊的作用 %}.

最大绝对值:{% label 尾数全为1 red %}，阶码真值最大127，对应移码机器数11111110此时整体的真值为$(1.111...11)_2,×2^{127}$

![image-20220925105402151](https://s2.loli.net/2022/11/06/WqY3hcOvE1dmgzp.png)

### 浮点数表示范围

IEEE 754单精度浮点型能表示的最小绝对值、最大绝对值是多少?

最小绝对值:尾数全为0，阶码真值最小-126，对应移码机器数0000 0001此时整体的真值为$(1.0)_2×2^{-126}$

若要表示的数绝对值还要更小，怎么办?

- {% label 这时候就需要应用我们之前所提到的，阶码全零，或者全1的情况了 red %}
- 如果把阶码看成无符号小数的话，那么他所表示的 范围为：0≤E≤255
- 抛去阶码全零和全一这两种情况，就是去掉0和255，那么只有当阶码表示范围在 1≤E≤254的时候，才正常

当{% span red, 阶码E全为0，尾数M不全为0 %}时，表示非规格化小数±$(0.xx.….x)_2 \times 2^{-126}$

- 阶码真值设置为固定设置为{% span red, 定值：-126 %}，隐含位变为0，这样就可以表示$(0.0001)_2 \times 2^{-126}$

当{% span red, 阶码E全为0，尾数M全为0时 %}，表示真值±0当阶码E全为0，表示真值 ±0

当{% span red, 阶码E全为1，尾数M全为0 %}时，表示无穷大±∞

当{% span red, 阶码E全为1，尾数M不全为0 %}时，表示非数值“NaN"(Not a Number)



由浮点数确定真值（阶码不是全0、也不是全1）:

![image-20220925143839258](https://s2.loli.net/2022/11/06/l3fHPaNEDVbJXm5.png)



- 根据“某浮点数”确定数符、阶码、尾数的分布
- 确定尾数1.M（注意补充最高的隐含位1)
- 确定阶码的真值 = 移码-偏置值︰(可将移码看作无符号数，用无符号数的值减去偏置值)
- $(-1)^s\times1.M\times2^{E-偏置值}$



## 浮点数的运算

### 加减运算

- 对阶
  - 小阶向大阶对齐，{% span red, 方便处理位数 %}.
- 尾数加减
- 规格化
  - 如果尾数加减出现类似$0.0099517 ×10^{12}$时，需要“左规”﹔
  - 如果尾数加减出现类似$99.517107×10^{12}$时，需要“右规”
- 舍入
  - 若规定只能保留6位有效尾数，
  - 9.9517107 ×1012→9.95171 ×1012 (多余的直接砍掉)
  - 9.9517107 × 1012→9.95172×1012(若砍掉部分非0，则入1)
  - 也可以采用四舍五入的原则，当舍弃位≥5时，高位入1
- 溢出
  - 若规定阶码不能超过两位，则运算后阶码超出范围，则溢出
  - {% span red, 只有阶码的溢出才是真正的溢出 %}.
  - {% span red, 尾数溢出的话可以采用规格化来处理 %}.

![image-20220925150615355](https://s2.loli.net/2022/11/06/hCBaGHyKYZtmLSx.png)



- {% label “0”舍“1”入法 red %}:类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为0，则舍去;被移去的最高数值位为1，则在尾数的末位加1。这样做可能会使尾数又溢出，此时需再做一次右规。

- {% label 恒置“1”法 red %}:尾数右移时，不论丢掉的最高数值位是“1”还是“O”,都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。

### 强制类型转换

![image-20220925151723105](https://s2.loli.net/2022/11/06/mnT5j76JxdkAt4q.png)

char→int  long→double			

float→double			

范围、精度从小到大，转换过程没有损失				

int→float: 可能损失精度

float→int:可能溢出及损失精度

int:表示整数，范围$-2^{31}～2^{31}-1$，有效数字32位

float:表示整数及小数，范围$±[2^{-126}～2^{127}×(2-2^{-23})]$，有效数字23+1=24位

![image-20220925152026115](https://s2.loli.net/2022/11/06/Jnaz3t1RpI7m6HD.png)



## 电路的基本原理，加法器的设计

### 算数逻辑单元ALU

![image-20220925153344647](https://s2.loli.net/2022/11/06/mWaBiglQAektXIF.png)

算术运算:加、减、乘、除等

逻辑运算:与、或、非、异或等

辅助功能:移位、求补等

普通的ALU的模型：

![image-20220925153440573](https://s2.loli.net/2022/11/06/n3XBEQzqCT4wmU6.png)

A，B是输入信号， K是由CU产生的控制信号， F是输出结果

四输入ALU模型：

![image-20220925153618509](https://s2.loli.net/2022/11/06/ELikz17paquRJW9.png)



### 最基本的逻辑运算

- 与

  - Y = A·B


|  A   |  B   |  Y   |
| :--: | :--: | :--: |
|  0   |  0   |  0   |
|  0   |  1   |  0   |
|  1   |  0   |  0   |
|  1   |  1   |  1   |



- 或

  - Y = A+B


|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  0   |  0   |  0   |
|  0   |  1   |  1   |
|  1   |  0   |  1   |
|  1   |  1   |  1   |

- 非
  - Y = 非A

|  A   |  Y   |
| :--: | :--: |
|  0   |  1   |
|  1   |  0   |

我们可以看出{% span red, 与和或 %}操作都是{% span red, 两个数据 %}进行操作,，非操作是一个数据

![image-20220925154224637](https://s2.loli.net/2022/11/06/5mBnfQ47ExZV2Ty.png)



- {% span red, 优先级 :与>或 %}
  - (类比乘法、加法)
- Eg: AB+CD先算与再算或
- A(C+D)= AC+ AD    分配律
- ABC=A(BC               结合律
- A+B+C=A+(B+C)     结合律

本质上{% span red, 逻辑表达式是对电路的数学化描述 %}，简化逻辑表达式,就是在简化电路，就是在省钱。

- 与非

  - Y = A·B


|  A   |  B   |  Y   |
| :--: | :--: | :--: |
|  0   |  0   |  1   |
|  0   |  1   |  1   |
|  1   |  0   |  1   |
|  1   |  1   |  0   |

![image-20220925155230807](https://s2.loli.net/2022/11/06/1gbXwFNQfPycJ7L.png)



- 或非

  - Y = A+B


|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  0   |  0   |  1   |
|  0   |  1   |  0   |
|  1   |  0   |  0   |
|  1   |  1   |  0   |

![image-20220925155242224](https://s2.loli.net/2022/11/06/HtR4BMOY3KCVS1o.png)

- 异或

  - Y = A⊕B

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  0   |  0   |  0   |
|  0   |  1   |  1   |
|  1   |  0   |  1   |
|  1   |  1   |  0   |

![image-20220925155253006](https://s2.loli.net/2022/11/06/s4PSjptYdZ8ylen.png)

![image-20220925155511886](https://s2.loli.net/2022/11/06/6aBeJEMc5m81Xyz.png)

同或

- Y = A⊙B

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  0   |  0   |  1   |
|  0   |  1   |  0   |
|  1   |  0   |  0   |
|  1   |  1   |  1   |

![image-20220925155641900](https://s2.loli.net/2022/11/06/GIPhBpNgcRft53a.png)



{% tip %}用门电路实现异或操作{% endtip %}

![image-20220925160530919](https://s2.loli.net/2022/11/06/mZzvlPSCUB6e1t5.png)

{% tip %}一位全加器{% endtip %}

![image-20220925162031387](https://s2.loli.net/2022/11/06/mC57LutAdfcnbNX.png)



{% tip %}串行加法器{% endtip %}

![image-20220925162713971](https://s2.loli.net/2022/11/06/dYktCmr2IaHxBeo.png)

- {% span red, 串行加法器 %}:只有{% label 一个 red %}全加器，数据逐位串行送入加法器中进行运算。进位触发器用来寄存进位信号，以便参与下一次运算。
- 如果操作数长n位，加法就要分n次进行，每次产生一位和，并且串行逐位地送回寄存器。

{% tip %}并行加法器{% endtip %}

![image-20220925163028396](https://s2.loli.net/2022/11/06/8XlqYRThbjZeFov.png)

- {% span red, 串行进位的并行加法器 %}:把n个全加器串接起来，就可进行两个n位数的相加。

- 串行进位又称为行波进位，每一级进位直接依赖于前一级的进位,即进位信号是逐级形成的。



![image-20220925163200850](https://s2.loli.net/2022/11/06/MFHqY9ykJjtVPO7.png)

## 加法器，ALU的改进

前面得出串行进位的并行加法器中，{% span red, 计算速度：%}取决于：{% span green, 进位产生和传递的速度%}

### 如何更快的产生进位

![image-20220925163902664](https://s2.loli.net/2022/11/06/Bbfe1ORLjVgKanF.png)

$C_i=A_iB_i+(A_i⊕B_i)C_{i-1}$

$C_i=A_iB_i+(A_i⊕B_i)(A_{i-1}B_{i-1}+(A_{i-1}⊕B_{i-1})C_{i-2})$

$C_i=A_iB_i+(A_i⊕B_i)(A_{i-1}B_{i-1}+(A_{i-1}⊕B_{i-1})(A_{i-2}B_{i-2}+(A_{i-2}⊕B_{i-2})C_{i-3}))$

总归能够展开到$C_0$

记作：$Gi = A_iB_i, P_i=A_i⊕B_i$

结论:第i位向更高位的进位C;可根据{% span red, 被加数、加数的第1~i位 %},再结合$C_0$即可确定



### 并行加法器的优化

![image-20220925165955943](https://s2.loli.net/2022/11/06/M5UYSPXkt2uKOQq.png)

![image-20220925170005640](https://s2.loli.net/2022/11/06/eiGMz7YpW6dPurJ.png)

我们通过观察发现，第一步算出来的$G_1和P_1$我们在计算G2， G3...的时候需要用到，

- 所以我们在第一步计算完G1和P1的时候需要链接一个线路 {% span red, 将G1和P1传递到更高位的计算模块中去 %},

同理，第二步算出来的$G_2和P_2$我们在计算G3， G4...的时候需要用到，

- 所以我们在第二步计算完G2和P2的时候需要链接一个线路 {% span red, 将G2和P2传递到更高位的计算模块中去 %},

这时候每一步的计算复杂度就会小很多，不用{% span red, 等待下一步运算结果出来之后再开始计算 %}

- {% span red, 并行进位的并行加法器:各级进位信号同时形成，又称为先行进位、同时进位 %}.

- 但是我们发现{% span red, 随着我们的迭代公式增加，我们的方程复杂度越来越大 %}，这时候我们需要进行截断处理，{% span red, 我们以四个方程为一组 %}，来进行计算

![image-20220925170600933](https://s2.loli.net/2022/11/06/gPiajpNAeqBXZm6.png)

由4个FA和一些新的线路、运算逻辑组成

- 我们称Pi为进位传递函数，Gi为进位产生函数
- $G_i = A_iB_i$，如果$A_i和B_i$都为1的话那么一定会向上产生进位，所以称Gi为进位产生函数
- $P_i和C_{i-1}$ 共同与操作来确定是否进位，因为$C_{i-1}$是从低位过来的，所以Pi决定是否向高位出传递

![image-20220925170656144](https://s2.loli.net/2022/11/06/I4Oxn9WsyjfcdP6.png)



![image-20220925172029615](https://s2.loli.net/2022/11/06/cD8SvyOagAYfbMd.png)

- {% span red, 单级先行进位方式 %},又称为{% span red, 组内并行 %}、{% span red, 组间串行 %}进位方式。
  - 组内并行：每一个CLA加法器内部都是安装上面优化的方法，来进行并行操作的
  - 组间串行：每一个组之间有一个先后顺序来依此进行
- 组内进位信号：

![image-20220925172303462](https://s2.loli.net/2022/11/06/KIdrlR6ZQTe3yMo.png)

记:Gi* =G4+ P4G3+ P4P3G2+ P4P3P2G1;

Pi* = P4P3PP1

Gi* 称为组进位产生函数，Pi*称为组进位传递函数

- 核心特性:根据本组的4×2个输入位即可确定本组的G* 和P*

- 组间进位信号

![image-20220925172519417](https://s2.loli.net/2022/11/06/M5sJ1GKI6eCl4pw.png)



通过观察组内进位和组间进位信号，我们可以发现这两个的方式形式都类似

- {% span red, 如果我们改变一下CLA输入的话 %}我们就可以得出C4,8,12,16
- ![image-20220925172722026](https://s2.loli.net/2022/11/06/3JiYmvHSK1ob4Fh.png)

- 再改进：

![image-20220925172751530](https://s2.loli.net/2022/11/06/CXKGVz2exa8oR1j.png)

- {% span red, 多级先进进位方式 %}：获得组内并行，组间并行进位方式



### ALU优化

原理和CLU相似

初始ALU

![image-20220925173108413](https://s2.loli.net/2022/11/06/OLTvFwkyJ4WtUYc.png)

优化ALU

![image-20220925173043655](https://s2.loli.net/2022/11/06/7tEd5sXWgIAoZDk.png)





# 第三章：存储系统

## 存储器的基本概念

### 存储器的层次结构

![image-20220926164201373](https://s2.loli.net/2022/11/06/dCPtxLR5DOahETq.png)

注:有的教材把安装在电脑内部的磁盘称为“辅存”，把U盘、光盘等称为“外存”，也有的教材把磁盘、U盘、光盘等{% span red, 统称为“辅存”或“外存” %}.

![image-20220926164258336](https://s2.loli.net/2022/11/06/CIPgWX7erVNh3DJ.png)

- {% span red, 辅存中的数据要调用主存后才能够被CPU访问 %}.

- 主存-辅存:实现虚拟存储系统，{% span red, 解决了主存容量不够的问题 %}.
- Cache—主存:{% span red, 解决了主存与CPU速度不匹配的问题 %}.

### 存储器的分类（从不同角度进行分类）

#### 层次分类：

- 高速缓存（Cache）
- 主存储器（主存，内存）
- 辅助存储器

- {% span red, 其中高速缓存和主存储器都是可以直接被CPU读写的，辅助存储器中的数据之后调用到主存中，才能够被CPU访问 %}

#### 存储介质

- 半导体存储器（主存，Cache）， 以半导体部件存储信息
- 磁表面存储器：磁带，磁盘，以磁性材料存储信息
- 光存储器，以光介质存储信息 

#### 存取方式

随机存取存储器（RandomAccess Memory,RAM）: 读写任何一个存储单元所需{% span red, 时间都相同 %}，与存储单元{% span red,所在的物理位置无关 %}.

顺序存取存储器(SequentialAccess Memory，SAM): 读写一个存储单元所需时间{% span red, 取决于存储单元所在的物理位置 %}

直接存取存储器（Direct hccessMemory，DAM) :  {% span red, 既有随机存取特性，也有顺序存取特性 %}。先直接选取信息所在区域，然后按顺序方式存取。

串行访问存储器: 读写某个存储单元所需时间与存储单元的物理位置有关

相联存储器(Associative Memory） ,即可以{% span red, 按内容访问的存储器 %}(ContentAddressed Memory，CAM)可以按照内容检索到存储位置进行读“快表”就是一种相联存储器



#### 信息的可更改性

读写存储器（Read/Write Memory)——即可读、也可写(如:磁盘、内存、Cache)

只读存储器（Read Only Memory)——只能读，不能写(如:实体音乐专辑通常采用CD-ROM,实体电影采用蓝光光碟，BIOS通常写在ROM中)



#### 信息的可保存性

断电后，存储信息消失的存储器―-{% span red, 易失性存储器（主存、Cache） %}.

断电后，存储信息依然保持的存储器――{% span red, 非易失性存储器（磁盘、光盘) %}.

信息读出后，原存储信息被破坏――{% span red, 破坏性读出（如DRAM芯片，读出数据后要进行重写) %}.

信息读出后，原存储信息不被破坏――{% span red, 非破坏性读出（如SRAM芯片、磁盘、光盘) %}.

### 存储器的性能指标

存储容量:存储字数×字长（如1M×8位）。{% span red, MDR位数反映存储字长,MAR位数反应存储字数%}

单位成本:每位价格=总成本/总容量。

存储速度:{% span red, 数据传输率 %}=数据的宽度/存储周期。

- 存取时间(Ta）:存取时间是指从{% span red, 启动一次存储器操作到完成该操作所经历的时间 %}，分为读出时间和写入时间。
- 存取周期(Tm): 存取周期又称为读写周期或访问周期。它是{% span red, 指存储器进行一次完整的读写操作所需的全部时间 %}，即连续两次独立地访问存储器操作（读或写操作）之间所需的{% span red, 最小时间间隔 %}。

![image-20220926173949583](https://s2.loli.net/2022/11/06/GaVMlw4yz5Rmn2r.png)

主存带宽（Bm):{% span red, 主存带宽又称数据传输率 %}，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒（B/s）或位/秒(b/s） 。

![image-20220926174113203](https://s2.loli.net/2022/11/06/QwBaO4vyijGpSJl.png)



## 主存储器的基本组成

### 半导体元件的原理

- 为什么称作半导体：{% span red, 这种元器件，在特定情况下可以导通 %}

存储元的基本图示：

- MOS管可理解为一种电控开关，输入电压达到某个阈值时，MOS管就可以接通，{% span red, 是一个半导体元件 %}
- 当电容中有电的时候，表明这个电容存放的数据是1，
- 当电容中没有电的时候，表明这个电容存放的数据是0，
- 因为电容的一端是接地的，所以就看另一端的电容板上电压是高电压还是低电压

​	![image-20220926175210628](https://s2.loli.net/2022/11/06/s4vnGSUk5AXOlHy.png)

- 上述存储元存数据和写数据的方式
- 读：
  - 给MOS管一个高电压，让这个电路接通，
  - 如果电容中有电的话，{% span red, 电子就会顺着导线向外流动，外部感受到高电压，表明这时候从中读取了1 %}
  - 如果电容中没有电的话，外部的会感受到低电压，那么表明这时候从中读取了数据 0
- 写
  - 给MOS管一个高电压，让这个电路接通，
  - 如果想要写入数据 0的话，我们就给外部一个低电压，那么电容中还是不存电
  - 如果想要写入数据1的话，我们给外部一个高电压，那么电容中会存电

![image-20220926180325589](https://s2.loli.net/2022/11/06/gaSwZe3yuTKYqN7.png)

### 存储芯片的基本原理

![image-20220926185325310](https://s2.loli.net/2022/11/06/uTPJ3Hrw5MxVeKA.png)

- 如果先要获取MAR中存放地址的数据需要经过以下步骤
  1. MAR先通过译码器翻译成机械码，例如图中MAR中的地址为：000，表明现在要读取第0个单元的数据，这时候我们通过译码器将{% span red, 地址信息为0号的字选线设置为1（高电平） %}
  2. 这时候第0个单元的数据开始进行读取，将读取的数据放到数据总线上去
- 改进：{% span red, 添加控制电路 %}
  1. 因为地址总线放入MAR中的数据是以高低电压为信号的，所以我们需要在{% span red, 其电压稳定之后再讲MAR中的数据放到译码器中 %}
  2. 我们在MDR中电流稳定的时候才能将数据放到数据总线中
- 外接线：
  - 片选线CS 和CE （Chip Control or Chip Enable），上面有一个横线表明低电平有效
  - 读写控制线：
    - 两根读/写线
    - WE允许写
    - OE允许读
    - 一根读写线：
      - WE低电平写
      - 高电平读

![image-20220927105616680](https://s2.loli.net/2022/11/06/EV6CNiMwST5sra9.png)

移码驱动：保证译码器输出的电信号稳定，其实就是把电信号放大的一个部件

片选线：来控制那个存储芯片有效，因为一个存储器中有很多个存储芯片

每一个存储芯片都有一定数量的金属引脚：{% span red, 数量 %}: 每一个地址线对应着一个金属引脚，每一个数据线对应着一个金属引脚，片选线对应着一个金属引脚，读写控制线至少对应着两个引脚

n位地址→$2^n$个存储单元

总容量 = 存储单元个数×存储字长 = $2^3 \times 8bit = 2^3 ×1Byte = 8B$

8×8位的存储芯片

常见的描述:8K×8位，即$2^{13}×8bit$
8K×1位，即$2^{13}×1bit$64K×16位，即$2^{16}×16bit$

### 如何实现不同的寻址方式

 ![image-20220928100940473](https://s2.loli.net/2022/11/06/AuLM8hiRPWSOKpl.png)

总容量为1KB地址线:10根

按字节寻址:1K个单元，每个单元1B

按字寻址:256个单元，每个单元4B

按半字寻址:512个单元，每个单元2B

按双字寻址:128个单元，每个单元8B

![image-20220928101056208](https://s2.loli.net/2022/11/06/IqXxv8aAF7TsSlp.png)







## SRAM和DRAM

- {%span red, 随机存储器 %}

Dynamic  Random Access Memory，即动态RAM，用于{% span red, 主存 %}

Static  Random Access Memory，即静态RAM，用于{% span red, Cache %}

高频考点：DRAM和SRAM的对比

{% tip %}栅极电容DRAM{% endtip %}

![image-20220928103619254](https://s2.loli.net/2022/11/06/Jkw3NvZxHOl6jFe.png)

读出1: MOS管接通,电容放电，数据线上产生电流

- 电容放电信息被破坏，是{% span red, 破坏性读出 %}。读出后应有{% span red, 重写 %}操作，也称“再生”
- {% label 读写速度更慢 red %}

读出0: MOS管接通后，数据线上无电流

- {% span red, 每个存储元制造成本更低，集成度高，功耗低 %}.
- 2ms之内必须“刷新”一次（给电容充电）



{% tip %}双稳态触犯器{% endtip %}

输出1：A高B低

输出0：A低B高

![image-20220928103930385](https://s2.loli.net/2022/11/06/VSxL4q57ysRcAUo.png)



读出数据，触发器状态保持稳定,是{% span red, 非破坏性读出,无需重写 %}.

- {% label 读写速度更快 green %}
- {% span red, 每个存储元制造成本更高，集成度低,功耗大 %}.
- 只要不断电,触发器的状态就不会改变

### DRAM的刷新

1. 多久需要刷新一次？
   - 刷新周期：{% span red, 一般为2ms %}
2. 每次刷新多少存储单元？
   - 以行地址为单位，每次刷新一行存储单元
   - 为什么需要使用行列地址，减少选通线的数量

简单存储器

![image-20220928144842722](https://s2.loli.net/2022/11/06/8XzZ5u4fwcDPb36.png)

行列存储器：

![image-20220928144924227](https://s2.loli.net/2022/11/06/hBJZ6EyL2bRVawQ.png)

- 如$2^8=256$根选通线，$2^4+2^4=32$根选通线

3. 如何刷新？
   - 有硬件支持，读写一行的信息之后重新写入，占用一个读写周期
4. 再什么时候刷新？
   - 存取周期假设DRAM内部结构排列成128×128的形式，读/写周期0.5us，2ms共2ms/0.5us = 4000个周期

- 第一种方式：
  - 每次读写完都刷新一行→系统的存取周期变为1us，前0.5us时间用于正常读写后0.5us时间用于刷新某行

![image-20220928150107577](https://s2.loli.net/2022/11/06/fYw14oFRMcnSzN3.png)

- 第二种方式：
  - 2ms内集中安排时间全部刷新→系统的存取周期还是0.5us有一段时间专门用于刷新，无法访问存储器，称为访存“死区”

![image-20220928150231642](https://s2.loli.net/2022/11/06/UiS3KmTvarIyzx7.png)

- 第三种方式：
  - 2ms内每行刷新1次即可，2ms内需要产生128次刷新请求每隔2ms/128= 15.6us一次，每15.6us内有0.5us的“死时间”

![image-20220928150347837](https://s2.loli.net/2022/11/06/yY2vBd1Xi36b8ah.png)

- 因为DRAM中的行列地址，所以我们在计算地址线，{% span red, 地址引脚减半 %}

## 只读存储器ROM

RAM芯片――易失性，断电后数据消失

ROM芯片――非易失性，断电后数据不会丢失


MROM( Mask Read-Only Memory） ――掩模式只读存储器

- 广家按照客户需求，在芯片生产过程中直接写入信息，之后{% span red, 任何人不可重写 %}(只能读出)可靠性高、灵活性差、生产周期长、只适合批量定制

PROM (Programmable Read-Only Memory) ――可编程只读存储器

+ 用户可用专门的PROM写入器写入信息，{% span red, 写一次之后就不可更改 %}.

EPROM (Erasable Programmable Read-Only Memory)――可擦除可编程只读存储器

- 允许用户写入信息，之后用某种方法擦除数据，{% span red, 可进行多次重写 %}.
- UVEPROM (ultraviolet rays）――用紫外线照射8~20分钟，擦除{% span red, 所有 %}信息
- EEPROM（也常记为$E^2PROM$，第一个E是Electrically)――可用“电擦除”的方式，擦除{% span red, 特定的字 %}.

Flash Memory ――闪速存储器（注:U盘、SD卡就是闪存）

- 在EEPROM基础上发展而来，断电后也能保存信息，且{% span red, 可进行多次快速擦除重写 %}.
- 注意:由于闪存需要先擦除在写入，因此{% span red, 闪存的“写”速度要比“读”速度更慢 %}。

SSD ( Solid State Drives) ――固态硬盘

- 由控制单元+存储单元（Flash芯片）构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，{% span red, 可进行多次快速擦除重写 %}。SSD速度快、功耗低、价格高。目前个人电脑上常,用SSD取代传统的机械硬盘

{% tip %}计算机内的重要ROM{% endtip %}

- 主板上的BIOS芯片（ROM) ,存储了“自举装入程序”，负责引导装入操作系统（开机）
- 逻辑上,主存由RAM+ROM组成,且二者常统一编址

![image-20220928153624603](https://s2.loli.net/2022/11/06/Ln4sO1Dk8pyrCUF.png)



![image-20220928153705437](https://s2.loli.net/2022/11/06/b7XgVs93Z6prECk.png)



- 很多ROM芯片虽然名字是“Read-Only”，但{% span red, 很多ROM也可以“写” %}.

- {% span red, 闪存的写速度一般比读速度更慢 %}，因为写入前要先擦除
- RAM芯片是易失性的，ROM芯片是非易失性的。很多{% span red, ROM也具有“随机存取”;的特性 %}.

## 存储器与CPU的链接

### 单块存储芯片与CPU的连接

{% tip %}解决数据总线宽度＞存储芯片字长{% endtip %}

- 使用位扩展和字扩展

![image-20220928163031986](https://s2.loli.net/2022/11/06/9mnNgzB4dS27Ty1.png)

{% tip %}现代计算机结构{% endtip %}

![image-20220928163319958](https://s2.loli.net/2022/11/06/OnrK9xF8H2YfL3P.png)

- 一般主存中有多个存储芯片

![image-20220928163914402](https://s2.loli.net/2022/11/06/VghoeNruPcx7JK5.png)

上面有横杆的是低电平有效，上面没杠的是高电平有效

{% tip warning %}如果让多个芯片之间互相连接{% endtip %}

### 位扩展

![image-20220928171600090](https://s2.loli.net/2022/11/06/lDGoOMrZme3C1aF.png)

例如上面这张图：每一个芯片的地址为为1位操作，但是CPU地址总线为8位，所以如果{% span red, 只有一个芯片的话无法满足CPU一次性读取的位数  %}，这时候我们需要使用位扩展，{% span red, 将多片一位芯片扩展为多位芯片 %}.

![image-20220928172050317](https://s2.loli.net/2022/11/06/SosuQNaUMbF4wdf.png)

### 字扩展

- 看下面这个图片，{% span red, 数据位（MDR）都占满了 %}，但是{%span red, 扩展位（MAR）没有全部使用 %}，这时候我们需要使用{%span red, 位扩展 %}来解决这个问题

![image-20220928172151076](https://s2.loli.net/2022/11/06/Qb9Uxirh7Efze8w.png)



解决方法一：

![image-20220928172856840](https://s2.loli.net/2022/11/06/EwRLBeQnvWPV4MI.png)

- {% span red, 线选法 %}:使用多余的地址线来控制每一个芯片,为每一个芯片{% span red, 都使用一个地址线 %}，所以称为线选法。
- 但是如果我们A13和A14都是1的话，那么芯片一和芯片二都会输出数据，会导致出错。

解决方法二：

![image-20220928173427741](https://s2.loli.net/2022/11/06/AIXi5moepsz7UuW.png)

采用译码器

![image-20220928173534867](https://s2.loli.net/2022/11/06/JADR8hYzXZSrbk1.png)

|      线选法       |      译码片选法       |
| :---------------: | :-------------------: |
| n条线→n个选片信号 | n条线→$2^n$个选片信号 |
|     电路简单      |       电路复杂        |
|  地址空间不连续   |     地址空间连续      |

### 字位同时扩展

![image-20220928173850684](https://s2.loli.net/2022/11/06/7hmxIWSFj5toyqM.png)



![image-20220928173913219](https://s2.loli.net/2022/11/06/r8ftMlUoZEaq23V.png)

### 译码器

![image-20220928174728974](https://s2.loli.net/2022/11/06/IeOwSbu6FigfMkU.png)

- 这里的译码器{% span red, 多了一个使能信号 %}，和CS片选线控制信号功能类似，
- 使能信号的功能：能够让地址信号稳定后才向存储器发出请求信号 

## 双口RAM和多模块存储器

{% tip warning %}RAM存在的问题{% endtip %}

![image-20220929221104346](https://s2.loli.net/2022/11/06/MyLNxrQZ5TRfA2W.png)

- {% span red, 存储周期 %}：{% span green, 可以连续读/写的最短时间间隔 %}

{% note blue 'fas fa-bullhorn' flat %}

 DRAM芯片的恢复时间比较长，有可能是存取时间的几倍（SRAM的恢复时间较短)；

如:存取时间为r，存取周期为T，T=4r

问题：

多核CPU都要访存，怎么办?
CPU的读写速度主存快很多主存恢复时间太长怎么办?

{% endnote %}

### 提升主存速度

{% tip %}双口RAM{% endtip %}

![image-20220929222146711](https://s2.loli.net/2022/11/06/Ss2iMgqZCnkBYW8.png)

需要有两组完全独立的数据线、地址线、控制线。CPU、RAM中也要有更复杂的控制电路

两个端口对同一主存操作有以下4种情况:

1. 两个端口同时对不同的地址单元存取数据。{% span green, 允许操作 %}.
2. 两个端口同时对同一地址单元读出数据。{% span green, 允许操作 %}.
3. 两个端口同时对同一地址单元写入数据。{% span red, 禁止操作，写入错误 %}.
4. 两个端口同时对同一地址单元，一个写入数据，另一个读出数据。{% span red, 禁止操作，读出错误 %}.

- {% span red, 解决方法:置“忙”信号为0,由判断逻辑决定暂时关闭一个端口（即被延时)，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问。 %}

{% tip %}多模块存储器{% endtip %}

- 高体交叉编址的多位存储器
- {% span red, 连续存储的时候，按地址依此读取，是一个内存读取的 %}

![image-20220929224249587](https://s2.loli.net/2022/11/06/fHLu9cejZbMhEXw.png)

- 低位交叉编址的多位存储器
- {% span red, 连续存储的时候，按地址依此读取，是多个内存读取的 %}

![image-20220929224807915](https://s2.loli.net/2022/11/06/WAwaydqDJCsIlce.png)

- {% span red, 每个存储体存取周期为T存取时间为r，假设T=4r %}

![image-20220929225112521](https://s2.loli.net/2022/11/06/4XgRxQ8z3W1jSEn.png)

- 连续读取n个存储字 耗时nT

![image-20220929225505300](https://s2.loli.net/2022/11/06/ps7c6wyx2CrTenU.png)

- 宏观上读写个字的时间接近r

{% note blue 'fas fa-bullhorn' flat %}

为什么要探讨“连续访问” 的情况？

1. 在写程序的时候，如果没有特殊情况的话，我们都是按照程序顺序依此进行的
2. 在实际应用的时候许多数据都是按照连续存储的，例如数组

{% endnote %}



{% tip %}应该取几个“体”{% endtip %}

采用“{% span yellow, 流水线 %}”的方式并行存取（宏观上并行，微观上串行)

宏观上，一个存储周期内，m体交叉存储器可以提供的数据量为单个模块的m倍。

存取周期为T，{% span red, 存取时间为r %}，为了使流水线不间断，应保证模块数m≥T/r

存取周期为T，{% span red, 总线传输周期为r %}，为了使流水线不间断，应保证模块数m≥T/r

- 这时候需要CPU需要{% span red, 等待R %}.

![image-20220929231209986](https://s2.loli.net/2022/11/06/lSXPyA8tT7F9s1x.png)

- 这时候需要CPU会{% span red, 闲置r %}.

![image-20220929231219183](https://s2.loli.net/2022/11/06/a3fKErDSk7ywvo5.png)

- 这时候CPU得到充分的利用{% span red, 完美衔接 %}

![image-20220929225505300](https://s2.loli.net/2022/11/06/ps7c6wyx2CrTenU.png)



- 特点：
  - 每个模块都有相同的容量和存取速度。
  - 各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。

{% tip %}单体多字存储器{% endtip %}

![image-20220929232224415](https://s2.loli.net/2022/11/06/5y3EYUePzL9uHlb.png)

- 每个存储单元存储m个字总线宽度也为m个字{% span red, 一次并行读出m个字 %}.
- 每次只能同时取m个字，{% span red, 不能单独取 %}其中某个字，指令和数据在主存内必须是{% span  red, 连续存放的 %}.

![image-20220929232243553](https://s2.loli.net/2022/11/06/WEsKrRNzjQ4CtkH.png)

### 内存条插入方法：低位交叉存储器

![image-20220930082723528](https://s2.loli.net/2022/11/06/CPizpkVSjKsW58X.png)

例如这个主板上的有四个内存条插口：

如何插入内存条，实现高位交叉的多体存储器（相当于单纯的扩容)？

- 插入颜色不同的内存条插口形成{% span red, 高位交叉多体存储器 %}.

如何插入内存条，实现低位交叉的多体存储器（俗称“双通道”)?

- 插入颜色相同的内存条插口形成{% span red, 低位交叉多体存储器 %}.

Tips:买内存条时，可挑选相同主频、相同容量的两根来组成双通道:

- 如果主频不同的话，按照低频率的内存条的频率来进行读取数据{%span red, 频率高的那个内存条会进行降频处理 %}，
- 如果容量不同的话，多出来的容量会形成高位交叉多体存储器，速度还是慢



## Cache基本原理，基本概念

{% tip warning %}虽然我们通过双端口RAM，多块存储器提高存储器的工作速度，但是优化之后的速度还是与CPU的速度差异很大，这时候我们引入“Cache-主存”来改善存储体系的速度，程序访问的局部性原理 {% endtip %}

### Cache工作原理

![image-20220930090629135](https://s2.loli.net/2022/11/06/QMsX4o5hkgYURLT.png)

- 我们在运行程序的时候分为以下几个步骤
  1. 首先从辅存中读取数据到内存中，{% span red, 这样辅存中的数据才能够被CPU访问 %}.
  2. 我们将内存中{% span red, 这一时间段内需要经常使用的数据放到Cache中 %}.
  3. CPU通过向Cache或者内存中读取数据来进行数据处理
- 实际上，Cache被集成在CPU内部Cache用SRAM实现，速度快，成本高



### 局部性原理

- {% label 空间局部性 red %}:在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在存储空间上是邻近的
  - 例如数组，顺序执行的指令代码
- {% label 时间局部性 red %}:在最近的未来要用到的信息，很可能是现在正在使用的信息
  - 循环结构的指令代码
- 基于局部性原理，不难想到，可以把CPU目前访问的地址“周围”的{% span red, 部分数据放到Cache中 %}.

![image-20220930091458450](https://s2.loli.net/2022/11/06/IF7bkXUxtYg6lpe.png)

- 程序A是顺序存储的数组，按行存储
- 程序B是跳序存储的数组，按列存储
- 由于数组在内存中的存储方式以按行顺序存储的，所以在执行程序A的时候，大概率会将A后面一部分放到Cache中，但是由于B不是按照顺序存储的，所以B程序运行时间大概率比A慢的多



### 性能分析

![image-20220930091912628](https://s2.loli.net/2022/11/06/l9OM6JX5qjBWbyx.png)

设$t_c$为访问一次Cache所需时间,$t_m$为访问一次主存所需时间

命中率H:CPU欲访问的信息已在Cache中的比率,{% span red, 就是CPU想要访问的数据已经放到Cache中的概率 %}.

缺失（未命中）率M= 1-H

- 访问时间

- 先访问Cache，若Cache未命中在访问主存

  - Cache—主存系统的{% span red, 平均访问时间 %}t为：$t = Ht_c+(1-H)(t_c+ t_m)$

- 同时访问Cache和主存，若Cache命中则立即停止访问主存

  - $t = Ht_c+(1-H)t_m)$

  

{% note blue 'fas fa-bullhorn' flat %}

假设Cache的速度是主存的5倍，且Cache的命中率为95%，则采用Cache后，存储器性能提高多少(设Cache和主存同时被访问，若Cache命中则中断访问主存)?

设Cache的存取周期为t，则主存的存取周期为5t

- {% span red, 若Cache和主存同时访问 %}，命中时访问时间为t，未命中时访问时间为5t
  - 平均访问时间为$0.95\times t+0.05\times 5t= 1.2t$
  - 故性能为原来的5/1.2≈4.17倍

-  {% span red, 若先访问cache再访问主存 %}，命中时访问时间为t，未命中时访问时间为t+5t
  - 平均访问时间为$T_a=0.95×t+0.05×6t=1.25t$
  - 故性能为原来的5/1.25 = 4倍

{% endnote %}

### 有待解决的问题

基于局部性原理，不难想到，可以把CPU目前访问的地址“{% span red, 周围 %}”的部分数据放到Cache中。如何界定“{% span red, 周围 %}”?

将主存的{% span red, 存储空间“分块” %}，如:每1KB为一块。{% span red, 主存与Cache之间以“块”为单位进行数据交换 %}.

![image-20220930093658738](https://s2.loli.net/2022/11/06/nmyaOxSVe5hu2tD.png)



主存地址共22位：

| 块号 | 块内地址 |
| :--: | :------: |
| 12位 |   10位   |

$4M=2^{22}，1K=2^{10}$
整个主存被分为$2^{12}= 4096$块

- 操作系统中,通常将主存中的"一个{% span red, 块 %}"也称为"一个页/页面/页框"
- Cache中的“{% span red, 块 %}”也称为“{% span red, 行 %}”

注意：

- {% label 每次CPU在主存中访问的数据块，一定会立即被调入Cache red %}

![image-20220930090024189](https://s2.loli.net/2022/11/06/eXsnmtJOfTNGpuj.png)

如何区分Cache 与主存的数据块对应关系?

- Cache和主存的映射方式

Cache很小，主存很大。如果cache满了怎么办?

- 替换算法

CPU修改了Cache中的数据副本，如何确保主存中数据母本的一致性?

- Cache写策略



## Cache与主存的三种映射方式

![image-20220930101734180](https://s2.loli.net/2022/11/06/zt1LYGo4gI9lHkx.png)

- 全相联映射：{% span red, 主存块可以放在Cache的任意位置 %}.
- 直接映射: {% span red, 每个主存块只能放到一个特定的位置:Cache块号=主存块号% Cache总块数 %}.
- 组相联映射：Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置，组号=主存块号%分组数

 ### 全相联映射

假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行（{% span red, 即Cache块，与主存块的大小相等 %}），行长为64B。

$256M=2^{28}$主存的地址共28位:

| 主存块号 | 块内地址 |
| :------: | :------: |
|   22位   |   6位    |

![image-20220930103151500](https://s2.loli.net/2022/11/06/wYSf58Tpa6GObih.png)

CPU访问主存地址1..1101001110:

- 主存地址的{% span red, 前22位 %},对比Cache中所有块的{% span red, 标记 %};
- 若标记匹配且有效位=1，则cache命中,访问块内地址为001110的单元。
- 若未命中或有效位=0，则正常访问主存



### 直接映射（只能存放在固定位置）

假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B。

直接映射，主存块在cache中的{% span red, 位置=主存块号取余Cache总块数 %}. 

![image-20220930103839367](https://s2.loli.net/2022/11/06/Hn8O61dblVmjBCq.png)

- {% span rd, 缺点 %}: 其他有空闲的Cache块，但是8号主存块不能够使用
- 这里标记位是22位，能否优化一下
  - 若Cache总块数=$2^n$则{% span red, 主存块号末尾n位直接反映它在Cache中的位置 %}.
  - {% span red, 将主存块号的其余位作为标记即可 %}.

CPU访问主存地址0...01000 001110 :

1. 根据主存块号的{% span red, 后3位确定Cache行 %}
2. 若主存块号的{% span red, 前19位 %}与Cache{% span red, 标记 %}匹配且有效位=1，则Cache命中，访问块内地址为001110的单元。
3. 若未命中或有效位=0，则正常访问主存



### 组相联映射

![image-20220930105015005](https://s2.loli.net/2022/11/06/qxiTIW9nrHtwvM7.png)



CPU访问主存地址1...1101001110 :

1. 根据主存块号的{% span red, 后2位 %}确定所属分组号
2. 若主存块号的{% span red, 前20位 %}与分组内的某个{% span red, 标记 %}匹配且效位=1,则cache命中，访问块内地址为001110的单元。

![image-20220930105050279](https://s2.loli.net/2022/11/06/ex7mOGcwkVNEaL3.png)



## Cache替换算法

- 替换算法只会用到{% span red, 全相联映射和组相联映射 %}，直接映射无需考虑替换算法。

{% tip %}随机算法（RAND）{% endtip %}

- {% span red, 随机算法（RAND %} ,Random)一―若cache已满，则随机选择一块替换。

设总共有4个cache块，初始整个Cache为空。采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}

![image-20220930142045382](https://s2.loli.net/2022/11/06/rgqBQ2DUVlzaEMd.png)

- 随机算法――实现简单，{% span red, 但完全没考虑局部性原理，命中率低 %}，(实际效果很不稳定)

{% tip %}先进先出算法（FIFO）{% endtip %}

- {% span red, 先进先出算法（FIFO %}, First In First Out）一―若Cache已满，则替换最先被调入Cache的块

设总共有4个Cache块，初始整个cache为空。采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}

![image-20220930142322292](https://s2.loli.net/2022/11/06/eVTA9ksREyzfO3a.png)

先进先出算法――实现简单，最开始按#O#1#2#3放入Cache，之后轮流替换#0#1#2#3FIFO

依然没考虑局部性原理，{% span red, 最先被调入Cache的块也有可能是被频繁访问的 %}.

- {% span red, 抖动现象 %}:频繁的换入换出现象(刚被替换的块很快又被调入)

{% tip %}近期最少使用（LRU）{% endtip %}

- {% span red, 近期最少使用算法(LRU %}, Least Recently Used )——为每一个Cache块设置一个“{% span yellow, 计数器 %}”，用于记录每个cache块已经有多久没被访问了。当Cache满后{% span red, 替换“计数器”最大的 %}.

设总共有4个cache块，初始整个cache为空。采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}

- {% label 我们在做题的时候，选择近期最少使用的数据的方式可以是：从该列向前寻找n-1列，找出最近没有被使用的数据，并将它替换 %}

![image-20220930143337369](https://s2.loli.net/2022/11/06/cnHUVdflLKxJjkP.png)

Cache块的总数=$2^n$，则计数器只需n位。且Cache装满后{% span red, 所有计数器的值一定不重复 %}.

1. 命中时，所命中的行的计数器清零，{% span red, 比其低的计数器加1，其余不变 %};
2. 未命中且还有空闲行时，新装入的行的计数器置0，其余{% span red, 非空闲行全加1 %}.
3. 未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全+1

LRU算法――基于“局部性原理”，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰蹻久没被访问过的块是合理的。LRU算法的实际运行效果优秀，Cache命中率高。

若被{% span red, 频繁访问的主存块数量>Cache行的数量 %}，则有可能发生“{% span red, 抖动 %}”，如:{123451234512}

{% tip %}最近不经常使用（LFU）{% endtip %}

最不经常使用算法({% span red, LFU %}, Least Frequently Used )-—为每一个Cache块设置一个“{% span red, 计数器 %}”，用于记录每个cache块被访问过几次。当cache满后{% span red, 替换“计数器”最小的 %}.

设总共有4个Cache块，{% span red, 初始整个Cache为空。采用全相联映射 %}，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}

![image-20220930144448189](https://s2.loli.net/2022/11/06/Vw29HWzsFJe6Rar.png)

- {%span red, 计数器的范围 %}：0-很大的数，这时候我们需要给计数器分配一个比较大的空间
- 新调入的块计数器=0，之后每被访问一次计数器+1。需要替换时，选择计数器最小的一行
- LFU算法：{% span red, 曾经被经常访问的主存块在未来不一定会用到 %}（如:微信视频聊天相关的块)并没有很好地遵循{% span red, 局部性原理 %}，因此实际运行效果不如 LRU

![image-20220930144740672](https://s2.loli.net/2022/11/06/CI9dfvoHVasU25O.png)

## Cache写策略

- 这是我们只是讨论写命中和写不命中两种情况
- 为什么不讨论读操作？
  - 因为只要是读操作，就一定不会出现数据不一致的问题

### 写命中

{% tip %}写回法(write-back){% endtip %}

写回法(write-back)—当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，{% span  red, 只有当此块被换出时才写回主存 %}.

减少了访存次数，但存在数据不一致的隐患

![image-20220930145858983](https://s2.loli.net/2022/11/06/PvdAjWTEUoXkFlM.png)



{% tip %}全写法（write-through）{% endtip %}

![image-20220930152003854](https://s2.loli.net/2022/11/06/iaLpv2V7DPgbxdY.png)



全写法(写直通法，write-through)——当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲(write buffer)

使用写缓冲，CPU写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞



### 写不命中

{% tip %}写分配法（write-allocate）{% endtip %}

![image-20220930152419269](https://s2.loli.net/2022/11/06/ISTLOuBJl54pFkw.png)



写分配法(write-allocate)——当CPU对Cache{% span red, 写不命中时 %}，把主存中的块调入Cache，在Cache中修改。通常{% span red, 搭配写回法使用 %}。

写回法(write-back)——当CPU对Cache{% span red, 写命中时 %}，只修改Cache的内容，而不立即写入主存,只有当此块被换出的时候才写会主存

{% tip %}非写分配法{% endtip %}

![image-20220930152537895](https://s2.loli.net/2022/11/06/3soniKIrDNOPp8G.png)

非写分配法(not-write-allocate)—当CPU对Cache写不命中时只写入主存，不调入Cache。搭配全写法使用。

全写法(写直通法，write-through)——当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲(write buffer)

### 多级Cache

![image-20220930153557599](https://s2.loli.net/2022/11/06/RpeS3lBo6LsAJGH.png)

现代计算机常采用{% span red, 多级Cache %}.

离CPU越近的速度越快，容量越小

离CPU越远的速度越慢，容量越大

- 各级Cache之间常采用"全写法+非写分配注"
- Cache-主存之间常采用"写回法+写分配法"

![image-20220930153757879](https://s2.loli.net/2022/11/07/NXnuE6W4RTvpchk.png)



## 页式存储器

我们在运行程序的时候，有可能这个程序运行所需要的内存很大，无法直接全部放进主存，可能主存空间不够，

- 为了解决这个页面我们通常可以将一个程序分为大小相等的一个个页，{% span red, 每个页面的大小和主存一个单元的大小相等 %}.
- 把分好的页面{% span red, 离散 %}的放入主存中，{% span red, 这时候可以提高主存利用率，不再需要连续的内存地址了 %}

![image-20221001091732955](https://s2.loli.net/2022/11/06/NGSJ7OxsImVF5RB.png)

- 页式存储系统:一个程序(进程)在逻辑上被分为若干个大小相等的“{% span red, 页面 %}”，{% span red, “页面”大小与“块”的大小相同 %}。每个页面可以离散地放入不同的主存块中。



### 虚地址 vs 实地址

- {% span red, 逻辑地址（虚地址） %}:程序员视角看到的地址

- {% span red, 物理地址（实地址） %}:实际在主存中的地址

取变量x至ACC寄存器

机器指令:{% span green, 000001 %} {% span red, 00 %}1000000011 {% span green, 操作码 %}+地址码（使用逻辑地址)

程序员视角:整个程序共$4KB=2^{12}B$，地址范围:000000000000~111111111111

变量x的逻辑地址:{% span red, 00 %} 1000000011

变量y的逻辑地址:{% span red, 11 %} 0000001010

| 逻辑页号 | 页内地址 |
| :------: | :------: |
|  若干位  |   10位   |

 ![image-20221001093400943](https://s2.loli.net/2022/11/06/ENpUg5RIKVv2FGt.png)

- 主存大小是4M = 4 * 1024k = $2^{12}k$ 
- 主存的物理地址共22位

| 主存块号 | 块内地址 |
| :------: | :------: |
|   12位   |   10位   |

变量x的物理地址:000000000010 1000000011

变量y的物理地址:111111111111 0000001010

### 逻辑页号→主存块号

通常使用页表来记录逻辑页号到物理页号的的映射

| 逻辑页号 | 主存页号 |
| :------: | :------: |
|    #0    |    2     |
|    #1    |   4094   |
|    #2    |    0     |
|    #3    |   4095   |

CPU执行的机器指令中，使用的是“逻辑地址”，因此需要通“页表”将逻辑地址转为物理地址。

页表的作用:记录了每个逻辑页面存放在哪个主存块中

变量x的逻辑地址:{% span red, 00 %}1000000011

变量x的物理地址:{% span red, 000000000010 %}1000000011

![image-20221001101703073](https://s2.loli.net/2022/11/06/uenWCKv5d3fQBiy.png)

{% tip %}增加快表{% endtip %}

![image-20221001102344799](https://s2.loli.net/2022/11/06/UouDTC823zkh1KP.png)

- 注意区别: 快表中存储的是页表项的副本; Cache中存储的是主存块的副本

{% tip %}读取文件全部过程{% endtip %}

![image-20221001103752745](https://s2.loli.net/2022/11/06/PEwJWXkFsRK65qH.png)

## 虚拟存储器

- 用户所感受到的内存比实际的内存要大很多，这就是虚拟存储器

| 逻辑页号 | 主存块号 | 外村块号 | 有效位 | 访问位 | 脏位 |
| :------: | :------: | :------: | :----: | :----: | :--: |
|    #0    |    2     |    a     |   1    |   13   |  0   |
|    #1    |   4094   |    b     |   1    |   18   |  1   |
|    #2    |    0     |    c     |   0    |   0    |  0   |
|    #3    |    0     |    d     |   0    |   0    |  0   |

{% tip %}页式虚拟存储器{% endtip %}

![image-20221001145116603](https://s2.loli.net/2022/11/06/yVNSM6qKtUD3r2i.png)

- {% span red, 有效位 %}:这个页面是否已调入主存

- {% span red, 脏位 %}:这个页面是否被修改过

- {% span red,引用位 %}:用于“页面置换算法”，比如，可以用来统计这个页面被访问过多少次

- {% span red,物理页 %}:即主存块号

- {% span red,磁盘地址 %}:即这个页面的数据在磁盘中的存放位置

{% tip %}存储器的层次化结构{% endtip %}

![image-20221001145501293](https://s2.loli.net/2022/11/06/ykOnbuQz1GxSpwI.png)

- 主存―辅存:实现虚拟存储系统，{% span red, 解决了主存容量不够的问题 %}.
  - 操作系统决定，哪些页面调入主存
- Cache一主存:{% span red, 解决了主存与CPU速度不匹配的问题 %}.
  - 硬件决定那些主存块调入Cache

![image-20221001145554094](https://s2.loli.net/2022/11/06/LvT8hzQFwiX1Up6.png)



{%tip%}段式虚拟存储器{%endtip%}

![image-20221001150029444](https://s2.loli.net/2022/11/06/JYHpA7FfOdEeWts.png)



段式虚拟存储器――按照{% span red, 功能模块 %}拆分如:

- O段是自己的代码，
- 1段是库函数代码，
- 2段是变量

页式虚拟存储器――拆分成{% span red, 大小相等 %}的页面

段式虚拟存储器的结构：

![image-20221001150204411](https://s2.loli.net/2022/11/06/ZQixrwpVq4BLv52.png)



{% tip %}段页式虚拟存储器{% endtip %}

把程序{% span red, 按逻辑结构分段 %}，每段再{% span red, 划分为固定大小的页 %}，{% span blue, 主存空间也划分为大小相等的页 %}，程序对主存的调入、调出仍{% span red, 以页为基本传送单位 %}。

每个程序对应一个段表，每段对应一个页表。

虚拟地址:{% span red, 段号+段内页号+页内地址 %}.



# 第四章：指令系统

## 指令格式

{% tip %}指令的定义{% endtip %}

指令(又称机器指令)）:

- 是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。
- 一台计算机的所有指令的集合构成该机的{% span red, 指令系统 %}，也称为{% span red, 指令集 %}。
- 注:一台计算机只能{% span red, 执行自己指令系统中的指令 %}，不能执行其他系统的指令。
- Eg: x86架构、ARM架构

{% tip %}指令格式{% endtip %}

一条指令就是机器语言的一个语句，它是一组有意义的二进制代。

一条指令通常要包括操作码字段和地址码字段两部分:

![image-20221007220838468](https://s2.loli.net/2022/11/06/7ikbOrjCqFAs8vy.png)

一条指令可能包含o个、1个、2个、3个、4个地址码...
根据地址码数目不同，可以将指令分为零地址指令、一地址指令、二地址指令...

{% tip %}零地址指令OP{% endtip %}

不需要操作数，如空操作、停机、关中断等指令
堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶

![image-20221007222450473](https://s2.loli.net/2022/11/06/6bw7EOBijk8Tvar.png)



{% tip %}一级地址指令{% endtip %}

![image-20221008110241184](https://s2.loli.net/2022/11/06/oEQReH8CBZ19AIs.png)

1. 只需要单操作数，如加1、减1、取反、求补等

   指令含义:OP(Ai)→A1，	完成一条指令需要3次访存:取指→读A1→写A1

2. 需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC)

   指令含义:(ACC)OP(Ai) → ACC, 完成一条指令需要2次访存:取指→读A1

3. 注:A1指某个{% span red, 主存地址 %}(类似：C语言指针)，(Ai)表示Ai所指向的{% span red, 地址中的内容 %}(指针所指置的内容)

{% tip %}二，三地址指令{% endtip %}

![image-20221008110301884](https://s2.loli.net/2022/11/06/l2gaD4xENHVU3io.png)

常用于需要两个操作数的算术运算、逻辑运算相关指令

指令含义:(Ai)OP(Az)→A1，（默认存回A1）

完成一条指令需要访存4次，取指→读A1→读A2→写A1

![image-20221008110349039](https://s2.loli.net/2022/11/06/tvbsPIUBWxuE8He.png)

常用于需要两个操作数的算术运算、逻辑运算相关指令

指令含义:(A1)OP(A2)→A

完成一条指令需要访存4次，取指→读A1→读A2→写A3

{% tip %}四地址指令{% endtip %}

![image-20221008110711166](https://s2.loli.net/2022/11/06/iM32rU8JbDwz5Kg.png)

指令含义:(Ai)OP(A2)→A3，A4={% span red, 下一条将要执行指令的地址 %}.

完成一条指令需要访存4次，取指→读A1→读A2→写A3

正常情况下:取指令之后PC+1，指向下一条指令

四地址指令:执行指令后，将PC的值修改位A4所指地址



{% tip %}地址码的位数有什么影响?{% endtip %}

n位地址码的直接寻址范围=$2^n$

若指令总长度固定变，则地址码数量越多，每个地址块的位数越短，寻址能力越差

![image-20221008111403815](https://s2.loli.net/2022/11/06/vQ6aiRDkjwFbNVd.png)



### 指令-按指令长度分类

- {% span red, 指令字长 %}:一条指令的总长度（可能会变)
- 机器字长:CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关)
- 存储字长:一个存储单元中的二进制代码位数（通常和MDR位数相同）

半字长指令、单字长指令、双字长指令		—―指令长度是机器字长的多少倍

指令字长会影响取指令所需时间。如:机器字长=存储字长=16bit, 则取一条双字长指令需要两次访存

- {% span red, 定长指令字结构 %} :(指令系统少所有指令的长度都相等
- {% span red, 变长指令字结构 %}:指令系统中各种指令的长度不等

### 指令-按操作码的长度分类

- {% span red, 定长操作码 %}:指令系统中所有指令的操作码长度都相同
  - n位→$2^n$条指令
  - 控制器的译码电路设计简单,但灵活性较低
- {% span red, 可变长操作码 %}:指令系统中各指令的操作码长度可变
  - 控制器的译码电路设计复杂,但灵活性较高

### 指令-按操作类型分类

{% tip %}数据传送类：进行主存与CPU之间的数据传送{% endtip %}

1. 数据传送

   LOAD作用:把存储器中的数据放到寄存器中

   STORE作用:把寄存器中的数据放到存储器中

{% tip %}运算类{% endtip%}

2. 算术逻辑操作

   算术:加、减、乘、除、增1、减1、求补、浮点运算、十进制运算

   逻辑:与、或、非、异或、位操作、位测试、位清除、位求反

3. 移位操作

   算术移位、逻辑移位、循环移位(带进位和不带进位)

{% tip %}程序控制类 - 改变程序执行的顺序{% endtip%}

4. 转移操作

   无条件转移JMP

   条件转移JZ:  结果为0;   JO:结果溢出;     JC:结果有进位

   调用和返回    CALL和RETURN

   陷阱(Trap)与陷阱指令

{% tip %}输入输出类（I/O）：进行CPU与I/O设备之间的数据传送{% endtip%}

5. 输入输出操作

   CPU寄存器与IO端口之间的数据传送(端口即IO接口中的寄存器)

![image-20221008113027826](https://s2.loli.net/2022/11/06/Dz39Q4o6ERbIlpS.png)



## 扩展操作码

指令由操作码和若干个地址码组成。

- {% span  red, 定长指令字结构 %}:指令系统中所有指令的长度都相等
- {% span red, 变长指令字结构 %}:指令系统中各种指令的长度不等
- {% span red, 定长操作码 %}:指令系统中所有指令的操作码长度都相同
- {% span red, 可变长操作码 %}:指令系统中各指令的操作码长度可变
- 定长指令字结构+可变长操作码 →{% span red, 扩展操作码指令格式 %}.不同地址数的指令使用不同长度的操作码

{% tip %}扩展操作码举例{% endtip %}

指令字长为16位，每个地址码占4位:

前4位为基本操作码字段OP，另有3个4位长的地址字段A1、A2和A3。

4位基本操作码若全部用于三地址指令，则有16条。

但至少须将1111留作扩展操作码之用，即三地址指令为15条;

11111111留作扩展操作码之用，二地址指令为15条;

1111 11111111留作扩展操作码之用，一地址指令为15条;

零地址指令为16条。

![image-20221008114133118](https://s2.loli.net/2022/11/06/LvHIyeiJUnzQ9qR.png)

在设计扩展操伤码指令格式时，必须注意以下两点:

1. {% span red, 不允许短码是长码的前缀 %}，即短操作码不能与长操作码的前面部分的代码相同。
2. 各指令的操作码一定不能重复。

通常情况下，对使用频率较高的指令，分配较短的操作码;对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。

![image-20221008120058405](https://s2.loli.net/2022/11/06/9nkPYJgs7LGqRmN.png)

设地址长度为n，上一层留出m种状态，下一层可扩展出m×$2^n$种状态

{% tip %}小结{% endtip %}

操作码指出指令中该指令应该执行什么性质的操作和具有何种功能。

操作码是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息。例如，指出是算术加运算，还是减运算;是程序转移，还是返回操作。

操作码分类:
定长操作码:在指令字的最高位部分分配固定的若干位（定长）表示操作码。

- 一般n位操作码字段的指令系统最大能够表示2"条指令。
- 优:定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利;
- 缺:指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。

扩展操作码(不定长操作码):全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。

- 最常见的变长操作码方法是扩展操作码，使操作码的长度随地址码的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。
- 优:在指令字长有限的前提下仍保持比较丰富的指令种类;
- 缺:增加了指令译码和分析的难度，使控制器的设计复杂化。

## 指令寻址

指令寻址：如何确定下一条指令的存放地址；

指令结构：![image-20221015085649220](https://s2.loli.net/2022/11/06/YqbGpnBlmP1HJer.png)

### 顺序寻址

（PC）+1→PC；其中1表示个指令字长，实际加的值会因指令长度、编址方式而不同

如果主存中是按字节编值的，并且一条指令的长度为16比特位，那么{% span red, 不能够让PC简单的加1来获取下一条指令存放的地址 %}，这时候需要让PC+2才能获取下一条指令的地址，{% span red, 如果是采用变长指令结构的话操作方式又不一样 %}.

EG:指令寻址:{% span blue, 下一条 %}欲执行{% span blue, 指令 %}的{% span red, 地址 %}(始终由程序计数器PC给出)

该系统采用{% span red, 定长指令字结构 %}，指令字长=存储字长=16bit=2B，主存{% span red, 按字编址 %}.

- 指令寻址方式：PC+1

该系统采用{% span red, 定长指令字结构 %}，指令字长=存储字长=16bit=2B，主存{% span red, 按字节编址 %}.

- 指令寻址方式：PC+2

该系统采用{% span red, 变长指令字结构 %}，指令字长=存储字长=16bit=2B，主存{% span red, 按字编址 %}.

- 读入一个字，根据操作码判断这条指令的总字节数n,修改PC的值
- ( PC)+n→PC
- 根据指令的类型，CPU可能还要进行多次访存，每次读入一个字

![image-20221015090458724](https://s2.loli.net/2022/11/06/ik6MogLcvNnFVxa.png)





### 跳跃寻址

跳跃寻址:由转移指令指出

- 该系统采用定长指令字结构
- 指令字长=存储字长=16bit=2B
- 主存按字编址
- JMP:无条件转移把PC中的内容改成7
- 当执行0，1,2的时候都是顺序寻址，直接让PC指向下一个位置的指令即可
- 在执行3语句的时候会执行JMP跳转，让PC跳转到7的位置

![image-20221015090858963](https://s2.loli.net/2022/11/06/1JNIKD3tkqRrjMh.png)



![image-20221015091153914](https://s2.loli.net/2022/11/06/S3ljLrH5TsbVEex.png)



## 数据寻址

![image-20221015091246861](https://s2.loli.net/2022/11/06/RYrU27yeOsKvPgX.png)

数据寻址：确定本条指令的地址码指明的真实地址

![image-20221015091403870](https://s2.loli.net/2022/11/06/IuQlYa6LiKPyOwN.png)

接下来会涉及到：隐含寻址，立即寻址，直接寻址，间接寻址，寄存器寻址，寄存器间接寻址，相对寻址，基址寻址，变址寻址，堆栈寻址，10中寻址方式，所以我们使用4位数据来表示寻址特征；

![image-20221015091651452](https://s2.loli.net/2022/11/06/7zvJDNfkR12pnHI.png)

求出操作数的{% span red, 真实地址 %},称为{% span red, 有效地址(EA) %}。

二地址指令

![image-20221015091744282](https://s2.loli.net/2022/11/06/UcOEykwD3sW6unm.png)



### 直接寻址

直接寻址:指令字中的{% span red, 形式地址A %}就是操作数的{% span red, 真实地址EA %}，即EA=A 

![image-20221015091926518](https://s2.loli.net/2022/11/06/WNLbj7TK54mJEnz.png)

一条指令的执行:{% span red, 取指令 %}访存1次,{% span red, 执行指令 %}访存1次暂不考虑存结果共{% span red, 访存2次 %}.

优点:简单，指令执行阶段{% span red, 仅访问一次主存 %}，不需专门计算操作数的地址。

缺点:A的位数决定了该指令操作数的寻址范围。操作数的地址不易修改,{% span red, 范围小不易修改 %}。

### 间接寻址

间接寻址:指令的地址字段给出的{% span red, 形式地址不是操作数的真正地址 %}，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=(A)。

![image-20221015092334939](https://s2.loli.net/2022/11/06/exVluwhcUdL67nr.png)

优点: 

- 可扩大寻址范围(有效地址EA的位数大于形式地址A的位数),实际寻址大小是EA的大小。
- 便于编制程序(用间接寻址可以{% span red, 方便地完成子程序返回 %})。

缺点:

- 指令在执行阶段{% span red, 要多次访存 %}(一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存)。



### 寄存器寻址

寄存器寻址:在指令字中直接给出操作数所在的寄存器编号，即EA =R，其操作数在由$R_i$所指的寄存器内。

![image-20221015092745301](https://s2.loli.net/2022/11/06/GUxtYe9rV5lgCEp.png)

一条指令的执行:{% span red, 取指令 %}访存1次, {% span red, 执行指令访存0次 %}暂不考虑存结果共访存1次

优点:

- 指令在{% span red, 执行阶段不访问主存 %}，只访问寄存器，{% span red, 指令字短且执行速度快 %}，支持向量/矩阵运算。

缺点:

- 寄存器价格昂贵，计算机中寄存器个数有限。



### 寄存器间接寻址

寄存器间接寻址:寄存器R,中给出的不是一个操作数，而是{% span red, 操作数所在主存单元的地址 %}，即EA=(R)。

![image-20221015093135883](https://s2.loli.net/2022/11/06/qzj361ynkT9ieDO.png)

一条指令的执行:{% span red, 取指令 %}访存1次, {% span red, 执行指令 %}访存1次暂不考虑存结果共访存2次

特点:

- 与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存(因为操作数在主存中)。



### 隐含寻址

隐含寻址:不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。

![image-20221015093348432](https://s2.loli.net/2022/11/06/z9d6IO8QhWfYDpT.png)

优点:有利于缩短指令字长。

缺点:需增加存储操作数或隐含地址的硬件。



### 立即寻址

立即寻址:形式地址A就是操作数本身，又称为立即数，{% span red, 一般采用补码形式 %}。#表示立即寻址特征。

一条指令的执行:取指令访存1次执行指令访存0次暂不考虑存结果共访存1次

优点:

- 指令执行阶段{% span red, 不访问主存 %}，指令执行时间最短

缺点:

- A的位数限制了立即数的范围。
- 如A的位数为n，且立即数采用补码时，可表示的数据范围为$-2^{n-1} - (2^{n-1}-1)$



### 偏移寻址

![image-20221015093815946](https://s2.loli.net/2022/11/06/tay3I89L5KjWX4A.png)

这三种方式区别在于偏移的”起点“不一样

- 基址寻址:以程序的起始存放地址作为“起点”

- 变址寻址:程序员自己决定从哪里作为“起点”

- 相对寻址:以程序计数器PC所指地址作为“起点”

### 基址寻址

基址寻址:将CPU中基址寄存器（BR）的内容加2指令格式中的形式地址A,而形成操作数的有效地址，即EA=(BR)+A。

优点:便于程序“浮动”，方便实现多道程序并发运行

BR一一base address register

EA一一effective address

拓展:程序运行前,CPU将BR的值修改为该程序的起始地址(存在操作系统PCB中)

专用寄存器

![image-20221015094508118](https://s2.loli.net/2022/11/06/PbmjNiyqQSadGw3.png)

通用寄存器：

![image-20221015094630490](https://s2.loli.net/2022/11/06/csv5nOPL18Qjga2.png)



注:基址寄存器是{% span red, 面向操作系统 %}的，其{% span red, 内容由操作系统或管理程序确定 %}。在程序执行过程中，基址寄存器的内容不变（作为基地址)，形式地址可变（作为偏移量）。

![image-20221015101801227](https://s2.loli.net/2022/11/06/pJYOhR8ko54U2uz.png)



当采用{% span red, 通用寄存器作为基址寄存器时 %}，可由{% span red, 用户决定哪个寄存器作为基址寄存器 %}，但其{% span red, 内容仍由操作系统确定 %}。

优点:可扩大寻址范围（基址寄存器的位数大于形式地址A的位数)﹔{% span red, 用户不必考虑自己的程序存于主存的哪一空间区域 %}，故{% span red, 有利于多道程序设计 %}，以及可用于编制浮动程序(整个程序在内存里边的浮动).

### 变址寻址

IX = Index Register

变址寻址:有效地址EA等于指令字中的形式地址A与{% span red, 变址寄存器IX %}的内容相加之和，即{% span red, EA= (IX)+A %}，其中{% span red, IX可为变址寄存器（专用），也可用通用寄存器作为变址寄存器 %} 。

![image-20221015101117172](https://s2.loli.net/2022/11/06/4ZVclKRwH67d5nJ.png)

注:变址寄存器是{% span red, 面向用户的 %}，在程序执行过程中，{% span red, 变址寄存器的内容可由用户改变 %}(IX作为偏移量)，形式地址A不变（{% span red, 作为基地址 %})

![image-20221015101544941](https://s2.loli.net/2022/11/06/wZdEH6bXpqVMnL3.png)

 

![image-20221015101933087](https://s2.loli.net/2022/11/06/zSvUiM2TtXWEsDk.png)



### 相对寻址

相对寻址:把{% span red, 程序计数器PC %}的内容加上指令格式中的形式地址A而形成操作数的有效地址，即{% span red, EA=(PC)+A %}，其中{% span red, A是相对于PC %}所指地址的{% span red, 位移量 %}，可正可负，{% label 补码表示 red %}。

![image-20221015102229602](https://s2.loli.net/2022/11/06/FYxJuEz1miOlyno.png)

- A是相对下一条指令地址的偏移量

没有采用相对寻址的时候：

![image-20221015102436892](https://s2.loli.net/2022/11/06/hPxwuHjgNMvrTQd.png)

如果我们想要移动一下改代码的位置的话：

![image-20221015102518865](https://s2.loli.net/2022/11/06/79N1YMBJV4KkcrS.png)

这时候如果在采用上面的方式的话则会出现错误，在执行到M+3的时候，程序会跳转到主存地址为2的位置，这显然不是我们想要的

![image-20221015102644850](https://s2.loli.net/2022/11/06/r4DO2Q8oxBCjTPL.png)

相对寻址:EA=(PC)+A，其中{% span red, A是相对于PC %}所指地址的{% span red, 位移量 %}，可正可负，{% span red, 补码表示 %}.

优点:这段代码在程序内浮动时{% span red, 不用更改跳转指令的地址码 %}.

但是这有一个问题：我们的基地址一直是7，解决方发：

- ACC加法指令的地址码,可采用“分段”方式解决，即程序段、数据段分开。
- 在每一段的地址都相对不变



优点:操作数的地址不是固定的，它随着Pc值的变化而变化，并且与指令地址之间总是相差一个固定值，因此{% span red, 便于程序浮动 %}(一段代码在程序内部的浮动）。

相对寻址{% span red, 广泛应用于转移指令 %}。



```C
if(a>b){
    ....
} else {
    ....
}
```

硬件视角:

- 通过”cmp指令”比较a和 b（如cmp a, b），实质上是用a-b
- 相减的结果信息会记录在程序状态字寄存器中(PSW)
- 根据PSW的某几个标志位进行条件判断，来决定是否转移

PSW中有几个比特位记录上次运算的结果

- 进位/借位标志CF:最高位有进位/借位时CF=1
- 零标志ZF:运算结果为0则ZF=1，否则ZF=0
- 符号标志SF:运算结果为负，SF=1，否则为0
- 溢出标志OF:运算结果有溢出OF=1否则为0



### 堆栈寻址

堆栈寻址:操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址

堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出(LIFO)”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针(SP) 。

- {%label SP-StackPointer red %}.

![image-20221015103823353](https://s2.loli.net/2022/11/06/vlHiAWbu4Lae7Ey.png)

![image-20221015104057726](https://s2.loli.net/2022/11/06/Gl9xnWrsLigQzaS.png)



![image-20221015104138693](https://s2.loli.net/2022/11/06/JgmIziKV3O7Bpot.png)



## CISC 和 RISC

ClSC:Complex Instruction Set Computer

- 设计思路:一条指令完成一个复杂的基本功能。

- 代表: x86架构，主要用于笔记本、台式机等
- C语言中库函数

RISC:Reduced lnstruction Set Computer

- 设计思路:一条指令完成一个基本“动作”;多条指令组合完成一个复杂的基本功能。
- 代表:ARM架构，主要用于手机、平板等
- 单纯C语言



EG：设计一套能实现整数、矩阵加/减/乘运算的指令集:

- CISC的思路:除了提供整数的加减乘指令除之外，还提供矩阵的加法指令、矩阵的减法指令、矩阵的乘法指令
  - 一条指令可以由一个专门的电路完成
  - 有的复杂指令用纯硬件实现很困难→采用“存储程序”的设计思想，由一个比较通用的电路配合存储部件完成一条指令
- RISC的思路:只提供整数的加减乘指令
  - ​	一条指令一个电路，电路设t相对简单，功耗更低“并行”、“流水线“

![image-20221015104904094](https://s2.loli.net/2022/11/06/g8yfJnwEF5mzHX6.png)



# 第五章：中央处理器

## CPU的功能和基本结构

### CPU的功能

1. 指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
2. 操作控制。一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
3. 时间控制。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。
4. 数据加工。对数据进行算术和逻辑运算。
5. 中断处理。对计算机运行过程中出现的异常情况和特殊请求进行处理。

### 运算器和控制器的基本功能

CPU ={% label 运算器+控制器 %}.

运算器：对数据进行加工

控制器：

1. 协调并控制计算机各部件执行程序的指令序列，基本功能包括取指令、分析指令、执行指令
2. 取指令:自动形成指令地址;自动发出取指令的命令。
3. 分析指令:操作码译码(分析本条指令要完成什么操作);产生操作数的有效地址。
4. 执行指令:根据分析指令得到的“操作命令”和“操作数地址”，形成操作信号控制序列，控制运算器、存储器以及I/O设备完成相应的操作。
5. 中断处理:管理总线及输入输出;处理异常情况(如掉电)和特殊请
   求(如打印机请求打印一行字符)。

### 运算器的基本结构

{% tip %}专用数据通路方式{% endtip %}

专用数据通路方式:根据指令执行过程中的数据和地址的流动方向安排连接线路。

如果{% span red, 直接用导线连接 %}，相当于多个寄存器同时并且一直向ALU传输数据

解决方法1.使用多路选择器根据控制信号选择一路输出

解决方法2.使用三态门可以控制每一路是否输出

如: ROout为1时Ro中的数据输出到A端，ROout为0时Ro中的数据无法输出到B端

![image-20221016091938478](https://s2.loli.net/2022/11/06/5NC9qFO8RxbQGtY.png)

解决方法1：

![image-20221016092450647](https://s2.loli.net/2022/11/06/EAoxcuBUW83DKCP.png)

解决方法2：

![image-20221016092521218](https://s2.loli.net/2022/11/06/dgaZGlLSQspkyIT.png)

其中R0,R1,R2...是通用寄存器，例如有些X86计算机中使用的寄存器，如AX, BX, CX,DX,SP等：

![image-20221016092233847](https://s2.loli.net/2022/11/06/yGe2oIbOvVLdnij.png)

{% tip %}CPU内部单总线方式{% endtip%}

所需要的元件：

1. 算术逻辑单元:主要功能是进行算术/逻辑运算。

2. 通用寄存器组:如AX、BX、CX、DX、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果)和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。

3. 暂存寄存器:用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。

   如:两个操作数分别来自主存和R0，最后结果存回R0，那么从主存中取来的操作数{% span red, 直接放入暂存器 %}，就{% span red, 不会破坏运算前R的内容 %}。

4. 累加寄存器:它是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算。

5. 程序状态字寄存器:保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志(OP)、符号标志（SF)、零标志(ZF）、进位标志(CF)）等。PSW中的这些位参与并决定微操作的形成。

6. 移位器:对运算结果进行移位运算。

7. 计数器:控制乘除运算的操作步数。

CPU内部单总线方式:将所有寄存器的输入端和输出端都连接到一条公共的通路上。

- {% label 结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。 red %}.

<img src="https://s2.loli.net/2022/11/06/t82OAerSaU46gKv.png" alt="image-20221016092751967" style="zoom:67%;" />

例如上面这个图：如果我们想要将R0和R1中的数据放到ALU中， 如果他们两个寄存器{% span red, 同时向数据总线传输数据的话 %}，ALU的AB两端可能会接收到冲突的数据

解决方法：添加一个暂存寄存器，可以吧先输入的数据先放到暂存寄存器中，等下一个数据过来之后在一起运算

<img src="https://s2.loli.net/2022/11/06/pNlVQL5ExdfRnPj.png" alt="image-20221016093532081" style="zoom:67%;" />

我们还可以给ALU输出端加一个寄存器：当{% span red, 运算结果稳定之后 %}再将结果送到数据总线中去

![image-20221016094005748](https://s2.loli.net/2022/11/06/KHxirZdguhzXoYQ.png)



### 控制器的基本结构

![image-20221016094705999](https://s2.loli.net/2022/11/06/JU8VDieXcd1PK4k.png)

1. 程序计数器:用于指出下一条指令在主存中的存放地址。CPU就是根据PC的内容去主存中取指令的。因程序中指令（通常）是顺序执行的，所以Pc有自增功能。
2. 指令寄存器:用于保存当前正在执行的那条指令。
3. 指令译码器:仅对操作码字段进行译码，向控制器提供特定的操作信号。
4. 微操作信号发生器:根据IR的内容（指令）、PSW的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。
5. 时序系统:用于产生各种时序信号，它们都是由统一时钟(CLocK）分频得到。
6. 存储器地址寄存器:用于存放所要访问的主存单元的地址。
7. 存储器数据寄存器:用于存放向主存写入的信息或从主存中读出的信息。



### CPU的基本结构

![image-20221016094913845](https://s2.loli.net/2022/11/06/ciEIPH75ZeDNwux.png)

![image-20221016094949927](https://s2.loli.net/2022/11/06/H12Y4oKbDJzNIdC.png)

![image-20221016095038772](https://s2.loli.net/2022/11/06/f2iRWKYP7xJT6nd.png)



## 指令执行过程

### 指令周期

1. 指令周期:CPU从主存中每取出并执行一条指令所需的全部时间。

2. 指令周期常常用若干{% span red, 机器周期 %}来表示，机器周期又叫{% span red , CPU周期 %}。

![image-20221016100915777](https://s2.loli.net/2022/11/06/JVF4QonTyEmvgGB.png)

一个{% span red, 机器周期又包含若干时钟周期 %}（也称为节拍、T周期或CPU时钟周期，它是CPU操作的最基本单位）。

每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等。

![image-20221016101020038](https://s2.loli.net/2022/11/06/d48NxkuUOEPgQCK.png)

![image-20221016101549983](https://s2.loli.net/2022/11/06/wV2UYZfSq1iv4AL.png)

### 指令周期流程

![image-20221016102400153](https://s2.loli.net/2022/11/06/HulGIvUOEYxg8a9.png)

四个工作周期都有CPU访存操作，{% span red, 只是访存的目的不同 %}。{% span red, 取指周期 %}是为了{% span red, 取指令 %}，{% span red, 间址周期 %}是为了{% span red, 取有效地址 %}，{% span red, 执行周期 %}是为了{% span red, 取操作数 %}，{% span red, 中断周期 %}是为了{% span red, 保存程序断点 %}。

### 指令周期的数据流-取指周期

![image-20221016103330882](https://s2.loli.net/2022/11/06/ghnDkwKzNvLay97.png)

1. 当前指令地址送至存储器地址寄存器，记做:(PC)→MAR
2. CU发出控制信号，经控制总线传到主存，这里是读信号，记做:1→R
3. 将MAR所指主存中的内容经数据总线送入MDR，记做:M(MAR)→MDR
4. 将MDR中的内容(此时是指令)送入IR,记做:(MDR)→IR
5. CU发出控制信景，形成下一条指令地址，记做:(PC)+1→(PC)

### 指令周期的数据流-间址周期

![image-20221016104546750](https://s2.loli.net/2022/11/06/a64LwY2KkftJchB.png)



1. 将指令的地址码送入MAR, 

   记做:	Ad(IR) → MAR  或	Ad(MDR)→ MAR

2. CU发出控制信号，启动主存做{% span red, 读操作 %},记做:1→R
3. 将MAR所指主存中的内容经数据总线送入MDR，记做: M(MAR)→KMDR
4. 将有效地址送至指令的地址码字段,记做:(MDR)→Ad(IR)

### 指令周期的数据流-执行周期

执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。



### 指令周期的数据流-中断周期

中断:暂停当前任务去完成其他任务。为了能够恢复当前任务，需要{% span red, 保存断点 %}。

一般使用{% span red, 堆栈 %}来保存断点，这里{% span red, 用SP表示栈顶地址 %}，假设{% span red, SP指向栈顶元素 %}，进栈操作是{% span red, 先修改指针，后存入数据 %}。

1. CU控制将SP减1，修改后的地址送入MAR记做:(SP)-1 →SP，(SP)→ MAR，本质上是将断点存入某个存储单元，假设其地址为a，故可记做: a → MAR，获取断点需要存放的堆栈寄存器的地址

2. CU发出控制信号，启动主存做写操作，记做:1→w，执行堆栈寄存器的写操作
3. 将断点(PC内容)送入MDR,记做:(PC)→MDR，将PC中的数据放到MDR中准备写入堆栈寄存器中
4. CU控制将中断服务程序的入口地址(由向量地址形成部件产生)送入PC,记做:向量地址→PC，记录中断数据的首地址

![image-20221016144804639](https://s2.loli.net/2022/11/06/YXt9pBgkG1dIqao.png)

### 指令执行方案

 一个指令周期通常要包括几个时间段（执行步骤)，每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。

![image-20221016145059880](https://s2.loli.net/2022/11/06/MYGlcJKrW386RSL.png)

方案1．单指令周期

- 对所有指令都选用相同的执行时间来完成。
- 指令之间串行执行;{% span red, 指令周期取决于执行时间最长的指令的执行时间 %}。
- 对于那些{% span red, 本来可以在更短时间内完成的指令，要使用这个较长的周期来完成 %}，会降低整个系统的运行速度。

方案2．多指令周期

- 对不同类型的指令选用不同的执行步骤来完成。
- 指令之间串行执行;可选用不同个数的时钟周期来完成不同指令的执行过程。
- 需要更复杂的硬件设计。

方案3．流水线方案

- 在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。指令之间并行执行。



![image-20221016145341323](https://s2.loli.net/2022/11/06/OAmNPQda8945rZR.png)



## 数据通路的功能

### 单总线结构

- {% span red, 内部总线 %}是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线;

- {% span red, 系统总线 %}是指同一台计算机系统的各部件，如CPU、内存、通道和各类I/O接口间互相连接的总线。

1. 寄存器之间数据传送

   比如把PC内容送至MAR，实现传送操作的流程及控制信号为:(PC)→Bus

   PCout有效，PC内容送总线

   Bus→MAR

   MARin有效，总线内容送MAR

2. 主存与CPU之间的数据传送

   比如CPU从主存读取指令，实现传送操作的流程及控制信号为;(PC)→Bus→MAR

   PCout和MARin有效，现行指令地址→MAR
   1→R     CU发读命令(通过控制总线发出，图中未画出
   MEM(MAR)→MDR       MDRin有效

3. 执行算术或逻辑运算

   比如一条加法指令微操作序列及控制信号为:

   Ad(IR)→Bus→MAR)	MDRout和MARin有效

   1→R	CU发读命令

   MEM(MAR)→数据线→MDR 	MDRin有效

   MDR→Bus→Y	MDRout和Yin有效,操作数→Y

   (ACC)+(Y)→z	ACCout和ALUin有效，CU向ALU发送加命令

   Z→ACC	Zout和ACCin有效，结果→ACC

![image-20221016153522355](https://s2.loli.net/2022/11/06/sRKzJgeHVjky7Tf.png)





### 单总线结构：例题

![image-20221016154148234](https://s2.loli.net/2022/11/06/IwDNn8ZV2zuFRiv.png)

设有如图所示的单总线结构，分析指令ADD(RO),R1的指令流程和控制信号。

1. 分析指令功能和指令周期

   功能:((RO))+(R1)→(RO)

   取指周期、间址周期、执行周期

2. 写出各阶段的指令流程

   取值周期：公共操作

| 时序 |                       微操作                       |       有效控制信号       |
| :--: | :------------------------------------------------: | :----------------------: |
|  1   |            (PC)→MAR<br />先获取这条指令            |       PCout, MARin       |
|  2   |        M(MAR) →MDR<br />获取这条指令的内容         | MemR，MARout<br />MDRinE |
|  3   | (MDR)→IR<br />将这条指令的内容<br />放到IR寄存器中 |       MDRout,IRin        |
|  4   |                      指令译码                      |            -             |
|  5   |                     (PC)+1→PC                      |            -             |

间址周期:{% span red, 完成取数操作，被加数在主存中，加数已经放在寄存器R1中 %}。

| 时序 |                            微操作                            |       有效控制信号        |
| :--: | :----------------------------------------------------------: | :-----------------------: |
|  1   | (R0)→MAR<br />将这条指令的间接地址放到<br />MAR中，从内存中读取这个数据的有效地址 |        R0out,MARin        |
|  2   |            M(MAR)→MDR<br />获取这个数据的有效地址            | MenR, MARout,<br />MDRinE |
|  3   |            (MDR )→Y<br />将这个地址放到Y寄存器中             |        MDRout,Yin         |

执行周期:完成取数操作，被加数在主存中，加数已经放在寄存器R1中。

| 时序 |                      微操作                      |              有效控制信号              |
| :--: | :----------------------------------------------: | :------------------------------------: |
|  1   |    (R1)+(Y)→Z<br />将R1和Y寄存器中的数据相加     | R1out,ALUin,CU<br />向ALU发ADD控制信号 |
|  2   | (Z)→MDR<br />将结果放到MDR中，<br />准备写入到R0 |              Zout，MDRin               |
|  3   |                   (MDR)→M(MAR)                   |          MemW,MDRoutE,MARout           |

![image-20221016160239937](https://s2.loli.net/2022/11/06/Q4Ol9SYWZAv8DLq.png)





### 专用通路结构

![image-20221016161516222](https://s2.loli.net/2022/11/06/bXJ3UQ2iB8MzynG.png)

(PC)>MAR	C0有效

(MAR)→主存	C1有效

1→R			控制单元向主存发送读命令
M(MAR)→MDR		C2有效

(MDR)>IR				C3有效

(PC)+1→PC

Op(IR)→CU		C4有效



### 专用通路结构：例题

下图是一个简化了的CPU与主存连接结构示意图(图中省略了所有的多路选择器)。其中有一个累加寄存器(ACC)、一个状态数据寄存器和其他4个寄存器:主存地址寄存器(MAR) 、主存数据寄存器(MDR) 、程序寄存器(PC) 和指令寄存器(IR) ，各部件及其之间的连线表示数据通路，箭头表示信息传递方向。

要求：

1. 请写出图中a、b、c、d 4个寄存器的名称。
   d能自动“+1”， 是PC

   PC内容是地址，送MAR，故c是MAR ,

   b与微操作信号发生器相连，是IR

   与主存相连的寄存器是MAR和MDR，c是MAR,

   则a是MDR

2. 简述图中取指令的数据通路。

   - (PC)→MAR
   - M(MAR)→MDR
   - (MDR)→IR
   - OP(IR)→微操作信号发生器
   - (PC)+1→PC

3. 简述数据在运算器和主存之间进行存/取访问的数据通路。

   - {% span red, 运算器中不能够存数据，所以这题是问的ACC到主存之间的数据的存取 %}.
   - 存/取的数据放到ACC中
   - 设数据地址已放入MAR
   - 取: M(MAR) > MDR      (MDR)→ALU→ACC
   - 存:(ACC) > MDR,    (MDR) > M(MAR)

4. 简述完成指令LDA X的数据通路(X为主存地址，LDA的功 能为(X)→ACC)。

   - X→MAR
   - M(MAR) → MDR
   - (MDR)→ALU→ACC

5. 简述完成指令ADD Y的数据通路(Y为主存地址，ADD的功 能为(ACC)+ (Y)→ACC)

   - Y→MAR
   - M(MAR) → MDR
   - (MDR)→ALU, (ACC)→ALU
   - ALU→ACC

6. 简述完成指令STA Z的数据通路(Z为主存地址，STA的功能为(ACC)→Z)。

   - Z→MAR
   - (ACC) → MDR
   - (MDR)→M(MAR)

![image-20221016163112380](https://s2.loli.net/2022/11/06/WnwfbMUeq3m59GZ.png)	

![image-20221016162912848](https://s2.loli.net/2022/11/06/K6PvwGd58qOYoA4.png)



## 硬布线控制器的设计

一条指令分为四个周期：{% label 取指周期(FE)，间值周期(IND)，执行周期(EX)，中断周期(INT) red %}.

![image-20221031151322233](https://s2.loli.net/2022/11/06/BhpFzfO58dHr3yC.png)

CU发出一个{% span red, 微命令 %}，可完成对应微操作。

- 如:{% span red, 微命令1 %}使得PCout、MARjn有效。完成对应的{% span red, 微操作 %}1(PC)→MAR

根据{% span red, 指令操作码、目前的机器周期、节拍信号、机器状态条件 %}，即可确定现在这个{% span red, 节拍下应该发出哪些“微命令” %}.

![image-20221031151449760](https://s2.loli.net/2022/11/06/th5asu7E6gJW9Bd.png)

一个节拍内可以{% span red, 并行 %}完成多个{% span red, “相容的”微操作 %}.

同一个微操作{% span red, 可能在不同指令的不同阶段被使用 %}.

不同指令的执行周期所需节拍数各不相同。为了简化设计，选择{% span red, 定长的机器周期 %}，以可能出现的最大节拍数为准（通常{% span red, 以访存所需节拍数作为参考 %})

若实际所需节拍数较少，可将微操作安排在机器周期未尾几个节拍上进行



### 硬布线控制器

![image-20221031152248535](https://s2.loli.net/2022/11/06/JtKhMSnwa7L4sjO.png)

根据{% span blue, 指令操作码 %}、{% span purple, 目前的机器周期 %}、{% span brown, 节拍信号 %}、{% span green, 机器状态条件 %}，即可确定现在这个节拍下{% span red, 应该发出哪些“微命令” %}.

所有指令的取指周期、T0节拍下一定要完成(PC)→MAR。则可知C1=FE·T0

微操作{% span red, 对应的逻辑表达式与电路 %}：

- {% span red, M(MAR) —>MDR %}微操作命令的逻辑表达式: FE·T1+IND·T1(ADD+STA+LDA+JMP+BAN)+EX·T(ADD+LDA)

![image-20221031154207120](https://s2.loli.net/2022/11/06/ro4bKj1TBqQix7w.png)



### 硬部件控制器的设计

{% tip warning %}探讨如何得到一个微操作与之对应的电路{% endtip %}



{% tip %}设计步骤{% endtip %}

1. 分析每个阶段的微操作序列(取值、间址、执行、中断四个阶段)

   确定哪些指令在什么阶段、在什么条件下会使用到的微操作

2. 选择CPU的控制方式

   采用定长机器周期还是不定长机器周期?每个机器周期安排几个节拍?

   假设采用同步控制方式（定长机器周期）,一个机器周期内安排3个节拍。

3. 安排微操作时序

   如何用3个节拍完成整个机器周期内的所有微操作?

4. 电路设计

   确定每个微操作命令的逻辑表达式,并用电路实现



{% tip %}分析每一个阶段的微操作序列{% endtip %}

取指周期（所有指令都一样）

- PC→ MAR
- 1→R
- M (MAR )→MDR
- MDR →IR
- OP (IR)→ID
- ( PC)+1 →PC
  - 注:ID是指令译码器lnstruction Decoder

间址周期（所有指令都一样)

- Ad(IR)→MAR
- 1→R
- {% span red, M(MAR ) MDR %}.
- MDR >Ad(IR)

执行周期(各不相同)

- CLA    0 →AC

  - clear ACC指令
  - ACC清零

- LDA X    Ad ( IR)MAR

  - 取数指令,	1→R
  - 把X所指内容  M(MAR) MDR
  - 取到ACC      MDR →AC

- JMP x    Ad (IR)PC

  - 无条件转移

- BAN X     A0*Ad ( lR ) + (非)A0·(PC)→PC

  Branch ACC Negative

  条件转移，当ACC为负时转移



{% tip %}安排微操作时序{% endtip %}

- {% label 原则 red %}

  原则一:微操作的{% span red, 先后顺序不得 %}随意{% span red, 更改 %}.

  原则二:{% span red, 被控对象不同 %}的微操作，尽量安排在{% span red, 一个节拍 %}内完成

  原则三:占用{% span red, 时间较短 %}的微操作，尽量安排在{% span red, 一个节拍内 %}完成，并{% span red, 允许有先后顺序 %}.

- 取指周期的微操作时序

  T0	(1)	PC→ MAR

  T0	(2) 	1 →R		存储器空闲即可
  T1	(3)	M(MAR ) →MDR	在(1)之后
  T1	(6)	 (PC)+1→PC		在(1)之后
  T2	(4)	MDR →IR		在(3)之后
  T2	(5)	OP ( IR)→ID		在(4)之后

  M( MAR )→MDR从主存取数据，{% span red, 用时较长，因此必须一个时钟周期才能保证微操作的完成 %}.

  MDR→IR是CPU内部寄存器的数据传送，{% span red, 速度很快，因此在一个时钟周期内可以紧接着完成 %},OP(IR )→ID。也就是可以一次同时发出两个微命令。

- 间值周期的微操作时序：

  T0	(1)	Ad(IR)→MAR

  T0	(2)	1→R
  T1	(3)	M (MAR ) → MDR

  T2	(4)	MDR→ Ad(IR)



{% tip %}电路的设计{% endtip %}

1. 列出操作时间表

   ![image-20221031170943367](https://s2.loli.net/2022/11/06/STFGxDQCwMYl8v2.png)

   

2. 写微操作命令的最简表达式

   有可能使用到M(MAR) → MDR所有情况

   ![image-20221031171605188](https://s2.loli.net/2022/11/06/tThiVkxzS5R8CKs.png)

   M(MAR) —>MDR微操作命令的逻辑表达式:
   FE·T1+ IND·T1(ADD+STA+LDA+JMP+BAN)+EX·T1(ADD+LDA)

   =T1{FE+IND(ADD+STA+LDA+JMP+BAN)+EX(ADD+LDA)}

3. 画出逻辑图、

   ![image-20221031171816566](https://s2.loli.net/2022/11/06/thRsvIY3JzBwjol.png)

硬布线控制器的特点:

指令越多，设计和实现就越复杂，因此一般用于RISC（精简指令集系统)

如果扩充一条新的指令，则控制器的设计就需要大改，因此扩充指令较困难。

由于使用纯硬件实现控制，因此执行速度很快。微操作控制信号由组合逻辑电路即时产生。



## 微程序控制器的基本原理

硬布线控制器：{% span red, 微操作控制信号 %}由组合逻辑电路根据当前的{% span red, 指令码、状态和时序(包含机器周期，节拍) %}，即时产生，{% span red, 使用纯硬件来实现 %}.

### 微程序控制器设计思路

采用“存储程序”的思想，{% span red, CPU出厂前将所有指令的“微程序”存入“控制器存储器”中 %}.

什么是微程序：

- {% label 程序 red %}:由指令序列组成

- {% label 微程序 red %}:由微指令序列组成，{% span red, 每一种指令对应一个微程序 %}.

- {% label 指令 red %}是对程序执行步骤的描述

- {% label 微指令 red %}是对指令执行步骤的描述

<img src="https://s2.loli.net/2022/11/06/Lajw6iImUykMRHr.png" alt="image-20221031190653825" style="zoom:50%;" /><img src="https://s2.loli.net/2022/11/06/MgnbrIJdf6mHGC8.png" alt="image-20221031181603580" style="zoom:50%;" />

- {% label 微命令与微操作 %}一一对应

- {% label 微指令 %}中可能包含{% span red, 多个微命令 %}.
- {% span red, 指令是对微指令功能的封装 %}

### 微程序控制器的基本结构

思考:所有指令的{% span red, 取指周期、间址周期、中断周期所对应的微指令序列都一样 %}，{% span green, 是否可以共享使用? %}.

![image-20221031183858126](https://s2.loli.net/2022/11/06/5bIOBnXgKldrqcx.png)



### 微控制器的工作原理

取指周期、间址周期、中断周期所对应的微指令序列都一样，{% span red, 可以一起使用 %}，故如果某指令系统中有n条机器指令，则CM中{% span red, 微程序段(有些地方认为取值，间址，中断，执行是一个微程序)的个数至少是n+1个 %}，因为{% span red, 一些早期的CPU、物联网设备的CPU可以不提供间接寻址和中断功能,因此这类CPU可以不包含间址周期、中断周期的微程序段 %}

<img src="https://s2.loli.net/2022/11/07/o84iw6vJAmZqEtX.png" alt="image-20221031185035390" style="zoom: 50%;" />        <img src="https://s2.loli.net/2022/11/06/gGsMAiekQbjDWzw.png" alt="image-20221031185159322" style="zoom: 50%;" />





![image-20221031190025656](https://s2.loli.net/2022/11/06/9BDKjOz4kVwyGPR.png)



## 微指令的设计

### 微程序控制器的工作原理

微指令的具体格式应该怎么设计? 如何{% span red, 根据微指令发出相应的微命令 %}?

微命令与微操作一一对应，{% span red, 一个微命令对应一根输出线 %}.

有的微命令可以并行执行，{% span red, 因此一条微指令可以包含多个微命令 %}.

<img src="https://s2.loli.net/2022/11/06/bNHTG7ruE4FWLDz.png" alt="image-20221031191048831" style="zoom:50%;" />

### 微命令的格式

相容性微命令:可以并行完成的微命令。

互斥性微命令:不允许并行完成的微命令。

1. 水平型微指令

   一条微指令能房义多个可并行的微命令。

   基本格式

<img src="https://s2.loli.net/2022/11/06/bNHTG7ruE4FWLDz.png" alt="image-20221031191048831" style="zoom: 67%;" />

![image-20221031191717243](https://s2.loli.net/2022/11/06/AR9eZbmx8FVMuOa.png)

- {% span green, 优点:微程序短，执行速度快 %};

- {% span red, 缺点:微指令长，编写微程序较麻烦 %}。

2. 垂直型微指令

一条微指令只能定义一个微命令，由微操作码字段规定具体功能

<img src="https://s2.loli.net/2022/11/06/toGxzia5KLj1s93.png" alt="image-20221031191434340" style="zoom:67%;" />

![image-20221031191733827](https://s2.loli.net/2022/11/06/BKeZcfN61WvCUTl.png)

- {% span green, 优点:微指令短、简单、规整，便于编写微程序 %};

- {% span red, 缺点:微程序长，执行速度慢，工作效率低 %}.

3. 混合型微指令

   在{% span red, 垂直型的基础上增加一些不太复杂的并行操作 %}。微指令较短，仍便于编写;微程序也不长，执行速度加快。



### 微指令的编码方式

微指令的编码方式又称为{% span red, 微指令的控制方式 %}，它是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是{% span red, 在保证速度的情况下，尽量缩短微指令字长 %}。

1. 直接编码（直接控制）方式

   在微指令的操作控制字段中，{% span red, 每一位代表一个微操作命令 %}

   某位为“{% span red, 1 %}”表示该控制信号有效

   其{% span green, 优点:简单、直观，执行速度快，操作并行性好 %}。

   其{% span red, 缺点:微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控存容量极大 %}。

![image-20221031192500340](https://s2.loli.net/2022/11/06/8zrQhnoPXKqFMsG.png)

2. 字段直接编码方式

   将微指令的控制字段分成若干“段”，{% span red, 每段经译码后发出控制信号 %}

   微命令字段分段的原则:

   1. {% span red, 互斥性 %}微命令分在{% span red, 同一段内 %}，{% span red, 相容性 %}微命令分在{% span red, 不同段内 %}。

   2. {% span red, 每个小段 %}中包含的{% span red, 信息位不能太多 %}，否则将增加译码线路的复杂性和译码时间。

   3. 一般{% span red, 每个小段还要留出一个状态 %}，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，{% span red, 通常用000表示不操作 %}。

   其{%label 优点:可以缩短微指令字长 green %}。

   其{% label 缺点:要通过译码电路后再发出微命令，因此比直接编码方式慢 red %}。

   ![image-20221031193300042](https://s2.loli.net/2022/11/06/1T9XIw2GnfiNyKO.png)



{% note blue 'fas fa-bullhorn' modern %}

问：某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用{% span red, 字段直接编码法 %}，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有多少位?

答：第1个互斥类有7个微命令，{% span red , 要留出1个状态表示不操作 %},所以需要表示8种不同的状态，故需要3个二进制位。以此类推，后面4个互斥类各需要表示4、13、6、7种不同的状态，分别对应2、4、3、3个二进制位。故操作控制字段的总位数为3+2+4+3+3=15位

tip：{% span red, 若采用直接编码的方式，则控制字段需要33位 %}.

{% endnote %}

3. 字段间接编码方式

   一个字段的{% span red, 某些微命令需由另一个字段中的某些微命令来解释 %},由于{% span red, 不是靠字段直接译码发出的微命令 %},故称为字段间接编码,又称隐式编码。

   其{% label 优点:可进一步缩短微指令字长 green %}。

   其{% label 缺点:削弱了微指令的并行控制能力，故通常作为字段直接编码方式的一种辅助手段 red %}。

![image-20221031194909555](https://s2.loli.net/2022/11/06/H6RAWcjStaxFyGh.png)





### 微指令的地址形成方式

1. 微指令的{% span red, 下地址字段指出―微指令格式中设置一个下地址字段 %}，由微指令的下地址字段直接指出后继微指令的地址，这种方式又称为{% span red, 断定方式 %}。
2. 根据机器指令的{% span red, 操作码 %}形成当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。
3. 增量{% span red, 计数器法 %}(CMAR )+1—>CMAR
4. 分支转移转移方式:指明判别条件;转移地址:指明转移成功后的去向。

![image-20221031203354739](https://s2.loli.net/2022/11/06/lFDIPVgAqfxHGKC.png)

5. 通过测试网络 

6. 由硬件产生微程序入口地址

   {% span red, 第一条微指令地址 %}由专门{% span red, 硬件 %}产生（用专门的硬件记录取指周期微程序首地址)

   中断周期由{% span red, 硬件 %}产生{% span red, 中断周期微程序首地址 %}（用专门的硬件记录)



### 例题：断定方式

<img src="https://s2.loli.net/2022/11/06/VcqWXDLN35y2YeS.png" alt="image-20221031185035390" style="zoom: 50%;" />

某计算机采用微程序控制器,共有32条指令，公共的取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成,采用{% span red, 断定法 %}（下地址字段法）确定下条微指令地址，则微指令中下地址字段的位数至少是多少位?

总共需要存储多少条微指令?

32×4+2= 130条

标注出130个不同的位置至少需要多少个二进制位?

$2^7=128,2^8=256$

下地址字段的位数至少是8位



![image-20221101150148027](https://s2.loli.net/2022/11/06/yNQ1uGnvT9scZxS.png)



## 微程序控制单元的设计

设计步骤:

1. 分析每个阶段的微操作序列
2. 写出对应机器指令的微操作命令及节拍安排
3. 确定微指令格式
4. 编写微指令码点

取指周期-{% span red, 硬布线控制器的节拍安排 %}:

1. T0 	PC→MAR
2. T0	1 → R
3. T1	M (MAR ) MDR
4. T1    (PC )+1→PC
5. T2    MDR →IR
6. T2    OP(IR )→ID，将分析完的指令直接放到对应的线路上，将对应的线路导通

取指周期-{% span red, 微程序控制器的节拍安排 %}: 分为三条微指令T0，T1，T2

1. T0    PC→MAR
2. T0    1→R
3. T1    M(MAR )→MDR
4. T1    (PC )+1→PC
5. T2    MDR→IR
6. T2    OP(IR )→微地址形成部件

但是{%label  实际上取值周期-微程序控制器的节拍安排，在每一条微指令下面都需要有一条指令来确定下一条指令的位置 red %}.

微指令a：

T0 	PC → MAR

T0	1→R

T1	Ad ( CMDR)→CMAR	.{% span red, 需要使用T1节拍确定下一条微指令的地址 %}.

微指令b：

T2	M(MAR )→MDR

T2	(PC)+1 →PC

T3	Ad ( CMDR )→CMAR	.{% span red, 需要使用T3节拍确定下一条微指令的地址 %}.

微指令c：

T4	MDR →IR

T4	OP(IR )→微地址形成部件

T5	微地址形成部件→CMAR	.{% span red, 根据指令操作码确定其执行周期微指令序列的首地址 %}.

显然微程序控制器的速度比硬布线控制器更慢



{% tip %}微程序控制单元的设计步骤{% endtip %}

1. 分析每个阶段的微操作序列

2. 写出对应机器指令的微操作命令及节拍安排

   1. 写出每个周期所需要的微操作(参照硬布线)

   2. 补充微程序控制器特有的微操作:

      取指周期:

      Ad (CMDR)CMAROP (IR ) >CMAR

      执行周期:

      Ad(CMDR)>CMAR

3. 确定微指令格式

   根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。根据cM中存储的微指令总数，确定微指令的顺序控制字段的位数。最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。

4. 编写微指令码点

   根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。

### 微程序设计分类

1. 静态微程序设计和动态微程序设计

   .{% span red, 静态 %}：微程序无需改变，采用{% span red, ROM %}.

   .{% span red, 动态 %}：通过{% span red, 改变微指令 %}和{% span red, 微程序 %}改变机器指令有利于仿真，采用{% span red, EPROM %}.

2. 毫微程序设计

   毫微程序设计的基本概念

   .{% span red, 微程序设计 %}        用   {% span red, 微程序解释机器指令 %}.

   .{% span green, 毫微程序设计 %}    用   {% span green, 毫微程序解释微程序 %}.



### 微程序控制器和硬布线控制器的对比

|          |                         微程序控制器                         |                         硬布线控制器                         |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 工作原理 | 微操作控制信号以微程序的形式<br />存放在控制存储器中，执行指令时<br/>读出即可 | 微操作控制信号由组合逻辑电路<br />根据当前的指令码、状态和时序，<br/>即时产生 |
| 执行速度 |                              慢                              |                              快                              |
|  规整性  |                            较规整                            |                         烦琐、不规整                         |
| 应用场景 |                           CISC CPU                           |                           RISC CPU                           |
| 易于扩充 |                          易扩充修改                          |                             困难                             |

![image-20221101160500234](https://s2.loli.net/2022/11/06/1xLX68za4tOJjbM.png)





## 指令流水线的基本概念

### 指令流水的定义

一条指令的执行过程可以分成多个阶段（或过程）。根据计算机的不同，具体的分法也不同。
![image-20221101161147659](https://s2.loli.net/2022/11/06/wmRxSAbXG1dofQs.png)

- {% span red, 取指 %}:根据PC内容访问主存储器，取出一条指令送到R中。
- {% span red, 分析 %}:对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA，并从有效地址EA中取出操作数。
- {% span red, 执行 %}:根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中。

设{% label 取指、分析、执行3个阶段的时间都相等，用t表示 red %}，按以下几种执行方式分析n条指令的执行时间:

1. 顺序执行方式：总耗时：T=n*3T = 3nt

![image-20221101161525422](https://s2.loli.net/2022/11/06/tVXjpocODgylCLU.png)

传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。{% span blue, 优点:控制简单，硬件代价小 %}。
.{% span red, 缺点:执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低 %}。

2. 一次重叠方式：总耗时：T=3t+(n-1)*2T=(1+2n)t

![image-20221101161752367](https://s2.loli.net/2022/11/06/TedNA2wbiFB6hC5.png)

.{% span blue, 优点:程序的执行时间缩短了1/3,各功能部件的利用率明显提高 %}。

.{% span red, 缺点:需要付出硬件上较大开销的代价，控制过程也比顺序执行复杂了 %}。

3. 二次重叠方式：总耗时T=3t+(n-1)t=(2+n)t

![image-20221101161931415](https://s2.loli.net/2022/11/06/rYD7jHOnyigbEwx.png)

.{% span blue, 与顺序执行方式相比，指令的执行时间缩短近2/3。这是一种理想的指令执行方式，在正常情况下,处理机中同时有3条指令在执行 %}。

注:{% label 也可以把每条指令的执行过程分成4个或5个阶段，分成5个阶段是比较常见的做法 red %}。

### 流水线表示方法

![image-20221101162701040](https://s2.loli.net/2022/11/06/1tJyEnNGM3oBDm8.png)

### 流水线的性能指标

{% tip %}吞吐率{% endtip %}

吞吐率是指在单位时间内流水线所完成的任务数量，或是输出结果的数量。

设任务数为n;处理完成n个任务所用的时间为$T_k$

则计算流水线吞吐率（TP）的最基本的公式为$TP=\frac{n}{T_k}$

理想情况下，流水线的时空图如下:		当连续输入的任务n→$\infty$时，得最大吞吐率为$TP_{max}=1/\Delta t$。

![image-20221101164429955](https://s2.loli.net/2022/11/06/7OTIDlgmtbnMoYH.png)

一条指令的执行分为k个阶段，每个阶段耗时$\Delta t$ ，一般取$\Delta t$ =一个时钟周期

$T_k=(k+n-1)\Delta t$

流水线的实际吞吐率为

$TP =\frac{n}{(k+n-1)\Delta t}$



{% tip %}加速比{% endtip %}

完成同样一批任务，{% span red, 不使用流水线所用的时间与使用流水线所用的时间之比 %}。

设T0,表示不使用流水线时的执行时间，即顺序执行所用的时间;$T_k$表示使用流水线时的执行时间则计算流水线加速比(S）的基本公式为$S=\frac{T_0}{T_k}$，	

理想情况下，流水线时空图：

一条指令的执行分为k个阶段，每个阶段耗时At ，一般取△t =一个时钟周期

![image-20221101164429955](https://s2.loli.net/2022/11/06/7OTIDlgmtbnMoYH.png)

单独完成一个任务耗时为$k\Delta t$，则顺序完成n个任务耗时$T_0=nk\Delta t$
$T_K=(k+n-1)\Delta t$

实际加速比为

$S=\frac{kn\Delta t}{(k+n-1)\Delta t}=\frac{kn}{k+n-1}$

当连续输入的任务n→$\infty$时，最大加速比为$S_{max}=k$



{% tip %}效率{% endtip %}

流水线的设备利用率称为流水线的效率。

在时空图上，流水线的效率定义为{% label 完成n个任务占用的时空区有效面积与n个任务所用的时间 red %}与{% label k个流水段所围成的时空区总面积 blue %}之比。

则流水线效率(E)的一般公式为$E=\frac{n个任务占用的k时空区有效面积}{n个任务所用的时间与k个流水段所围成的时空区总面积}=\frac{T_0}{kT_k}$

当连续输入的任务n→$\infty$时，最高效率为为$E_{max}=1$

## 指令流水线的影响因素和分类

### 机器周期的设置

IF: Instruction Fetch 取值阶段

ID: Instruction Decode 指令译码阶段，还包括对寄存器的读取操作，将本条指令所需要的数据放到这个段的锁存器中

EX: EXecute 指令执行阶段

M: Memory 访存阶段

WB: WriteBack 写会阶段

五段式：基于MIPS架构提出的，MIPS是世界上第一个精简指令集RISC的系统

<img src="https://s2.loli.net/2022/11/06/kmnCU27BVMZORhP.png" alt="image-20221101180417170" style="zoom:50%;" />



为{% span red, 方便流水线的设计 %}，将每个阶段的耗时取成一样，{% span red, 以最长耗时为准 %}。即此处应将机器周期设置为100ns。

流水线{% span red, 每一个功能段部件后面都要有一个缓冲寄存器 %}，或称为锁存器其作用是保存本流水段的执行结果，提供给下一流水段使用。

缓冲器的作用：因为各个阶段都是以最长时间段的时间来确定的，所以在短时间段的阶段下，如果提前弄好了那么会将结果放在缓冲寄存器中，等待时间到了之后再将数据放到下一个数据块中

### 结构相关(资源冲突)

由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关。

解决办法:

1. {% span blue, 后一相关指令暂停一周期 %}.
2. {% span blue, 资源重复配置:数据存储器+指令存储器 %}.

![image-20221101184603407](https://s2.loli.net/2022/11/06/16grTCWcbR2iNv3.png)

### 数据相关(数据冲突)

数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。

其中{% span red, 第一条指令的运算结果需要作为后续指令的参数 %}，如下图所示，我们在第一条指令还没有执行完毕的时候就需要读取r1中的数据，这时候会造成数据冲突

![image-20221101184748681](https://s2.loli.net/2022/11/06/P1aYvxRbQoytG39.png)



解决办法:

1. 把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为硬件阻塞(stall)和软件插入“NOP”两种方法。

<img src="https://s2.loli.net/2022/11/06/OTwP5YZS1H8LiCD.png" alt="image-20221101185317558" style="zoom: 33%;" /><img src="https://s2.loli.net/2022/11/06/C2E1GaWfM8cwDhq.png" alt="image-20221101185823071.png" style="zoom:33%;" />

2. 数据旁路技术。(转发机制)

   我们在运算完结果之后不一定需要放到寄存器中，然后再从寄存器中读取，我们可以在运算结果运算完毕之后直接将数据放到运算器中进行运算，省略了放到寄存器中这一步

3. 编译优化：

   通过编译器调整指令顺序来解决数据冲突，我们可以先将后面指令中没有用到第一条指令运算结果的指令，先放到第一条指令后面，这样的话，等无管理指令执行完毕之后，结果也就放回到相应的寄存器中去了，这时候也不影响后面指令的运行

### 控制相关(控制冲突)

当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制冲突。

![image-20221101190620109](https://s2.loli.net/2022/11/06/6zN5TFUPJCRZiKX.png)

解决办法:

1. 转移指令分支预测。简单预测（永远猜ture或false)、动态预测（根据历史情况动态调整)
2. 预取转移成功和不成功两个控制流方向上的目标指令
3. 加快和提前形成条件码
4. 提高转移方向的猜准率

### 流水线的分类

{% tip %}根据使用等级分类{% endtip %}

根据流水线使用的级别的不同，流水线可分为{% span red, 部件功能级流水线、处理机级流水线和处理机间流水线 %}。

- {% span red, 部件功能级流水 %}：就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。

- {% span red, 处理机级流水 %}：是把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存及写回5个子过程p

- {% span red, 处理机间流水 %}：是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。

{% tip %}根据流水线的功能分类{% endtip %}

按流水线可以完成的功能，流水线可分为单功能流水线和多功能流水线。

- {% span red, 单功能流水线 %}：指只能实现一种固定的专门功能的流水线;
- {% span red, 多功能流水线 %}：指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。

{% tip %}根据同一时间内各段之间的连接方式{% endtip %}

按同一时间内各段之间的连接方式,流水线可分为静态流水线和动态流水线。

- {% span red, 静态流水线 %}：指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。

- {% span red, 动态流水线 %}：指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。

{% tip %}按照各功能段之间是否有返回信号{% endtip %}

按流水线的各个功能段之间是否有反馈信号影流水线可分为线性流水线与非线性流水线。

- {% span red, 线性流水线 %}：从输人到输出，每个功能段只允许经过一次，不存在反馈回路。
- {% span red, 非线性流水线 %}：存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。

### 流水线的多发技术

{% tip %}超标量技术{% endtip %}

![image-20221101194208816](https://s2.loli.net/2022/11/06/2GKbC5rhMd1BQVT.png)

每个时钟周期内可{% span red, 并发多条独立指令 %}.

要配置多个功能部件

.{% span red, 不能调整 %}指令的{% span red, 执行顺序 %}.这里需要和{% span red, 乱序发射 %}对比起来

通过编译优化技术，把可并行执行的指令搭配起来



{% tip %}超流水技术{% endtip %}

![image-20221101194712220](https://s2.loli.net/2022/11/06/3DiBvEMFR8hWr7s.png)

在{% span red, 一个时钟周期 %}内{% span red, 再分段 %}（ 3段)

在一个时钟周期内{% span red, 一个功能部件使用多次 %}（ 3次)

.{% span red, 不能调整 %}指令的{% span red, 执行顺序 %}.

靠编译程序解决优化问题

在这个例题中流水线速度是原来的三倍

{% tip %}超长指令字{% endtip %}

![image-20221101195238098](https://s2.loli.net/2022/11/06/Ct8Aev9Tm2bnDWy.png)

由{% span red, 编译程序挖掘 %}出指令间{% span red, 潜在 %}的{% span red, 并行性 %}，

将{% span red, 多条 %}能{% span red, 并行操作 %}的指令组合成{% span red, 一条 %}.

具有{% span red, 多个操作码字段 %}的{% span red, 超长指令字 %}（可达几百位)

采用{% span red, 多个处理部件 %}.

![image-20221101195520063](https://s2.loli.net/2022/11/06/LxBlb8FJ9COmsIy.png)





## 五段式指令流水线

<img src="https://s2.loli.net/2022/11/06/kmnCU27BVMZORhP.png" alt="image-20221101180417170" style="zoom:50%;" />

①IF取指→②ID译码&取数→③EX执行→④M访存→⑤WB写回寄存器

我们常用的指令是否都需要执行这五个段呢？

考试中常见的五类指令:
运算类指令、LOAD指令、STORE指令、条件转移指令、无条件转移指令

{% tip %}运算类指令的执行过程{% endtip %}

![image-20221101200945196](https://s2.loli.net/2022/11/06/pXlVwouyvEstknr.png)

没有访存操作，因为运算的操作码都是来自寄存器或者立即数，然后再写会寄存器中

注:

Rs指源操作数( source)

Rd指目的操作数（ destination)

运算类指令

- lF:根据PC从指令Cache取指令至IF段的锁存器
- ID:取出操作数至ID段锁存器
- EX:运算，将结果存入EX段锁存器
- M:空段
- WB:将运算结果写回指定寄存器

|         运算类指令举例          | 指令的汇编格式 |     功能     |
| :-----------------------------: | :------------: | :----------: |
|   加法指令（两个寄存器相加）    |   ADD Rs,Rd    | (Rs)+(Rd)→Rd |
| :加法指令（寄存器与立即数相加） |  ADD #996,Rd   | 996+(Rd)→Rd  |
|          算数左移指令           |     SHL Rd     |  Rd)<<<2Rd   |



{% tip %}LOAD指令的执行过程{% endtip %}

LOAD指令

- lF:根据PC从指令Cache取指令至IlF段的锁存器
- ID:将基址寄存器的值放到锁存器A,将偏移量的值放到Imm
- EX:运算，得到有效地址
- M:从数据cache中取数并放入锁存器
- WB:将取出的数写回寄存器

| 指令的汇编格式  |     功能      |
| :-------------: | :-----------: |
| LOAD Rd,996(Rs) | (996+(Rs))→Rd |
|   LOAD Rd,mem   |   (mem)→Rd    |

通常，{% label RISC处理器只有“取数LOAD”和“存数STORE”指令才能访问主存 red %}.

{% tip %}STORE指令的执行过程{% endtip %}

STORE指令

- lF:根据PC从指令Cache取指令至IF段的锁存器
- ID:将基址寄存器的值放到锁存器A，将偏移量的值放到Imm。将要存的数放到B
- EX:运算，得到有效地址。并将锁存器B的内容放到锁存器Store。
- M:写入数据cache
- WB:空段

|  指令的汇编格式  |     功能      |
| :--------------: | :-----------: |
| STORE Rs,996(Rd) | Rs→(996+(Rd)) |
|   STORE Rs,mem   |   Rs→(mem)    |

通常，{% label RISC处理器只有“取数LOAD”和“存数STORE”指令才能访问主存 red %}.

{% tip %}有条件转移指令的执行过程{% endtip %}

条件转移指令

- lF:根据PC从指令Cache取指令至IF段的锁存器
- ID:进行比较的两个数放入锁存器A、B;偏移量放入Imm
- EX:运算，比较两个数
- M:将目标Pc值写回PC（左图没画全)
- WB:空段，很多教材把写回PC的功能段称为“WrPC段”其耗时比M段更短，可安排在M段时间丙完成

|   指令的汇编格式   |                             功能                             |
| :----------------: | :----------------------------------------------------------: |
| beq Rs, Rt, 偏移量 | 若(Rs)==(Rt),则(PC)+指令字长+(偏移量×指令字长)→PC;否则(PC)+指令字长→PC |
| bne Rs, Rt, 偏移量 | 若(Rs)!=(Rt),则(PC)+指令字长+(偏移量×指令字长)→PC;否则(PC)+指令字长→PC, |

通常，{% label RISC处理器只有“取数LOAD”和“存数STORE”指令才能访问主存 red %}.

{% tip %}无条件转移指令的执行过程{% endtip %}

无条件转移指令

+ lF:根据PC从指令Cache取指令至IF段的锁存器
+ ID:偏移量放入lmm
+ EX:将目标PC值写回PC
+ M:空段
+ WB:空段

"WrPC段”耗时比EX段更短，可安排在EX段时间内完成。{% span red, WrPC段越早完成就越能避免控制冲突 %}、当然，也有的地方会在WB段时间内才修改PC的值

| 指令的汇编格式 |                                    |
| :------------: | :--------------------------------: |
|   jmp 偏移量   | (PC)+指令字长+(偏移量×指令字长)→PC |

![image-20221101213027205](https://s2.loli.net/2022/11/06/fk1pM8r4DhB3qPb.png)



# 第六章：总线

总线简图：

<img src="https://s2.loli.net/2022/11/06/oZygz1l4cCWT2tH.png" alt="image-20221102153633850" style="zoom:50%;" />

总线的物理实现：

![image-20221102153715788](https://s2.loli.net/2022/11/06/6VpbD7xKhXPFTrC.png)

如上图，4根信号线组成“一根”总线，所有硬件部件都可以通过这根总线传递数据可并行发送4bit数据。同一时刻{% span red, 只能有一个部件发送 %}数据，但是{% span red, 可有多个部件接受数据 %}.

## 总线的概述

### 总线的定义：

总线{% span red, 是一组能为多个部伴分时共享的公共信息传送线路 %}。

![image-20221102154348322](https://s2.loli.net/2022/11/06/V6Y281JDFqpht5M.png)

为什么要用总线?

早期计算机外部设备少时{% span red, 大多采用分散连接方式 %}，{% span red, 不易实现随时增减外部设备 %}。{% label 为了更好地解决I/O设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接 red %}。

### 总线的特点

总线是一组能为多个部件{% span red, 分时 %}{% span blue, 共享 %}的公共信息传送线路。

.{% span blue, 共享是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享 %}。

.{% span red, 分时是指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息 %}。



### 总线的特性

1. 机械特性:尺寸、形状、管脚数、排列顺序
2. 电气特性:传输方向和有效的电平范围
3. 功能特性:每根传输线的功能(地址、数据、控制)
4. 时间特性:信号的时序关系

### 串行总线和并行总线

![image-20221102155607881](https://s2.loli.net/2022/11/06/oDR4ifyPrkJvAT2.png)

优点:{% span red, 只需要一条传输线，成本低廉 %}，广泛应用于长距离传输;应用于计算机内部时，可以节省布线空间。

缺点:在数据发送和接收的时候要进行拆卸和装配，{% span red, 要考虑串行-并行转换的问题 %}。

![image-20221102155554428](https://s2.loli.net/2022/11/06/Kj6ABLP7E5anUHV.png)

优点:总线的逻辑时序比较简单，电路实现起来比较容易。

缺点:信号线数量多，{% span red, 占用更多的布线空间;远距离传输成本高昂 %};由于工作频率较高时，{% span red, 并行的信号线之间会产生严重干扰 %}，对每条线等长的要求也越高，所以无法持续提升工作频率。

注意：{%label 串行总线的速度不一定比并行总线速度慢 red%}

### 片内总线，系统总线和通信总线

1. 片内总线

   片内总线是芯片{% span red, 内部的总线 %}。它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。

2. 系统总线

   系统总线是{% span red, 计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线 %}。按系统总线{% span red, 传输信息内容 %}的不同，又可分为3类:{% span blue, 数据总线 %}、{% span brown, 地址总线 %}和{% span green, 控制总线 %}。

   - 数据总线(DB)：传输各功能部件之间的数据信息，包括指令和操作数;位数(根数)与机器字长、存储字长有关;  双向。
   - 地址总线(AB)：传输地址信息,包括主存单元或I/O端口的地址; 位数(根数)与主存地址空间大小及设备数量有关;  单向。只有CPU向各个设备发送信号
   - 控制总线(CB)：传输控制信息;一根控制线传输一个信号;，对单根控制线来说是单向的，对整体来说是双向的
     - 有出: CPU送出的控制命令;
     - 有入:主存（或外设）返回CPU的反馈信号。

![image-20221102154348322](https://s2.loli.net/2022/11/06/V6Y281JDFqpht5M.png)

3. 通信总线

   通信总线是用于{% span red, 计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备)之间信息传送的总线 %}，通信总线也称为外部总线。



### 系统总线的结构

{% tip %}单总线结构{% endtip %}

注:{% span red, 单总线并不是指只有一根信号线 %}，系统总线按传送信息的不同{% span red, 可以细分为地址总线、数据总线和控制总线 %}。

- 结构:CPU、主存、I/O设备（通过IO接口）都连接在一组总线上，允许I/O设备之间、I/O设备和CPU之间或IO设备与主存之间直接交换信息。
- 优点:{% label 结构简单，成本低，易于接入新的设备 blue %}。
- 缺点:{% span red, 带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作 %}。{% label 系统总线非常快，但是有一些外部设备的速度非常慢，这就会导致系统总线在接受外部设备的信息的时候会导致速度浪费 red %}.

![image-20221102162335454](https://s2.loli.net/2022/11/06/hCvz8OlYIMBd9xW.png)

{% tip %}双总线结构{% endtip %}

- {% span red, 支持突发(猝发)传送:送出一个地址，收到多个地址连续的数据 %}。CPU向主存发送一个信息，但是主存中往往是需要多个地址连续存储的，这时候就可以送出一个地址，收到多个地址连续的数据了

- {% span red, 通道是具有特殊功能的处理器,能对I/O设备进行统一管理 %}。{% label 通道程序放在主存中 blue %}
- 结构:双总线结构有两条总线，一条是主存总线，用于CPU、主存和通道之间进行数据传送;另一条是/o总线，用于多个外部设备与通道之间进行数据传送。
- 优点:{% label 将较低速的I/O设备从单总线上分离出来，实现存储器总线和I/O总线分离 blue %}。
- 缺点:{% label 需要增加通道等硬件设备 red %}。

![image-20221102162716892](https://s2.loli.net/2022/11/06/3jkfH97qBUDbnc5.png)



{% tip %}三总线结构{% endtip %}

将IO设备再次分为快速的IO设备和慢速的IO设备，快速的IO设备通过DMA总线和主存访问，慢速的IO设备通过IO总线和CPU交互	

- 结构:三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路,这3条总线分别为{% span red, 主存总线 %}、{% span red, IO总线 %}和直接内存访问{% span red, DMA总线 %}。
- 优点:{% label 提高了I/O设备的性能，使其更快地响应命令，提高系统吞吐量 blue %}。
- 缺点:{% label 系统工作效率较低 red %}。三总线中同一时刻只能有一个总线在工作，所以效率比较低

![image-20221102163056621](https://s2.loli.net/2022/11/06/aqz9A1VOSRkLc2p.png)

{% tip %}四总线结构{% endtip %}

1. 桥接器:用于连接不同的总线，具有数据缓冲、转换和控制功能。
2. 靠近CPU的总线速度较快。
3. 每级总线的设计遵循总线标准。

![image-20221102163624163](https://s2.loli.net/2022/11/06/yputLzZaYO3CJHT.png)

![image-20221102161101622](https://s2.loli.net/2022/11/06/BGdeSs3O8zu2Ucr.png)





## 总线的性能指标

总线周期与总线时钟周期的关系比较魔幻，
大多数情况下，一个总线周期包含多个总线时钟周期，有的时候，一个总线周期就是一个总线时钟周期，有的时候，一个总线时钟周期可包含多个总线周期

1. 总线的{% span red, 传输周期(总线周期) %}.

   .{% span red, 一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段） %}，通常由若干个总线时钟周期构成。{% span red, 就是一组数据传送所需要的时间 %}.

2. 总线{% span blue, 时钟周期 %}.

   即{% span blue, 机器的时钟周期 %}。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。

   时钟周期=1/CPU的频率

3. 总线的{% span red, 工作频率 %}.

   总线上各种操作的频率，为{% span red, 总线周期的倒数 %}。

   若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N。{% span red, 实际上指一秒内传送几次数据 %}。

4. 总线的{% span blue, 时钟频率 %}.

   即机器的时钟频率，为{% span blue, 时钟周期的倒数 %}。若时钟周期为T，则时钟频率为1/T。

   实际上指{% span blue, 一秒内有多少个时钟周期 %}。

5. 总线宽度

   又称为总线位宽，{% span red, 它是总线上同时能够传输的数据位数 %} ，通常是指数据总线的根数，如32根称为32位(bit）总线。

6. 总线带宽

   可理解为总线的{% span red, 数据传输率 %}，即{% span red, 单位时间内总线上可传输数据的位数 %},通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒(B/s）表示。

   总线带宽=总线工作频率×总线宽度(bit/s）=总线工作频率×(总线宽度/8)(B/s）

   注:{% span red, 总线带宽是指总线本身所能达到的最高传输速率。在计算实际的有效数据传输率时，要用实际传输的数据量除以耗时 %}。

   {% note purple 'far fa-hand-scissors' modern %}

   例．某同步总线采用数据线和地址线复用方式，其中地址/数据线有32根，总线时钟频率为66MHz，每个时钟周期传送两次数据(上升淞和下降沿各传送一次数据)。

   1. 该总线的最大数据传输率（总线带宽）是多少?
   2. 若该总线支持突发（猝发）传输方式，传输一个地址占用一个时钟周期，则一次“主存写”总线事务传输128位数据所需要的时间至少是多少？

   答：

   1. 每个时钟周期传送两次数据→总线工作频率是时钟频率的两倍

      总线工作频率=2 × 66MHz =132MHz

      总线宽度= 32bit = 4B

      总线带宽=总线工作频率×总线宽度=132×4 MB/s = 528 MB/s

   2. 突发(猝发)传输方式:一次总线事务中，主设备只需给出一个首地址，从攻备肌能从首地址开始的若干连续单元读出或写入多个数据。

      发送首地址占用1个时钟周期，128位数据需传输4次，占用2个时钟周期

      一个时钟周期=1/66MHz15ns

      总耗时=(1+2)×15ns =45ns

   {% endnote %}

   这里可以的出来，串行总线的速度，不一定比并行总线的速度慢，因为{% span red, 总线带宽=总线工作频率x总线宽度(bit/s) %}.

   1. {% span red, 工作频率相问时，串行总线传输速度比并行总线慢 %}。
   2. {% span blue, 并行总线的工作频率无法持续捷阍而串行总线可以通过不断提高工作频率来提高传输速度，最终超过并行总线 %}。

7. 总线复用

   总线复用是指{% span blue, 一种信号线 %}{% span brown, 在不同的时间 %}{% span green, 传输不同的信息 %}。可以使用较少的线传输更多的信息，从而节省了空间和成本。

8. 信号线数

   地址总线、数据总线和控制总线3种总线数的总和称为信号线数。



## 总线的仲裁

{% tip warning %}如何解决多个设备争用总线的问题？{% endtip %}

### 仲裁的基本概念

同一时刻只能有{% span red, 一个设备控制 %}总线传输操作，可以有{% span brown, 一个或多个设备 %}从总线{% span brown, 接收 %}数据。

将总线上所连接的各类设备按其对总线有无控制功能分为:

- {% span blue, 主设备:获得总线控制权的设备 %}。
- {% span brown, 从设备:被主设备访问的设备，只能响应从主设备发来的各种总线命令 %}。

为什么要仲裁?

- 总线作为一种共享设备，不可避免地会出现同一时刻有多个主设备竞争总线控制权的问题。

总线仲裁的定义:

- 多个主设备同时竞争主线控制权时，以某种方式选择一个主设备优先获得总线控制权称为总线仲裁。

总线仲裁分类:

- 集中仲裁方式：链式查询方式、计数器定时查询方式、独立请求方式
- 分布仲裁方式



### 集中仲裁方式：

工作流程:

1. 主设备发出请求信号;
2. 若多个主设备同时要使用总线，则由总线控制器的判优、仲裁逻辑按一定的优先等级顺序确定哪个主设备能使用总线;
3. 获得总线使用权的主设备开始传送数据。

{% tip %}链式查询{% endtip %}

![image-20221102193857755](https://s2.loli.net/2022/11/06/cJKPaqfwtiAeO2W.png)

“{% span red, 总线忙 %}”信号的建立者是{% span red, 获得总线控制权的设备 %}.

优先级:

离总线控制器越{% span red, 近 %}的部件,其{% span red, 优先级越高 %};

离总线控制器越{% span red, 远 %}的部件,其{% span red, 优先级越低 %}。

优点:{% span blue, 个链式查询方式优先级固定。只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易 %}。

缺点:{% span red, 对硬件电路的故障敏感，并且优先级不能改变。当优先级高的部件频繁请求使用总线时，会使优先级较低的部件长期不能使用总线 %}.

{% tip %}计数器查询方式{% endtip %}

结构特点:用一个计数器控制总线使用权，相对链式查询方式{% span red, 多了一组设备地址线，少了一根总线响应线BG %};它仍共用一根总线请求线。

- 当总线控制器收到总线请求信号，判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。
- 当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权。同时，中止计数器的计数及查询。

![image-20221102194735850](https://s2.loli.net/2022/11/06/fZakUxW7Q5CqK9z.png)

优点:

1. 计数初始值可以改变优先次序
   - 计数每次从“0”开始，设备的优先级就按顺序排列，固定不变;
   - 计数从上一次的终点开始，此时设备使用总线的优先级相等;
   - 计数器的初值还可以由程序设置
2. 对电路的故障没有链式敏感

缺点:

1. 增加了控制线数
   - 若设备有n个，则需$[\log_2n]+2$条控制线:
2. 控制相对比链式查询相对复杂

{% tip %}独立请求方式{% endtip %}

当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队。

当总线控制器按一定的优先次序决定批准某个部件的请求时,则给该部件发送总线响应信号。

结构特点:每一个设备均有一对总线请求线BRi和总线允许线BGi。

![image-20221102195951818](https://s2.loli.net/2022/11/06/vMOmI8XHf3DESTu.png)

优点:

1. 响应速度快，总线允许信号BG直接从控制器发送到有关设备,不必在设备间传递或者查询。
2. 对优先次序的控制相当灵活。

缺点:

1. 控制线数量多
   - 若设备有n个，则需要2n+1条控制线。
   - 其中+1为BS线，用于设备向总线控制部件反馈已经是否正在使用总线。
2. 总线的控制逻辑更加复杂

|          |                      链式查询                      |                          计数器查询                          |                       独立请求                        |
| :------: | :------------------------------------------------: | :----------------------------------------------------------: | :---------------------------------------------------: |
| 控制线路 | 3<br />总线请求：1<br />总线允许：1<br />总线忙：1 | $[\log_2n]+2$<br />总线请求：1<br />总线允许：$\log_2n$<br />总线忙：1 | 2n+1<br />总线请求：n<br />总线允许：n<br />总线忙：1 |
|   优点   |            优先级固定结构简单，扩充容易            |                         优先级较灵活                         |                 响应速度快优先级灵活                  |
|   缺点   |             对电路故障敏感优先级不灵活             |                    控制线较多控制相对复杂                    |                   控制线多控制复杂                    |

“{% span red, 总线忙 %}”信号的建立者是{% span red, 获得总线控制权的设备 %}.



特点:不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。

当设备有总线请求时，它们就把各自唯一的中裁号发送到共享的仲裁总线上;

每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较;

如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号;最后，获胜者的仲裁号保留在仲裁总线上。



## 总线的操作和定时

{% tip warning %}占用总线的一对设备如何进行数据传输{% endtip %}

### 总线传输的四个阶段

总线周期的四个阶段

1. 申请分配阶段:由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者。也可将此阶段细分为传输请求和总线仲裁两个阶段。
2. 寻址阶段:获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，启动参与本次传输的从模块。
3. 传输阶段:主模块和从模块进行数据交换，可单向或双向进行数据传送。
4. 结束阶段:主模块的有关信息均从系统总线上撤除，让出总线使用权。



总线定时是指{% span red, 总线在双方交换数据的过程中需要时间上配合关系的控制 %}，这种控制称为总线定时，它的实质{% span red, 是一种协议或规则 %}.

|          方式          |                             方法                             |
| :--------------------: | :----------------------------------------------------------: |
| 同步通信(同步定时方式) |            由{% span red, 统一时钟 %}控制数据传送            |
| 异步通信(异步定时方式) |        采用{% span red, 应答方式 %}，没有公共时钟标准        |
|       半同步通信       |               .{% span red, 同步、异步结合 %}.               |
|       分离式通信       | 充分{% span red, 挖掘 %}系统{% span red, 总线每瞬间 %}的{% span red, 潜力 %}. |

### 同步定时方式

同步定时方式是指{% span red, 系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系 %}。

若干个时钟产生相等的时间间隔，每个间隔构成一个总线周期。

在一个总线周期中，{% span red, 发送方和接收方可进行一次数据传送 %}。

因为采用统一的时钟，{% span red, 每个部件或设备发送或接收信息都在固定的总线传送周期中 %}，一个总线的传送周期结束，下一个总线传送周期开始。

优点:{% span blue, 传送速度快，具有较高的传输速率;总线控制逻辑简单 %}。

缺点:{% span red, 主从设备属于强制性同步;不能及时进行数据通信的有效性检验，可靠性较差 %}。

同步通信适用于{% span red, 总线长度较短 %}及总线{% span red, 所接部件的存取时间比较接近 %}的系统。

{% tip %}读命令{% endtip %}

![image-20221102202622090](https://s2.loli.net/2022/11/06/wHjpLxGV7fyUbYK.png)

假设: {% span blue, CPU作为主设备，某个输入设备作为从设备 %}.

1. CPU在T1时刻的上升沿给出地址信息
2. 在T2的上升沿给出读命令(低电平有效），与地址信息相符合的输入设备按命令进行一系列的内部操作,{% span red, 且必须在T3的上升沿来之前将CPU所需的数据送到数据总线上 %}。
3. CPU在T3时钟周期内，将数据线上的信息传送到其内部寄存器中。
4. CPU在T4的上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。

如果{% span red, 从设备跟不上节奏，在T3给不出数据，就会出错 %}.



### 异步定时方式

在异步定时方式中，{% span blue, 没有统一的时钟，也没有固定的时间间隔 %}，{% span red, 完全依靠传送双方相互制约的“握手”信号来实现定时控制 %}。

主设备{% span red, 提出交换信息的“请求”信号 %}，经接口传送到从设备;从设备接到主设备的请求后，{% span blue, 通过接口向主设备发出“回答”信号 %}。

优点:{% span blue, 总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合 %}。

缺点:{% span red, 比同步控制方式稍复杂一些，速度比同步定时方式慢 %}。

根据“请求”和“回答”信号的撤销是否互锁，分为以下3种类型

1. 不互锁方式		速度最快，可靠性最差

   主设备发出“{% span red, 请求 %}”信号后，不必等到接到从设备的“{% span blue, 回答 %}”信号，而是经过一段时间，便撤销“{% span red, 请求 %}”信号。

   从设备在接到“{% span red, 请求 %}”信号后，发出“{% span blue, 回答 %}”信号，并经过一段时间，自动撤销“{% span red, 回答 %}”信号。双方不存在互锁关系。

![image-20221102204753668](https://s2.loli.net/2022/11/06/jkr3ulxzHcMLn4Z.png)

2. 半互锁方式

   主设备发出“{% span red, 请求 %}”信号后，必须待接到从设备的“{% span blue, 回答 %}”信号后，才撤销“{% span red, 请求 %}”信号，有互锁的关系。

   从设备在接到“{% span red, 请求 %}”信号后，发出“{% span blue, 回答 %}”信号，但不必等待获知主设备的“{% span red, 请求 %}”信号已经撤销，而是隔一段时间后自动撤销“{% span blue, 回答 %}”信号，不存在互锁关系。

![image-20221102204954943](https://s2.loli.net/2022/11/06/FOkvtaIi49xZwfR.png)



3. 全互锁方式		最可靠，速度最慢

   主设备发出“{% span red, 请求 %}”信号后，必须待从设备“{% span blue, 回答 %}”后，才撤销“{% span red, 请求 %}”信号;

   从设备发出“{% span blue, 回答 %}”信号，必须待获知主设备“{% span red, 请求 %}”信号已撤销后，再撤销其“{% span blue, 回答 %}”信号。双方存在互锁关系。

![image-20221102205159049](https://s2.loli.net/2022/11/06/lMPLx5U7RtZb1aY.png)

### 半同步通信

同步：

- 发送方用系统时钟前沿发信号
- 接收方用系统时钟后沿判断、识别

异步：

- 允许不同速度的模块和谐工作

半同步通信:统一时钟的基础上，增加一个{% span red, “等待”响应信号 %}WAIT

![image-20221102205828613](https://s2.loli.net/2022/11/06/XYyhcNjWu7s6HiL.png)

当T2节拍完成之后，如果数据没有准备好的话，则使用WAIT信号，来等待数据的填充，填充完毕之后在进行T3



### 分离式通信

上述三种通信的共同点

一个总线传输周期（以输入数据为例)

- 主模块发地址、命令			使用总线
- 从模块准备数据					不使用总线			总线空闲
- 从模块向主模块发数据		使用总线

分离式通信的一个总线传输周期：

子周期1：{% span red, 主模块 %}申请{% span red, 占用总线 %}，使用完后{% span red, 放弃总线 %}的使用权

子周期2：{% span red, 从模块 %}申请{% span red, 占用总线 %}，将各种信息送至总线上

特点:

1. 各模块均有权申请占用总线
2. 采用同步方式通信，不等对方回答
3. 各模块准备数据时，不占用总线
4. 总线利用率提高

![image-20221102210816335](https://s2.loli.net/2022/11/06/einX3IpoWv5VLg2.png)



## 总线标准

### 总线标准的基本概念

总线标准{% span red, 是国际上公布或推荐的互连各个模块的标准 %}，{% span red, 它是把各种不同的模块组成计算机系统时必须遵守的规范 %}。按总线标准设计的接口可视为通用接口，在接口的两端，任何一方只需根据总线标准的要求完成自身方面的功能要求，而无须了解对方接口的要求。

根据总线在计算机系统中的位置，可分为

- {% span red, 系统总线 %}：通常{% span red, 与CPU直接相连 %}，用于连接CPU与北桥芯片、或CPU与主存等
- {% span red, 局部总线 %}:{% span red, 没有直接与CPU连接 %}，通常是连接高速的北桥芯片，用于连接了很多重要的硬件部件（如显千、声卡等)
- {% span red, 设备总线、通信总线 %}:{% span red, 通常由南桥芯片控制 %}，用于连接计算机与计算机，或连接计算机与外部I/O设备

### 系统总线的标准

| 总线标准 |              全称              | 工作频率 | 数据线 |       最大速度       |   特点   |
| :------: | :----------------------------: | :------: | :----: | :------------------: | :------: |
|   ISA    | Industry Standard Architecture |   8MHz   |  8/16  | 16MB/s<br />并行总线 | 系统总线 |
|   EISA   |          Extended ISA          |   8MHz   |   32   | 32MB/s<br />并行总线 | 系统总线 |

ISA被称为PC/AT总线，数据传送需要CPU或DMA接口来管理,不支持总线仲裁。

EISA与8/16bit 的ISA总线完全兼容,从CPU中分离出了总线控制权，支持多个总线主控器和突发传送

还有Intel的FBS前端总线和QPI总线

### 局部总线标准

| 总线标准 |                  全称                   | 工作频率 | 数据线 |       最大速度        |   特点   |
| :------: | :-------------------------------------: | :------: | :----: | :-------------------: | :------: |
|   VESA   | Video Electronics Standard Architecture |  33MHz   |   32   | 132MB/s<br />并行总线 | 局部总线 |

是针对多媒体PC要求高速传送活动图像的大量数据应运而生的。

主要是依靠CPU来运行的，随着CPU速度越来越快，VESA渐渐跟不上CPU的速度被淘汰

| 总线标准 |               全称                | 工作频率 | 数据线 |       最大速度        |   特点   |
| :------: | :-------------------------------: | :------: | :----: | :-------------------: | :------: |
|   PCI    | Peripheral Component Interconnect | 33/66MHz | 32/64  | 528MB/s<br />并行总线 | 局部总线 |

是由北桥芯片来控制的

特点:

1. 高性能:不依附于某个具体的处理器,支持突发传送
2. 良好的兼容性。
3. 支持即插即用。
4. 支持多主设备。
5. 具有与处理器和存储器子系统完全并行操作的能力。
6. 提供数据和地址奇偶校验的能力。
7. 可扩充性好，可采用多层结构提高驱动能力。
8. 采用多路复用技术，减少了总线引脚个数。

| 总线标准 |          全称           | 工作频率 | 数据线 |                 最大速度                 |   特点   |
| :------: | :---------------------: | :------: | :----: | :--------------------------------------: | :------: |
|   AGP    | Accelerate Graphic Port |    -     |   -    | X1:266MB/s<br />X8:2.1GB/s<br />并行总线 | 局部总线 |

AGP(加速图形接口，Accelerated Graphics Port)接口，这是显示卡专用的局部总线，是基于PCI 2.1版规范并进行扩充修改而成

| 总线标准 |       全称        | 工作频率 | 数据线 |  最大速度  | 特点 |
| :------: | :---------------: | :------: | :----: | :--------: | :--: |
|  PCI-E   | PCI-Express(3GIO) |    -     |   -    | 10GB/s以上 | 串行 |

是一种点对点串行连接的设备连接方式，{% span red, 点对点意味着每一个PCI Express设备都拥有自己独立的数据连接 %}，{% span red, 各个设备之间并发的数据传输互不影响 %}，

在传输速率方面，PCI Express总线利用串行的连接特点将能轻松将数据传输速度提到一个很高的频率，达到远超出PCI总线的传输速率。与此同时，PCI Express总线支持双向传输模式，还可以运行{% span red, 全双工模式 %}。

支持热拔插。



### 设备总线标准

| 总线标准 |         全称         | 工作频率 | 数据线 | 最大速度 |     特点     |
| :------: | :------------------: | :------: | :----: | :------: | :----------: |
| RS-232C  | Recommended Standard |    -     |   -    |  20Kbps  | 串行通信总线 |

RS-232C是应用于{% span red, 串行二进制交换的数据终端设备(DTE）和数据通信设备(DCE) %}之间的标准接口。

| 总线标准 |              全称               | 工作频率 | 数据线 | 最大速度 |     特点     |
| :------: | :-----------------------------: | :------: | :----: | :------: | :----------: |
|   SCSI   | Small Computer System Interface |    -     |   -    | 640MB/s  | 智能通用接口 |

SCSI(小型计算机系统接口）是一种{% span red, 用于计算机和智能设备之间 %}（硬盘、软驱、光驱、打印机、扫描仪等）系统级接口的独立处理器标准。SCSI是一种智能的通用接口标准。

| 总线标准 |                            全称                            | 工作频率 | 数据线 | 最大速度 |     特点     |
| :------: | :--------------------------------------------------------: | :------: | :----: | :------: | :----------: |
|  PCMCIA  | Person Computer Memory Card<br />International Association |    -     |   -    |  90Mbps  | 便携设备接口 |

用于早期计算机之间进行数据交换，相当于存储卡

| 总线标准 |         全称         | 工作频率 | 数据线 | 最大速度 |      特点      |
| :------: | :------------------: | :------: | :----: | :------: | :------------: |
|   USB    | Universal Serial Bus |    -     |   -    | 1280MB/s | 设备总线，串行 |

USB属于{% span red, 设备总线 %}，是设备和设备控制器之间的接口。

1. 可以{% span red, 热插拔、即插即用 %}。
2. 具有{% span red, 很强的连接能力和很好的可扩充性 %}。采用菊花链形式将众多外设连接起来，可使用USB集线器链式{% span red, 连接127个外设 %},
3. {% span red, 标准统一 %}。以前大家常见的是IDE接口的硬盘，串口的鼠标键盘，并口的打印机扫描仪，可是有了USB之后，这些应用外设统统可以用同样的标准与个人电脑连接，这时就有了USB硬盘、USB鼠标、USB打印机等等。
4. 高速传输。
5. 连接电缆轻巧，可为低压(5V)外设供电。

![image-20221103151900014](https://s2.loli.net/2022/11/06/SnMLlP5AvuHzm3q.png)

差模信号:根据2、3的压差来确定1bit数据，差模信号的抗干扰能力很强，因此工作频率可以很高

注意：{% span red, USB每次只能传送1bit数据 %}.



| 总线标准 |            全称             | 工作频率 | 数据线 | 最大速度 |        特点        |
| :------: | :-------------------------: | :------: | :----: | :------: | :----------------: |
| IDE(ATA) | Integrated Drive Electronic |    -     |   -    | 100MB/s  | 硬盘光驱接口，并行 |

用于IDE硬盘的接口最初被称为IDE接口，后来扩展为CD-ROM、磁带机、可移动磁盘、LS-120磁盘等设备的接口。

硬盘和光驱通过IDE接口与主板连接。



| 总线标准 |                 全称                 | 工作频率 | 数据线 | 最大速度 |     特点     |
| :------: | :----------------------------------: | :------: | :----: | :------: | :----------: |
|   SATA   | Serial Advance Technology Attachment |    -     |   -    | 600MB/s  | 串行硬盘接口 |

SATA由于采用{% span red, 串行 %}接口而闻名.

与并行ATA相比，SATA具有比较大的优势。

- Serial ATA以连续串行的方式传送数据，可以在较少的位宽下使用较高的工作频率来提高数据传输的带宽。

- Serial ATA一次只会传送1位数据，这样能减少SATA接口的针脚数目，使连接电缆数目变少，效率也会更高。

- 同时还能降低系统能耗，减小系统复杂性。

趋势：{% label 串行总线代替并行总线 red %}.

![image-20221103152748901](https://s2.loli.net/2022/11/06/gZhI8SzvJFRe5cL.png)

{% tip %}为何串行总线能够取代并行总线{% endtip %}

- {% span red, 并行总线 %}:用m根线每次传送m个比特，用{% span red, 高/低电平表示1/0 %}，通常采用同步定时方式，由于线间信号干扰，因此总线{% span red, 工作频率不能太高 %}。另外，各条线不能有长度差，长距离并行传输时工艺难度大。

- {% span red, 串行总线 %}:用两根线每次传送一个比特，采用差模信号表示1/0，通常采用异步定时的方式，总线{% span red, 工作频率可以很高 %}。现在的串行总线通常基于包传输，如80bit为一个数据包，包与包之间有先后关系，因此
  可以用多个数据通路分别串行传输多个数据包。因此某种程度上现在的串行总线也有“并行”的特点

# 第七章：IO系统

## IO系统的基本概念

“I/O”就是“输入/输出”( lnput/Output)

I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备

### 主机如何与IO设备进行交互

![image-20221103154827389](https://s2.loli.net/2022/11/06/2BlXmM3EsNpHD5G.png)

.{% label I/O接口 red %}:又称{% span red, I/O控制器(I/O Controller)、设备控制器 %}，负责协调主机与外部设备之间的数据传输

I/O控制器多种多样，也会制定相应的标准，如:用于控制USB设备的IO接口、用于控制SATA 3.0硬盘的lO接口等({% span red, I/O控制器就是一块芯片，常被集成在主板上 %})

![image-20221103155049715](https://s2.loli.net/2022/11/06/ckoJNanQRltDCp1.png)



### IO控制方式简介

![image-20221103155728123](https://s2.loli.net/2022/11/06/ElRpPkTNV5DhyfF.png)

数据流:键盘→lO接口的数据寄存器→数据总线→CPU某寄存器→主存（变量i的对应位置)

```C
#include <stdio.h>
int main() {
    char i;
    scanf("%c", &i);	// 等待键盘IO完成
    printf("i = %c\n", i);
    return 0;
}
```

1. {% span red, 程序查询方式 %}:CPU不断轮询检查I/O控制器中的“状态寄存器”，检测到状态为“已完成”之后，再从数据寄存器取出输入数据
2. {% span red, 程序中断方式 %}:等待键盘I/O时CPU可以先去执行其他程序，键盘I/O完成后I/O控制器向CPU发出{% span red, 中断请求 %}，CPU响应中断请求，并取走输入数据

![image-20221103174734239](https://s2.loli.net/2022/11/06/NimRZ9YKFUHc8xd.png)

思考：对于快速的IO设备，如“磁盘”，每准备好一个字就给CPU发送一次中断请求，会导致什么问题？

答：CPU需要花费大量的时间来处理中断程序服务，CPU利用率严重下降

### DMA控制方式

DMA：Direct Memory Access直接内存访问

CPU和DMA接口之间的交互是通过IO总线来进行交互的

DMA控制方式：主存与高速IO设备之间有一条{% span red, 直接数据通路 %}(DMA总线)，CPU向DMA接口发出“读写命令”指明主存地址，磁盘地址，读写数据量等参数

DMA控制器自动控制磁盘与主存的数据读写，{% span  red, 每完成一整块数据读写 %}(如1KB为一整块），{% span red, 才向CPU发出一次中断请求 %}。

![image-20221102163056621](https://s2.loli.net/2022/11/06/zawAfJCNmsbWMIV.png)

![image-20221103181937058](https://s2.loli.net/2022/11/06/2egKRzrbLp5SYyA.png)

DMA控制器与主存{% span red, 每次传送1个字 %},{% span blue, 当传送完一整块数据后 %}才向CPU发出中断请求



### 通道的控制方式

有的商用中型机、大型机可能会接上超多的I/O设备，如果都让CPU来管理，那么CPU就太累了...，这时候就可以引入通道这种方式，来代替CPU与IO接口进行交互

![image-20221103182252550](https://s2.loli.net/2022/11/06/HoytbQAP6wLT1Ez.png)

通道:可以理解为是“{% span red, 弱鸡版的CPU %}”。通道可以识别并执行一系列{% span red, 通道指令 %}，通道指令种类、功能通常比较单一

通道的运行过程：

1. CPU向通道发出IO指令，指明{% span red, 通道程序 %}在内存中的位置，并指明要操作的是哪个IO设备。然后CPU就可以去干别的事情了
2. 通道执行内存中的通道程序，控制IO设备完成一系列的任务
3. 通道执行完规定的任务之后，向CPU发出中断请求，之后CPU对中断请求进行处理



![image-20221103182608996](https://s2.loli.net/2022/11/06/kp9uKI2CUxz738f.png)

### IO系统的基本组成

一般来说，I/O系统由I/O软件和I/O硬件两部分构成。

1. I/O硬件包括外部设备、I/O接口、IO总线等。

![image-20221103183659510](https://s2.loli.net/2022/11/07/d6sJwICA4UnLYvH.png)

2. I/О软件包括驱动程序、用户程序、管理程序、升级补丁等。

   通常采用1O指令和通道指令实现主机和I/O设备的信息交换。

   1. IO指令CPU指令的一部分

      操作码：识别IO指令

      命令码：表明这条指令需要做什么操作

      设备码：对那个设备进行操作

      ![image-20221103183823090](https://s2.loli.net/2022/11/07/u9DiWnOLKYxywqU.png)

   2. 通道指令：通道能识别的指令

      .{% span red, 通道程序提前编好放到主存中 %}.

      在含有通道的计算机中，CPU执行{% span blue, I/O指令 %}对通道发出命令，由通道执行一系列{% span red, 通道指令 %}，代替CPU对I/O设备进行管理

![image-20221103184309731](https://s2.loli.net/2022/11/07/DWxCd3JLjhwHrVN.png)



## IO设备

### 外部设备

外部设备也称外围设备，是除了主机以外的、能直接或间接与计算机交换信息的装置。

### 输入设备

- 用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备

{% tabs IO设备 %}

<!--tab 键盘 -->

键盘

键盘是最常用的输入设备，通过它可发出命令或输入数据。每个键相当于一个开关，当按下键时，电信号连通;当松开键时，弹簧把键弹起，电信号断开。

键盘输入信息可分为3个步骤:

1. 查出按下的是哪个键;
2. 将该键翻译成能被主机接收的编码，如ASCIl码;
3. 将编码传送给主机。

<!-- endtab -->

<!--tab 鼠标 -->

鼠标

鼠标是常用的定位输入设备，它把用户的操作与计算机屏幕上的位置信息相联系。常用的鼠标有机械式和光电式两种。

工作原理:

- 当鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应运动。

<!-- endtab -->

{% endtabs %}



### 输出设备

- 用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备。



显示器：

{% tabs 输出设备 %}

<!--tab 按显示设备所用的显示器件分类 -->

- ☆阴极射线管（CRT)显示器
- 液晶显示器(LCD)
- LED显示器
- ....

<!-- endtab -->

<!--tab 按所显示的信息内容分类 -->

- 字符显示器
- 图形显示器
- 图像显示器

<!-- endtab -->

{% endtabs %}

屏幕大小：以对角线长度表示，常用的有12～29英寸等。

分辨率：所能表示的像素个数，屏幕上的每一个光点就是一个像素，以宽、高的像素的乘积表示，例如，800×600，1024×768和1280×1024等。

灰度级：灰度级是指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚逼真，典型的有8位（256级)、16位等。{% span red, n位可以表示2"种不同的亮度或颜色 %}。

刷新：光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称为刷新。

刷新频率：单位时间内扫描整个屏幕内容的次数，按照人的视觉生理，刷新频率大于30Hz时才不会感到闪烁，通常显示器{% span red, 刷新频率 %}在60～120Hz。

显示存储器VRAM：也称{% span red, 刷新存储器 %}，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。

VRAM容量=分辨率×灰度级位数

VRAM带宽=分辨率x灰度级位数x帧频

注:现代计算机中，显存除了作为当前显示帧的缓存，还会用于保存即将渲染的图像数据。

集成显卡计算机中，通常分配一片内存作为显存。



{% tabs  显示器 %}

<!--tab 阴极射线管（CRT）显示器 -->

- CRT显示器主要由电子枪、偏转线圈、荫罩、高压石墨电极和荧光粉涂层及玻璃外壳5部分组成。具有可视角度大、无坏点、色彩还原度高、色度均匀、可调节的多分辨率模式、响应时间极短等优点。

<!-- endtab -->

<!--tab 液晶显示器(LCD) -->

- 原理:利用液晶的电光效应，由图像信号电压直接控制薄膜晶体管，再间接控制液晶分子的光学特性来实现图像的显示。
- 特点:体积小、重量轻、省电、无辐射、绿色环保、画面柔、不伤眼等。

<!-- endtab -->

<!-- tab LED(发光二极管)显示器 -->

- 原理:通过控制半导体发光二极管进行显示，用来显示文字、图形、图像等各种信息。

<!-- endtab -->

{% endtabs %}

LCD与LED是两种不同的显示技术，LCD是由液态晶体组成的显示屏，而LED则是由发光二极管组成的显示屏。与LCD相比，{% span red, LED显示器在亮度、功耗、可视角度和刷新速率等方面都更具优势 %}。

{% tabs 显示器 %}

<!--tab 字符型显示器 -->

- 显示字符的方法{% span red, 以点阵为基础 %}。{% span blue, 点阵是指由m×n个点组成的阵列 %}。点阵的多少取决于显示字符的质量和字符窗口的大小。字符窗口是指每个字符在屏幕上所占的点数，它包括字符显示点阵和字符间隔。
- 将{% span blue, 点阵存入由ROM构成的字符发生器 %}中，在CRT进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中0和1代码不同控制扫描电子束的开或关，从而在屏幕上显示出字符。对应于每个字符窗口，所需显示{% span red, 字符的ASCII代码被存放在视频存储器VRAM %}中，以备刷新。
- 阴极射线管显示字符的方式
  - 先通过接口电路，将键盘输入的信息或者主机先要显示的信息的ASCII码放到显示存储器RAM中
  - 在引进射线管CRT控制器的操作下，将显示存储器中的字符一个个的发射到字符发生器ROM中
  - ROM中除了处理电信号外，还有一个ROM来存放对应ASCII码的字形码

![image-20221103192458615](https://s2.loli.net/2022/11/07/4ojZheYcEW9ASXU.png)

![image-20221103193010163](https://s2.loli.net/2022/11/07/g3WLsxI2vATjZaK.png)

<!-- endtab -->

<!--tab 图形显示器 -->

- 根据扫描方式的不同可以分为光栅扫描显示器和随机扫描显示器

- 将所显示图形的一组坐标点和绘图命令组成显示文件存放在缓冲存储器中，缓存中的显示文件传送给矢量（线段）产生器，产生相应的模拟电压，直接控制电子束在屏幕上的移动。为了在屏幕上保留持久稳定的图像，需要按一定的频率对屏幕进行反复刷新。
- 这种显示器的优点是分辨率高且显示的曲线平滑。目前高质量的图形显示器采用这种随机扫描方式。缺点是当显示复杂图形时，会有闪烁感。

<!-- endtab -->

{% endtabs %}



打印机：

打印机是计算机的输出设备之一，用于将计算机处理结果打印在相关介质上。



按印字原理不同可分为：

{% tabs 打印机类型 %}

<!-- tab 击打式打印机 -->

利用机械动作使印字机构与色带和纸相撞而打印字符

- 优: 设备成本低，印字质量好，防伪性好
- 缺:噪声大，速度慢

<!-- endtab -->

<!-- tab 非击打式打印机 -->

非击打式打印机:采用电、磁、光、喷墨等物理、化学方法来印刷字符

- 优:速度快，噪声小
- 缺:成本高

<!-- endtab -->

{% endtabs %}

按打印机工作方式不同可分为：

{% tabs 打印机工作方式 %}

<!-- tab 串行打印机 -->

逐字打印，速度慢

<!-- endtab -->

<!-- tab 行式打印机 -->

逐行打印，速度快

<!-- endtab -->

{% endtabs %}

按工作方式可分为

{% tabs 打印机工作方式 %}

<!-- tab 针式打印机 -->

原理: 在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横
向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需内容。

特点:针式打印机擅长“多层复写打印”，实现各种票据或蜡纸等的打印。它工作原理简单，造价低
廉，耗材（色带）便宜，但打印分辨率和打印速度不够高。

<!-- endtab -->

<!-- tab 喷墨式打印机 -->

原理:带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理，
即分别喷射3种颜色墨滴，按一定的比例混合出所要求的颜色。

特点:打印噪声小，可实现高质量彩色打印，通常打印速度比针式打印机快;但防水性差，高质量打
印需要专用打印纸。

<!-- endtab -->

<!-- tab 激光打印机 -->

原理:计算机输出的二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，再经过显影、转
印和定影，便在纸上得到所需的字符或图像。

特点:打印质量高、速度快、噪声小、处理能力强;但耗材多、价格较贵、不能复写打印多份，且对
纸张的要求高。激光打印机是将激光技术和电子显像技术相结合的产物。感光鼓（也称为硒鼓)是激光打印机的核心部件。

<!-- endtab -->	

{% endtabs %}

![image-20221103195244324](https://s2.loli.net/2022/11/07/eAxQoXY9iSucvCB.png)

### 外存设备

- 是指除计算机内存及CPU缓存等以外的存储器。硬磁盘、光盘等是最基本的外存设备。

{% tip %}外存储器{% endtip %}

计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器。

所谓“磁表面存储”，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。

磁表面存储器的优点:

1. 存储容量大，位价格低;
2. 记录介质可以重复使用;
3. 记录信息可以长期保存而不丢失，甚至可以脱机存档;
4. 非破坏性读出，读出时不需要再生。

磁表面存储器的缺点:

1. 存取速度慢;
2. 机械结构复杂;
3. 对工作环境要求较高。

![image-20221103203555206](https://s2.loli.net/2022/11/07/KzsdEi5Gtuo4DPy.png)

外存储器既可以作为输入设备，也可以作为输出设备。(既可以存数据，也可以读数据)

{% tip %}磁盘存储器{% endtip %}

磁盘设备的组成：

1. 存储区域

   一块硬盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分为若干个扇区，扇区（也称块）是磁盘读写的最小单位，也就是说磁盘按块存取。

   - 磁头数(Heads)：即记录面数，表示硬盘总共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头。
   - 柱面数(Cylinders)：表示硬盘每一面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面
   - 扇区数(Sectors)：表示每一条磁道上有多少个扇区。

2. 硬盘存储器

   硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成。

3. 磁盘驱动器:核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动头固定盘片的硬盘存储器。

4. 磁盘控制器:是硬盘存储器和主机的接口，主流的标准有IDE、SCSI、SATA等。

![image-20221103204503939](https://s2.loli.net/2022/11/07/F1qz9MvoPCcVSgm.png)

磁盘的性能指标：

1. 磁盘的容量:一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。
   - 非格式化容量：是指磁记录表面可以利用的磁化单元总数。
   - 格式化容量：是指按照某种特定的记录格式所能存储信息的总量。
2. 记录密度:记录密度是指盘片单位面积上记录的二进制的信息量通常以道密度、位密度和面密度表示。		
   - 道密度是沿磁盘半径方向单位长度上的磁道数;
   - 位密度是磁道单位长度上能记录的二进制代码位数;
   - 面密度是位密度和道密度的乘积。
   - 注意:磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同。
3. 平均存取时间:
   - 平均存取时间=寻道时间（磁头移动到目的磁道）+  旋转延迟时间（磁头定位到所在扇区) +  传输时间（传输数据所花费的时间)

![image-20221103210158123](https://s2.loli.net/2022/11/07/1vXcgki4RtJylHU.png)

4. 数据传输率:磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。
   - 假设磁盘转数为r转/秒），每条磁道容量为N个字节，则数据传输率为$D_r=rN$

磁盘地址：

- 主机向磁盘控制器发送寻址信息，磁盘的地址一般如图所示:

![image-20221103210520810](https://s2.loli.net/2022/11/07/TK4V12kYW6gOlHi.png)

- 若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码;

![image-20221103210545312](https://s2.loli.net/2022/11/07/sPgWTzJ28VNtuE1.png)

硬盘的工作过程

- 硬盘的主要操作是{% span red, 寻址、读盘、写盘 %}。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。
- 硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。

![image-20221103210821299](https://s2.loli.net/2022/11/07/2RMbjqgelUyh43N.png)

{% tip %}磁盘阵列{% endtip %}

RAID (Redundant Array of Inexpensive Disks，廉价冗余磁盘阵列）{% span red, 是将多个独立的物理磁盘组成一个独立的逻辑盘 %}，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。

RAID的分级如下所示。在RAID1～RAID5的几种方案中，{% span red, 无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏 %}。

- {% label 从上到下安全性和可靠性依此提高 red %}

- RAID0:无冗余和无校验的磁盘阵列。
  - RAID0把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但RAID0没有容错能力。

- RAID1:镜像磁盘阵列。
  - RAID1是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障,可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。

<img src="https://s2.loli.net/2022/11/07/54z2vdghprnHIDB.png" alt="image-20221103211629696" style="zoom:50%;" />

- RAID2:采用纠错的海明码的磁盘阵列。

<img src="https://s2.loli.net/2022/11/07/qe9NFpM2vPZtOaJ.png" alt="image-20221103211659078" style="zoom:50%;" />

- RAID3:位交叉奇偶校验的磁盘阵列。

- RAID4:块交叉奇偶校验的磁盘阵列。

- RAID5:无独立校验的奇偶校验磁盘阵列。
- RAID通过同时使用多个磁盘，提高了传输率;通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量;通过镜像功能，可以提高安全可靠性;通过数据校验，可以提供容错能力。

{% tip %}光盘存储器{% endtip %}

光盘存储器是利用光学原理读/写信息的存储装置，它采用聚焦激光束对盘式介质以非接触的方式记录信息。

![image-20221103212505008](https://s2.loli.net/2022/11/07/Hj9675VAoWvfgIw.png)

特点：

- 存储密度高
- 携带方便
- 成本低
- 容量大
- 存储期限长
- 容易保存等…

光盘的类型如下:

- CD-ROM:只读型光盘，只能读出其中内容，不能写入或修改。
- CD-R:只可写入一次信息，之后不可修改。
- CD-RW:可读可写光盘，可以重复读写。
- DVD-ROM:高容量的CD-ROM，DVD表示通用数字化多功能光盘。



{% tip %}固态硬盘{% endtip %}

在微小型高档笔记本电脑中，采用高性能Flash Memory作为硬盘来记录数据，这种“硬盘”称固态硬盘。

固态硬盘除了需要Flash Memory外，还需要其他硬件和软件的支持。

注:闪存(Flash Memory)是在E2PROM的基础上发展起来的，本质上是只读存储器。

![image-20221103213107670](https://s2.loli.net/2022/11/07/VfIYBtkQUcDWyTx.png)



## IO接口

又称{% span red, I/O控制器(I/O Controller）、设备控制器 %}，负责协调主机与外部设备之间的数据传输

### IO接口的作用

![image-20221103213537508](https://s2.loli.net/2022/11/07/AiZYBojRg6aCfQm.png)



- 数据缓冲:通过数据缓冲寄存器（DBR）达到主机和外设工作速度的匹配
- 错误或状态监测:通过状态寄存器反馈设备的各种错误、状态信息，供CPU查用
- 控制和定时:接收从控制总线发来的控制信号、时钟信号
- 数据格式转换:串-并、并-串等格式转换
- 与主机和设备通信:实现主机—IO接口一IO设备之间的通信

### IO接口

![image-20221103213808081](https://s2.loli.net/2022/11/07/SOPWJYocCryKnZE.png)

主机侧：内部接口:内部接口与系统总线相连，实质上是与内存、CPU相连。 {% del 数据的传输方式只能是并行传输 %} 。这种说法不完全正确，并行传输是2000年以前用的方法，现在在慢慢的转换成串行方法

设备侧：外部接口:外部接口通过接口电缆与外设相连,外部接口的数据传输可能是串行方式，因此I/O接口需具有串/并转换功能。

![image-20221103214632312](https://s2.loli.net/2022/11/07/fVH2W3ZtsmhpFxy.png)

1. 发命令:发送命令字到/o控制寄存器，向设备发送命令（需要驱动程序的协助
2. 读状态:从状态寄存器读取状态字，获得设备或I/O控制器的状态信息
3. 读/写数据:从数据缓冲寄存器发送或读取数据，完成主机与外设的数据交换

- {% span red, 控制寄存器、状态寄存器 %}在使用时间上是错开的，因此有的I/O接口中{% span red, 可将二者合二为一 %}.
- IO控制器中的各种寄存器称为{% label I/O端口 red %}.

如何确定要操作的设备?

- 每个设备对应一组寄存器，操作不同的寄存器就是在操作不同的设备

### 接口与端口

![image-20221104100602428](https://s2.loli.net/2022/11/07/u5kYG1BSi7ILJsD.png)



IO接口是指电路中可以被CPU直接访问的寄存器

CPU如何访问不同的IO端口？

{% tip %}统一编制和独立编制{% endtip %}

统一编制：

靠{% span red, 不同的地址码 %}区分内存和IO设备。访存类的指令都可以访问I/O端口，{% span red, 因为不同地址对应的内存单元不同 %}(RISC机器常用)

<img src="https://s2.loli.net/2022/11/07/4S92Jc1XiV7Q8xw.png" alt="image-20221104100949143" style="zoom:50%;" />

独立编制：

靠{% span red, 不同的指令区 %}分内存和I/O设备。{% span red, 只能用专门的I/O指令访问I/O端口 %}(Intel处理器常用，IN、OUT就是lO指令)

<img src="https://s2.loli.net/2022/11/07/jirCqXKcguZxat8.png" alt="image-20221104101146144" style="zoom:50%;" />



{% tip %}统一编制和独立编制的优缺点{% endtip %}

1.{% label 统一编址 red %}.
把I/O端口当做存储器的单元进行地址分配，用统一的{% span red, 访存指令 %}就可以访问I/O端口，又称{% span red, 存储器映射方式 %}。

靠不同的{% span red, 地址码 %}区分内存和I/O设备，I/O地址要求相对固定在地址的某部分。

如系统总线中地址线共10根，则可以访问的存储单元个数为210= 1024个，假设要给10个I/O端口编址:

1. 0～9表示I/O地址，10～1023为主存单元地址
2. 0～1013表示主存单元地址，1014～1023为IO地址
3. 10～19表示I/O地址，0～9、20～1023为主存单元地址

优点:

- {% span green, 不需要专门的输入/输出指令，所有访存指令都可直接访问端口，程序设计灵活性高，端口有较大的编址空间，读写控制逻辑电路简单 %}。

缺点:

- {% span red, 端口占用了主存地址空间，使主存地址空间变小外设寻址时间长(地址位数多，地址译码速度慢) %}.



2. {% label 独立编制: red %}

I/O端口地址与存储器地址无关，独立编址CPU需要设置{% span red, 专门的输入/输出指令访问端口 %}，又称I/O映射方式。靠不同的指令区分内存和I/O设备。

优点:

- {% span green, 使用专用IO指令，程序编制清晰IO端口地址位数少，地址译码速度快I/O端口的地址不右用主存地址空间 %}.

缺点:

- {% span red, IO指令类型少，一般只能对端口进行传送操作,程序设计灵活性差，需要CPU提供存储器读/写、I/O设备读/写两组控制信号，增加了控制逻辑电路的复杂性 %}.



{% tip %}IO接口的类型{% endtip %}

按数据传送方式可分为：

- 并行接口:一个字节或一个字所有位同时传送。
- 串行接口:一位一位地传送。
- 注:这里所说的数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧，{% del 数据总是并行传送的 %}。接口要完成数据格式转换。

按主机访问IO设备的控制方式可分为：

- 程序查询接口
- 中断接口DMA接口

按功能选择的灵活性可分为：

- 可编程接口
- 不可编程接口

![image-20221104103141535](https://s2.loli.net/2022/11/07/EX4rvYKU9J5Bnjf.png)



## 程序查询方式

![image-20221104104706643](https://s2.loli.net/2022/11/07/VZ3TYSGdIF7xNoK.png)

x86中的IO指令实例

- lN Rd, Rs:把IO端口Rs的数据输入到CPU寄存器Rd

- OUT Rd, Rs:把CPU寄存器Rs的数据输出到IO端口Rd

模拟打印三个字符：abc

1. 先通过OUT指令把我们需要打印的字符放到CPU的寄存器中
2. 经过打印机的驱动处理，可以把打印机启动的指令放到CPU的寄存器中
3. 现在CPU需要吧打印机启动命令放到IO接口的控制寄存器中
   1. 先通过地址线指明我们需要的写入的IO端口
   2. 在通过控制线指明我们需要的操作，写操作
   3. 在通过数据线，把打印机启动的指令放到控制寄存器中
4. IO控制逻辑根据CPU发来的指令来给打印机发出控制信号，当打印机启动完成之后，会给状态控制寄存器返回一个Ready的信号
5. CPU一直通过IN指令轮回检查IO接口的状态控制器，如果没有准备好的话则会一直检查，如果准备好的话，则会进行下一步操作
6. 将我们需要打印的字符通过地址线指明我们需要放入寄存器的地址，在通过控制线，表明我们这次的操作是写操作，然后通过数据线将我们需要打印的字符放到数据缓冲寄存器中
7. 我们在通过IO控制逻辑将我们需要打印的数据放到打印机的设备控制逻辑单元中，然后打印
8. 这样循环三次即可打印出ABC

![image-20221104110158397](https://s2.loli.net/2022/11/07/AOli8Ihg9C7a3Fo.png)



![image-20221104110254978](https://s2.loli.net/2022/11/07/TfjeQb1uMaJSPxY.png)



### 程序查询方式例题

在程序查询方式的输入/输出系统中，假设不考虑处理时间，每一个查询操作需要100个时钟周期,CPU的时钟频率为50MHz。现有鼠标和硬盘两个设备，而且CPU必须每秒对鼠标进行30次查询，硬盘以32位字长为单位传输数据，即每32位被CPU查询一次，传输率为$2×2^{20}B/s$。求CPU对这两个设备查询所花费的时间比率，由此可得出什么结论?

时间的角度:

一个时钟周期为1/50MHz = 20ns

一个查询操作耗时100 × 20ns = 2000ns

1. 鼠标

   每秒查询鼠标耗时30× 2000ns = 60000ns

   查询鼠标所花费的时间比率=60000ns/1s = 0.006%对鼠标的查询基本不影响CPU的性能

2. 硬盘

   每32位需要查询一次，每秒传送$2×2^{20}B$每秒需要查询$(2×2^{20}B)/4B=2^{19}$次

   查询硬盘耗时$2^{19}\cdot2000ns = 512\cdot1024\cdot2000ns≈1.05\cdot10^9 ns$

   查询硬盘所花费的时间比率$=(1.05×10^9ns)/1s=105%$

   CPU将全部时间都用于对硬盘的查询也不能满足磁盘传输的要求

频率的角度:

CPU的时钟频率为50MHz，即每秒50×106个时钟周期

1. 鼠标

   每秒查询鼠标占用的时钟周期数30×100= 3000

   查询鼠树所花费的时间比率=$3000/(50\cdot10^6) = 0.006%$对鼠标的查询基本不影响CPU的性能

2. 硬盘

   每秒需要查询$(2\cdot2^{20}B)/4B=2^{19}$次

   每秒查询硬盘占用的时钟周期数$2^{19}×100≈5.24\cdot10^7$

   查询硬盘所花费的时间比率=$(5.24×10^7)/(50×10^6)≈105$%

   CPU将全部时间都用于对硬盘的查询也不能满足磁盘传输的要求



CPU一旦启动I/O，{% span red, 必须停止现行程序的运行 %}，并在现行程序中插入一段程序。

主要特点: {% span blue, CPU有“踏步”等待现象，CPU与I/O串行工作 %}。

优点:{% span green, 接口设计简单、设备量少 %}。

缺点:{% span red, CPU在信息传送过程中要花费很多时间用于查询和等待，而且如果采用独占查询，则在一段时间内只能和一台外设交换信息，效率大大降低 %}。

独占查询: CPU 100%的时间都在查询I/0状态，完全串行

定时查询:在保证数据不丢失的情况下，每隔一段时间CPU就查询一次I/O状态。 查询的间隔内CPU可以执行其他程序

## 程序中断的作用和原理

### 中断的基本概念

程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后CPU又自动返回到现行程序的断点处，继续执行原程序。

工作流程:

1. 中断请求：

   中断源向CPU发送中断请求信号。

2. 中断响应

   响应中断的条件。

   中断判优:多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。

3. 中断处理

   中断隐指令。

   中断服务程序。

![image-20221104155820492](https://s2.loli.net/2022/11/07/yPb8sVjnUM6rQXw.png)

### 中断请求的分类

![image-20220823154033775](https://s2.loli.net/2022/11/02/fgURNsl2q46zHbA.png)

狭义的中断分为：

- 非屏蔽中断：关中断也会被相应（断点）
- 可屏蔽中断：关中断不会被相应

关中断的作用:实现原子操作

- lF=1表示{% span red, 开中断 %}（允许中断)
- IF=0表示{% span red, 关中断 %}(不允许中断)

中断命令存放在PSW中:

![image-20221104162145669](https://s2.loli.net/2022/11/07/McWgiH3U6NVstrR.png)

### 中断请求标记

{% tip warning %}如何判断那个设备发来的中断信号？{% endtip %}

每个中断源向CPU发出中断请求的时间是随机的。

为了记录中断事件并区分不同的中断源，中断系统需对每个中断源设置{% span red, 中断请求标记触发器INTR %},当其状态为“1”时，表示中断源有请求。

这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。

![image-20221104162525474](https://s2.loli.net/2022/11/07/a7f5yBRCFrOnbMH.png)

对于{% span red, 外中断 %}，CPU是在统一的时刻即{% span red, 每条指令执行阶段结束前 %}向接口{% span red, 发出中断查询信号 %}，以获取I/O的中断请求，也就是说，{% span red, CPU响应中断的时间 %}是在每条{% span red, 指令执行阶段的结束时刻 %}。

CPU响应中断必须满足以下3个条件:

1. 中断源有中断请求。
2. CPU允许中断即开中断。
3. 一条指令执行完毕，且没有更紧迫的任务。

### 中断判优

中断判优既可以用硬件实现，也可用软件实现:

- {% span red, 硬件实现是通过硬件排队器实现的 %}，它既可以设置在CPU中，也可以分散在各个中断源中;
- {% span red, 软件实现是通过查询程序实现的 %}。

![image-20221104162839765](https://s2.loli.net/2022/11/07/JWFodi2DL6cExyP.png)

![image-20221104162909631](https://s2.loli.net/2022/11/07/R8gBxcJ6PMpLyvZ.png)

![image-20221104162930509](https://s2.loli.net/2022/11/07/PUJeGLkpRbymHfu.png)

{% tip %}优先级的设置{% endtip %}

1. 硬件故障中断属于最高级，其次是软件中断
2. 非屏蔽中断优于可屏蔽中断;
3. DMA请求优于I/O设备传送的中断请求
4. 高速设备优于低速设备;
5. 输入设备优于输出设备;
6. 实时设备优于普通设备。

### 中断处理过程

中断隐指令的主要任务:

1. {% span red, 关中断 %}。在中断服务程序中，为了保护中断现场（即CPU主要寄存器中的内容）期间不被新的中断所打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。
2. {% span red, 保存断点 %}。为了保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（即程序计数器（PC)的内容）保存起来。可以存入堆栈，也可以存入指定单元。
3. {% span red, 引出中断服务程序 %}。引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器（PC） 。

引出终端服务程序有两种方式：软件查询法，硬件向量查询法

{% tip %}硬件向量查询法{% endtip %}

由{% span red, 硬件 %}产生{% span red, 向量地址 %}.

再由{% span red, 向量地址 %}找到{% span red, 中断程序入口地址 %}.

![image-20221104164942710](https://s2.loli.net/2022/11/07/YuIKFpMxX6dQhVm.png)

{% tip %}中断服务程序{% endtip %}

.查询到中断服务程序存放的位置之后，就开始执行中断服务程序

中断服务程序的主要任务:

1. 保护现场

   保存通用寄存器和状态寄存器的内容（eg:保存ACC寄存器的值），以便返回原程序后可以恢复CPU环境。可使用堆栈，也可以使用特定存储单元。

2. 中断服务(设备服务)

   主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲存储器中（eg:中断服务的过程中有可能修改ACC寄存器的值)

3. 恢复现场

   通过出栈指令或取数指令把之前保存的信息送回寄存器中(eg:把原程序算到一般的Acc值恢复原样)

4. 中断返回

   通过中断返回指令回到原程序断点处。

![image-20221104170623253](https://s2.loli.net/2022/11/07/JkrSYEH4OjoelyL.png)

- {% span red, 单重中断:执行中断服务程序时不响应新的中断请求 %}。



## 多重中断

.{% label 单重中断:执行中断服务程序时不响应新的中断请求 red %}。

.{% label 多重中断:又称中断嵌套,执行中断服务程序时可响应新的中断请求 green %}。

<img src="https://s2.loli.net/2022/11/07/4T3UmqjPAsaGRXI.png" alt="image-20221104182634003" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/11/07/7dnxNPJImQ9tFCs.png" alt="image-20221104182654066" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/11/07/ERSioV8Kg6DALaY.png" alt="image-20221104182818484" style="zoom:50%;" />



### 中断屏蔽技术

中断屏蔽技术{% span red, 主要用于多重中断 %}，CPU要具备多重中断的功能，须满足下列条件。

1. 在中断服务程序中提前设置开中断指令。
2. 优先级别高的中断源有权中断优先级别低的中断源。

每个{% span red, 中断源都有一个屏蔽触发器 %}，{% label 1表示屏蔽该中断源的请求 red %}，{% label 0表示可以正常申请 green %}，所有屏蔽触发器组合在一起，便构成一个屏蔽字寄存器，{% span red, 屏蔽字寄存器的内容称为屏蔽字 %}。

屏蔽字设置的规律:

1. 一般用‘1'表示屏蔽，'0'表示正常申请。
2. 每个中断源对应一个屏蔽字(在处理该中断源的中断服务程序时,屏蔽寄存器中的内容为该中断源对应的屏蔽字)。
3. 屏蔽字中‘1'越多，优先级越高。{% span red, 每个屏蔽字中至少有一个'1'(至少要能屏蔽自身的中断) %}。

<img src="https://s2.loli.net/2022/11/07/9urEQ61YwfzRZ7e.png" alt="image-20221104183053909" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/11/07/M2qAcg6vaK3SX8J.png" alt="image-20221104183129100" style="zoom:50%;" />

设某机有4个中断源A、B、C、D，其硬件排队优先次序为A>B>C>D，现要求将中断处理次序改为D>A>C>B。

1. 写出每个中断源对应的屏蔽字。

![image-20221104184301543](https://s2.loli.net/2022/11/07/UAenJDSdszZXchE.png)

2. 按下图所示的时间轴给出的4个中断源的请求时刻，画出CPU执行程序的轨迹。设每个中断源的中断服务程序时间均为20us.

![image-20221104184338783](https://s2.loli.net/2022/11/07/qVrXGQc8lTJmHa7.png)



![image-20221104184506123](https://s2.loli.net/2022/11/07/JYHz1AvPKcgC9fD.png)



### 拓展

- {% span red, IF %} (Interrupt Flag）开/关中断标志。当IF=1时，表示开中断，当IF=0时表示关中断

- {% span red, INTR:可屏蔽中断请求 %}（ interrupt request）信号，输入，用来申请一个硬件中断。当IF=1时，若INTR保持高电平，则在当前指令执行完毕后就进入中断响应周期

- {% span red, NMl:非屏蔽中断 %}(non-maskable interrupt）输入信号。与INTR信号类似，但 NMI中断不必检查IF标志位是否为1。常用于处理电源掉电紧急情况。

- {% span red, INTA:中断响应 %}( interrupt acknowledge）信号，输出。{% span red, 响应INTR输入 %}。该引脚常用来选通中断向量码以响应中断请求。

![image-20221104185329136](https://s2.loli.net/2022/11/07/O3FztG4ScvNyZC7.png)

1. 中断程序先通过终端接口，向中断控制器的中断请求寄存器IRR中发送中断信号
   - 不管多少个中断程序中断控制器一律接受，
2. 然后通过中断控制器里面的数据总线，向控制逻辑发送信号
3. 控制逻辑通过INT接口向CPU的INTR接口发送中断信号，让CPU知道现在有一个中断程序过来了需要他处理，
   - 如果CPU检测没有关中断的话，则通过INTA接口向中断控制器的INTA接口发送信息，我可以处理中断信号，但是你需要告诉我，我需要处理那个中断信号
4. 因为中断控制器可能接收到了多个中断信号，所以这时候需要通过优先权电路确定需要处理那个中断信号
5. 通过优先权电路筛选出来之后，通过终端服务寄存器ISR的处理，我们可以得出我们所要处理的中断信号的类型号
6. 中断服务寄存器通过数据总线告诉CPU需要处理那个中断程序，然后CPU就开始执行

## 程序中断控制方式

程序中断控制方式具体操作

![image-20221104192256135](https://s2.loli.net/2022/11/07/5IVOQDWRAfrMCny.png)



当CPU需要接受外部设备中的数据的时候，可以先让外部设备输入数据，等数据输入完毕之后，外部设备通过中断操作，向CPU发出终端操作，等到CPU执行完K这条指令的之后，开始检测中断信号，CPU开始处理这个终端操作，先通过关中断，防止别的中断程序在进行插入，保存断点k，开始执行中断服务程序，执行的时候先要保护现场，将CPU正在用的寄存器中的数据都保存下来，然后通过中断服务程序控制数据传送，最后恢复现场，CPU继续执行k+1个指令，IO设备继续输入数据

![image-20221104193642335](https://s2.loli.net/2022/11/07/2sViHqnR9thkIQp.png)



## DMA方式

![image-20221104195127934](https://s2.loli.net/2022/11/07/rkGlXJq2TfgHMhZ.png)

CPU向DMA控制器指明要输入还是输出;要传送多少个数据;数据在主存、外设中的地址。

1. 接受外设发出的DMA请求（外设传送一个字的请求)，并向CPU发出总线请求。
2. CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期。
3. 确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数。
4. 规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作。
5. 向CPU报告DMA操作的结束

注意：{% label 在DMA传送过程中，DMA控制器将接管CPU的地址总线、数据总线和控制总线，CPU的主存控制信号被禁止使用。而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作 red %}.

![image-20221104195305560](https://s2.loli.net/2022/11/07/GM4FTa7ZdNvi5PW.png)

### DMA传送过程

预处理:

- 主存起始地址→AR
- I/O设备地址→DAR
- 传送数据个数→WC
- 启动I/O设备

数据传送:

- 继续执行主程序
- 同时完成一批数据的传送

后处理:

- 中断服务程序
- 做DMA结束处理

继续执行主程序

![image-20221104195707993](https://s2.loli.net/2022/11/07/jduln7JtNRaxepI.png)



### DMA传送解决方案

上面这种方式采用的是{% span red, CPU和DMA共用同一根主线 %}，所以不会发生主存访问冲突

如果采用下面这个三总线方式的话可能会出现CPU和DMA对主存访问冲突

![image-20221104200643341](https://s2.loli.net/2022/11/07/lbvmn94jt5HIsVX.png)

{% tip %}解决方法{% endtip %}

1. 停止CPU访问主存

   .{% span green, 控制简单 %}.

   .{% span red, CPU处于不工作状态或保持状态未充分发挥CPU对主存的利用率 %}.

![image-20221104200851921](https://s2.loli.net/2022/11/07/UbaRWZosEFu9C1K.png)

2. DMA与CPU交替访存

   .{% span red, 不需要总线使用权的申请、建立和归还过程 %}.

   .{% span red, 硬件逻辑更为复杂 %}.

![image-20221104201121662](https://s2.loli.net/2022/11/07/31AfOUbPHTRYS4z.png)

3. 周期挪用(周期窃取)

   DMA 访问主存有三种可能:

   - CPU此时不访存（不冲突)
   - CPU正在访存(存取周期结束让出总线)
   - CPU与DMA同时访存({% span red, IO访存优先 %})

![image-20221104201243122](https://s2.loli.net/2022/11/07/HASPhWyB8VeMNru.png)



### DMA方式的特点

主存和DMA接口之间有一条直接数据通路。

由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，{% span red, IO与主机并行工作，程序和传送并行工作 %}。

DMA方式具有下列特点:

1. 它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。
2. 在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。
3. 主存中要开辟专用缓冲区，及时供给和接收外设的数据。
4. DMA传送速度快，CPU和外设并行工作，提高了系统效率。
5. DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。

|          |                  中断                   |                          DMA                          |
| :------: | :-------------------------------------: | :---------------------------------------------------: |
| 数据传送 | 程序控制<br />程序的切换→保存和恢复现场 |     硬件控制<br />CPU只需要进行预处理和后处理即可     |
| 中断请求 |                传送数据                 |                        后处理                         |
|   相应   |       指令执行周期结束后相应中断        | 每个机器周期结束均可，总线空闲时<br />即可相应DMA请求 |
|   场景   |            CPU控制，低速设备            |                DMA控制器控制，高速设备                |
|  优先级  |              优先级低于DMA              |                    优先级高于中断                     |
| 异常处理 |             能处理异常事件              |                      仅传送数据                       |



![image-20221104202341950](https://s2.loli.net/2022/11/07/oM468NZvJhf5ag1.png)

