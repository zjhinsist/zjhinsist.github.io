---
title: 最长公共子序列
date: 2022-05-05 10:27:28
tags: 算法
description: 最长公共子序列 理论 + 实现
background: url(https://s3.bmp.ovh/imgs/2022/08/08/e1c9bda47806a33d.png)
categories: 算法实现
---

# 最长公共子序列问题（动态规划）

给定两个序列X和Y：

![image-20220502210804170](https://s2.loli.net/2022/11/05/wi5IyNa3LCk21Hz.png)

其公共序列为：

![image-20220502210820695](https://s2.loli.net/2022/11/05/b7XauMek8iBEsdL.png)

这里我们要找出它的最长子序列，由上面的情况得出最长的公共自序列长度为4 为BCAB

如果我们采用枚举法的话，有如下这种情况：

![image-20220502211056663](https://s2.loli.net/2022/11/05/LwiB6K3zOyhDn5v.png)

我们再次观察一下这个公共自序列：

![image-20220502211214029](https://s2.loli.net/2022/11/05/gXb4m9krRDTM8fP.png)

我们发现长一点的数组依靠于短一点的数组：这时候可能会出现{% label 最优子结构 orange %}和{% label 重叠子问题 orange %}

当一个结构里面包含最优子结构问题和重叠子问题的时候我们就应该想到使用动态规划来解决这个问题



## 动态分析问题

我们采用C[i, j] 来表示[1..i]和Y[1..j]的最长公共子序列长度

我们从最后一个字母来开始推导，有两种情况，

### 情况一：

	这两个序列的最后一个字母不相同

![image-20220502211652786](https://s2.loli.net/2022/11/05/Hbwk5gvEQYCMoml.png)

如果最后两个字母不同的话，可分为两种情况

#### 情况一

C[i, j] = C[i, j -1 ] + 0

#### 情况二

C[i, j] = C[i-1, j] + 0

![image-20220502211938610](https://s2.loli.net/2022/11/05/Z3QoH8V2pTt1zcb.png)



### 情况二：

	这两个序列的最后一个字母相同。

![image-20220502211606410](https://s2.loli.net/2022/11/05/F6H3Pi1mBvh8tls.png)

这里面需要分为三种情况：

1. 第一种：最后这个相同的字符在最长子序列中
2. 第二种：最后这个相同的字符不一定出现在最长子序列中，我们删除第一个序列的最后一个，在和第二个序列相比较
3. 第三种：最后这个相同的字符不一定出现在最长子序列中，我们删除第二个序列的最后一个，在和第一个序列相比较

![image-20220502212425684](https://s2.loli.net/2022/11/05/3NXMglOnGw5PtHq.png)

在这里我们看到：

c[i-1,j]比c[i -1,j -1]至多大1

c[i,j -1]比c[i -1, j -1]至多大1

c[i- 1,i -1]+1，另外两个+0

c[i- 1,i -1]+1 ≥ {c[i,j -1]，c[i-1,j] }



递推公式为：

![image-20220502212741379](https://s2.loli.net/2022/11/05/9KL8kRTHoeAIxCh.png)

追踪数组递推公式为：

![image-20220502212815454](https://s2.loli.net/2022/11/05/9KL8kRTHoeAIxCh.png)

## 代码实现

```python
# 初始化矩阵 
# 把矩阵的第零行第零列都设置为零
def init_matrix(mt_length, mt_width):
    matrix =  [[ [] for m in range(mt_length+1) ] for i in range(mt_width+1)]
    for i in range(mt_width+1):
        matrix[i][0] = 0
    for m in range(mt_length+1):
        matrix[0][m] = 0
    return matrix

# 进行最大子数组求导
def max_subsequence(A_strand, B_strand, matrix, rec):
    mx_width = len(A_strand)
    mx_height = len(B_serand)

    for line_num in range(mx_height):
        for column_num in range(mx_width):
            # 这里分为三种情况
            # 情况一：这两个字符相同
            
            if B_strand[line_num] ==  A_strand[column_num]:

                matrix[line_num+1][column_num+1] = matrix[line_num][column_num]+1
                rec[line_num][column_num] = "LU"
            # 情况二：这两个字符串不同，但是上大于左
            elif matrix[line_num + 1][column_num] > matrix[line_num][column_num+1]:
                 matrix[line_num+1][column_num+1] = matrix[line_num+1][column_num]
                 rec[line_num][column_num] = "L"
            # 左大于上 
            else:
                matrix[line_num+1][column_num+1] = matrix[line_num][column_num+1]
                rec[line_num][column_num] = "U"

# 追踪数组
def trace(rec, mx_length, mx_width, trace_list):
    if mx_length ==  0 or mx_width ==  0:
        return trace_list.append((mx_length, mx_width))
    if rec[mx_length][mx_width] ==  "LU":
        trace_list.append((mx_length,mx_width))
        trace(rec, mx_length-1, mx_width-1, trace_list)
    elif rec[mx_length][mx_width] ==  "L":
        trace(rec, mx_length, mx_width-1, trace_list)
    elif rec[mx_length][mx_width] ==  "U":
        trace(rec, mx_length-1, mx_width, trace_list)
```

测试数据

A_strand = "BDCABABCFGASDFGS"

B_serand = "ABCBDABCFGDFGAS"

最后结果：

B  C  B  A  B  C  F  G  D  F  G  S  
