---
title: 气温数据构建模型
date: 2022-07-12 11:23:59
tags: PyTorch
background: url(https://s3.bmp.ovh/imgs/2022/08/08/e1c9bda47806a33d.png)
description: 使用Pytorch实现气温模型预测
categories: 人工智能
---

# 气温预测

通过前天，昨天，和历史上这一天的最高温度，和今天实际的最高温低来进行回归模型的建立

先导包

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import torch
import torch.optim as optim
import warnings
warnings.filterwarnings("ignore")
%matplotlib inline
```



读取一下数据

```python
features = pd.read_csv("data/temps.csv")

# 展示一下数据
features.head()
```

<div>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>month</th>
      <th>day</th>
      <th>week</th>
      <th>temp_2</th>
      <th>temp_1</th>
      <th>average</th>
      <th>actual</th>
      <th>friend</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2016</td>
      <td>1</td>
      <td>1</td>
      <td>Fri</td>
      <td>45</td>
      <td>45</td>
      <td>45.6</td>
      <td>45</td>
      <td>29</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2016</td>
      <td>1</td>
      <td>2</td>
      <td>Sat</td>
      <td>44</td>
      <td>45</td>
      <td>45.7</td>
      <td>44</td>
      <td>61</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2016</td>
      <td>1</td>
      <td>3</td>
      <td>Sun</td>
      <td>45</td>
      <td>44</td>
      <td>45.8</td>
      <td>41</td>
      <td>56</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2016</td>
      <td>1</td>
      <td>4</td>
      <td>Mon</td>
      <td>44</td>
      <td>41</td>
      <td>45.9</td>
      <td>40</td>
      <td>53</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2016</td>
      <td>1</td>
      <td>5</td>
      <td>Tues</td>
      <td>41</td>
      <td>40</td>
      <td>46.0</td>
      <td>44</td>
      <td>41</td>
    </tr>
  </tbody>
</table>


数据表中

- year,moth,day,week分别表示的具体的时间
- temp_2:前天的最高温度值
- temp_1:昨天的最高温度值
- average:在历史中，每年这一天的平均最高温度值
- actual:这就是我们的标签值了，当天的真实最高温度
- friend:这一列可能是凑热闹的，你的朋友猜测的可能值，咱们不管它就好了



处理时间数据

```python
# 处理时间数据
import datetime

# 分别得到年月日
years = features["year"]
months = features["month"]
days = features["day"]

# datetime格式
dates = [str(int(year)) + "-" + str(int(month)) + "-" + str(int(day)) for year, month, day in zip(years, months, days)]
dates = [datetime.datetime.strptime(date, "%Y-%m-%d") for date in dates]

print(dates[:5])
#[datetime.datetime(2016, 1, 1, 0, 0),
# datetime.datetime(2016, 1, 2, 0, 0),
# datetime.datetime(2016, 1, 3, 0, 0),
# datetime.datetime(2016, 1, 4, 0, 0),
# datetime.datetime(2016, 1, 5, 0, 0)]
```



展示数据

```python
# 准备画图
# 指定默认风格
plt.style.use("fivethirtyeight")

# 设置布局
fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(nrows = 2, ncols=2, figsize=(10, 10))
fig.autofmt_xdate(rotation = 45)

# 标签值
ax1.plot(dates,features["actual"])
ax1.set_xlabel(""); ax1.set_ylabel("Temperature"); ax1.set_title("Max Temp")

# 昨天
ax2.plot(dates,features["temp_1"])
ax2.set_xlabel(""); ax2.set_ylabel("Temperature"); ax2.set_title("Previous Max Temp")

# 前天
ax3.plot(dates,features["temp_2"])
ax3.set_xlabel("Date"); ax3.set_ylabel("Temperature"); ax3.set_title("Two Days Prior Max Temp")

# 朋友
ax4.plot(dates, features["friend"])
ax4.set_xlabel("Date"); ax4.set_ylabel("Temperature"); ax4.set_title("Friend Estimate")

plt.tight_layout(pad=2)

```

![image-20220712114441385](https://s2.loli.net/2022/11/04/psoi5tGI6WqXwRN.png)



使用get_dummies(features) 函数来进行星期转换

```python
# 独热编码
# 将字符串代表的数字转换成对应的数字,例如上面表格中的星期那一栏
features = pd.get_dummies(features)
features.head(5)
```

<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }


<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>month</th>
      <th>day</th>
      <th>temp_2</th>
      <th>temp_1</th>
      <th>average</th>
      <th>actual</th>
      <th>friend</th>
      <th>week_Fri</th>
      <th>week_Mon</th>
      <th>week_Sat</th>
      <th>week_Sun</th>
      <th>week_Thurs</th>
      <th>week_Tues</th>
      <th>week_Wed</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2016</td>
      <td>1</td>
      <td>1</td>
      <td>45</td>
      <td>45</td>
      <td>45.6</td>
      <td>45</td>
      <td>29</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2016</td>
      <td>1</td>
      <td>2</td>
      <td>44</td>
      <td>45</td>
      <td>45.7</td>
      <td>44</td>
      <td>61</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2016</td>
      <td>1</td>
      <td>3</td>
      <td>45</td>
      <td>44</td>
      <td>45.8</td>
      <td>41</td>
      <td>56</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2016</td>
      <td>1</td>
      <td>4</td>
      <td>44</td>
      <td>41</td>
      <td>45.9</td>
      <td>40</td>
      <td>53</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2016</td>
      <td>1</td>
      <td>5</td>
      <td>41</td>
      <td>40</td>
      <td>46.0</td>
      <td>44</td>
      <td>41</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>


将特征修改一下

```python
# 标签 实际值
labels = np.array(features["actual"])

# 在特征中去掉标签，或得到的全部是预测值
features = features.drop("actual", axis=1)

#名字单独保存，防止丢失
features_list = list(features.columns)

# 转换成合适的格式
features = np.array(features)
```



进行数据预处理

```python
# 引入预处理模块
from sklearn import preprocessing

# 数据标准化
# 做标准化的目的：能够在数据处理的时候，数据收敛的比较快一些
input_features = preprocessing.StandardScaler().fit_transform(features)
```



构建网络模型

```python
# 预测数据
x = torch.tensor(input_features, dtype = float)
# 标签值
y = torch.tensor(labels, dtype = float)
```

参数的设计

```python
# 权重参数初始化
# 因为我们的参数矩阵为348 * 14, 所以我们的权重参数矩阵应该是14开头的，我们选择124个神经元
weights = torch.randn((14, 128), dtype=float, requires_grad = True)
# 偏置参数
biases = torch.randn(128, dtype = float, requires_grad = True)
# 权重参数二：
weights2 = torch.randn((128, 1), dtype=float, requires_grad = True)
# 偏置参数二：
biases2 = torch.randn(1, dtype = float, requires_grad = True)

# 学习率：
learning_rate = 0.001
# 损失值
losses = []
```

进行迭代

```python
for i in range(1000):
    # 计算隐层 Wx + b
    hidden = x.mm(weights) + biases
    
    # 加入激活函数
    hidden = torch.relu(hidden)
    # 预测结果
    predictions = hidden.mm(weights2) + biases2
    # 计算损失值
    loss = torch.mean((predictions - y)**2)
    losses.append(loss.data.numpy)
    
    # 打印损失值
    if i % 100 == 0:
        print("loss:", loss)
    
    # 逆向传播计算
    loss.backward()
    
    # 更新参数
    weights.data.add_(-learning_rate * weights.grad.data)
    biases.data.add_(-learning_rate * biases.grad.data)
    weights2.data.add_(-learning_rate * weights2.grad.data)
    biases2.data.add_(-learning_rate * biases2.grad.data)
    
    # 迭代完之后，需要把上一层的梯度值清空，否则会进行叠加
    weights.grad.data.zero_()
    biases.grad.data.zero_()
    weights2.grad.data.zero_()
    biases2.grad.data.zero_()
    
    
```



{% label 另一种方式，简单版 orange %}

```python
# 输入维度
input_size = input_features.shape[1]
# 隐层
hidden_size = 128
# 输出维度
output_size = 1
# 一轮的长度
batch_size = 16
# 序列化
my_nn = torch.nn.Sequential(
    # 构建输入层
    torch.nn.Linear(input_size, hidden_size),
    # Sigmoid函数归一化
    torch.nn.Sigmoid(),
    # 输出层
    torch.nn.Linear(hidden_size, output_size),
)

# MSE损失函数
cost = torch.nn.MSELoss(reduction = "mean")
# 优化器，能够自动更新权重参数
optimizer = torch.optim.Adam(my_nn.parameters(), lr = 0.001)
```



训练网络

```python
# 训练网络
losses = []
for i in range(1000):
    batch_loss = []
    # 使用MINI-Batch方法来进行训练
    for start in range(0, len(input_features), batch_size):
        # 获取训练数据长度
        end = start + batch_size if start + batch_size < len(input_features) else len(input_features)
        # 获取训练数据
        xx = torch.tensor(input_features[start:end], dtype = torch.float, requires_grad = True)
        # 获取样本
        yy = torch.tensor(labels[start:end], dtype = torch.float, requires_grad = True)
        # 预测值
        prediction = my_nn(xx)
        # 损失函数
        loss = cost(prediction, yy)
        # 对梯度进行清零
        optimizer.zero_grad()
        # 进行反向传播
        loss.backward(retain_graph=True)
        # 进行更新操作
        optimizer.step()
        # 记录损失值
        batch_loss.append(loss.data.numpy())
    # 打印损失
    if i % 100 == 0:
        losses.append(np.mean(batch_loss))
        print(i, np.mean(batch_loss))
```



损失值

```
0 3950.8616
100 38.00995
200 35.664764
300 35.30284
400 35.138676
500 35.001663
600 34.880367
700 34.762344
800 34.642002
900 34.51666
```



预测训练结果

```python
# 将x转换成tensor格式
x = torch.tensor(input_features, dtype = torch.float)
# 预测训练结果
predict = my_nn(x).data.numpy()
```



```python
# 转换日期格式
dates = [str(int(year)) + "-" + str(int(month)) + "-" + str(int(day)) for year, month, day in zip(years, months, days)]
dates = [datetime.datetime.strptime(date, "%Y-%m-%d") for date in dates]
# 创建一个表格来存日期和其对应的标签数值
true_data = pd.DataFrame(data = {"date":dates, "actual" : labels})
# 同理，在创建一个来存日期和其对应的模型的预测值
months = features[:, features_list.index("month")]
days = features[:, features_list.index("day")]
years = features[:, features_list.index("year")]

test_dates = [str(int(year)) + "-" + str(int(month)) + "-" + str(int(day)) for year, month, day in zip(years, months, days)]
test_dates = [datetime.datetime.strptime(date, "%Y-%m-%d") for date in test_dates]

predictions_data = pd.DataFrame(data = {"date":test_dates, "prediction":predict.reshape(-1)})
```



开始画图

```python
# 真实值
plt.plot(true_data["date"], true_data["actual"], "b-", label = "actual")

# 预测值
plt.plot(predictions_data["date"], predictions_data["prediction"], 'ro', label="prediction")

plt.xticks(rotation = '60')
plt.legend()

# 图名
plt.xlabel("Date"); plt.ylabel("Maximum Temperature(F)"); plt.title("Actual and Predicted Values");
```

![image-20220712162046025](https://s2.loli.net/2022/11/04/8HGmJqvZpyn5gMd.png)
