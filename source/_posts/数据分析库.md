---
title: 数据分析库（pandas，numpy，matplotlib）
date: 2022-06-05 10:12:43
tags: 人工智能
cover: "https://s2.loli.net/2022/11/21/rWoSUxItliEPYHk.webp"
description: 数据分析库的使用
categories: 人工智能
---

# matplotlib的使用

特点

1. 能够将数据进行可视化，更直观的呈现
2. 使数据更加直观，根据有说服力

导入方式：

```python
from matplotlib import pyplot as plt 

# 产生数据
x = range(2,26,2)
y = [15,13,14.5,17,20,25,26,26,24,22,18,15]

# 开始作图
plt.plot(x, y)
plt.scatter(x, y)
# 展示图
plt.show()
```

可以实现的方法：

1. 设置图片大小（高清无码大图）

   ```python
   fig = plt.figure(figsize=(20,8), dpi = 80)
   # figure 是图形的意思，在这里指的是我们画的图
   # 通过实例化一个figure并且传递参数，就能够在后台自动使用该figure实例
   # 在图像模糊的时候可以传入dpi参数，让图片更清晰
   ```

   

2. 保存到本地

   ```python
   plt.plot()
   # 开始保存，一定要在图像画完之后在保存
   plt.savefig("图片想要保存的路径")
   ```

   

3. 描述信息，x轴y轴，这个图的信息

   ```python
   plt.xlabel("x轴英文名称")
   plt.ylabel("y轴英文名称")
   plt.title("英文标题")
   ```

   

4. 调整x或者y的刻度间距

   ```python
   from matplotlib import pyplot as plt 
   
   # 产生数据
   x = range(2,26,2)
   y = [15,13,14.5,17,20,25,26,26,24,22,18,15]
   
   # 开始作图
   plt.plot(x, y)
   
   # 这样x轴的间距就是2 - 24每间隔 1 出一个点
   plt.xticks(range(2,25))
   
   # 使用下面这种方法步长为0.5
   _x_lables = [i/2 for i in range(4,49)]
   plt.xticks(_x_lables)
   plt.yticks(range(min(y), max(y)+1)) # y轴刻度
   
   plt.show()
   
   ## 调整x或者y轴上的刻度：
   plt.xticks(x[::5],_x_ticks[::5], rotation=90)
   # 让列表中的数据和_x_ticks上面的数据都传入，最终会在x轴上一一对应的显示出来
   # 两组数据长度必须一样，否则不能够完全覆盖整个轴
   # 使用列表的切片，每隔5个选择一个数据进行展示
   # 为了让字符串不会被覆盖，使用rotation选项，让字符串旋转90°显示
   ```

   

5. 线条的样式（比如颜色透明度）

   ```python
   plt.plot(
   	x,
       y,
       # 在绘图的时候指定即可
       color = "颜色英文", # 线条颜色， 可以缩写，也可以直接写全称
       linestyle = '--',  # 线条风格
       linewidth = 5, # 线条粗细
       alpha = 0.5 # 线条透明度
      
   )
   ```

   |      颜色字符       |       风格字符       |
   | :-----------------: | :------------------: |
   |      r    红色      |      -    实线       |
   |      g    绿色      |       -- 虚线        |
   |      b    蓝色      |     -.    点划线     |
   |      w    白色      |       ：点虚线       |
   |        cyan         | ''留空或空格，无线条 |
   |      c    青色      |                      |
   |      m    洋红      |                      |
   |      y    黄色      |                      |
   |      k    黑色      |                      |
   |                     |                      |
   |   #00ff00 16进制    |                      |
   | 0.8    灰度值字符串 |                      |

   

6. 标记处特殊的点（比如告诉别人最高点最低点在哪里）

7. 给图片加上一个水印（防止盗用）

8. 绘制网格，方便更好的观看

   ```python
   # 函数表达
   plt.grid()
   # grid默认情况下横轴和纵轴的线段条数依据x轴和y轴的刻度
   
   # 绘制网格的透明度
   plt.grid(alpha = 0.4)
   ```

9. 添加图例

   ```python
   # 当我们在一个图上话两条线段的时候这时候我们需要添加图例来进行区分
   plt.plot(x, y1, label="Myself")
   plt.plot(x, y2,label = "Youself")  # 画两条线段， 并添加label进行区分
   plt.legend() # 显示图例
   
   # 图例的位置我们也可以自己手动调整一下
   plt.legend(loc = "upper left")# loc里面的参数不需要我们自己记住，只要去那个函数中寻找即可
   ```

   ![image-20220210104200024](https://s3.bmp.ovh/imgs/2022/11/04/35953f9b1c586db3.png)

10. 画图：

    ```python
    # 画条形图
    plt.bar("x轴","y轴",width = "")
    # 画横着的条形图
    plt.barh("x轴","y轴",height = "")
    ```

    直方图：

    ```python
    # 绘制直方图的前提
    # 原始数据，没有进行统计过的数据才是能够话直方图的
    # density = True 这个参数是进行显示比率的
    plt.hist("原始数据","要分成的组数")
    
    # 自己设置宽度
    bin_width = n
    
    # 至于具体分成多少组的话，我们可以让原始数据中的最大值减去最小值，除以自己设置的宽度
    num_bins = int((max(time)-min(time))/bin_width)
    
    plt.hist(time, num_bins,color="cyan",density=True)
    
    
    # 设置x标签
    plt.xticks(range(min(time),max(time)+bin_width, bin_width)[::bin_width]
    
    ```

# numpy的使用

一个在Python中做科学计算的基础库，重在数值计算，也是大部分PYTHON科学计算库的基础库，多用于在大型多维数组上面执行数值运算

## 数组的形状

1. 创建数组

   ```python
   import numpy as np
   
   # 使用numpy生成数组，得到ndarray的类型
   
   a = np.array([1,2,3,4,5])
   b = np.array(range(1,6))
   c = np.arange(1,6)
   # 上面的a,b,c内容相同，注意arange和range的区别
   np.arange的用法：arange([start], [stop], dtype=None)
   ```

2. 查看数据类型：

   ```python
   a.dtype # 使用这种方法可以查看数据类型
   
   # 也可以指定数据类型：
   a = np.array(range(1,10), dtype="int64") # 还有int32， int8, int16, float, bool
   
   # 调整数据类型：
   b = a.astype("数据类型名称")
   ```

3. 保留小数：

   ```python
   import random
   t6 = np.array([random.random() for i in range(10)])
   print(t6, t6.dtype)
   
   # 结果为：
   #[0.83883059 0.53226869 0.88972366 0.14007629 0.01660871 0.93454237,0.6718681  0.34420642 0.61125849 0.63995072]
   t7 = np.round(t6, 2)
   print(t7)
   
   #结果为：0.84 0.53 0.89 0.14 0.02 0.93 0.67 0.34 0.61 0.64
   
       
   ```

4. 查看数据是几维的

   ```python
   t1 = np.array(range(10))
   print(t1)
   # [0 1 2 3 4 5 6 7 8 9]
   print(t1.shape)
   # (10,)  这就是一维数组，有一个数，这一个数表示有几列
   t2 = np.array([[1,2,3],[4,5,6]])
   print(t2)
   # [[1 2 3]
   #  [4 5 6]]
   print(t2.shape)
   # (2, 3)  # 这就是二维数组，有两个数，这个表示有两行三列 
   
   t3 = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])
   print(t3)
   '''
   [[[ 1  2  3]
     [ 4  5  6]]
   
    [[ 7  8  9]
     [10 11 12]]]
   '''
   
   print(t3.shape)
   # (2, 2, 3) # 这里面有三个数，表示三维的， 第一个表示有两个面，第二个表示面有两行，第三个数表示有3列
   
   
   # 使用reshape方法调整数据的维数，前提是数据数量必须相等
   t1 = np.array(range(10))
   t1.reshape((2,5))  # 2*5 = 10
   
   t2.flatten() # 将数组按照一维的方式展开
   ```

## 数组的计算(广播原则)

	一个操作能够进行到下面每一个数据

1. 数组和数字进行计算

   ```python
   a = np.array(range(12))
   b = a + 2
   # 这样表示 a中所有元素都加2， 同理还有 * - / 如果除以零的话会出现提醒，返回值就不再是一个数组了
   ```

2. 数组和数组进行相加：

   ```python
   t5 = np.array(range(0,24)).reshape(4,6)
   t6 = np.array(range(100,124)).reshape(4,6)
   t7 = t5 + t6
   print(t7)
   # 对应位数依次相加
   '''
   [[100 102 104 106 108 110]
    [112 114 116 118 120 122]
    [124 126 128 130 132 134]
    [136 138 140 142 144 146]]
   '''
   # 同理还可以进行乘法除法减法
   
   # 上面是维数相同的时候运算规则
   
   # 下面是维数不相同的时候运算规则
   # 对应的维数相同的行或列进行运算
   # 如果行列都不相同的话，会报错
   t5 = np.array(range(0,24)).reshape(4,6)
   t6 = np.array(range(6))
   t5 - t6 
   '''
   [ 0,  0,  0,  0,  0,  0],
   [ 6,  6,  6,  6,  6,  6],       
   [12, 12, 12, 12, 12, 12],
   [18, 18, 18, 18, 18, 18]]
   '''
   
   t7 = np.array(range(4)).resheape(4,1)
   t7
   '''
   [[0]
    [1]
    [2]
    [3]]
   '''
   t5-t7
   '''
   [[ 0  1  2  3  4  5]
    [ 5  6  7  8  9 10]
    [10 11 12 13 14 15]
    [15 16 17 18 19 20]]
   '''
   
   ```

3. 广播原则：

   如果两个数组的后缘维度(trailing dimension，即从末尾开始算起的维度)的轴长度相符或其中一方的长度为1，则认为它们是广播兼容的。广播会在缺失和（或)长度为1的维度上进行。
   例如：shape为(3,3,3) 和shape为(3,2)的数组可进行运算

   shape为(3,3,2) 和shape为(3,2)的数组可进行运算

## 轴

在numpy中可以理解为方向，使用0，1，2。。数字表示，对于一个一维数组，只有一个0轴，对于二维数组（shape(2,2)）,有0轴和1轴，对于三维数组（shape(2,2,3)）有0，1，2轴

<img src="https://s3.bmp.ovh/imgs/2022/11/04/e2e832c9090bf3d7.png" style="zoom:50%;" />

![image-20220211141001403](https://s3.bmp.ovh/imgs/2022/11/04/ef269650e4d73831.png)

## 索引和切片(a[行起始：行结束，列起始：列结束])

对于刚刚加载出来的数据，我如果指向选择其中的某一列我么应该怎么做？

操作和列表的操作一样

```python
a = np.array(range(12)).reshape((3,4))
print(a)
'''
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
'''

print(f"取一行：{a[0]}")
print(f"取一列：{a[:,1]}")
print(f"取多行：{a[1:2]}")
print(f"取多列：\n{a[:,1:3]}")
'''
取一行：[0 1 2 3]
取一列：[1 5 9]
取多行：[[4 5 6 7]]
取多列：
[[ 1  2]
 [ 5  6]
 [ 9 10]]
'''

# 取不连续的多行：
a[[2,4,6]] === 取到第二行第四行第六行

# 取连续的多列：
a[:,2:] # 从第二列开始全要

#取不连续的多列：
a[:,[0,2]]  === 取第一列和第三列

# 取特定的行列：
a[2,3] # 第三行第四列

# 取多行多列：
a[2:5, 1:4] === 取第三行到底物行，第二列到第四列
```

### 数值修改：

在取到某个数值之后，再给他赋予相同格式的数据就行

```python
# 替换的数据必须和原数据格式相同

a = np.array(range(24)).reshape(4,6)
print(a)
'''
[[ 0  1  2  3  4  5]
 [ 5  6  7  8  9 10]
 [10 11 12 13 14 15]
 [15 16 17 18 19 20]]
'''
print(a[:,2:4])
a[:,2:4] = np.array(range(10,18)).reshape(4,2)
print(a)
'''
[[ 0  1 10 11  4  5]
 [ 6  7 12 13 10 11]
 [12 13 14 15 16 17]
 [18 19 16 17 22 23]]
 '''
```

修改数组中所有小于10的数，修改为1：

```python
print(a<10)
'''
[[ True  True  True  True  True  True]
 [ True  True  True  True False False]
 [False False False False False False]
 [False False False False False False]]
'''
# 赋值规律，把是true的地方的值赋予
a[a<10] = 1
print(a)
'''
[[ 1  1  1  1  1  1]
 [ 1  1  1  1 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
'''
```

numpy中的三元运算符 where

```python
b = np.where(a<=10, 100, 300)
print(b)
print(a)
'''
[[100 100 100 100 100 100]
 [100 100 100 100 100 300]
 [300 300 300 300 300 300]
 [300 300 300 300 300 300]]
[[ 1  1  1  1  1  1]
 [ 1  1  1  1 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
'''
```

clip(裁剪)

```python
a.clip(10,18) ====》 把小于10的替换成10， 大于18的替换成18
'''
[[ 1  1  1  1  1  1]
 [ 1  1  1  1 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
[[10 10 10 10 10 10]
 [10 10 10 10 10 11]
 [12 13 14 15 16 17]
 [18 18 18 18 18 18]]
'''
```

numpy中的nan和inf含义：

出现nan的情况：

1. 读取本地文件为float的时候，如果有缺失，就会出现nan

2. 当做了一个不合适的计算的时候（比如无穷大(inf)减去无穷大）

3. nan和任何值进行计算结果都是nan

   所以我们需要在计算的时候将nan替换掉

   - 不能够全部替换成0这样会影响最后结果，

     - 例如计算[1，2，3，nan]这一行的均值
       - 如果把nan替换成0的话那么 均值为 (1 +2 +3 +0 )/4 会影响最后结果

   - 我们能够把nan替换成均值(中指)，或直接删除所有缺失值的一行

   - |  含义  |          公式           |
     | :----: | :---------------------: |
     |  求和  |    t.sum(axis=None)     |
     |  均值  |  t.mean(a, axis=None)   |
     |  中值  | np.median(t, axis=None) |
     | 最大值 |    t.max(axis=None)     |
     | 最小值 |    t.min(axis=None)     |
     |  极值  |    np.ptp(axis=None)    |
     | 标准差 |    t.std(axis=None)     |

     

     

inf 表示无穷， +inf表示正无穷，-inf表示负无穷

统计非零个数：

	np.count_nonzero(a)

统计nan个数：

	np.isnan(a)

进行加法运算

	np.sun(a, axis = 0,1,2) 
	
	如果没有axis的话则最后结果就是 所有数字的和
	
	如果有axis的话:
	
		0 表示 最后结果的个数为行的个数，就是让每一列相加
	
		1 表示最后结果是列的个数，就是让每行相加

## 数组的拼接

![image-20220212104934176](https://s3.bmp.ovh/imgs/2022/11/04/94ae779b80e0473d.png)



## 数组的交换

![image-20220212105216821](https://s3.bmp.ovh/imgs/2022/11/04/9184e33982c50f88.png)

# pandas

pandas相比于numpy它能够帮助我们处理数值以外的数据

1. pandas的常用的数据类型：

   - Series一维的，带标签的数组

     ```python
     pd.Series(np.array(range(0,10,2)))
     '''
     0    0
     1    2
     2    4
     3    6
     4    8
     第一列是标签，第二列是数据
     '''
     # 我们还可以指定标签：
     pd.Series(np.array(range(0,10,2)), index=[range(10,20,2)])
     '''
     10    0
     12    2
     14    4
     16    6
     18    8
     标签可以自己指定
     '''
     ```

     

   - DataFrame二维，Series容器 

     ```python
     pd.DataFrame(np.arange(12).reshape((3,4)))
     '''
     	0	1	2	3
     0	0	1	2	3
     1	4	5	6	7
     2	8	9	10	11
     '''
     
     # 我们还可以指定标签：
     pd.DataFrame(np.arange(12).reshape((3,4)), index=list("abc"),columns=list("WXYZ"))
     
     '''
     
     	W	X	Y	Z
     a	0	1	2	3
     b	4	5	6	7
     c	8	9	10	11
     '''
     ```


   ## pandas常用操作：

   **DataFrame的基础属性**

   df.shape #行数列数
   df.dtypes #列数据类型

   df. ndim#数据维度
   df.index #行索引

   df.columns #列索引
   df.values #对象值，二维ndarray数组

   **DataFrame整体情况查询**
   df.head(3)#显示头部几行，默认5行

   df.tail(3)#显示末尾几行，默认5行
   df.info() # 相关信息概览︰行数，列数，列索引，列非空值个数，列类型，列类型，内存占用

   df.describe()#快速综合统计结果︰计数，均值，标准差，最大值，四分位数，最小值

   ```python
   # 查看a
   '''
   
   	W	X	Y	Z
   a	0	1	2	3
   b	4	5	6	7
   c	8	9	10	11
   '''
   
   # 查看列索引
   a.index
   # Index(['a', 'b', 'c'], dtype='object')
   
   
   # 查看行索引
   a.colums
   # array(['W', 'X', 'Y', 'Z'], dtype=object)
   
   
   # 查看值
   a.values
   '''
   array([[ 0,  1,  2,  3],
          [ 4,  5,  6,  7],
          [ 8,  9, 10, 11]])
   '''
   
   # 查看形状
   a.shape
   # (3, 4)
   
   # 查看维度
   a.ndim
   # 2
   
   #
   
   ```

   DateFrame 中的排序方法

   1. date.sort_values(by="需要排序的行索引名称", ascending=False) 

      ascending值为True的时候 结果是升序，false的时候是降序

   DateFrame 中获取某一行或者列的方法：

   1. date[5:20]==== 表示获取数据中的第五行到第20行

   2. date["Title"]  表示获取数据中 的列的表头为Title的列

   3. pandas之loc操作：

      date.loc 通过标签索引行数据

      date.iloc	通过位置索引进行获取行数据

      ```python
      date.loc[3:5,"Year"] # 表示获取Year这一列，3-5这些行
      date.loc([[3,5]]) # 表示获取第三行和第五行的数据
      # 多列同理
      
      # iloc 方式获取
      date.iloc[3:5, 2:]
      '''
      
      	Year
      3	2016
      4	2016
      '''
      ```

   4. pandas 中的&(且) 和 |(或)

      ```python
      date[(date["Rating"]>8) & (date["Rating"] < 10)]
      # 这句话的含义就是 获取评分大于8，并且小于10的数据
      ```

   5. pandas中缺失数据的处理

      1. 可以先使用pd.isnull("数据") 来判断那个数据是缺失的， 缺失的显示为True，没有缺失的显示false

      2. 也可以使用pd.notnull(“数据”)来判断那个数据是没有缺失的，没有缺失的显示为Ture，缺失的显示为false

      3. 使用date.dropna(axis=0) 来删除含有nan的哪一整行

         如果我们不想要删除含有nan的行，我们只想要删除全部是nan的哪一行，这时候我们可以使用how这个参数来进行指定，how =""，默认情况下是any，只要有nan就删除，我们可以给他指定一个参数all，含义就是都为nan的时候才删除这一行

         date.drpna(axis=0, how="all") , 这样就是删除全部是nan的哪一行

         还有一个inplace 参数，默认情况下是False，含义就是返回一个修改后的变量，不会再元数据上面进行修改，如果我们设置成了True的话，那么就是在元素据上面进行修改

      4. 填充数据

         date.fillna(数据)， 我们一般填 date.mean(), 这个也是不会修改原本数据的，

         也可以对某一行进行修改 date["age"] = date["age"].fillna(date["age"].mean())

   6. 数据合并：

      join默认情况下是吧索引相同的数据合并到一起，合并后的形状为依据调用join方法的变量的形状

      ```python
      t1 = pd.DataFrame(np.zeros((3,3)), index=["A","B", "C"], columns=list("abc"))
      t1
      
      '''
      
      	a	b	c
      A	0.0	0.0	0.0
      B	0.0	0.0	0.0
      C	0.0	0.0	0.0
      '''
      
      t2 = pd.DataFrame(np.ones((2,4)), index=["A", "B"], columns=list("defg"))
      t2
      
      '''
      
      	d	e	f	g
      A	1.0	1.0	1.0	1.0
      B	1.0	1.0	1.0	1.0
      '''
      
      t1.join(t2)
      
      '''
      
      	a	b	c	d	e	f	g
      A	0.0	0.0	0.0	1.0	1.0	1.0	1.0
      B	0.0	0.0	0.0	1.0	1.0	1.0	1.0
      C	0.0	0.0	0.0	NaN	NaN	NaN	NaN
      '''
      
      t2.join(t1)
      '''
      
      	d	e	f	g	a	b	c
      A	1.0	1.0	1.0	1.0	0.0	0.0	0.0
      B	1.0	1.0	1.0	1.0	0.0	0.0	0.0
      
      '''
      ```

      merge合并

      ```python
      t3 = pd.DataFrame(np.arange(9).reshape((3,3)), columns=list("abc"))
      t3
      '''
      
      	a	b	c
      0	0	1	2
      1	3	4	5
      2	6	7	8
      '''
      
      t4 = pd.DataFrame(np.zeros((3,3)), columns=list("aef"))
      t4.loc[[0,1,2],'a']=[1,2,3]
      t4
      '''
      
      	a	e	f
      0	1.0	0.0	0.0
      1	2.0	0.0	0.0
      2	3.0	0.0	0.0
      '''
      # 右依据， 主体是右边的形式，通过右边的第一列是的数据，和左边的第一列数据对比，找出相同的，如果没有找到，则使用nan代替
      t3.merge(t4,how="right")
      '''
      
      	a	b	c	e	f
      0	1.0	NaN	NaN	0.0	0.0
      1	2.0	NaN	NaN	0.0	0.0
      2	3.0	4.0	5.0	0.0	0.0
      '''
      
      # 同理 依照左边为基准 让右边第一列和左边第一列依次比较
      t3.merge(t4,how="left")
      '''
      
      	a	b	c	e	f
      0	0	1	2	NaN	NaN
      1	3	4	5	0.0	0.0
      2	6	7	8	NaN	NaN
      t4.loc[0,"a"] = 1
      '''
      
      t3.merge(t4,how="outer")
      '''
      	a	b	c	e	f
      0	0.0	1.0	2.0	NaN	NaN
      1	3.0	4.0	5.0	0.0	0.0
      2	6.0	7.0	8.0	NaN	NaN
      3	1.0	NaN	NaN	0.0	0.0
      4	2.0	NaN	NaN	0.0	0.0
      把t4加到t3后面 相同的放在前面，不同的放在后面
      '''
      
      t3.merge(t4,how="inner")
      '''
      	a	b	c	e	f
      0	3	4	5   0.0	0.0
      把相同的行合在一起
      '''
      
      
      # 只是在a这一列上比较，相同的出现，不相同的舍去
      t3.merge(t4, on="a")
      '''
      
      	a	b	c	e	f
      0	3	4	5	0.0	0.0
      '''
      ```

      

      
