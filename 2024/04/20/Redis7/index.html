<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Redis7 | Nuyoah</title><meta name="author" content="Nuyoah"><meta name="copyright" content="Nuyoah"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Redis7"><meta name="application-name" content="Redis7"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Redis7"><meta property="og:url" content="http://262259.xyz/2024/04/20/Redis7/index.html"><meta property="og:site_name" content="Nuyoah"><meta property="og:description" content="Redis7入门概述 作者：antirez Github 博客 Remote Dictionary Server(远程字典服务)是完全开源的，使用ANSIC语言编写遵守BSD协议，是一个高性能的Key-Value数据库提供了丰富的数据结构，例如String、Hash、List、Set、Sorted"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://s2.loli.net/2022/11/19/vJMKhVAUYNXRQuE.jpg?_r_=2c77c62d-27f5-863c-fa81-c49d5475ad7e"><meta property="article:author" content="Nuyoah"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2022/11/19/vJMKhVAUYNXRQuE.jpg?_r_=2c77c62d-27f5-863c-fa81-c49d5475ad7e"><meta name="description" content="Redis7入门概述 作者：antirez Github 博客 Remote Dictionary Server(远程字典服务)是完全开源的，使用ANSIC语言编写遵守BSD协议，是一个高性能的Key-Value数据库提供了丰富的数据结构，例如String、Hash、List、Set、Sorted"><link rel="shortcut icon" href="https://s1.ax1x.com/2022/11/27/zUFla6.png"><link rel="canonical" href="http://262259.xyz/2024/04/20/Redis7/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"404！加载失败！","backTitle":"加载成功！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.262259.xyz/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":"a665f8c80fd739329dd0d3f3fe7d90fc"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Nuyoah","link":"链接: ","source":"来源: Nuyoah","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: {"enable":true,"delay":100,"shiftDelay":200},
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Nuyoah',
  title: 'Redis7',
  postAI: '',
  pageFillDescription: ' Redis7入门概述,  优势,  下载,  安装,  启动服务,  删除Redis,  Redis的10大数据类型,  类型：,  redis字符串—String,  redis列表—List,  redis哈希表—Hash,  redis集合—Set,  redis有序集合—ZSet,  redis地理空间—GEO,  redis基数统计—HyperLogLog,  redis位图—bitmap,  redis位域—bitfield,  redis流—Stream,  redis常用命令,  数据类型命令及落地运用,  String,  List,  Hash,  Set,  ZSET,  BitMap位图,  HyperLogLog基数统计,  地理空间GEO,  Redis流（Stream）,  Redis持久化,  RDB数据库,  概念,  作用：,  保存频率,  自动触发,  手动触发,  恢复文件,  优点,  缺点,  检查和修复RDB文件,  禁用快照RDB,  Redis优化配置项详解,  AOF持久化,  功能配置,  恢复操作,  正常恢复,  异常恢复,  优点,  缺点,  AOF重写机制,  触发机制,  重写原理,  配置命令,  总结,  RDB-AOF混合持久化,  数据恢复顺序和加载流程,  如何选择,  纯缓存模式,  Redis事务,  Redis命令,  正常执行,  放弃事务,  全部终止,  终止错误,  WATCH监控,  放弃监控,  总结,  Redis管道,  概念,  执行方式,  总结,  pipeline与原生批量命令对比,  pipeline与事务对比,  pipline注意事项,  Redis订阅,  常用命令,  SUBSCRIBE,  PUBLISH,  PSUBSCRIBE,  PUBSUB,  UNSUBSCRIBE,  PUNSUBSCRIBE,  总结,  Redis复制,  作用,  配置,  常用命令,  修改配置文件,  主从命令,  问题—主从写入配置文件,  问题—命令操作手动指定,  薪火相传,  反客为主,  原理及工作流程,  缺点,  Redis哨兵,  作用,  功能,  使用方法,  创建哨兵服务,  文件配置,  启动redis 一主二从,  启动哨兵,  模拟挂机,  切换结果,  运行流程,  使用建议,  Redis集群,  定义,  作用,  集群算法,  槽位,  分片,  优势,  槽位映射,  哈希取余分区,  一致性HASH算法,  哈希槽分区,  集群环境的搭建,  三主三从redis集群配置,  通过redis-cli命令为6台机器构建集群关系,  3主3从redis集群读写,  主从容错切换,  节点从属调整,  主从扩容,  主从缩容,  总结,  常用命令,  SpringBoot整合Redis,  Jedis,  Lettuce,  RedisTemplate !!!,  引依赖,  yml配置文件,  定义配置类,  测试,  序列化,  集群入门概述作者博客远程字典服务是完全开源的使用语言编写遵守协议是一个高性能的数据库提供了丰富的数据结构例如等等数据是存在内存中的同时支持事务持久化脚本发布订阅缓存淘汰流技术等多种功能特性提供了主从模式和集群架构方案是一种缓存技术分布式缓存挡在数据库之前的带刀护卫内存存储和持久化支持异步将内存中的数据写到硬盘上同时不影响继续服务高可用架构搭配缓存穿透击穿雪崩分布式锁队列排行版点赞数据库遵循写读原则为了让这两个保持平衡我们使用缓存将读进行降低与传统数据库关系是数据库一种是关系数据库数据操作主要在内存而主要存储在磁盘在某一些场景使用中要明显优于比如计数器排行榜等方面通常用于一些特定场景需要与一起配合使用两者并不是相互替换和竞争关系而是共用和配合使用优势性能极高能读的速度是次秒写的速度是次秒数据类型丰富不仅仅支持简单的类型的数据同时还提供等数据结构的存储支持数据的持久化可以将内存中的数据保持在磁盘中重启的时候可以再次加载进行使用支持数据的备份即模式的数据备份下载官网文档资料源码地址在线测试命令参考版本号第二位如果是奇数则为非稳定版本如版本号第二位如果是偶数则为稳定版本如当前奇数版本就是下一个稳定版本的开发版本如版本是版本的开发版本安装下载获得后将它放入我们的目录文件夹寻找方法打开终端返回上一层目录返回上一层目录就能看到目录下解压进入文件夹在中执行可能需要下载按照终端提示就行默认安装目录在同级文件夹下的性能测试工具服务启动后运行该命令看看自己本子性能如何修复有问题的文件和后面讲修复有问题的文件客户端操作入口集群使用服务器启动命令将默认的拷贝到自己定义好的一个路径下比如修改目录下配置文件做初始化设置配置文件改完后确保生效记得重启记得重启使用修改打开操作需要打开的文件夹查找操作查找的字符串查到之后按回车然后通过查找下一个查找上一个插入操作修改完毕之后使用退出退出操作默认改为默认改为默认改为直接注释掉默认只能本机访问或改成本机地址否则影响远程连接添加密码改为你自己设置的密码启动服务使用中修改完的配置文件启动连接服务启动服务端密码端口连接服务设置键值对删除停止所有服务查看服务关闭服务查看是否关闭删除目录下与相关的所有文件查看对应目录下所有开头的文件删除对应目录先所有开头的文件的大数据类型官网查阅类型字符串是最基本的类型一个对应一个类型是二进制安全的意思是的可以包含任何数据比如图片或者序列化的对象类型是最基本的数据类型一个中字符串最多可以是列表列表是简单的字符串列表按照插入顺序排序你可以添加一个元素到列表的头部左边或者尾部右边它的底层实际是个双端链表最多可以包含个元素每个列表超过亿个元素哈希表是一个类型的字段和值的映射表特别适合用于存储对象中每个可以存储键值对多亿集合的是类型的无序集合集合成员是唯一的这就意味着集合中不能出现重复的数据集合对象的编码可以是或者中集合是通过哈希表实现的所以添加删除查找的复杂度都是集合中最大的成员数为每个集合可存储多亿个成员有序集合和一样也是类型元素的集合且不允许重复的成员不同的是每个元素都会关联一个类型的分数正是通过分数来为集合中的成员进行从小到大的排序的成员是唯一的但分数却可以重复集合是通过哈希表实现的所以添加删除查找的复杂度都是集合中最大的成员数为地理空间主要用于存储地理位置信息并对存储的信息进行操作包括添加地理位置的坐标获取地理位置的坐标计算两个位置之间的距离根据用户给定的经纬度坐标来获取指定范围内的地理位置集合基数统计是用来做基数统计的算法的优点是在输入元素的数量或者体积非常非常大时计算基数所需的空间总是固定且是很小的在里面每个键只需要花费内存就可以计算接近个不同元素的基数这和计算基数时元素越多耗费内存就越多的集合形成鲜明对比但是因为只会根据输入元素来计算基数而不会储存输入元素本身所以不能像集合那样返回输入的各个元素位图由和状态表现的二进制位的数组位域通过命令可以一次性操作多个比特位域指的是连续的多个比特位它会执行一系列操作并返回一个响应数组这个数组中的元素对应参数列表中的相应操作的执行结果说白了就是通过命令我们可以一次性对多个比特位域进行操作流主要用于消息队列本身是有一个发布订阅来实现消息队列的功能但它有个缺点就是消息无法持久化如果出现网络断开宕机等消息就会被丢弃简单来说发布订阅可以分发消息但无法记录历史消息而提供了消息的持久化和主备复制功能可以让任何客户端访问任何时刻的数据并且能记住每一个客户端的访问位置还能保证消息不丢失常用命令命令描述查看当前库中的所有判断某个是否存在查看你的是什么类型删除指定的数据非阻塞删除仅仅将充元数据中删除真正的删除会在后续异步中操作查看还有多少秒过期表示永不过期表示已过期单位秒为指定的设置过期时间将当前数据库的移动到给定的数据库中切换数据库默认为查看当前数据库的数量清空当前数据库通杀全部库数据类型命令及落地运用命令不区分大小写区分大小写类型命令有以及五个可选参数其中为版本添加的可选参数其它为版本添加的可选参数以秒为单位设置过期时间以毫秒为单位设置过期时间设置以秒为单位的时间戳所对应的时间为过期时间设置以毫秒为单位的时间戳所对应的时间为过期时间键不存在的时候设置键值键存在的时候设置键值保留设置前指定键的生存时间返回指定键原本的值若键不存在时返回命令使用参数其效果等同于命令根据官方文档的描述未来版本中命令可能会被淘汰以及为新增的可选参数返回值设置成功则返回返回为未执行命令如不满足条件等若使用参数则返回该键原来的值或在键不存在时返回在没有存在的时候能够设置成功当存在的时候无法设置成功在已存在的时候设置成功不存在的时候无法设置成功在给设置的时候先返回的值然后再将的值存入中在设置设置的时候设置过期时间为秒在设置设置的时候设置过期时间为毫秒以时间戳为过期时间设置的时候继承上一次的设置时间同时设置获取多个键值同时设置多个键值对通过获取多个值设置多个值必须存在才能设置成功获取指定区间范围的值获取指定字符串的特定位置的字符获取所有字符串获取索引在之间的所有字符设置指定字符串特定位置的字符串将索引为的字符替换为数值增减递增数字默认是一次递增三递减数字默认是一次递减三获取字符串长度和内容增加获取中的字符串长度向中的字符串后面添加分布式锁当有多个微服务同时争抢一个资源的时候可以使用来进行分布式锁命令过期时间创建键值对的时候设置过期时间如果不存在才进行创建命令先将的值取出来然后在给它赋值新值本质是双端列表左边右边都可操作有序插入从左边插入从右边插入遍历从左边遍历第一个参数是第二第三个参数是开始和结束的索引删除从左边弹出从右边弹出取元素按照索引取元素从上到下获取长度获取列表中元素的个数删除指定元素数字给定值删除个值为的元素如果中值的个数小于则全部删除截取截取中位置从到位置的元素提取中的元素给源列表目的列表将源列表右边第一个元素提到目的列表左边第一个元素替换指定位置的元素将中从左边开始算起位置的元素替换成插入指定位置已有值插入新值在列表中值为已有值的前面插入新值不变是一个键值对设置元素是键是键同时设置多个值存在则不添加不存在则添加获取元素获取中键为的值通过获取多个值将中的所有键值对遍历出来删除元素将中键为的删掉获取某个中的所有键值对的数量判断中是否存在键为的键值对获取某个中的全部或者全部获取全部的键获取全部的值增加整数或小数增加的表中的值为的值加一单值多不重复无序添加元素遍历元素将中的元素全部遍历出来查询数据元素是否存在判断是否在里面删除元素将中值为的元素删除通过集合里面有多少个元素随机获取集合中的元素不会改变源集合随机展示中数量为的元素随机获取集合中的元素会改变源集合随机展示中数量为的元素数据迁移将中的数据迁移到中将中的迁移到中集合运算差集获取在中但不在中的元素并集获取和的并集交集获取即余数也属于的有序集合在的基础上每一个值前加一个分数值之前是现在是添加元素再添加元素的时候需要给元素设置上分数获取元素从小到大获取元素的值从小到大获取元素的值和分数从大到小获取元素的值从小到大获取元素的值和分数根据分数来获取元素可以使用来限制显示的个数根据分数来获取元素和分数默认是分数如果加上小括号则表示不包含断点分数获取元素分数获取集合中元素的个数删除集合中的元素增加对应的分数给值为的元素添加分获取指定分数段的元素的个数从对象中第一个非空排序集中弹出一个或多个元素他们是成员分数对从中弹出最小的元素弹出个获取对应元素下标获取在中的下标值顺序获取在中的下标值逆序位图用于状态判断设置状态给的位置设置为或获取状态获取位置的数据获取的字节数获取的字节数八位一组获取键里面的个数全部键里面含有的个数对不同的二进制存储数据进行位运算运算符包括基数统计去重统计功能的基数估计算法不能存储数据之鞥呢发挥去重之后的基数个数基数统计统计一个集合中不重复的元素个数就是对集合去重复后剩余元素的计算添加元素返回给定的的基数估算值将多个合并为一个地理空间添加地理位置精度维度地点如果有乱码需要执行命令来处理中文乱码返回对应地理位置地点地点返回坐标用表示返回坐标用表示返回两个位置之间的距离地点地点以半径为中心返回查找附近的地点经度维度在返回位置元素的同时将位置元素与中心之间的距离也一并返回距离的单位和用户给定的范围单位保持一致将位置元素的经度和维度也一并返回以位有符号整数的形式返回位置元素经过原始编码的有序集合分值这个选项主要用于底层应用或者调试实际中的作用并不大限定返回的记录数给定地点查找改地点周围的地点天安门流就是版本的消息中间件之前的消息队列实现两种方法实现消息队列和一进一出订阅方式一个生产方多个消费方缺点无法持久化如果一个消费者都没有则会丢失消息作用实现消息队列它支持消息的持久化支持自动生成全局唯一支持确认消息的模式支持消费组模式等让消息队列更加的稳定和可靠结构一个消息链表将所有加入的消息都串起来每一个消息都有一个唯一的和对应的内容需要标识作用消息内容消费组通过命令创建同一个消费组可以有多个消费者游标每一个消费组都有一个游标任意一个消费者读取了消息都会使游标往前移动消费者消费组中的消费者消费者会有一个状态变量用于记录被当前消费已读取但未的消息如果客户端没有这个变量里面的消息会越来越多一旦某个消息被它就开始减少这个变量在官方被称之为记录了当前已经被客户端读取的消息但是还没有确认字符它用来确保客户端至少消费了消息一次而不会在网络传输的中途丢失了没处理队列相关命令操作消息增删改指令名称指令作用将消息添加到消息队列队尾限制的长度如果已经超出会进行截取删除消息获取中的消息长度获取消息列表可以指定范围忽略删除的信息和的区别在于反向获取从小到大获取消息阻塞非阻塞返回大于指定的消息将消息添加到消息队列队尾消息必须比上一个大默认用号表示自动生成规矩用户命令中让系统自动生成用于向队列中添加消息如果指定的队列不存在则该命令执行时会新建一个队列号表示服务器自动生成类似里面主键后面顺序跟着一堆业务获取消息列表可以指定范围忽略删除的信息表示开始的值代表最小值表示结束的值代表最大值表示最多可以获取多少个如果不写则表示获取全部和的区别在于反向获取从小到大删除消息时间戳获取中的消息长度用于对的长度进行截取如果超长就会进行截取允许的最大长度对流进行修剪长度允许的最小获取消息阻塞非阻塞返回大于指定的消息非阻塞代表特殊表示以当前已经存储的最大的作为最后一个当前中不存在大于当前最大的消息因此此时返回代表从最小的开始获取中的消息当不指定将会返回中的所有消息注意也可以使用也都是可以的阻塞获取比当前队列最大的还大的一条数据并进行阻塞等待获取等有了之后就输出消费组相关指令创建消费者组表示从尾部开始消费表示从头部开始消费创建消费者组的时候必须指定为表示从头开始消费为表示只消费新的消息队尾新来为消息队列创建一个消费者组并从队尾开始消费只消费最新消息中的消息一旦被消费组里的一个消费者读取了就不能再被该消费组内的其他消费者读取了即同一个消费组里的消费者不能消费同一条消息刚才的命令再执行次此时读到的就是空值但是不同消费组的消费者可以消费同一条消息表示从第一条尚未被消费的消息开始读取指定消费者组创建消费者名称要消费的消息队列名称通过将消息队列分发出去让组内的多个消费者共同分担读取消息所以我们通常会让每个消费者读取部分消息从而实现消息读取负载在多个消费者间是均衡分布的将中的消息分为三个消费者来进行读取查询每个消费者组内所有消费者已读但未确认的消息问题基于实现的消息队列如何保证消费者在发生故障或宕机再次重启后仍然可以读取未处理完的消息解决会自动使用内部队列也称为留存消费组里每个消费者读取的消息保底措施直到消费者使用命令通知消息已经处理完成消费确认增加了消息的可靠性一般在业务处理完成之后需要执行命令确认消息已经被消费完成获取消费者组读取但未确认的条数和起始结束和组内每一个消费者读取消息的个数确认消息消息对里面的对应的消息进行确认确认完毕之后在使用进行获取就无法获取对应的消息了打印消息队列的信息持久化数据库概念持久性以指定的时间间隔执行数据集的时间点快照实现类似照片记录效果的方式就是把某一时刻的数据和状态以文件的形式写到磁盘上也就是快照这样一来即使故障宕机快照文件也不会丢失数据的可靠性也就得到了保证这个快照文件就称为文件其中就是的缩写作用在指定是时间内将内存中的数据集快照写入磁盘也就是将内存快照它恢复的时候再将磁盘快照文件读回内存中在执行快照的时候会将内存中所有的数据都记录到磁盘中保存频率以前每间隔秒分钟有一次发生变化的就进行一次快照每间隔秒分钟有十次发生变化就进行一个快照处理每间隔秒一分钟有发生变化就进行一个快照之后每间隔秒一小时有一次发生变化的就进行一次快照每间隔秒分钟有次发生变化的就进行一次快照每间隔秒一分钟有次发生变化的就进行一次快照自动触发修改配置文件按照里配置的在多少秒内有多少次修改就会进行保存搜索能找到修改文件保存路径搜索能找到可以将修改成我们自己的路径修改文件保存名称搜索找到修改进行保存即可等待我们在秒内修改次数超过次之后就会触发自动保存保存在文件中手动触发会阻塞当前的服务器直到持久化工作完成在执行期间不能处理其他命令线上禁止使用该方式会一个子进程不会阻塞当前主进程主进程和保存进程会同时进行恢复文件当我们使用清空当前数据库中的所有键命令后会自动产生文件但里面是空的没有意义我们使用命令关闭服务的时候也会自动产生文件等待服务器重启的时候会自动去配置的文件夹底下寻找配置的文件然后将其中对应的数据进行恢复优点适合大规模的数据恢复按照业务定时备份对数据完整性和一致性要求不高文件在内存中加载速度要比快的多缺点在服务器宕机的时候数据不能完整的保存下来只能够尽量避免数据丢失需要经常子进程在磁盘上进行持久化如果数据很大可能会很耗时检查和修复文件使用命令指定文件路径禁用快照动态停止保存规则配置禁用打开配置文件中将注掉的打开即可优化配置项详解在配置文件模块中进行配置配置文件自动保存触发条件在秒内发生了次修改就会触发自动保存配置自动保存文件名配置自动保存文件路径默认如果配置成表示你不在乎数据不一致或者有其他的手段发现和控制这种不一致那么在快照写入失败时也能确保继续接受新的写请求默认对于存储到磁盘中的快照可以设置是否进行压缩存储如果是的话会采用算法进行压缩如果你不想消耗来进行压缩的话可以设置为关闭此功能默认在存储快照后还可以让使用算法来进行数据校验但是这样做会增加大约的性能消耗如果希望获取到最大的性能提升可以关闭此功能在没有持久性的情况下删除复制中使用的文件启用默认情况下此选项是禁用的持久化以日志形式记录每一个写操作只许追加文件但不可以改写文件启动之初会读取该文件重新构建数据换言之重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作默认情况下是没有开启的如果要开启功能需要设置配置保存的文件作为命令的来源会有多个源头以及源源不断的请求命令在这些命今到达以后并不是直接写入文件会将其这些命令先放入缓存中进行保存这里的缓冲区实际上是内存中的一片区域存在的目的是当这些命令达到一定量以后再写入磁盘避免频繁的磁盘操作缓冲会根据缓冲区同步文件的三种写回策略将命令写入磁盘上的文件同步写回每个写命令执行完毕之后立刻同步的将日志写回磁盘每秒写回默认写回方式每个写命令执行完毕之后先把日志写到缓冲区中每隔一秒将缓冲区的内容写到文件中操作系统控制的写回每个写命令执行完毕之后先把日志文件写到的内存缓冲区中由操作系统决定什么时候写回磁盘随着写入内容的增加为避免文件膨胀会根据规则进行命令的合并又称重写从而起到文件压缩的目的重启之后会从文件中读取命令进行数据恢复功能配置开启在配置文件中找到配置项在后面写上开启功能默认是使用默认写回策略设置的保存路径之前和保存路径是相同的设置一个和都会公用这个文件夹之后是的文件存放路径在中还有一个配置项会存放在设置文件保存名称之前在配置文件中设置配置项来配置保存文件名之后有三个基本文件基本文件表示基本一般有子进程通过重写产生该文件只存在一个增量文件表示增量一般会在开始执行时被创建该文件可能存在多个表示历史它是有和变化而来每次成功完成之后本次之前对应的和都会变成类型的会被自动删除清单文件来管理这些文件恢复操作正常恢复在重启的时候会去指定文件夹内读取文件来恢复数据异常恢复一秒写一次但是可能写的文件较多在一秒之内没写完就宕机了会导致文件出错文件出错会导致服务无法正常启动需要使用进行文件修复一定要加需要修复的文件路径优点更好的保存数据不丢失性能高可做紧急恢复使用更加持久可以有不同的策略即使丢失也只有的丢失能接受日志是一个仅附加日志因此不会出现寻道问题也不会在断电时出现损坏问题即使由于某种原因磁盘已满或其他原因日志以写一半的命令结尾工具也能够轻松修复它当变得太大时能够在后台自动重写重写是完全安全的因为当继续附加到旧文件时会使用创建当前数据集所需的最少操作集生成一个全新的文件一旦第二个文件准备就绪就会切换两者并开始附加到新的那一个以易于理解和解析的格式依次包含所有操作的日志甚至可以轻松导出文件例如即使不小心使用该命令刷新了所有内容只要在此期间没有执行日志重写您仍然可以通过停止服务器删除最新命令并重新启动来保存您的数据集缺点文件通常比相同数据集的等效文件大根据确切的策略可能比慢一般来说将设置为每秒性能仍然非常高并且在禁用的情况下即使在高负载下它也应该与一样快即使在巨大的写入负载的情况下仍然能够提供关于最大延迟的更多保证重写机制由于持久化是不断将写命令记录到文件中随着不断的进行的文件会越来越大文件越大占用服务器内存越大以及恢复要求时间越长为了解决这个问题新增了重写机制当文件的大小超过所设定的峰值时就会自动启动文件的内容压缩只保留可以恢复数据的最小指令集或者可以手动使用命令来重写启动的文件内容压缩只保留可以恢复数据的最小指令集例如对一个进行多次操作之后重写完之后只保留最后一次写操作重写之后只保留触发机制在文件中有两个配置项注意同时满足且的关系会触发根据上次重写后的大小判断当前大小是不是增长了倍重写时满足的文件大小自动触发满足上诉配置项之后进行重写重写之后会将文件内容压缩完之后放入中并且会改变文件名称为改变文件名称为手动触发使用命令来进行手动重写也就是说文件重写并不是对原文件进行重新整理而是直接读取服务器现有的键值对然后用一条命令去代替之前记录这个键值对的多条命令生成一个新的文件后去替换原来的文件文件重写触发机制通过配置文件中的默认值为以及配置也就是说默认会记录上次重写时的大小默认配置是当文件大小是上次后大小的一倍且文件大于时触发重写原理在重写开始前会创建一个重写子进程这个子进程会读取现有的文件并将其包含的指令进行分析乐缩并写入到一个临时文件中与此同时主进程会将新接收到的写指令一边累积到内存缓冲区中一边继续写入到原有的文件中这样做是保证原有的文件的可用性避免在重写过程中出现意外当重写子进程完成重写工作后它会给父进程发一个信号父进程收到信号后就会将内存中缓存的写指令追加到新文件中当追加结束后就会用新文件来代替旧文件之后再有新的写指令就都会追加到新的文件中重写文件的操作并没有读取旧的文件而是将整个内存中的数据库内容用命令的方式重写了一个新的文件这点和快照有点类似配置命令配置指令配置含义配置示例是否开启文件名称同步方式重写期间是否同类重写触发配置文件重写策略总结混合持久化默认不开开启之后优先级较高数据恢复顺序和加载流程如何选择持久化方式能够在指定的时间间隔能对你的数据进行快照存储持久化方式记录每次对服务器写的操作当服务器重启的时候会重新执行这些命令来恢复原始的数据命令以协议追加保存每次写的操作到文件末尾推荐混合使用先使用进行快照存储然后使用持久化记录所有的写操作当重写策略满足或手动触发重写的时候将最新的数据存储为新的记录这样的话重启服务的时候会从和两部分恢复数据既保证了数据完整性又提高了恢复数据的性能简单来说混合持久化方式产生的文件一部分是格式一部分是格式包括了头部混写纯缓存模式同时关闭和获取极致的性能在配置文件中设置禁用持久化的模式下也可使用时命令和生成文件禁用持久化的模式下也可使用时命令生成文件事务本质可以一次执行多个命令本质是一组命令的集合一个事务中的所有命令都会序列化按顺序地串行化执行而不会被其它命令插入不许加塞作用一个队列中一次性顺序性排他性的执行一系列操作特点解释单独的隔离操作的事务仅仅是保证事务里的操作会被连续独占的执行命令执行是单线程架构在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的没有隔离级别的概念因为事务提交前任何指令都不会被实际执行也就不存在事务内的査询要看到事务里的更新在事务外查询不能看到这种问题了不保证原子性的事务不保证原子性也就是不保证所有指令同时成功或同时失败只有决定是否开始执行全部指令的能力没有执行到一半进行回滚的能力排他性会保证一个事务内的命令依次执行而不会被其它命令入命令正常执行开启事务开始事务开启事务向事务队列中添加一个元素向事务队列中添加一个元素向事务队列中添加一个元素向事务队列中添加一个元素开始执行事务放弃事务开启事务向事务队列中添加一个元素向事务队列中添加一个元素向事务队列中添加一个元素向事务队列中添加一个元素放弃事务执行全部终止当我们在执行命令之前输入的语句有误则在队列中所有的命令都不会被执行开启事务向事务队列中添加一个元素向事务队列中添加一个元素向事务队列中添加一个错误元素向事务队列中添加一个元素事务执行并不会执行事务中的内容终止错误当我们在执行命令之后输入的语句其中一个又错误则只会不执行错误语句正确语句会依次执行开启事务向事务队列中添加一个元素向事务队列中添加一个元素向事务队列中添加一个错误元素向事务队列中添加一个元素事务执行语句一二四会正确执行语句三不会执行监控悲观锁悲观锁顾名思义就是很悲观每次去拿数据的时候都认为别人会修改所以每次在拿数据的时候都会上锁这样别人想拿这个数据就会直到它拿到锁乐观锁乐观锁顾名思义就是很乐观每次去拿数据的时候都认为别人不会修改所以不会上锁但是在更新的时候会判断一下在此期间别人有没有去更新这个数据采用乐观锁执行流行正常执行设置初始值设置初始值监控事务中的一个元素开始事务执行事务出错情况设置初始值设置初始值监控事务中的一个元素开始事务执行事务和上面同时进行在上方向事务队列中中添加语句的时候我们执行如下代码这样会导致在事务执行的时候监听的元素已经被改变所以事务执行失败放弃监控设置初始值设置初始值监控事务中的一个元素放弃监控开始事务执行事务总结一旦执行了之前加的监控锁都会被取消掉了当客户端连接丢失的时候比如退出链接所有东西都会被取消监视流程开启以开始一个事务入队将多个命令入队到事务中接到这些命令并不会立即执行而是放到等待执行的事务队列里面执行由命令触发事务管道如何优化频繁命令往返造成的性能瓶颈是一种基于客户端服务端模型以及请求响应协议的服务一个请求会遵循以下步骤客户端向服务端发送命令分四步发送命令一命令排队一命令执行一返回结果并监听返回通常以阻塞模式等待服务端响应服务端处理命令并将结果返回给客户端上述两步称为简称数据包往返于两端的时间如果同时需要执行大量的命令那么就要等待上一条命令应答后再执行这中间不仅仅多了而且还频繁调用系统发送网络请求同时需要调用多次和系统方法系统方法会将数据从用户态转移到内核态这样就会对进程上下文有比较大的影响了性能不太好概念管道可以一次性发送多条命令给服务端服务端依次处理完完毕后通过一条响应一次性将结果返回通过减少客户端与的通信次数来实现降低往返延时时间实现的原理是队列先进先出特性就保证数据的顺序性是为了解决往返回时仅仅是将命令打包一次性发送对整个的执行不造成其它任何影响执行方式通过文件执行将我们要执行的命令放到一个文件中执行过程是将文件中的命令都展示出来通过将展示的命令作为参数传递到中并使用管道执行总结与原生批量命令对比原生批量命令是原子性例如是非原子性原生批量命令一次只能执行一种命令支持批量执行不同命令原生批命令是服务端实现而需要服务端与客户端共同完成与事务对比事务具有原子性管道不具有原子性管道一次性将多条命令发送到服务器事务是一条一条的发事务只有在接收到命令后才会执行管道不会执行事务时会阻塞其他命令的执行而执行管道中的命令时不会注意事项缓冲的指令只是会依次执行不保证原子性如果执行中指令发生异常将会继续执行后续的指令使用组装的命令个数不能太多不然数据量过大客户端阻塞的时间可能过久同时服务端此时也被迫回复一个队列答复占用很多内存订阅可以实现消息中间件的功能通过发布订阅实现消息的引导和分流不推荐该功能通过发布的消息订阅者都可以收到常用命令命令订阅给定的一个或多个频道的信息推荐先执行订阅后再发布订阅成功之前发布的消息是收不到的订阅的客户端每次可以收到一个个参数的消息消息类型消息消息命令发布消息到指定频道命令按照模式批量订阅订阅一个或多个符合给定模式支持号号之类的的频道命令查看订阅与发布系统状态查看由活跃频道组成的列表某个频道有几个订阅者只统计使用命令执行的返回客户端订阅的唯一模式的数量命令取消订阅命令按照模式取消订阅总结订阅缺点发布的消息在系统中不能持久化因此必须先执行订阅再等待消息发布如果先发布了消息那么该消息由于没有订阅者消息将被丢弃消息只管发送对于发布者而言消息是即发即失的不管接收也没有机制无法保证消息的消费成功以上的缺点导致的模式就像个小玩具在生产环境中几平无用武之地为此版本新增了数据结构不但支持多播还支持数据持久化相比更加的强大复制复制就是主从复制以写为主以读为主当数据变化的时候自动将新的数据同步到中作用读写分离容灾恢复数据备份水平扩容支持高并发配置配从库不配主库如果配置了参数需要密码登陆那么就要配置来设置校验密码否则的话会拒绝的访问请求常用命令可以查看复制节点的主从关系和配置信息主库主库端口在从机上设置主库和主库端口一般写入配置文件中新主库新主库端口每次与断开之后都需要重新连接除非你配置进文件在运行期间修改节点的信息如果该数据库已经是某个主数据库的从数据库那么会停止和原主数据库的同步关系转而和新的主数据库同步重新拜码头使当前数据库停止与其他数据库的同步转成主数据库自立为王修改配置文件在备份文件中将设置为注释掉关闭保护模式指定运行端口指定当前工作目录存放配置文件的文件夹文件名文件名设置启动密码密码修改文件名修改文件名如果配置该项需要开始从机访问主机的通行密码在中配置主机访问密码从机配置主机不需要从机访问主机需要配置主机主机端口从机配置主机不需要主从命令先启动主机再启动从机从机启动时候需要指定端口可以从日志文件中查看信息主机中有从机连接成功信息命令查看问题主从写入配置文件问从机可以执行写命令吗答从机是只读模式的主机是可读可写的问是从头开始复制还是从切入点开始复制启动写到跟着同时启动跟着写到写到后才启动那之前的是否也可以复制答之前也可以复制问主机之后从机会变成主机吗答不会问主机后重启后主从关系还在吗从机还能否顺利复制答关系存在可以继续进行复制问某台从机后继续从机重启后它能跟上大部队吗答可以问题命令操作手动指定当从机之后去掉配置项中的配置项使从机变成主机在从机启动之后使用命令主机主机端口配置主机之后还可以同步主机上的数据通过命令行手动配置主机的从机重启之后就回丢失与主机的联系薪火相传当主连接过多从机那么主机的写压力会大大增加导致主机性能下降这时候可以让多个从机互相连接上一个可以是下一个的同样可以接收其他的连接和同步请求那么该作为了链条中下一个的可以有效减轻主的写压力中途变更转向会清除之前的数据重新建立拷贝最新的新主库新主库端口中间的从机即使有从机连接它它也不具备写能力反客为主使用命令可以与主机断开连接自己当主机原理及工作流程启动同步请求启动成功连接到后会发送一个命令首次全新连接一次完全同步全量复制将被自动执行自身原有数据会被数据覆盖清除首次连接全量复制节点收到命令后会开始在后台保存快照即持久化主从复制时会触发同时收集所有接收到的用于修改数据集命令缓存起来节点执行持久化完后将快照文件和所有缓存的命令发送到所有以完成一次完全同步而服务在接收到数据库文件数据后将其存盘并加载到内存中从而完成复制初始化心跳持续保持通讯在配置文件中包含这个配置项表明主机在一次一下从机看看从机是否在线进入平稳增量复制继续将新的所有收集到的修改命令自动依次传给完成同步从机下线重连续传会检查里面的和都会保存一个复制的还有一个是保存在中的只会把已经复制的后面的数据复制给类似断点续传缺点复制延迟信号衰减由于所有的写操作都是先在上操作然后同步更新到上所以从同步到机器有一定的延迟当系统很繁忙的时候延迟问题会更加严重机器数量的增加也会使这个问题更加严重挂了怎么办默认情况下不会在节点中自动重选一个需要从中选出一个当主机哨兵作用监控运行状态包括和当一般哨兵配置三台功能主从监控监控主从库运行是否正常消息通知哨兵可以将故障转移的结果发送给客户端故障转移如果异常则会进行主从切换将其中一个作为新配置中心客户端通过连接哨兵来获得当前服务的主节点地址使用方法创建哨兵服务复制三份到我们指定目录下命名为参数服务监听地址用于客户端连接默认本机地址是否以后台方式运行安全保护模式端口日志文件路径文件路径工作目录设置要监控的服务器表示最少有几个哨兵认可客观下线同意故障迁移的法定票数我们知道网络是不可靠的有时候一个会因为网络堵塞而误以为一个已经死掉了在集群环境下需要多个互相沟通来确认某个是否真的死了这个参数是进行客观下线的一个依据意思是至少有个认为这个有故障才会对这个进行下线以及故障转移因为有的时候某个节点可能因为自身网络原因导致无法连接而此时并没有出现故障所以这就需要多个都一致认为该有问题才可以进行下一步操作这就保证公平性和高可用设置了密码连接服务的密码指定多少毫秒之后主节点没有应答哨兵此时哨兵主观上认为主节点下线默认即可表示允许并行同步的个数当挂了后哨兵会选出新的此时剩余的会向新的发起同步数据默认即可故障转移的超时时间进行故障转移时如果超过设置的毫秒表示故障转移失败默认即可配置当某一事件发生时所需要执行的脚本默认即可客户端重新配置主节点参数脚本默认即可文件配置在中进行配置启动一主二从主机设置访问密码是上述为配从不配主这里又进行了主机配置解释后续可能会变成从机需要设置访问新主机的密码请设置项访问密码为不然后续可能报错从机设置主机密码启动哨兵模拟挂机通过将主进行之后哨兵会先进行挂机确认确认完之后会进行新选择即使原先的从新上线之后不会转换为原先的原先挂机的会变成从机老并且会在配置文件后面添加上进行主从切换新的配置项会被移除问题的意思是对端的管道已经断开往往发生在远端把这个读写管道关闭了你无法在对这个管道进行读写操作从的四次挥手来讲远端已经发送了序号告诉你我这个管道已经关闭这时候如果你继续往管道里写数据第一次你会收到一个远端发送的信号如果你继续往管道里数据操作系统就会给你发送的信号并且将置为如果你的程序默认没有对进行处理那么程序会中断退出一般情况下可以用忽略这个信号这样的话程序不会退出但是会返回并且将置为只会出现在往对端已经关闭的管道里写数据的情况下在收到对端的序号后第一次写不会出现而是返回这时候正确的做法应该是本端也这个管道如果继续那么就会出现这个错误切换结果配置文件的内容在运行期间会被动态进行更改切换后和的内容都会发生改变即中会多一行的配置的监控目标会随之调换运行流程当一个主从配置中的失效之后可以选举出一个新的用于自动接替原的工作主从配置中的其他服务器自动指向新的同步数据一般建议采取奇数台防止某一台无法连接到导致误切换流程三个哨兵监控一主二从正常运行中主观下线所谓主观下线简称指的是单个实例对服务器做出的下线判断即单个认为某个服务下线有可能是接收不到订阅之间的网络不通等等原因主观下线就是说如果服务器在给定的毫秒数之内没有回应命令或者返回一个错误消息那么这个会主观的单方面的认为这个不可以用了表示被当前实例认定为失效的间隔时间这个配置其实就是进行主观下线的一个依据在多长时间内一直没有给返回有效信息则认定该主观下线也就是说如果多久没联系上认为这个进入到失效状态客观下线需要一定数量的多个哨兵达成一致意见才能认为客观上已经宕掉这个参数是进行客观下线的一个依据法定人数法定票数意思是至少有个认为这个有故障才会对这个进行下线以及故障转移因为有的时候某个节点可能因为自身网络原因导致无法连接而此时并没有出现故障所以这就需要多个都一致认为该有问题才可以进行下一步操作这就保证了公平性和高可用选举出领导者哨兵哨兵中选出兵王当主节点被判断客观下线以后各个哨兵节点会进行协商先选举出一个领导者哨兵节点兵王并由该领导者节点也即被选举出的兵王进行故障迁移选择算法算法基本思路先到先得由兵王开始推动故障切换流程并选出一个新分为三步选择新规则如下在没问题的情况下新王登基文件中优先级或者最高的从节点数字越小优先级越高复制偏移位置最大的从节点谁拥有最全的老的数据谁当新最小的从节点字典顺序码将其余转换到新中俯首称臣新执行命令让选出来的从节点成为新的主节点并通过命令让其他节点成为其从节点会对选举出的新执行操作将其提升为节点向其它发送命令让剩余的成为新的节点的老重启之后也会变成旧主拜服将之前已下线的老设置为新选出的新的从节点当老重新上线后它会成为新的会让原来的降级为并恢复正常工作上述都是自动完成使用建议哨兵节点的数量应为多个哨兵本身应该集群保证高可用哨兵节点的数量应该是奇数各个哨兵节点的配置应一致如果哨兵节点部署在等容器里面尤其要注意端口的正确映射哨兵集群主从复制并不能保证数据零丢失在挂了之后会有一点选出新的时间间隔在这个时间间隔内无法写入新数据集群定义由于数据量过大单个复制集难以承担因此需要对多个复制集进行集群形成水平扩展每个复制集只负责存储整个数据集的一部分这就是的集群其作用是提供在多个节点间共享数据的程序集如下图所示左边是哨兵主从复制右边是集群集群相对于哨兵主从的优点在于哨兵主从过度依赖于一台把希望全部寄托在一个中如果挂了之后需要有一点时间的空窗期但是集群拥有多个即使其中有一个挂了其他的也可以使用不会导致整个系统瘫痪作用集群支持多个每个又可以挂载多个由于自带的故障转移机制内置了高可用的支持无需再去使用哨兵功能客户端与的节点连接不再需要连接集群中所有的节点只需要任意连接集群中的一个可用节点即可槽位负责分配到各个物理服务节点由对应的集群来负责维护节点插槽和数据之间的关系集群算法集群的密钥空间被分成个槽有效地设置了个主节点的集群大小上限但是建议的最大节点大小约为个节点集群中的每个主节点处理个哈希槽的一个子集当没有集群重新配置正在进行时即哈希槽从一个节点移动到另一个节点集群是稳定的当集群稳定时单个哈希将由单个节点提供服务但是服务节点可以有一个或多个副本在网络分裂或故障的情况下替换它并且可以用于扩展读取陈旧数据是可接受的操作槽位集群投有使用一致性而是引入了哈希槽的概念集群有个哈希槽每个通过校验后对取模来决定放置哪个槽集群的每个节点负责部分槽举个例子比如当前集群有个节点那么分片分片是什么使用集群时我们会将存储的数据分散到多台机器上这称为分片简言之集群中的每个实例都被认为是整个数据的一个分片如何找到给定的分片为了找到给定的分片我们对进行算法处理并通过对总分片数量取模然后使用确定性哈希函数这意味着给定的将多次始终映射到同一个分片我们可以推断将来读取特定的位置优势方便扩容和数据分派查找这种结构很容易添加或者咧除节点比如如果我想新添加个节点我需要从节点中得部分槽到上如果我想移除节点需要将中的槽移到和节点上然后将没有任何槽的节点从集群中移除即可由于从一个节点将哈希槽移动到另一个节点并不会停止服务所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态槽位映射哈希取余分区服务个数亿条记录就是亿个我们单机不行必须要分布式多机假设有台机器构成一个集群用户每次读写操作都是根据公式个机器台数计算出哈希值用来决定数据映射到哪一个节点上优点简单粗暴直接有效只需要预估好数据规划好节点例如台台台就能保证一段时间的数据支撑使用算法让固定的一部分请求落到同一台服务器上这样每台服务器固定处理一部分请求并维护这些请求的信息起到负载均衡分而治之的作用缺点原来规划好的节点进行扩容或者缩容就比较麻烦了不管扩缩每次数据变动导致节点有变动映射关系需要重新进行计算在服务器个数固定不变时没有问题如果需要弹性扩容或故障停机的情况下原来的取模公式就会发生变化会变成此时地址经过取余运算的结果将发生很大变化根据公式获取的服务器也会变得不可控某个机器宕机了由于台数数量变化会导致取余全部数据重新洗牌一致性算法设计目标是为了解决分布式缓存数据变动和映射问题某个机器宕机了分母数量改变了自然取余数不了目的是当服务器个数发生变动时尽量减少影响客户端到服务器的映射关系步骤算法构建一致性环一致性哈希算法必然有个函数并按照算法产生值这个算法的所有可能哈希值会构成一个全量集这个集合可以成为一个空间这个是一个线性空间但是在算法中我们通过适当的逻辑控制将它首尾相连这样让它逻辑上形成了一个环形空间它也是按照使用取模的方法节点取模法是对节点服务器的数量进行取模而一致性算法是对取模简单来说一致性算法将整个哈希值空间组织成一个虚拟的圆环如假设某哈希函数的值空间为即哈希值是一个位无符号整形整个哈希环如下图整个空间按顺时针方问组织圆环的正上方的点代表点右侧的第一个点代表以此类推直到也就是说点左侧的第一个点代表和在零点中方向重合我们把这个由个点组成的圆环称为环服务器节点映射将集群中各个节点映射到环上的某一个位置将各个服务器使用进行一个哈希具体可以选择服务器的或主机名作为关键字进行哈希这样每台机器就能确定其在哈希环上的位置假如个节点经过地址的哈希函数计算使用地址哈希后在环空间的位置如下落到服务器的落键规则当我们需要存储一个键值对时首先计算的值将这个使用相同的函数计算出哈希值并确定此数据在环上的位置从此位置沿环顺时针行走第一台遇到的服务器就是其应该定位到的服务器并将该键值对存储在该节点上如我们有四个数据对象经过哈希计算后在环空间上的位置如下根据一致性算法数据会被定为到上被定为到上被定为到上被定为到上优点容错性假设宕机可以看到此时对象不会受到影响一般的在一致性算法中如果一台服务器不可用则受影响的数据仅仅是此服务器到其环空间中前一台服务器即沿着逆时针方向行走遇到的第一台服务器之问数据其它不会受到影响简单说就是挂了受到影响的只是之间的数据且这些数据会转移到进行存储扩展性数据量增加了需要增加一台节点的位置在和之间那收到影响的也就是到之间的数据重新把到的数据录入到上即可不会导致取余全部数据重新洗牌缺点数据的分布和节点的位置有关因为这些节点不是均匀的分布在哈希环上的所以数据在进行存储时达不到均匀分布的效果哈希槽分区出现缘由一致性算法的数据倾斜问题槽实质是一个数组数组形成空间作用解决均匀分配的问题在数据和节点之间又加入了一层把这层称为哈希槽用于管理数据和节点之间的关系现在就相当于节点上放的是槽槽里放的是数据为什么集群的最大槽数是个集群不保证强一致性这意味着在特定的条件下集群可能会丢掉一些被系统收到的写入请求命令集群环境的搭建三主三从集群配置新建个独立的实例服务主机集群打开集群配置文件集群超时时间启动台独立的实例服务通过命令为台机器构建集群关系集群构建成功之后会产生上面配置的的配置文件查看集群所有的节点信息查看某一个节点的集群信息主从集群读写通过新增两个可以发现有的能够添加进去有的会报错这是因为使用集群后在添加的时候有槽位限制解决方式再启动客户端的时候添加上参数即可使用查看某一个的槽位主从容错切换当主机之后从机会进行上位等待原先主机恢复之后并不会继续是主机而是会变成从机节点从属调整如果想要原先的主机恢复之后还是主机登录原先的主机使用主从节点调整指令主从扩容新建两个实例一主一从启动两个实例都是以身份启动的将加入到集群中将新增的作为节点加入原有集群密码自己实际地址集群中的主机就是将要作为新增节点就是原来集群节点里面的领路人相当于拜拜的码头从而找到组织加入集群检查集群中的节点分布情况发现新加入的没有分配槽位重新分配槽位从新分派槽号密码地址端口号输入完上述命令中之后会出现如下情况通过计算所以我们分出个槽位出俩我们通过上述展示的信息获取我们想要分配的主机输入全部需要调整的为什么是个新的区间以前的还是连续重新分配成本太高所以前家各自匀出来一部分从三个旧节点分别匀出个坑位给新节点分配节点命令密码新端口新端口新主机节点将挂载到上面这个是的编号按照自己实际情况主从缩容检查从节点信息获取从节点的节点执行删除命令的节点将需要删除的节点槽从新分配从新分派槽号密码地址端口号节点槽全部分给结果是会从上退下来变成的最后将进行删除的节点总结不在一个槽中的不支持操作解决方式我们在设置值的时候可以给值分一个组常用命令默认现在集群架构是主从的由个平分个每个的小集群负责的对应一部分数据默认值即需要集群完整性方可对外提供服务通常情况如果这个小集群中任何一个主从挂了你这个集群对外可提供的数据只有了整个集群是不完整的默认在这种情况下是不会对外提供服务的如果你的诉求是集群不完整的话也需要对外提供服务需要将该参数设置为这样的话你挂了的那个小集群是不行了但是其他的小集群仍然可以对外提供服务槽位编号该槽位被占用该槽位没占用键名称查看对应的键应该在那个槽位上整合引入依赖案例通过指定的和端口号获取连接设置密码练手获取链接对象查询所有的判断键是否存在判断一个键的存活时间获取一个键同时设置获取多个键值对类型设置类型数据有序可重复设置类型数据无序不重复设置类型数据是固定的是键值对有序缺点每次访问都需要新建一个对象开销大且线程不安全当有多但是如果使用这个客户端连接服务器的时候就不会出现上面的情况底层使用的是多个线程都需要连接服务器的时候可以保证只创建一个连接使所有的线程共享这一个连接这样可以减少创建关闭一个连接时候的开销而且这种方式也是线程安全的不会出现一个线程通过更改服务器中的数据之后而影响另一个线程的情况引入依赖测试通过获取对象创建链接客户端获取连接通过创建操作的关闭链接资源引依赖配置文件在结合会提示空指针异常原因是在中将默认路径匹配策略从更改为导致出错解决办法是切换回之日志设置定义配置类序列化的工具配置类下面这个请一定开启配置序列化过野生没有序列化过提供了操作类型的所有方法提供了操作类型的所有方法提供了操作的所有方法提供了操作表的所有方法提供了操作的所有方法设置序列化方式设置的序列化方式使用替换默认序列化你自己的利用构建接口文档整合测试订单接口新增订单按照订单获取订单生成随机数通过生成序列化设置我的订单向中添加数据向中添加一条订单序列化如果不进行序列化则会出现编码问题键和值都是通过提供的序列化到数据库的默认使用的是默认使用的是被序列化成这样线上通过去查询对应的非常不方便可以将替换为来解决序列化问题默认构造方法是使用序列化编码器我们需要使用序列化编码器配置文件设置的初始化配置文件在配置的时候使用来进行配置配置指定序列化编码器序列化的工具配置类下面这个请一定开启配置序列化过野生没有序列化过提供了操作类型的所有方法提供了操作类型的所有方法提供了操作的所有方法提供了操作表的所有方法提供了操作的所有方法设置序列化方式设置的序列化方式使用替换默认序列化集群定义配置文件设置集群获取失败最大重定向次数设置集群节点正常写入即可如果集群中有一个宕机了之后服务会自动的进行主从替换但是没有动态的感受到的最新集群信息这时候再次写入就会连接超时版本默认的连接池采用当集群节点发生变化后默认是不会刷新节点拓扑配置动态拓扑刷新设置集群获取失败最大重定向次数设置集群节点配置动态刷新',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-22 15:19:29',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.1.1"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://s1.ax1x.com/2022/11/27/zUFla6.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://262259.xyz/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" href="https://262259.xyz/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">管理</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://qexo.262259.xyz/" title="博客后端"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://unpkg.com/qexo-static@1.4.0/assets/img/brand/qexo.png" alt="博客后端"/><span class="back-menu-item-text">博客后端</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Nuyoah</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://s2.loli.net/2022/08/16/weL31EHsON5ldDU.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/08/16/weL31EHsON5ldDU.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/08/16/2yRjVx9gFKQaidA.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/08/16/2yRjVx9gFKQaidA.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Gitee/" style="font-size: 1.05rem;">Gitee<sup>1</sup></a><a href="/tags/JAVA/" style="font-size: 1.05rem; font-weight: 500; color: var(--anzhiyu-lighttext)">JAVA<sup>5</sup></a><a href="/tags/JS/" style="font-size: 1.05rem;">JS<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>1</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>7</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>2</sup></a><a href="/tags/hexo/" style="font-size: 1.05rem;">hexo<sup>4</sup></a><a href="/tags/win10/" style="font-size: 1.05rem;">win10<sup>1</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/" style="font-size: 1.05rem;">个人日记<sup>1</sup></a><a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 1.05rem;">人工智能<sup>15</sup></a><a href="/tags/%E5%B7%A5%E4%BD%9C/" style="font-size: 1.05rem;">工作<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%BA%8E%E9%80%BB%E8%BE%91/" style="font-size: 1.05rem;">数字电路于逻辑<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" style="font-size: 1.05rem;">算法实现<sup>12</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">计算机基础<sup>13</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/12/"><span class="card-archive-list-date">十二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">Redis7</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-04-20T02:31:27.000Z" title="发表于 2024-04-20 10:31:27">2024-04-20</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-09-22T07:19:29.834Z" title="更新于 2024-09-22 15:19:29">2024-09-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">22.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>79分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为石家庄"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>石家庄</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://s2.loli.net/2022/11/19/vJMKhVAUYNXRQuE.jpg?_r_=2c77c62d-27f5-863c-fa81-c49d5475ad7e"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://262259.xyz/2024/04/20/Redis7/"><header><h1 id="CrawlerTitle" itemprop="name headline">Redis7</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Nuyoah</span><time itemprop="dateCreated datePublished" datetime="2024-04-20T02:31:27.000Z" title="发表于 2024-04-20 10:31:27">2024-04-20</time><time itemprop="dateCreated datePublished" datetime="2024-09-22T07:19:29.834Z" title="更新于 2024-09-22 15:19:29">2024-09-22</time></header><h1 id="redis7入门概述"><a class="markdownIt-Anchor" href="#redis7入门概述"></a> Redis7入门概述</h1>
<p>作者：<a target="_blank" rel="noopener" href="https://github.com/antirez">antirez Github</a></p>
<p><a target="_blank" rel="noopener" href="http://antirez.com/latest/0">博客</a></p>
<p>Remote Dictionary Server(远程字典服务)是完全开源的，使用ANSIC语言编写遵守BSD协议，是一个高性能的Key-Value数据库提供了丰富的数据结构，例如<strong>String、Hash、List、Set、SortedSet</strong>等等。数据是存在内存中的，同时Redis支持事务、持久化、LUA脚本、发布/订阅、缓存淘汰、流技术等多种功能特性提供了主从模式、Redis Sentinel和Redis Cluster集群架构方案</p>
<p><strong>Redis是一种缓存技术</strong></p>
<ol>
<li>分布式缓存，挡在mysql数据库之前的带刀护卫</li>
<li>内存存储和持久化(RDB+AOF)， redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务</li>
<li>高可用架构搭配</li>
<li>缓存穿透、击穿、雪崩</li>
<li>分布式锁</li>
<li>队列</li>
<li>排行版+点赞</li>
<li>…</li>
</ol>
<p>数据库遵循 2(写)- 8(读)原则，为了让这两个保持平衡，我们使用redis缓存，将8(读)进行降低。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/04/21/eC5yBTDjklPfg9p.png" alt="image-20240421191309648" /></p>
<p>与传统数据库关系(mysql)</p>
<ol>
<li>
<p>Redis是key-value数据库(NoSQL一种)，mysql是关系数据库</p>
</li>
<li>
<p>Redis数据操作主要在内存，而mysql主要存储在磁盘</p>
</li>
<li>
<p>Redis在某一些场景使用中要明显优于mysql，比如计数器、排行榜等方面</p>
</li>
<li>
<p>Redis通常用于一些特定场景，需要与Mysql一起配合使用</p>
</li>
<li>
<p>两者并不是相互替换和竞争关系，而是共用和配合使用</p>
</li>
</ol>
<h2 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> 优势</h2>
<ol>
<li>性能极高 - Redis能读的速度是110000次/秒,写的速度是81000次/秒</li>
<li>Redis数据类型丰富，不仅仅支持简单的key-value类型的数据</li>
<li>同时还提供list，set，zset，hash等数据结构的存储</li>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中</li>
<li>重启的时候可以再次加载进行使用</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份</li>
</ol>
<h2 id="下载"><a class="markdownIt-Anchor" href="#下载"></a> 下载</h2>
<p>官网：<a target="_blank" rel="noopener" href="https://redis.io/">www.redis.cn</a></p>
<p>github：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/releases/tag/7.2.4">Release 7.2.4 · redis/redis (github.com)</a></p>
<p>文档资料：</p>
<ol>
<li>源码地址：<a target="_blank" rel="noopener" href="https://github.com/redis/redis">https://github.com/redis/redis</a></li>
<li>在线测试：<a target="_blank" rel="noopener" href="https://try.redis.io">https://try.redis.io</a></li>
<li>命令参考：<a target="_blank" rel="noopener" href="http://doc.redisfans.com">http://doc.redisfans.com</a></li>
</ol>
<p>版本号第二位如果是<strong>奇数</strong>，则为<strong>非稳定版本</strong> 如2.7、2.9、3.1</p>
<p>版本号第二位如果是<strong>偶数</strong>，则为<strong>稳定版本</strong> 如2.6、2.8、3.0、3.2</p>
<p>当前奇数版本就是下一个稳定版本的开发版本，如2.9版本是3.0版本的开发版本</p>
<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<ol>
<li>
<p>下载获得redis-7.0.0.tar.gz后将它放入我们的Linux目录/opt</p>
<p>opt文件夹寻找方法：</p>
<ol>
<li>ctrl + alt + t 打开终端</li>
<li>cd …/ 返回上一层目录</li>
<li>cd …/ 返回上一层目录</li>
<li>ls  就能看到opt</li>
</ol>
</li>
<li>
<p>/opt目录下解压redis</p>
<p>tar -zxvf redis-7.0.0.tar.gz</p>
</li>
<li>
<p>进入 redis文件夹</p>
</li>
<li>
<p>在redis中执行 make &amp;&amp; make install，make可能需要下载，按照终端提示就行</p>
</li>
<li>
<p>默认安装目录：在opt同级文件夹下的  usr/local/bin</p>
<ol>
<li>redis-benchmark:性能测试工具，服务启动后运行该命令，看看自己本子性能如何</li>
<li>redis-check-aof: 修复有问题的AOF文件，rdb和aof后面讲</li>
<li>redis-check-dump: 修复有问题的dump.rdb文件</li>
<li>redis-cli: 客户端，操作入口</li>
<li>redis-sentinel: redis集群使用</li>
<li>Redis服务器启动命令</li>
<li>redis-server:</li>
</ol>
</li>
<li>
<p>将默认的redis.conf拷贝到自己定义好的一个路径下，比如/myredis</p>
</li>
<li>
<p>修改/myredis目录下redis.conf配置文件做初始化设置</p>
<p>redis.conf配置文件，改完后确保生效，记得重启，记得重启</p>
<p>使用vim修改</p>
<blockquote>
<p>vim打开操作：<strong>vim 需要打开的文件夹</strong></p>
<p>vim查找操作：<strong>/查找的字符串</strong>，查到之后按回车，然后通过n查找下一个，N查找上一个</p>
<p>vim插入操作：<strong>i</strong>，修改完毕之后使用esc退出</p>
<p>vim退出操作：<strong>:wq!</strong></p>
</blockquote>
<ol>
<li>默认daemonize no        改为 daemonize yes</li>
<li>默认protected-mode yes   改为 protected-mode no</li>
<li>默认bind 127.0.0.1       改为 直接注释掉(默认bind 127.0.0.1只能本机访问)或改成本机IP地址，否则影响远程IP连接</li>
<li>添加redis密码           改为 requirepass 你自己设置的密码</li>
</ol>
</li>
</ol>
<h2 id="启动服务"><a class="markdownIt-Anchor" href="#启动服务"></a> 启动服务</h2>
<ol>
<li>
<p>使用/myredis中修改完的配置文件启动redis</p>
<blockquote>
<p>redis-server /myredis/redis7.conf</p>
<p>ps -ef|grep redis|grep -v grep</p>
</blockquote>
</li>
<li>
<p>连接服务</p>
<blockquote>
<p>redis- server /myredis/redis.conf   // 启动服务端</p>
<p>redis-cli -a 密码 -p 端口  // 连接服务</p>
</blockquote>
</li>
<li>
<p>设置KV键值对</p>
<blockquote>
<p>set k1 helloword</p>
<p>get k1</p>
</blockquote>
</li>
</ol>
<h2 id="删除redis"><a class="markdownIt-Anchor" href="#删除redis"></a> 删除Redis</h2>
<ol>
<li>
<p>停止所有redis服务</p>
<blockquote>
<p>ps -ef|grep redis|grep -v grep  // 查看redis服务</p>
<p>redis-cli shutdown // 关闭服务</p>
<p>ps -ef|grep redis|grep -v grep  // 查看是否关闭</p>
</blockquote>
</li>
<li>
<p>删除usr/local/lib目录下与redis相关的所有文件</p>
<blockquote>
<p>ls -l /usr/local/bin/redis-* // 查看对应目录下所有redis开头的文件</p>
<p>rm -rf /usr/local/bin/redis-*  // 删除对应目录先所有redis开头的文件</p>
</blockquote>
</li>
</ol>
<h1 id="redis的10大数据类型"><a class="markdownIt-Anchor" href="#redis的10大数据类型"></a> Redis的10大数据类型</h1>
<p>官网查阅：<a target="_blank" rel="noopener" href="https://redis.io/docs/latest/commands/">Commands | Docs (redis.io)</a></p>
<h2 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型：</h2>
<h3 id="redis字符串string"><a class="markdownIt-Anchor" href="#redis字符串string"></a> redis字符串—String</h3>
<p>string是redis最基本的类型，一个key对应一个value。</p>
<p>string类型是<strong>二进制安全的</strong>，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p>
<h3 id="redis列表list"><a class="markdownIt-Anchor" href="#redis列表list"></a> redis列表—List</h3>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的<strong>头部（左边）或者尾部（右边）</strong></p>
<p>它的底层实际是个<strong>双端链表</strong>，最多可以包含 2^32 - 1 个元素 (4294967295, 每个列表超过40亿个元素)</p>
<h3 id="redis哈希表hash"><a class="markdownIt-Anchor" href="#redis哈希表hash"></a> redis哈希表—Hash</h3>
<p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<p>Redis 中每个 hash 可以存储 2^32 - 1 键值对（40多亿）</p>
<h3 id="redis集合set"><a class="markdownIt-Anchor" href="#redis集合set"></a> redis集合—Set</h3>
<p>Redis 的 Set 是 String 类型的<strong>无序集合</strong>。集合成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是 intset 或者 hashtable。</p>
<p>Redis 中Set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)</p>
<h3 id="redis有序集合zset"><a class="markdownIt-Anchor" href="#redis有序集合zset"></a> redis有序集合—ZSet</h3>
<p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p>
<p><strong>不同的是每个元素都会关联一个double类型的分数</strong>，redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p><strong>zset的成员是唯一的,但分数(score)却可以重复。</strong></p>
<p><strong>zset集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2^32 - 1</strong></p>
<h3 id="redis地理空间geo"><a class="markdownIt-Anchor" href="#redis地理空间geo"></a> redis地理空间—GEO</h3>
<p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，包括</p>
<p>添加地理位置的坐标。</p>
<p>获取地理位置的坐标。</p>
<p>计算两个位置之间的距离。</p>
<p>根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</p>
<h3 id="redis基数统计hyperloglog"><a class="markdownIt-Anchor" href="#redis基数统计hyperloglog"></a> redis基数统计—HyperLogLog</h3>
<p>HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<h3 id="redis位图bitmap"><a class="markdownIt-Anchor" href="#redis位图bitmap"></a> redis位图—bitmap</h3>
<p>由0和1状态表现的二进制位的bit数组</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/04/25/ZpLCe46UOGasFd1.png" alt="image-20240425094606943" /></p>
<h3 id="redis位域bitfield"><a class="markdownIt-Anchor" href="#redis位域bitfield"></a> redis位域—bitfield</h3>
<p>通过bitfield命令可以一次性操作多个<strong>比特位域(指的是连续的多个比特位)</strong>，它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果。</p>
<p>说白了就是通过bitfield命令我们可以一次性对多个比特位域进行操作。</p>
<h3 id="redis流stream"><a class="markdownIt-Anchor" href="#redis流stream"></a> redis流—Stream</h3>
<p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p>
<p>简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。</p>
<p>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失</p>
<h2 id="redis常用命令"><a class="markdownIt-Anchor" href="#redis常用命令"></a> redis常用命令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">keys *</td>
<td style="text-align:center">查看当前库中的所有key</td>
</tr>
<tr>
<td style="text-align:center">exists key</td>
<td style="text-align:center">判断某个key是否存在</td>
</tr>
<tr>
<td style="text-align:center">type key</td>
<td style="text-align:center">查看你的key是什么类型</td>
</tr>
<tr>
<td style="text-align:center">del key</td>
<td style="text-align:center">删除指定的key数据</td>
</tr>
<tr>
<td style="text-align:center">unlink key</td>
<td style="text-align:center">非阻塞删除，仅仅将keys充keysspace元数据中删除<br />真正的删除会在后续异步中操作</td>
</tr>
<tr>
<td style="text-align:center">ttl key</td>
<td style="text-align:center">查看还有多少秒过期，-1表示永不过期，-2表示已过期</td>
</tr>
<tr>
<td style="text-align:center">expire key(单位：秒)</td>
<td style="text-align:center">为指定的key设置过期时间</td>
</tr>
<tr>
<td style="text-align:center">move key dbindex[0-15]</td>
<td style="text-align:center">将当前数据库的key移动到给定的数据库db中</td>
</tr>
<tr>
<td style="text-align:center">select dbindex</td>
<td style="text-align:center">切换数据库0-15，默认为0</td>
</tr>
<tr>
<td style="text-align:center">dbsize</td>
<td style="text-align:center">查看当前数据库key的数量</td>
</tr>
<tr>
<td style="text-align:center">flushdb</td>
<td style="text-align:center">清空当前数据库</td>
</tr>
<tr>
<td style="text-align:center">flushall</td>
<td style="text-align:center">通杀全部库</td>
</tr>
</tbody>
</table>
<h2 id="数据类型命令及落地运用"><a class="markdownIt-Anchor" href="#数据类型命令及落地运用"></a> 数据类型命令及落地运用</h2>
<p><strong>Redis命令不区分大小写，Key区分大小写</strong></p>
<p>help @类型，help @String</p>
<h3 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h3>
<ol>
<li>
<p>set key value</p>
<blockquote>
<p>set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time- seconds | PXAT unix- time- milliseconds |KEEPTTL ]</p>
<p>SET命令有EX、PX、NX、x以及KEEPTTL五个可选参数，其中KEEPTTL为6.0版本添加的可选参数，其它为2.6.12版本添加的可选参数。</p>
<ul>
<li>EX seconds:以秒为单位设置过期时间</li>
<li>Px milliseconds:以毫秒为单位设置过期时间</li>
<li>EXAT timestamp:设置以秒为单位的UNIX时间戳所对应的时间为过期时间</li>
<li>PXAT milliseconds-timestamp: 设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间</li>
<li>NX:键不存在的时候设置键值</li>
<li>XX:键存在的时候设置键值</li>
<li>KEEPTTI:保留设置前指定键的生存时间</li>
<li>GET:返回指定键原本的值，若键不存在时返回nil</li>
</ul>
<p>SET命令使用EX、EX、NX参数，其效果等同于SETEX、PSETEX、SETNX命令。根据官方文档的描述，未来版本中SETEX、PSETEX、SETNX命令可能会被淘汰。</p>
<p>EXAT，PXAT以及GET为Redis 6.2新增的可选参数</p>
<p><strong>返回值</strong></p>
<p>设置成功则返回oK;返回ni1为未执行SET命令，如不满足NX、XX条件等</p>
<p>若使用GET参数，则返回该键原来的值，或在键不存在时返回nil。</p>
</blockquote>
<ul>
<li>set key value NX: 在key没有存在的时候能够设置成功，当key存在的时候无法设置成功</li>
<li>set key value XX：在key已存在的时候设置成功，不存在的时候无法设置成功</li>
<li>set key value get：在给key设置的时候，先返回key的值，然后再将value的值存入key中</li>
<li>set key value EX 10: 在设置key设置的时候，设置过期时间 EX为秒</li>
<li>set key value PX 10：在设置key设置的时候，设置过期时间 PX为毫秒</li>
<li>set key value EXAT 10：以时间戳为过期时间</li>
<li>set key value keepttl：设置key的时候，继承上一次的key设置时间</li>
</ul>
</li>
<li>
<p>get key</p>
</li>
<li>
<p>同时设置/获取多个键值</p>
<ul>
<li>mset：同时设置多个键值对-----mset k1 v1 k2 v2</li>
<li>mget：通过获取多个值-------mget k1 k2 k3</li>
<li>msetnx：设置多个值，key必须存在才能设置成功</li>
</ul>
</li>
<li>
<p>获取指定区间范围的值</p>
<ul>
<li>
<p>getrange：获取指定字符串的特定位置的字符</p>
<blockquote>
<p>set k1 123456789</p>
<p>getrange k1 0 -1  // 获取所有字符串</p>
<p>getrange k1 3 8  // 获取索引在3-8之间的所有字符</p>
</blockquote>
</li>
<li>
<p>setrange：设置指定字符串特定位置的字符串</p>
<blockquote>
<p>set k1 123456789</p>
<p>settrange k1 1 xy  // 将索引为1的字符替换为xy</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>数值增减</p>
<ul>
<li>INCR key：递增数字，默认是1，INCR key 3，一次递增三</li>
<li>DECR key：递减数字，默认是1，DECR key 3，一次递减三</li>
</ul>
</li>
<li>
<p>获取字符串长度和内容增加</p>
<ul>
<li>STRLEN k1：获取k1中的字符串长度</li>
<li>APPEND k1 xxx：向k1中的字符串后面添加xxx</li>
</ul>
</li>
<li>
<p>分布式锁：</p>
<ul>
<li>当有多个微服务同时争抢一个资源的时候可以使用redis来进行分布式锁</li>
</ul>
<p>命令：</p>
<ul>
<li>setex key 过期时间 value，创建k-v键值对的时候设置过期时间</li>
<li>setnx key value 如果key不存在才进行创建</li>
</ul>
</li>
<li>
<p>getset 命令</p>
<p>getset key value：先将key的值取出来，然后在给它赋值新值</p>
</li>
</ol>
<h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h3>
<p>本质是双端列表，左边右边都可操作，有序</p>
<ol>
<li>插入：
<ul>
<li>LPUSH：从左边插入，LPUSH list1 1 2 3 4 5</li>
<li>RPUSH：从右边插入，RPUSH list2 11 22 33 44 55</li>
</ul>
</li>
<li>遍历：
<ul>
<li>LRANGE KEY start stop：从左边遍历第一个参数是key，第二第三个参数是开始和结束的索引</li>
</ul>
</li>
<li>删除
<ul>
<li>LPOP：从左边弹出，LPOP list1</li>
<li>RPOP：从右边弹出，RPOP list2</li>
</ul>
</li>
<li>取元素
<ul>
<li>LINDEX：按照索引取元素（从上到下），LINDEX  KEY index</li>
</ul>
</li>
<li>获取list长度
<ul>
<li>LLEN：获取列表中元素的个数，LLEN key</li>
</ul>
</li>
<li>删除指定元素
<ul>
<li>LREM key 数字N 给定值V1，删除N个值为V1的元素，如果key中值V1的个数小于N则全部删除</li>
</ul>
</li>
<li>截取list
<ul>
<li>LTRIM key start stop， 截取key中位置从start 到 stop位置的元素</li>
</ul>
</li>
<li>提取key1中的元素给key2
<ul>
<li>RPOPLPUSH 源列表 目的列表，将源列表右边第一个元素提到目的列表左边第一个元素</li>
</ul>
</li>
<li>替换指定位置的元素
<ul>
<li>LSET key index value：将key中从左边开始算起index位置的元素替换成value</li>
</ul>
</li>
<li>插入指定位置
<ul>
<li>LINSERT key before/after 已有值 插入新值：在key列表中值为已有值的前面插入新值</li>
</ul>
</li>
</ol>
<h3 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> Hash</h3>
<p>K不变V是一个KV键值对</p>
<ol>
<li>设置元素
<ul>
<li>HSET key k1 v1 k2 v2：key是键 k1是键1</li>
<li>HMSET key k1 v2 k2 v2：同时设置多个值</li>
<li>HSETNX key k1 v1：存在则不添加，不存在则添加</li>
</ul>
</li>
<li>获取元素
<ul>
<li>HGET key k1：获取key中键为k1的值</li>
<li>HMGET key k1 k2 k3：通过获取多个值</li>
<li>HGETALL key ：将key中的所有键值对遍历出来</li>
</ul>
</li>
<li>删除元素
<ul>
<li>HDEL key k1：将key中键为k1的删掉</li>
</ul>
</li>
<li>获取某个KEY中的所有键值对的数量
<ul>
<li>HLEN key</li>
</ul>
</li>
<li>判断KEY中是否存在键为k1的键值对
<ul>
<li>HEXISTS key k1</li>
</ul>
</li>
<li>获取某个hash中的全部key，或者全部value
<ul>
<li>HKEYS KEY：获取全部的键</li>
<li>HVALS KEY：获取全部的值</li>
</ul>
</li>
<li>增加整数或小数
<ul>
<li>HINCRBY KEY K1 1：增加KEY的hash表中的值为K1的值加一</li>
<li>HINCRBYFLOAT KEY K1 0.1</li>
</ul>
</li>
</ol>
<h3 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h3>
<p>单值多values，values不重复，无序</p>
<ol>
<li>添加元素
<ul>
<li>SADD KEY V1 V2 V3</li>
</ul>
</li>
<li>遍历元素
<ul>
<li>SMEMBERS KEY：将KEY中的元素全部遍历出来</li>
</ul>
</li>
<li>查询数据元素是否存在
<ul>
<li>SISMEMBER KEY value：判断value是否在KEY里面</li>
</ul>
</li>
<li>删除元素
<ul>
<li>SREM KEY VALUE：将KEY中值为VALUE的元素删除</li>
</ul>
</li>
<li>通过集合里面有多少个元素
<ul>
<li>SCARD KEY</li>
</ul>
</li>
<li>随机获取集合中的元素，不会改变源集合
<ul>
<li>SRANDMEMBER KEY NUM：随机展示KEY中数量为NUM的元素</li>
</ul>
</li>
<li>随机获取集合中的元素，会改变源集合
<ul>
<li>SPOP KEY NUM：随机展示KEY中数量为NUM的元素</li>
</ul>
</li>
<li>数据迁移，将KEY中的数据迁移到KEY2中
<ul>
<li>SMOVE KEY1 KEY2 value：将KEY1中的value迁移到KEY2中</li>
</ul>
</li>
<li>集合运算
<ul>
<li>差集：SDIFF KEY1 KEY2：获取在KEY1中但不在KEY2中的元素</li>
<li>并集：SUNION KEY1 KEY2：获取KEY1和KEY2的并集</li>
<li>交集：SINTER KEY1 KEY2：获取即余数KEY1也属于KEY2的</li>
</ul>
</li>
</ol>
<h3 id="zset"><a class="markdownIt-Anchor" href="#zset"></a> ZSET</h3>
<p>有序集合</p>
<p>在SET的基础上每一个VAL值前加一个score分数值，之前set是set K1 v1 v2 v3，现在ZSET是Zset k1 scor1e v1 score2 v2</p>
<ol>
<li>添加元素</li>
</ol>
<ul>
<li>ZADD：ZADD score 10 zhang 20 li，再添加元素的时候需要给元素设置上分数</li>
</ul>
<ol start="2">
<li>获取元素
<ul>
<li>从小到大   获取元素的值：ZRANGE score 0 -1</li>
<li>从小到大  获取元素的值和分数：ZRANGE score 0 -1 WITHSCORES</li>
<li>从大到小  获取元素的值：ZREVRANGE score 0 -1</li>
<li>从小到大  获取元素的值和分数：ZREVRANGE score 0 -1 WITHSCORES</li>
<li>根据分数来获取元素：ZRANGEBYSCORE score 60 90 LIMIT 0 2，可以使用LIMIT来限制显示的个数</li>
<li>根据分数来获取元素和分数：ZRANGEBYSCORE score 60 90 WITHSCORE   默认是 60 &lt;= 分数 &lt;= 90 ，如果加上小括号则表示不包含断点分数 ZRANGEBYSCORE score (60 90 WITHSCORE</li>
</ul>
</li>
<li>获取元素分数
<ul>
<li>ZSCORE zset v2</li>
</ul>
</li>
<li>获取集合中元素的个数
<ul>
<li>ZCARD KEY</li>
</ul>
</li>
<li>删除集合中的元素
<ul>
<li>ZREM zset value</li>
</ul>
</li>
<li>增加对应value的分数
<ul>
<li>ZINCRBY key increment value：给值为value的元素添加increment 分</li>
</ul>
</li>
<li>获取指定分数段的元素的个数
<ul>
<li>ZCOUNT key min max</li>
</ul>
</li>
<li>从ZET对象中第一个非空排序集中弹出一个或多个元素，他们是成员分数对
<ul>
<li>ZMPOP myset MIN COUNT NUM：从myset中弹出最小的元素，弹出NUM个</li>
</ul>
</li>
<li>获取对应元素下标
<ul>
<li>ZRANK key values：获取values在key中的下标值    顺序</li>
<li>ZREVRANK key values：获取values在key中的下标值    逆序</li>
</ul>
</li>
</ol>
<h3 id="bitmap位图"><a class="markdownIt-Anchor" href="#bitmap位图"></a> BitMap位图</h3>
<p>用于状态判断</p>
<ol>
<li>设置状态
<ul>
<li>SETBIT bit1 index (0 or 1)：给bit1的index位置设置为0或1</li>
</ul>
</li>
<li>获取状态
<ul>
<li>GETBIT bit1 index：获取bit1index位置的数据</li>
</ul>
</li>
<li>获取bit的字节数
<ul>
<li>STRLEN bit1：获取bit1的字节数，八位一组</li>
</ul>
</li>
<li>获取bit键里面1的个数：
<ul>
<li>BITCOUNT：全部键里面含有1的个数</li>
</ul>
</li>
<li>对不同的二进制存储数据进行位运算
<ul>
<li>BITOP OPERATION destkey key：OPERATION运算符包括：AND OR NOT XOR</li>
</ul>
</li>
</ol>
<h3 id="hyperloglog基数统计"><a class="markdownIt-Anchor" href="#hyperloglog基数统计"></a> HyperLogLog基数统计</h3>
<p>去重统计功能的基数估计算法，**不能存储数据，之鞥呢发挥去重之后的基数个数 **</p>
<p>基数统计：统计一个集合中不重复的元素个数，就是对集合去重复后剩余元素的计算</p>
<ol>
<li>添加元素
<ul>
<li>PFADD hello1 1 3 4 5 7 9:</li>
</ul>
</li>
<li>返回给定的HyperLogLog的基数估算值：
<ul>
<li>PFCOUNT key</li>
</ul>
</li>
<li>将多个HyperLogLog合并为一个HyperLogLog
<ul>
<li>PFMERGE dest source1 source2</li>
</ul>
</li>
</ol>
<h3 id="地理空间geo"><a class="markdownIt-Anchor" href="#地理空间geo"></a> 地理空间GEO</h3>
<ol>
<li>添加地理位置
<ul>
<li>GEOADD city 精度 维度 地点</li>
<li>如果有乱码需要执行 redis-cli --raw命令来处理中文乱码</li>
</ul>
</li>
<li>返回对应地理位置
<ul>
<li>GEOPOS city 地点1 地点2</li>
<li>返回坐标用HASH表示：GEOHASH返回坐标用HASH表示</li>
</ul>
</li>
<li>返回两个位置之间的距离
<ul>
<li>GEODITS 地点1 地点2 （m, km）</li>
</ul>
</li>
<li>以半径为中心返回查找附近的地点
<ul>
<li>GEORADIUS city 经度 维度 10KM WITHDIST WITHCOORD WITHHASH COUNT</li>
<li>WITHDIST:在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li>
<li>WITHCOORD:将位置元素的经度和维度也一并返回。</li>
<li>WITHHASH:以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试实际中的作用并不大</li>
<li>COUNT 限定返回的记录数</li>
</ul>
</li>
<li>给定地点查找改地点周围的地点
<ul>
<li>GEORADIUSMEMBER city 天安门 10KM WITHDIST WITHCOORD WITHHASH COUNT</li>
</ul>
</li>
</ol>
<h3 id="redis流stream-2"><a class="markdownIt-Anchor" href="#redis流stream-2"></a> Redis流（Stream）</h3>
<p>就是Redis版本的<strong>消息中间件</strong></p>
<p>redis5.0之前的消息队列实现两种方法：</p>
<ol>
<li>
<p>List实现消息队列，LPUSH 和 RPOP，一进一出</p>
</li>
<li>
<p>订阅方式：PUB/SUB，一个生产方多个消费方</p>
<p>缺点：无法持久化，如果一个消费者都没有则会丢失消息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/08/13/mB7JYF1x8VCg245.png" alt="image-20240813211445648" /></p>
</li>
</ol>
<p><strong>Stream作用</strong>：实现消息队列，它支持消息的持久化、支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠</p>
<p><strong>Stream结构</strong>：</p>
<p>一个消息链表，将所有加入的消息都串起来，每一个消息都有一个唯一的ID和对应的内容</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/08/13/MHqQG24EWciR9XV.png" alt="image-20240813212002806" /></p>
<table>
<thead>
<tr>
<th style="text-align:center">需要</th>
<th style="text-align:center">标识</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">Message Content</td>
<td style="text-align:center">消息内容</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Consumer group</td>
<td style="text-align:center">消费组，通过XGROUP CREATE 命令创建，同一个<br />消费组可以有多个消费者</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">Last_delivered_id</td>
<td style="text-align:center">游标，每一个消费组都有一个游标Last_delivered_id，任意一个消费者读取了消息<br />都会使游标Last_delivered_id往前移动</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">Consumer</td>
<td style="text-align:center">消费者，消费组中的消费者</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">Pending_ids</td>
<td style="text-align:center">消费者会有一个状态变量，用于记录被当前消费已读取但未ack的消息Id，如果客户端没有ack，这个变量里<br/>面的消息ID会越来越多，一旦某个消息被ack它就开始减少。这个pending ids变量在Redis官方被称之为<br/>PEL(Pending Entries List)，记录了当前已经被客户端读取的消息，但是还没有 ack(Acknowledge<br/>character:确认字符)，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理</td>
</tr>
</tbody>
</table>
<p><strong>队列相关命令—操作消息增删改</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">指令名称</th>
<th style="text-align:center">指令作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">XADD</td>
<td style="text-align:center">将消息添加到消息队列队尾</td>
</tr>
<tr>
<td style="text-align:center">XTREM</td>
<td style="text-align:center">限制Stream的长度，如果已经超出会进行截取</td>
</tr>
<tr>
<td style="text-align:center">XDEL</td>
<td style="text-align:center">删除消息</td>
</tr>
<tr>
<td style="text-align:center">XLEN</td>
<td style="text-align:center">获取Stream中的消息长度</td>
</tr>
<tr>
<td style="text-align:center">XRANGE</td>
<td style="text-align:center">获取消息列表（可以指定范围），忽略删除的信息</td>
</tr>
<tr>
<td style="text-align:center">XREVERANGE</td>
<td style="text-align:center">和XRANGE的区别在于反向获取，从小到大</td>
</tr>
<tr>
<td style="text-align:center">XREAD</td>
<td style="text-align:center">获取消息（阻塞/非阻塞），返回大于指定ID的消息</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>XADD：将消息添加到消息队列队尾，消息ID必须比上一个ID大，默认用*号表示自动生成规矩，用户XADD命令中让系统自动生成ID</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD myStream * k1 v1 k2 v2</span><br></pre></td></tr></table></figure>
<p>XADD 用于向Stream 队列中添加消息，如果指定的Stream 队列不存在，则该命令执行时会新建一个Stream 队列</p>
<p>//*号表示服务器自动生成 MessageID(类似mysql里面主键auto_increment)，后面顺序跟着一堆 业务key/value</p>
</li>
<li>
<p>XRANGE：获取消息列表（可以指定范围），忽略删除的信息</p>
<p>start表示开始的值，- 代表最小值</p>
<p>end表示结束的值，+ 代表最大值</p>
<p>count表示最多可以获取多少个，如果不写则表示获取全部</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XRANGE myStream - + COUNT 1</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>XREVERANGE：和XRANGE的区别在于反向获取，从小到大</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XRANGE myStream + - COUNT 1</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>XDEL：删除消息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XDEL myStream 时间戳ID</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>XLEN：获取Stream中的消息长度</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XLEN myStream</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>XTREM：用于对Stream的长度进行截取，如果超长就会进行截取</p>
<p>MAXLEN：允许的最大长度对流进行修剪长度</p>
<p>MINID：允许的最小ID</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XTRIM myStream maxlen 2</span><br><span class="line">XTRIM myStream minid 165464</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>XREAD：获取消息（阻塞/非阻塞），返回大于指定ID的消息</p>
<p><strong>非阻塞：</strong></p>
<p>$代表特殊ID，表示以当前stream已经存储的最大的ID作为最后一个ID，当前Stream中不存在大于当前最大ID的消息，因此此时返回nil</p>
<p>0-0代表从最小的ID开始获取Stream中的消息，当不指定count，将会返回Stream中的所有消息，注意也可以使用0(00/000也都是可以的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XREAD count 2 streams myStream $</span><br><span class="line">XREAD count 2 streams myStream 0-0</span><br></pre></td></tr></table></figure>
<p><strong>阻塞：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREAN count 1 block 0 streams myStream $  // 获取比当前队列最大的ID还大的一条数据，并进行阻塞等待获取，等有了之后就输出</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>消费组相关指令</strong></p>
<ol>
<li>
<p>XGROUP CREATE：创建消费者组</p>
<p>$表示从Stream尾部开始消费</p>
<p>0表示从Stream头部开始消费</p>
<p>创建消费者组的时候必须指定 ID,ID 为 0 表示从头开始消费，为 $表示只消费新的消息，<strong>队尾新来</strong></p>
<p>为消息队列myStream创建一个消费者组groupA 并从队尾开始消费，只消费最新消息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE myStream groupA $</span><br><span class="line">XGROUP CREATE myStream groupB 0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>XREADGROUP GROUP</p>
<p>stream中的消息<strong>一旦被消费组里的一个消费者读取了</strong>，就不能再被<strong>该消费组</strong>内的<strong>其他消费者读取</strong>了，即同一个消费组里的消费者不能消费同一条消息。刚才的XREADGROUP命令再执行次，此时读到的就是空值，<strong>但是不同消费组的消费者可以消费同一条消息</strong></p>
<p>“&gt;”：表示从第一条尚未被消费的消息开始读取</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP groupA(指定消费者组)   consumer1(创建消费者名称)   streams myStream(要消费的消息队列名称) &gt;</span><br></pre></td></tr></table></figure>
<p>通过COUNT将消息队列分发出去让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP gropuC consumer1 count 1 streams myStream</span><br><span class="line">XREADGROUP GROUP gropuC consumer2 count 1 streams myStream</span><br><span class="line">XREADGROUP GROUP gropuC consumer3 count 1 streams myStream</span><br></pre></td></tr></table></figure>
<p>将myStream中的消息分为三个消费者来进行读取</p>
</li>
<li>
<p>XPENDING：查询每个消费者组内所有消费者<strong>已读但未确认</strong>的消息</p>
<p><strong>问题</strong>：基于 stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息?<br />
<strong>解决</strong>：Streams 会自动使用内部队列(也称为 PENDING List)留存消费组里每个消费者读取的消息保底措施，<strong>直到消费者使用 XACK命令通知 Streams&quot;消息已经处理完成&quot;</strong>。<strong>消费确认增加了消息的可靠性</strong>，一般在<strong>业务处理完成之后</strong>，<strong>需要执行XACK命令确认消息已经被消费完成</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/08/13/3oiJOxYQGveMbDn.png" alt="image-20240813222141540" /></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XPENDING myStream groupA - + 10 consumer2</span><br><span class="line">//获取消费者组groupA读取myStream但未确认的条数和起始结束ID，和组内每一个消费者读取消息的个数</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>XACK确认消息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XACK myStream groupC 46545646546(消息ID)</span><br><span class="line">//对groupC里面的对应ID的消息进行确认，确认完毕之后在使用XPENDING进行获取，就无法获取对应的消息了</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>XINFO：打印消息队列的信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XINFO stream myS</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="redis持久化"><a class="markdownIt-Anchor" href="#redis持久化"></a> Redis持久化</h1>
<h2 id="rdb数据库"><a class="markdownIt-Anchor" href="#rdb数据库"></a> RDB数据库</h2>
<h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3>
<p>RDB持久性以指定的时间间隔执行数据集的时间点快照</p>
<p>实现类似照片记录效果的方式，就是把某一时刻的数据和状态以文件的形式写到磁盘上，也就是快照。这样一来即使故障宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为<strong>RDB文件(dump.rdb)</strong>，其中，RDB就是Redis DataBase的缩写</p>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用：</h3>
<p>在指定是时间内将内存中的数据集快照写入磁盘，也就是将<strong>Snapshot内存快照</strong>，它恢复的时候再将磁盘快照文件读回内存中</p>
<p>Redis在执行快照的时候会将内存中所有的数据都记录到磁盘中</p>
<h3 id="保存频率"><a class="markdownIt-Anchor" href="#保存频率"></a> 保存频率</h3>
<p>Redis7以前：</p>
<blockquote>
<p>save 900 1：每间隔900秒（15分钟）有一次发生变化的，就进行一次快照</p>
<p>save 300 10 : 每间隔300秒（5分钟）有十次发生变化，就进行一个快照处理</p>
<p>save 60 10000：每间隔60秒（一分钟）有10000发生变化，就进行一个快照</p>
</blockquote>
<p>Redis7之后</p>
<blockquote>
<p>save 3600 1 : 每间隔3600秒（一小时）有一次发生变化的，就进行一次快照</p>
<p>save 300 100 : 每间隔300秒（5分钟）有100次发生变化的，就进行一次快照</p>
<p>save 60 10000 : 每间隔60秒（一分钟）有10000次发生变化的，就进行一次快照</p>
</blockquote>
<h3 id="自动触发"><a class="markdownIt-Anchor" href="#自动触发"></a> 自动触发</h3>
<p>修改Redis配置文件，按照redis.conf里配置的save &lt; second &gt; &lt; changes &gt; 在多少秒内有多少次修改就会进行保存，搜索Snapshot能找到</p>
<p>修改dump.rdb文件保存路径：搜索dir 能找到 dir ./  可以将“./”修改成我们自己的路径</p>
<p>修改dump.rdb文件保存名称：搜索dump.rdb找到 dbfilename dump.rdb，修改dump.rdb进行保存即可</p>
<p>等待我们在second秒内修改次数超过changes次之后就会触发自动保存，保存在dump.rdb文件中</p>
<h3 id="手动触发"><a class="markdownIt-Anchor" href="#手动触发"></a> 手动触发</h3>
<p>save：会阻塞当前的Redis服务器，直到持久化工作完成，在save执行期间Redis不能处理其他命令，<strong>线上禁止使用</strong></p>
<p>bgsave：该方式会fork一个子进程，不会阻塞当前主进程，主进程和保存进程会同时进行</p>
<h3 id="恢复文件"><a class="markdownIt-Anchor" href="#恢复文件"></a> 恢复文件</h3>
<p>当我们使用flushall/flushdb（清空当前数据库中的所有键）命令后Redis会自动产生dump.rdb文件，但里面是空的没有意义</p>
<p>我们使用shutdown命令关闭服务的时候也会自动产生dump.rdb文件</p>
<p>等待Redis服务器重启的时候会自动去配置的文件夹底下寻找配置的文件，然后将其中对应的数据进行恢复</p>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
<ol>
<li>适合大规模的数据恢复</li>
<li>按照业务定时备份</li>
<li>对数据完整性和一致性要求不高</li>
<li>RDB文件在内存中加载速度要比AOF快的多</li>
</ol>
<h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3>
<p>在Redis服务器宕机的时候数据不能完整的保存下来，只能够尽量避免数据丢失</p>
<p>Redis需要经常fork子进程在磁盘上进行持久化，如果数据很大fork可能会很耗时</p>
<h3 id="检查和修复rdb文件"><a class="markdownIt-Anchor" href="#检查和修复rdb文件"></a> 检查和修复RDB文件</h3>
<p>使用命令redis-check-rdb “指定rdb文件路径”</p>
<h3 id="禁用快照rdb"><a class="markdownIt-Anchor" href="#禁用快照rdb"></a> 禁用快照RDB</h3>
<p>动态停止RDB保存规则：redis-cli config set save “”</p>
<p>配置禁用：打开redis.config配置文件中将注掉的save “” 打开即可</p>
<h3 id="redis优化配置项详解"><a class="markdownIt-Anchor" href="#redis优化配置项详解"></a> Redis优化配置项详解</h3>
<p>在Redis.config配置文件SNAPSHOTTING模块中进行配置</p>
<ol>
<li>SAVE &lt; SECONDS &gt; &lt; CHANGES &gt;：配置RDB文件自动保存触发条件在seconds秒内，发生了changes次修改就会触发自动保存</li>
<li>dbfilename：配置自动保存文件名</li>
<li>dir：配置自动保存文件路径</li>
<li>stop-writes-on-bgsave-error ：默认yes，如果配置成no，表示你<strong>不在乎数据不一致或者有其他的手段发现和控制这种不一致</strong>，那么<strong>在快照写入失败时</strong>。<strong>也能确保redis继续接受新的写请求</strong></li>
<li>rdbcompression ：默认yes，对于存储到磁盘中的快照，可以<strong>设置是否进行压缩存储</strong>。如果是的话，<strong>redls会采用LZF算法进行压缩</strong>。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能</li>
<li>rdbchecksum：默认yes，在存储快照后，还可以<strong>让redis使用CRC64算法来进行数据校验</strong>，但是<strong>这样做会增加大约10%的性能消耗</strong>，如果希望获取到最大的性能提升。可以关闭此功能</li>
<li>rdb-del-sync-files：在没有持久性的情况下删除复制中使用的RDB文件启用。默认情况下no，此选项是禁用的。</li>
</ol>
<h2 id="aof持久化"><a class="markdownIt-Anchor" href="#aof持久化"></a> AOF持久化</h2>
<p>以日志形式记录每一个写操作，<strong>只许追加文件但不可以改写文件</strong>，<strong>redis启动之初会读取该文件重新构建数据</strong>，换言之，redis<br />
重启的话就<strong>根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</strong></p>
<p>默认情况下redis是没有开启AOF的，如果要开启AOF功能需要设置配置appendonly yes</p>
<p>AOF保存的appendonly.aof文件</p>
<ol>
<li>
<p>Client作为命令的来源，会有多个源头以及源源不断的请求命令。</p>
</li>
<li>
<p>在这些命今到达Redis Server 以后并不是直接写入AOF文件，会将其这些命令先放入AOF缓存中进行保存。这里的AOF缓冲区实际上是内存中的一片区域，存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘IO操作。</p>
</li>
<li>
<p>AOF缓冲会根据AOF缓冲区<strong>同步文件的三种写回策略</strong>将命令写入磁盘上的AOF文件。</p>
<blockquote>
<p>Always：同步写回，每个写命令执行完毕之后立刻同步的将日志写回磁盘</p>
<p>everysec：每秒写回，<strong>默认写回方式</strong>，每个写命令执行完毕之后先把日志写到AOF缓冲区中，每隔一秒将缓冲区的内容写到aof文件中</p>
<p>no：操作系统控制的写回，每个写命令执行完毕之后，先把日志文件写到AOF的内存缓冲区中，由操作系统决定什么时候写回磁盘</p>
</blockquote>
</li>
<li>
<p>随着写入AOF内容的增加为避免文件膨胀，会根据规则进行命令的合并(又称<strong>AOF重写</strong>)，从而起到AOF文件压缩的目的。</p>
</li>
<li>
<p>重启redis之后会从AOF文件中读取命令进行数据恢复</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/08/18/iQfOBnCu5cKhswS.png" alt="image-20240818173856943" /></p>
<h3 id="功能配置"><a class="markdownIt-Anchor" href="#功能配置"></a> 功能配置</h3>
<p>开启AOF：在redis.confg配置文件中找到 appendonly 配置项，在后面写上yes开启AOF功能，默认是NO</p>
<p>使用默认写回策略：appendfsync everysec</p>
<p>设置AOF的保存路径</p>
<blockquote>
<p>redis6之前：RDB和AOF保存路径是相同的，设置一个dir，RDB和AOF都会公用这个文件夹</p>
<p>redis7之后：dir是RDB的文件存放路径，在redis.conf中还有一个配置项appenddirname，AOF会存放在 dir/appenddirname/xxx.aof</p>
</blockquote>
<p>设置AOF文件保存名称：</p>
<blockquote>
<p>redis7之前：在redis.conf配置文件中设置 appendfilename 配置项来配置AOF保存文件名</p>
<p>redis7之后：有三个基本文件</p>
<ol>
<li>BASE基本文件：表示基本AOF，一般有子进程通过重写产生，该文件只存在一个 appendonly.aof.1.base.rdb</li>
<li>INCR增量文件：表示增量AOF，一般会在AOFRW开始执行时被创建，该文件可能存在多个 appendonly.aof.1.incr.rdb</li>
<li>HISTORY：表示历史AOF，它是有BASE和INCR变化而来，每次AOFRW成功完成之后，本次AOFRW之前对应的BASE和INCRAOF都会变成HISTORY，HISTORY类型的AOF会被REDIS自动删除</li>
</ol>
<p>manifest清单文件：来管理这些AOF文件  appendonly.aof.manifest</p>
</blockquote>
<h3 id="恢复操作"><a class="markdownIt-Anchor" href="#恢复操作"></a> 恢复操作</h3>
<h4 id="正常恢复"><a class="markdownIt-Anchor" href="#正常恢复"></a> <strong>正常恢复</strong></h4>
<p>在redis重启的时候会去指定文件夹内读取aof文件来恢复数据</p>
<h4 id="异常恢复"><a class="markdownIt-Anchor" href="#异常恢复"></a> <strong>异常恢复</strong></h4>
<p>AOF一秒写一次，但是AOF可能写的文件较多，在一秒之内没写完redis就宕机了，会导致AOF文件出错，AOF文件出错，会导致redis服务无法正常启动</p>
<p>需要使用redis-check-aof --fix进行文件修复，一定要加–fix</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix <span class="string">&quot;需要修复的文件路径/appendonlu.aof.*&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3>
<p>更好的保存数据不丢失，性能高，可做紧急恢复</p>
<ol>
<li>使用AOF redis更加持久：可以有不同的fsync策略：Always， everysec， no，即使丢失也只有1s的丢失，能接受</li>
<li>AOF日志是一个仅附加日志，因此不会出现寻道问题，也不会在断电时出现损坏问题。即使由于某种原因(磁盘已满或其他原因)日志以写一半的命令结尾，redis-check-aof 工具也能够轻松修复它。</li>
<li>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。重写是完全安全的，因为当 Redis 继续附加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis就会切换两者并开始附加到新的那一个。</li>
<li>AOF 以易于理解和解析的格式依次包含所有操作的日志。<strong>甚至可以轻松导出 AOF 文件</strong>。例如，<strong>即使不小心使用该FLUSHALL命令刷新了所有内容</strong>，<strong>只要在此期间没有执行日志重写</strong>，您仍然<strong>可以通过停止服务器</strong>、<strong>删除最新命令并重新启动 Redis 来保存您的数据集</strong></li>
</ol>
<h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3>
<ol>
<li>AOF 文件通常比相同数据集的等效 RDB 文件大。</li>
<li>根据确切的 fsync 策略，AOF 可能比 RDB 慢。一般来说，将 fsync 设置为每秒性能仍然非常高，并且在禁用 fsync 的情况下，即使在高负载下它也应该与 RDB 一样快。即使在巨大的写入负载的情况下，RDB 仍然能够提供关于最大延迟的更多保证。</li>
</ol>
<h3 id="aof重写机制"><a class="markdownIt-Anchor" href="#aof重写机制"></a> AOF重写机制</h3>
<p>由于AOF持久化是Redis不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大,文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。</p>
<p>为了解决这个问题，<strong>Redis新增了重写机制</strong>，当AOF文件的大小超过所设定的峰值时，Redis就会自动启动AOF文件的内容压缩。<br />
只保留可以恢复数据的最小指令集，或者可以<strong>手动使用命令 bgrewriteaof 来重写</strong></p>
<p><strong>启动AOF的文件内容压缩，只保留可以恢复数据的最小指令集</strong></p>
<blockquote>
<p>例如对一个key进行多次操作之后，重写完之后只保留最后一次写操作</p>
<p>set k1 1</p>
<p>set k1 2</p>
<p>set k1 3</p>
<p>重写之后只保留set k1 3</p>
</blockquote>
<h4 id="触发机制"><a class="markdownIt-Anchor" href="#触发机制"></a> 触发机制</h4>
<p>在redis.conf文件中有两个配置项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>
<p>注意 ，同时满足，且的关系会触发</p>
<ol>
<li>根据上次重写后的aof大小，判断当前aof大小是不是增长了1倍</li>
<li>重写时满足的文件大小</li>
</ol>
<p><strong>自动触发</strong>：满足上诉配置项之后进行重写，重写之后 会将incr文件内容压缩完之后放入 appendonly.aof.1.base.rdb中，并且会改变base文件名称为appendonly.aof.2.base.rdb，改变文件名称 appendonly.aof.1.incr.rdb为 appendonly.aof.2.incr.rdb</p>
<p><strong>手动触发</strong>：使用bgrewriteaof命令来进行手动重写</p>
<p><strong>也就是说 AOF 文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个</strong><br />
<strong>键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件</strong>。</p>
<p>AOF 文件重写触发机制:通过 redis.conf配置文件中的 auto-aof-rewrite-percentage:默认值为100，以及auto-aof-rewrite<br />
min-size:64mb 配置，也就是说默认Redis会记录上次重写时的AOF大小，<strong>默认配置是当AOF文件大小是上次rewrite后大小的一倍</strong><br />
<strong>且文件大于64M时触发</strong>。</p>
<h4 id="重写原理"><a class="markdownIt-Anchor" href="#重写原理"></a> 重写原理</h4>
<ol>
<li>在重写开始前，redis会创建一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析乐缩并写入到一个临时文件中。</li>
<li>与此同时，主进程会将<strong>新接收到的写指令一边累积到内存缓冲区中</strong>，<strong>一边继续写入到原有的AOF文件中</strong>，这样做是<strong>保证原有的AOF文件的可用性</strong>，避免在重写过程中出现意外。</li>
<li>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中</li>
<li>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中，重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</li>
</ol>
<h4 id="配置命令"><a class="markdownIt-Anchor" href="#配置命令"></a> 配置命令</h4>
<table>
<thead>
<tr>
<th style="text-align:center">配置指令</th>
<th style="text-align:center">配置含义</th>
<th style="text-align:center">配置示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">appendonly</td>
<td style="text-align:center">是否开启 aof</td>
<td style="text-align:center">appendonly yes</td>
</tr>
<tr>
<td style="text-align:center">appendfilename</td>
<td style="text-align:center">文件名称</td>
<td style="text-align:center">appendfilename &quot;appendonly.aof’</td>
</tr>
<tr>
<td style="text-align:center">appendfsync</td>
<td style="text-align:center">同步方式</td>
<td style="text-align:center">everysec/always/no</td>
</tr>
<tr>
<td style="text-align:center">no-appendfsync-on-rewrite</td>
<td style="text-align:center">aof 重写期间是否同类</td>
<td style="text-align:center">no-appendfsync-on-rewrite no</td>
</tr>
<tr>
<td style="text-align:center">auto-aof-rewrite-percentage<br/>auto-aof-rewrite-min-size</td>
<td style="text-align:center">重写触发配置、文件重写策略</td>
<td style="text-align:center">auto-aof-rewrite-percentage 100<br/>auto-aof-rewrite-min-size 64mb</td>
</tr>
</tbody>
</table>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/08/18/jw14ZyBS76xiRn2.png" alt="image-20240818231813220" /></p>
<h2 id="rdb-aof混合持久化"><a class="markdownIt-Anchor" href="#rdb-aof混合持久化"></a> RDB-AOF混合持久化</h2>
<p>AOF默认不开，开启之后AOF优先级较高</p>
<h3 id="数据恢复顺序和加载流程"><a class="markdownIt-Anchor" href="#数据恢复顺序和加载流程"></a> 数据恢复顺序和加载流程</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/08/18/QpRWKiMuXzlOnIe.png" alt="image-20240818232431221" /></p>
<h3 id="如何选择"><a class="markdownIt-Anchor" href="#如何选择"></a> 如何选择</h3>
<p><strong>RDB持久化</strong>方式能够在<strong>指定的时间间隔能对你的数据进行快照存储</strong></p>
<p><strong>AOF持久化</strong>方式<strong>记录每次对服务器写的操作</strong>,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.</p>
<p><strong>推荐混合使用</strong></p>
<p><strong>先使用RDB进行快照存储</strong>，<strong>然后使用AOF持久化记录所有的写操作</strong>，当重写策略满足或手动触发重写的时候，<strong>将最新的数据存储为新的RDB记录</strong>。这样的话，重启服务的时候会从RDB和AOF两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。简单来说:混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。----》<strong>AOF包括了RDB头部+AOF混写</strong></p>
<h2 id="纯缓存模式"><a class="markdownIt-Anchor" href="#纯缓存模式"></a> 纯缓存模式</h2>
<p>同时关闭RDB和AOF获取极致的性能</p>
<p>在配置文件中设置</p>
<p>禁用rdb持久化的模式下也可使用时命令save和bgsave生成rdb文件</p>
<p>禁用AOF持久化的模式下也可使用时命令bgrewriteaof生成rdb文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save <span class="string">&quot;&quot;</span></span><br><span class="line">appendonly no</span><br></pre></td></tr></table></figure>
<h1 id="redis事务"><a class="markdownIt-Anchor" href="#redis事务"></a> Redis事务</h1>
<p><strong>本质</strong>：可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，<strong>按顺序地串行化执行而不会被其它命令插入，不许加塞</strong></p>
<p><strong>作用</strong>：一个队列中一次性，顺序性，排他性的执行一系列操作</p>
<table>
<thead>
<tr>
<th style="text-align:center">特点</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单独的隔离操作</td>
<td style="text-align:center">Redis的事务<strong>仅仅是保证事务里的操作会被连续独占的执行</strong>，<br />redis命令执行是单线程架构，<br />在<strong>执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的</strong></td>
</tr>
<tr>
<td style="text-align:center">没有隔离级别的概念</td>
<td style="text-align:center">因为事务提交前任何指令都不会被实际执行，<br />也就不存在&quot;事务内的査询要看到事务里的更新，<br />在事务外查询不能看到&quot;这种问题了</td>
</tr>
<tr>
<td style="text-align:center">不保证原子性</td>
<td style="text-align:center">Redis的事务不保证原子性，<br />也就是不保证所有指令同时成功或同时失败，<br />只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力</td>
</tr>
<tr>
<td style="text-align:center">排他性</td>
<td style="text-align:center">Redis会保证一个事务内的命令依次执行，而不会被其它命令入</td>
</tr>
</tbody>
</table>
<h2 id="redis命令"><a class="markdownIt-Anchor" href="#redis命令"></a> Redis命令</h2>
<h3 id="正常执行"><a class="markdownIt-Anchor" href="#正常执行"></a> 正常执行</h3>
<p><strong>开启事务</strong>：<strong>MULTI</strong></p>
<p><strong>开始事务</strong>：<strong>EXEC</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MULTI // 开启事务</span><br><span class="line"><span class="built_in">set</span> k1 v1  // 向事务队列中添加一个元素</span><br><span class="line"><span class="built_in">set</span> k2 v2  // 向事务队列中添加一个元素</span><br><span class="line"><span class="built_in">set</span> k3 v3  // 向事务队列中添加一个元素</span><br><span class="line">INCR count // 向事务队列中添加一个元素</span><br><span class="line">EXEC // 开始执行事务</span><br></pre></td></tr></table></figure>
<h3 id="放弃事务"><a class="markdownIt-Anchor" href="#放弃事务"></a> 放弃事务</h3>
<p><strong>DISCARD</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MULTI // 开启事务</span><br><span class="line"><span class="built_in">set</span> k1 v1  // 向事务队列中添加一个元素</span><br><span class="line"><span class="built_in">set</span> k2 v2  // 向事务队列中添加一个元素</span><br><span class="line"><span class="built_in">set</span> k3 v3  // 向事务队列中添加一个元素</span><br><span class="line">INCR count // 向事务队列中添加一个元素</span><br><span class="line">DISCARD // 放弃事务执行</span><br></pre></td></tr></table></figure>
<h3 id="全部终止"><a class="markdownIt-Anchor" href="#全部终止"></a> 全部终止</h3>
<p>当我们在<strong>执行EXEC命令之前</strong>，输入的语句有误，则在队列中所有的命令都不会被执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MULTI // 开启事务</span><br><span class="line"><span class="built_in">set</span> k1 v1  // 向事务队列中添加一个元素</span><br><span class="line"><span class="built_in">set</span> k2 v2  // 向事务队列中添加一个元素</span><br><span class="line"><span class="built_in">set</span> k3    // 向事务队列中添加一个错误元素</span><br><span class="line">INCR count // 向事务队列中添加一个元素</span><br><span class="line">EXEC // 事务执行，并不会执行事务中的内容</span><br></pre></td></tr></table></figure>
<h3 id="终止错误"><a class="markdownIt-Anchor" href="#终止错误"></a> 终止错误</h3>
<p>当我们在<strong>执行EXEC命令之后</strong>，输入的语句其中一个又错误，则只会不执行错误语句，正确语句会依次执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MULTI // 开启事务</span><br><span class="line"><span class="built_in">set</span> k1 v1  // 向事务队列中添加一个元素</span><br><span class="line"><span class="built_in">set</span> k2 v2  // 向事务队列中添加一个元素</span><br><span class="line">INCR email  // 向事务队列中添加一个错误元素</span><br><span class="line">INCR count // 向事务队列中添加一个元素</span><br><span class="line">EXEC // 事务执行========语句一二四会正确执行，语句三不会执行</span><br></pre></td></tr></table></figure>
<h3 id="watch监控"><a class="markdownIt-Anchor" href="#watch监控"></a> WATCH监控</h3>
<p><strong>悲观锁</strong>：悲观锁(Pessimistic Lock),顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁</p>
<p><strong>乐观锁</strong>：乐观锁(Optimistic Lock),顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，<strong>但是在更新的时候会判断一下在此期间别人有没有去更新这个数据</strong>。</p>
<p><strong>Redis采用乐观锁</strong></p>
<p>执行流行</p>
<p><strong>正常执行</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> k1 v1  		// 设置初始值</span><br><span class="line"><span class="built_in">set</span> balance 100  // 设置初始值</span><br><span class="line">WATCH balance	// 监控事务中的一个元素</span><br><span class="line">MULTI				// 开始事务</span><br><span class="line"><span class="built_in">set</span> k1 v11</span><br><span class="line"><span class="built_in">set</span> balance 110</span><br><span class="line">EXEC		// 执行事务</span><br></pre></td></tr></table></figure>
<p><strong>出错情况</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> k1 v1  		// 设置初始值</span><br><span class="line"><span class="built_in">set</span> balance 100  // 设置初始值</span><br><span class="line">WATCH balance	// 监控事务中的一个元素</span><br><span class="line">MULTI				// 开始事务</span><br><span class="line"><span class="built_in">set</span> k1 v11</span><br><span class="line"><span class="built_in">set</span> balance 110</span><br><span class="line">EXEC		// 执行事务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ======== 和上面同时进行</span><br><span class="line">// 在上方向 事务队列中中添加语句的时候我们执行如下代码</span><br><span class="line"><span class="built_in">set</span> balance 120  // 这样会导致在事务执行的时候，监听的元素已经被改变，所以事务执行失败</span><br></pre></td></tr></table></figure>
<h3 id="放弃监控"><a class="markdownIt-Anchor" href="#放弃监控"></a> 放弃监控</h3>
<p><strong>UNWATCH</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> k1 v1  		// 设置初始值</span><br><span class="line"><span class="built_in">set</span> balance 100  // 设置初始值</span><br><span class="line">WATCH balance	// 监控事务中的一个元素</span><br><span class="line">UNWATCH balance // 放弃监控</span><br><span class="line">MULTI				// 开始事务</span><br><span class="line"><span class="built_in">set</span> k1 v11</span><br><span class="line"><span class="built_in">set</span> balance 110</span><br><span class="line">EXEC		// 执行事务</span><br></pre></td></tr></table></figure>
<h2 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h2>
<p><strong>一旦执行了exec之前加的监控锁都会被取消掉了</strong></p>
<p>当客户端连接丢失的时候(比如退出链接)，<strong>所有东西都会被取消监视</strong></p>
<p>流程：</p>
<p><strong>开启</strong>:以MULTI开始一个事务</p>
<p><strong>入队</strong>:将多个命令入队到事务中，接到这些命令并不会立即执行而是放到等待执行的事务队列里面</p>
<p><strong>执行</strong>:由EXEC命令触发事务</p>
<h1 id="redis管道"><a class="markdownIt-Anchor" href="#redis管道"></a> Redis管道</h1>
<p><strong>如何优化频繁命令往返造成的性能瓶颈？</strong></p>
<p>Redis是一种基于<strong>客户端-服务端模型</strong>以及请求/响应协议的TCP服务。一个请求会遵循以下步骤:</p>
<ol>
<li>客户端向服务端发送命令分四步(发送命令一命令排队一命令执行一返回结果)，并监听Socket返回，通常以阻塞模式等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
</ol>
<p>上述两步称为:<strong>Round Trip Time(简称RTT,数据包往返于两端的时间)</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/08/23/JGD2NXlhpPucLfW.png" alt="image-20240823221539319" /></p>
<p>如果同时需要<strong>执行大量的命令</strong>，那么就要<strong>等待上一条命令应答后再执行</strong>，这中间不仅仅<strong>多了RTT(Round TimeTrip)</strong>，而且还频繁调用系统IO，发送网络请求，同时需要redis调用多次read()和write()系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，性能不太好。</p>
<h2 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h2>
<p>管道(pipeline)可以一次性发送多条命令给服务端，服务端依次处理完完毕后，<strong>通过一条响应一次性将结果返回，通过减少客户端与redis的通信次数来实现降低往返延时时间</strong>。pipeline<strong>实现的原理是队列</strong>，先进先出特性就保证数据的顺序性。</p>
<p><strong>Pipeline是为了解决RTT往返回时，仅仅是将命令打包一次性发送对整个Redis的执行不造成其它任何影响</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/08/23/a6icIwCqG3fHMoD.png" alt="image-20240823221847247" /></p>
<h2 id="执行方式"><a class="markdownIt-Anchor" href="#执行方式"></a> 执行方式</h2>
<p>通过txt文件执行：</p>
<p>将我们要执行的redis命令放到一个txt文件中</p>
<blockquote>
<p>set k100 v100</p>
<p>set k200 v200</p>
<p>hset k300 name haha</p>
<p>hset k300 age 20</p>
<p>hset k300 gender male</p>
<p>lpush list 1 2 3 4 5</p>
</blockquote>
<p><strong>执行过程</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> cmd.txt | redis-cli -a 11111 --pipe // <span class="built_in">cat</span> cmd.txt是将cmd.txt文件中的命令都展示出来，通过 | 将展示的命令作为参数传递到redis-cli中 并使用pipe管道执行</span><br></pre></td></tr></table></figure>
<h2 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h2>
<h3 id="pipeline与原生批量命令对比"><a class="markdownIt-Anchor" href="#pipeline与原生批量命令对比"></a> pipeline与原生批量命令对比</h3>
<ol>
<li><strong>原生批量命令是原子性</strong>(例如:mset mget)，<strong>pipeline是非原子性</strong></li>
<li>原生批量命令<strong>一次只能执行一种命令</strong>，<strong>pipeline支持批量执行不同命令</strong></li>
<li><strong>原生批命令是服务端实现</strong>，而<strong>pipelne需要服务端与客户端共同完成</strong></li>
</ol>
<h3 id="pipeline与事务对比"><a class="markdownIt-Anchor" href="#pipeline与事务对比"></a> pipeline与事务对比</h3>
<ol>
<li><strong>事务具有原子性</strong>，<strong>管道不具有原子性</strong></li>
<li><strong>管道一次性将多条命令发送到服务器</strong>，<strong>事务是一条一条的发</strong>，事务只有在<strong>接收到exec命令后才会执行</strong>，管道不会</li>
<li><strong>执行事务时会阻塞其他命令的执行</strong>，<strong>而执行管道中的命令时不会</strong></li>
</ol>
<h3 id="pipline注意事项"><a class="markdownIt-Anchor" href="#pipline注意事项"></a> pipline注意事项</h3>
<ol>
<li>pipeline缓冲的指令只是会依次执行，不保证原子性，<strong>如果执行中指令发生异常，将会继续执行后续的指令</strong></li>
<li>使用pipeline<strong>组装的命令个数不能太多</strong>，不然数据量过大客户端阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存</li>
</ol>
<h1 id="redis订阅"><a class="markdownIt-Anchor" href="#redis订阅"></a> Redis订阅</h1>
<p>Redis可以实现消息中间件MQ的功能，通过发布订阅实现消息的引导和分流。<strong>不推荐该功能</strong></p>
<p>通过PUBLISH发布的消息，订阅者都可以收到</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/08/26/pBiVeGvcPO3k19Z.png" alt="image-20240826213916313" /></p>
<h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h2>
<h3 id="subscribe"><a class="markdownIt-Anchor" href="#subscribe"></a> SUBSCRIBE</h3>
<p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE channel [channel]</span><br><span class="line">SUBSCRIBE c1</span><br></pre></td></tr></table></figure>
<p>订阅给定的一个或多个频道的信息</p>
<p><strong>推荐先执行订阅后再发布，订阅成功之前发布的消息是收不到的</strong></p>
<p>订阅的客户端每次可以收到一个3个参数的消息，消息类型，消息key，消息value</p>
<h3 id="publish"><a class="markdownIt-Anchor" href="#publish"></a> PUBLISH</h3>
<p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH channel message</span><br><span class="line">PUBLISH c1 helloc1</span><br></pre></td></tr></table></figure>
<p>发布消息到指定频道</p>
<h3 id="psubscribe"><a class="markdownIt-Anchor" href="#psubscribe"></a> PSUBSCRIBE</h3>
<p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PSUBSCRIBE pattern [pattern]</span><br><span class="line">PSUBSCRIBE c*</span><br></pre></td></tr></table></figure>
<p>按照模式<strong>批量订阅</strong>，订阅一个或多个符合给定模式(支持*号?号之类的)的频道</p>
<h3 id="pubsub"><a class="markdownIt-Anchor" href="#pubsub"></a> PUBSUB</h3>
<p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBSUB subcommand [argument ...]</span><br></pre></td></tr></table></figure>
<p>查看订阅与发布系统状态</p>
<ol>
<li>PUBSUB CHANNELS：查看由活跃频道组成的列表</li>
<li>PUBSUB NUMBER [channel [channel]]：某个频道有几个订阅者</li>
<li>PUBSUB NUMPAT：只统计使用PSUBSCRIBE命令执行的，返回客户端订阅的唯一<strong>模式的数量</strong></li>
</ol>
<h3 id="unsubscribe"><a class="markdownIt-Anchor" href="#unsubscribe"></a> UNSUBSCRIBE</h3>
<p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNSUBSCRIBE [channel [channel]]</span><br></pre></td></tr></table></figure>
<p>取消订阅</p>
<h3 id="punsubscribe"><a class="markdownIt-Anchor" href="#punsubscribe"></a> PUNSUBSCRIBE</h3>
<p>命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUNSUBSCRIBE [pattern [pattern]]</span><br></pre></td></tr></table></figure>
<p>按照模式取消订阅</p>
<h2 id="总结-4"><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h2>
<p>订阅缺点</p>
<ol>
<li>发布的消息在Redis系统中不能持久化，因此，必须先执行订阅，再等待消息发布。如果先发布了消息，那么该消息由于没有订阅者，<strong>消息将被丢弃</strong></li>
<li>消息只管发送对于发布者而言消息是即发即失的，不管接收，也没有ACK机制，<strong>无法保证消息的消费成功</strong>。</li>
<li>以上的缺点导致Redis的Pub/sub模式就像个小玩具，在生产环境中几平无用武之地，为此Redis5.0版本新增了Stream数据结构，不但支持多播，还支持数据持久化，相比Pub/Sub更加的强大</li>
</ol>
<h1 id="redis复制"><a class="markdownIt-Anchor" href="#redis复制"></a> Redis复制</h1>
<p><strong>Redis复制</strong>：就是主从复制，master以写为主，Slave以读为主，当master数据变化的时候，自动将新的数据同步到slave中</p>
<h2 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2"></a> 作用</h2>
<ol>
<li>读写分离</li>
<li>容灾恢复</li>
<li>数据备份</li>
<li>水平扩容支持高并发</li>
</ol>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<p>配从库不配主库</p>
<p><strong>master如果配置了requirepass参数</strong>，需要密码登陆。那么<strong>slave就要配置masterauth来设置校验密码</strong>，<strong>否则的话master会拒绝slave的访问请求</strong></p>
<h2 id="常用命令-2"><a class="markdownIt-Anchor" href="#常用命令-2"></a> 常用命令</h2>
<ol>
<li>info replication：可以查看复制节点的主从关系和配置信息</li>
<li>replicaof 主库IP 主库端口：在从机上设置主库IP和主库端口，一般写入redis.conf配置文件中</li>
<li>slaveof  新主库IP  新主库端口
<ul>
<li>每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件</li>
<li>在<strong>运行期间修改slave节点的信息</strong>，如果该数据库已经是某个主数据库的从数据库，那么会<strong>停止和原主数据库的同步关系转而和新的主数据库同步</strong>，重新拜码头</li>
</ul>
</li>
<li>slaveof no one：使当前数据库停止与其他数据库的同步，转成主数据库，自立为王</li>
</ol>
<h2 id="修改配置文件"><a class="markdownIt-Anchor" href="#修改配置文件"></a> 修改配置文件</h2>
<ol>
<li>在redis.conf备份文件中将daemonize 设置为yes</li>
<li>注释掉bind 127.0.0.1</li>
<li>关闭保护模式：protected-mode no</li>
<li>指定redis运行端口 port</li>
<li>指定当前工作目录 dir /myredis  存放配置文件的文件夹</li>
<li>pid文件名， pidfile</li>
<li>log文件名，logfile “/myredis/6379.log”</li>
<li>设置启动密码：requirepass 密码</li>
<li>修改dump文件名：dbfilename dump6379.rdb</li>
<li>修改aof文件名：appendfilename，<strong>如果配置该项需要开始appendonly</strong></li>
<li><strong>从机</strong>访问主机的通行密码 在reids.conf 中配置 masterauth 主机访问密码  <strong>从机配置主机不需要</strong></li>
<li><strong>从机</strong>访问主机需要配置repliaof 主机ip 主机端口 <strong>从机配置主机不需要</strong></li>
</ol>
<h2 id="主从命令"><a class="markdownIt-Anchor" href="#主从命令"></a> 主从命令</h2>
<p><strong>先启动主机再启动从机</strong>，从机启动时候<strong>需要指定端口</strong></p>
<p>可以从日志文件中查看信息，主机中有从机连接成功信息</p>
<p>info replication命令查看</p>
<h3 id="问题主从写入配置文件"><a class="markdownIt-Anchor" href="#问题主从写入配置文件"></a> 问题—主从写入配置文件</h3>
<blockquote>
<p>问：</p>
<p>从机可以执行写命令吗？</p>
<p>答：</p>
<p>从机是只读模式的，主机是可读可写的</p>
</blockquote>
<blockquote>
<p>问：</p>
<p>slave是从头开始复制还是从切入点开始复制?</p>
<p>master启动，写到k3</p>
<p>slave1跟着master同时启动，跟着写到k3</p>
<p>slave2写到k3后才启动，那之前的是否也可以复制?</p>
<p>答：</p>
<p>之前也可以复制</p>
</blockquote>
<blockquote>
<p>问：</p>
<p>主机shutdown之后从机会变成主机吗？</p>
<p>答：</p>
<p>不会</p>
</blockquote>
<blockquote>
<p>问：</p>
<p>主机shutdown后重启后主从关系还在吗?从机还能否顺利复制?</p>
<p>答：</p>
<p>关系存在可以继续进行复制</p>
</blockquote>
<blockquote>
<p>问：</p>
<p>某台从机down后，master继续，从机重启后它能跟上大部队吗?</p>
<p>答：</p>
<p>可以</p>
</blockquote>
<h3 id="问题命令操作手动指定"><a class="markdownIt-Anchor" href="#问题命令操作手动指定"></a> 问题—命令操作手动指定</h3>
<p>当从机shutdown之后去掉配置项中的repliaof 配置项，使从机变成主机</p>
<p>在从机启动之后，使用命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF 主机Ip 主机端口</span><br></pre></td></tr></table></figure>
<p>配置主机之后，还可以同步主机上的数据</p>
<p><strong>通过命令行手动配置主机的从机</strong>重启之后就回丢失与主机的联系</p>
<h2 id="薪火相传"><a class="markdownIt-Anchor" href="#薪火相传"></a> 薪火相传</h2>
<p>当主master连接过多从机slave，那么主机master的写压力会大大增加，导致主机性能下降</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/08/27/EltVhFmfNorAxDG.png" alt="image-20240827223603358" /></p>
<p>这时候可以让多个从机互相连接</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/08/27/RE7qb3iWfpTNSc4.png" alt="image-20240827223541090" /></p>
<p>上一个slave可以是下一个slave的master，slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master<strong>可以有效减轻主master的写压力</strong></p>
<p><strong>中途变更转向:会清除之前的数据，重新建立拷贝最新的</strong></p>
<p>slaveof    新主库IP    新主库端口</p>
<p>中间的从机即使有从机连接它，它也不具备写能力</p>
<h2 id="反客为主"><a class="markdownIt-Anchor" href="#反客为主"></a> 反客为主</h2>
<p>使用命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF no one</span><br></pre></td></tr></table></figure>
<p>可以与主机断开连接，自己当主机</p>
<h2 id="原理及工作流程"><a class="markdownIt-Anchor" href="#原理及工作流程"></a> 原理及工作流程</h2>
<ol>
<li>Slave启动，同步请求
<ul>
<li>slave启动成功连接到master后会发送一个sync命令</li>
<li>slave首次全新连接master,<strong>一次完全同步(全量复制)将被自动执行</strong>，slave自身原有数据会被master数据覆盖清除</li>
</ul>
</li>
<li>首次连接，全量复制
<ul>
<li>master节点收到sync命令后会开始在后台保存快照(即RDB持久化，<strong>主从复制时会触发RDB</strong>)，同时收集所有接收到的用于修改数据集命令缓存起来，<strong>master节点执行RDB持久化完后</strong>，master<strong>将rdb快照文件和所有缓存的命令发送到所有slave,以完成一次完全同步</strong></li>
<li>而<strong>slave服务在接收到数据库文件数据后</strong>，将其<strong>存盘并加载到内存中</strong>，从而完成复制初始化</li>
</ul>
</li>
<li>心跳持续，保持通讯
<ul>
<li>repl-ping-replica-period 10 在配置文件中包含这个配置项，表明主机在10一次 ping一下从机看看从机是否在线</li>
</ul>
</li>
<li>进入平稳。增量复制
<ul>
<li>Master继续将新的所有收集到的修改命令自动依次传给slave,完成同步</li>
</ul>
</li>
<li>从机下线，重连续传
<ul>
<li>master会检查backlog里面的offset，master和slave都会保存一个复制的offset还有一个masterId,offset是保存在backlog中的。<strong>Master只会把已经复制的offset后面的数据复制给Slave</strong>，类似<strong>断点续传</strong></li>
</ul>
</li>
</ol>
<h2 id="缺点-3"><a class="markdownIt-Anchor" href="#缺点-3"></a> 缺点</h2>
<ol>
<li>
<p>复制延迟信号衰减</p>
<p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/08/27/2aM8q6KPhExw3yu.png" alt="image-20240827225257773" /></p>
</li>
<li>
<p>Master挂了怎么办</p>
<p>默认情况下，不会在slave节点中自动重选一个master，<strong>需要从slave中选出一个当主机</strong></p>
</li>
</ol>
<h1 id="redis哨兵"><a class="markdownIt-Anchor" href="#redis哨兵"></a> Redis哨兵</h1>
<h2 id="作用-3"><a class="markdownIt-Anchor" href="#作用-3"></a> 作用</h2>
<p>监控Redis运行状态，包括master和slave</p>
<p>当master down</p>
<p>一般哨兵配置三台</p>
<h2 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h2>
<p>主从监控 : 监控主从redis库运行是否正常</p>
<p>消息通知 : 哨兵可以将故障转移的结果发送给客户端</p>
<p>故障转移 : 如果Master异常，则会进行主从切换, 将其中一个Slave作为新Master</p>
<p>配置中心 :客户端通过连接哨兵来获得当前Redis服务的主节点地址</p>
<h2 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240903211637072.png" alt="image-20240903211637072" /></p>
<h3 id="创建哨兵服务"><a class="markdownIt-Anchor" href="#创建哨兵服务"></a> 创建哨兵服务</h3>
<p>复制三份sentinel.conf到我们指定目录下myredis/ 命名为sentinel.conf</p>
<p>参数：</p>
<ol>
<li>bind：服务监听地址，用于客户端连接，默认本机地址</li>
<li>daemonize：是否以后台daemon方式运行</li>
<li>protected-mode：安全保护模式</li>
<li>port：端口</li>
<li>logfile：日志文件路径</li>
<li>pidfile：pid文件路径</li>
<li>dir：工作目录</li>
<li>sentinel monitor  &lt; master-name &gt; &lt; redis-port &gt; &lt; quorum &gt;
<ul>
<li>设置要监控的master服务器</li>
<li>quorum表示<strong>最少有几个哨兵认可客观下线</strong>，同意故障迁移的法定票数。</li>
<li>我们知道，网络是不可靠的，有时候一个sentinel会因为网络堵塞而误以为一个master redis已经死掉了，在sentinel集群环境下需要多个sentinel互相沟通来确认某个master是否真的死了，quorum这个参数是进行客观下线的一个依据，意思是至少有quorum个sentinel认为这个master有故障，才会对这个master进行下线以及故障转移。因为有的时候，某个sentinel节点可能因为自身网络原因，导致无法连接master，而此时master并没有出现故障，所以，这就需要多个sentinel都一致认为该master有问题，才可以进行下一步操作，这就保证公平性和高可用。</li>
</ul>
</li>
<li>sentinel auth-pass &lt; master-name &gt; &lt; password &gt; ：master设置了密码，连接master服务的密码</li>
<li>sentinel down-after-milliseconds &lt; master-name &gt; &lt; milliseconds &gt;
<ul>
<li>指定多少毫秒之后，主节点没有应答哨兵，此时哨兵主观上认为主节点下线， <strong>默认即可</strong></li>
</ul>
</li>
<li>sentinel parallel-syncs &lt; master-name &gt;&lt; nums &gt;
<ul>
<li>表示允许并行同步的slave个数，当Master挂了后，哨兵会选出新的Master，此时，剩余的slave会向新的master发起同步数据 <strong>默认即可</strong></li>
</ul>
</li>
<li>sentinel failover-timeout &lt; master-name &gt;&lt; milliseconds &gt;:
<ul>
<li>故障转移的超时时间，进行故障转移时，如果超过设置的毫秒，表示故障转移失败， <strong>默认即可</strong></li>
</ul>
</li>
<li>sentinel notification-script &lt; master-name &gt;&lt; script-path &gt; :
<ul>
<li>配置当某一事件发生时所需要执行的脚本， <strong>默认即可</strong></li>
</ul>
</li>
<li>sentinel client-reconfig-script &lt; master-name &gt;&lt; script-path &gt;:
<ul>
<li>客户端重新配置主节点参数脚本， <strong>默认即可</strong></li>
</ul>
</li>
</ol>
<h3 id="文件配置"><a class="markdownIt-Anchor" href="#文件配置"></a> 文件配置</h3>
<p>在sentinel.conf中进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">daemonize yes</span><br><span class="line">protected-mode no</span><br><span class="line">port 26380</span><br><span class="line">logfile</span><br><span class="line">/myredis/sentinel26380.log</span><br><span class="line">pidfile /var/run/redis-sentinel26380.pid</span><br><span class="line">dir &quot;/myredis</span><br><span class="line">sentinel monitor mymaster IP PORT 2</span><br><span class="line">sentinel auth pass mymaster 1l1111</span><br></pre></td></tr></table></figure>
<h3 id="启动redis-一主二从"><a class="markdownIt-Anchor" href="#启动redis-一主二从"></a> 启动redis 一主二从</h3>
<p><strong>master（主机）设置</strong>：masterauth访问密码是 11111，上述为<strong>配从不配主</strong>，这里又进行了主机配置，解释：6379后续可能会变成从机，需要设置访问新主机的密码，请设置masterauth项访问密码为111111,不然后续可能报错master link status:down</p>
<p><strong>slave（从机）设置</strong>：replicaof masterIP port， masterauth 主机密码</p>
<h3 id="启动哨兵"><a class="markdownIt-Anchor" href="#启动哨兵"></a> 启动哨兵</h3>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel sentinel26379.conf --sentinel</span><br></pre></td></tr></table></figure>
<h3 id="模拟挂机"><a class="markdownIt-Anchor" href="#模拟挂机"></a> 模拟挂机</h3>
<p>通过将主master进行shutdow之后</p>
<p>哨兵会先进行master挂机确认，<strong>确认完之后会进行新master选择</strong>，即使原先的master从新上线之后，不会转换master为原先的master，原先挂机的master会变成slave从机 ，<strong>老master 并且会在配置文件后面添加上replicaof masterIP port</strong> ，进行主从切换，<strong>新master的replicaof配置项会被移除</strong></p>
<p><strong>BrokenPipe问题</strong>：broken pipe的意思是<strong>对端的管道已经断开</strong>，往往发生在<strong>远端把这个读/写管道关闭了</strong>，你<strong>无法在对这个管道进行读写操作</strong>。从tcp的四次挥手来讲远端已经发送了FIN序号，告诉你我这个管道已经关闭，这时候，如果你继续往管道里写数据，第一次，你会收到一个远端发送的RST信号，如果你继续往管道里write数据，操作系统就会给你发送SIGPIPE的信号，并且将errno置为Broken pipe(32)，如果你的程序默认没有对SIGPIPE进行处理，那么程序会中断退出。一般情况下，可以用<strong>signal(SIGPIPE,SIG IGN)<strong>忽略这个信号，这样的话程序不会退出，但是write会返回-1并且将errno置为Brokenpipe(32)。brokerpipe只会出现在往</strong>对端已经关闭的管道里写数据的情况下</strong>在收到对端的RST序号后第一次写不会出现broke pipe，而是write返回-1，这时候正确的做法应该是本端也close这个管道，如果继续write，那么就会出现这个错误)。</p>
<h3 id="切换结果"><a class="markdownIt-Anchor" href="#切换结果"></a> 切换结果</h3>
<p>配置文件的内容，在运行期间会被sentinel动态进行更改</p>
<p>Master-Slave切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换</p>
<h2 id="运行流程"><a class="markdownIt-Anchor" href="#运行流程"></a> 运行流程</h2>
<p>当一个主从配置中的master失效之后，<strong>sentinel可以选举出一个新的master用于自动接替原master的工作</strong>，主从配置中的其他redis服务器自动指向新的master同步数据，<strong>一般建议sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换</strong></p>
<p><strong>流程</strong></p>
<ol>
<li>
<p>三个哨兵监控一主二从，正常运行中</p>
</li>
<li>
<p>SDown<strong>主观下线</strong>(Subjectively Down)</p>
<ul>
<li>所谓主观下线(Subjectively Down， 简称 SDOWN)指的是<strong>单个Sentinel实例</strong>对服务器做出的下线判断，即单个sentinel认为某个服务下线(有可能是接收不到订阅，之间的网络不通等等原因)。主观下线就是说如果服务器在[sentinel down-after-miliseconds]给定的毫秒数之内没有回应PING命令或者返回一个错误消息， 那么这个Sentinel会主观的(<strong>单方面的</strong>)认为这个master不可以用了。</li>
<li>sentinel down-after-milliseconds &lt; masterName &gt; &lt; timeout &gt;</li>
<li>表示master被当前sentinel实例认定为失效的间隔时间，这个配置其实就是进行主观下线的一个依据master在多长时间内一直没有给Sentine返回有效信息，则认定该master主观下线。也就是说如果多久没联系上redis-servevr，认为这个redis-server进入到失效(SDOWN)状态。</li>
</ul>
</li>
<li>
<p>ODown<strong>客观下线</strong>(Objectively Down)</p>
<ul>
<li>DOWN需要一定数量的sentinel<strong>多个哨兵达成一致意见</strong>才能认为masfer客观上已经宕掉</li>
<li>quorum这个参数是进行客观下线的一个依据，法定人数/法定票数</li>
<li>意思是至少有quorum个sentinel认为这个master有故障才会对这个master进行下线以及故障转移。因为有的时候，某个sentinel节点可能因为自身网络原因导致无法连接master，而此时master并没有出现故障，所以这就需要多个sentinel都一致认为该master有问题，才可以进行下一步操作，这就保证了公平性和高可用。</li>
</ul>
</li>
<li>
<p>选举出领导者哨兵(哨兵中选出兵王)</p>
<ul>
<li>当主节点被判断客观下线以后，各个哨兵节点会进行协商先选举出一个**领导者哨兵节点(兵王)**并由该领导者节点也即被选举出的兵王进行failover(故障迁移)</li>
<li>选择算法RAFT算法：<strong>基本思路先到先得</strong></li>
</ul>
</li>
<li>
<p>由兵王开始推动故障切换流程并选出一个新master，分为三步</p>
<ul>
<li>
<p>选择新master，规则如下，在slave没问题的情况下（新王登基）</p>
<ul>
<li>
<p>redis.conf文件中，优先级slave-priority或者replica-priority最高的从节点(数字越小优先级越高</p>
</li>
<li>
<p>复制偏移位置offset最大的从节点，谁拥有最全的老master的数据，谁当新master</p>
</li>
<li>
<p>最小Run ID的从节点 字典顺序，ASCII码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240903234546851.png" alt="image-20240903234546851" /></p>
</li>
</ul>
</li>
<li>
<p>将其余slave转换到新master中（俯首称臣）</p>
<ul>
<li>新master执行slaveofno one命令让选出来的从节点成为新的主节点，并通过slaveof命令让其他节点成为其从节点</li>
<li>Sentinel leader会对选举出的新master执行slaveofno one操作，将其提升为master节点</li>
<li>Sentinelleader向其它slave发送命令，让剩余的slave成为新的master节点的slave</li>
</ul>
</li>
<li>
<p>老master重启之后也会变成slave（旧主拜服）</p>
<ul>
<li>将之前已下线的老master设置为新选出的新master的从节点，当老master重新上线后，它会成为新master的slave</li>
<li>Sentinelleader会让原来的master降级为slave并恢复正常工作。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>上述都是sentinel自动完成</strong></p>
</li>
</ol>
<h2 id="使用建议"><a class="markdownIt-Anchor" href="#使用建议"></a> 使用建议</h2>
<ol>
<li>哨兵节点的数量应为多个，哨兵本身应该集群，保证高可用</li>
<li>哨兵节点的数量应该是奇数</li>
<li>各个哨兵节点的配置应一致</li>
<li>如果哨兵节点部署在Docker等容器里面，尤其要注意端口的正确映射</li>
<li>哨兵集群+主从复制，<strong>并不能保证数据零丢失</strong>，在master挂了之后，会有一点选出新master的时间间隔，在这个时间间隔内无法写入新数据</li>
</ol>
<h1 id="redis集群"><a class="markdownIt-Anchor" href="#redis集群"></a> Redis集群</h1>
<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2>
<p><strong>由于数据量过大，单个Master复制集难以承担</strong>，因此需要对多个复制集进行集群，形成水平扩展每个复制集只负责存储整个数据集的一部分，这就是Redis的集群，其<strong>作用是提供在多个Redis节点间共享数据的程序集</strong>。</p>
<p>如下图所示，左边是哨兵+主从复制，右边是集群</p>
<p>集群相对于哨兵+主从的优点在于，哨兵+主从过度依赖于一台master，把希望全部寄托在一个master中，如果master挂了之后需要有一点时间的空窗期，但是集群拥有多个master，即使其中有一个挂了其他的也可以使用，不会导致整个系统瘫痪</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240904222753410.png" alt="image-20240904222753410" /></p>
<h2 id="作用-4"><a class="markdownIt-Anchor" href="#作用-4"></a> 作用</h2>
<p>Redis集群<strong>支持多个Master</strong>，每个Master又可以<strong>挂载多个Slave</strong></p>
<p>由于Cluster自带Sentinel的<strong>故障转移机制</strong>，内置了高可用的支持，<strong>无需再去使用哨兵功能</strong></p>
<p>客户端与Redis的节点连接，不再需要连接集群中所有的节点，<strong>只需要任意连接集群中的一个可用节点即可</strong></p>
<p><strong>槽位slot</strong>负责分配到各个物理服务节点，由对应的集群来负责维护节点、插槽和数据之间的关系</p>
<h2 id="集群算法"><a class="markdownIt-Anchor" href="#集群算法"></a> 集群算法</h2>
<p>集群的密钥空间被<strong>分成 16384个槽</strong>，有效地设置了 16384 个主节点的集群大小上限(但是，<strong>建议的最大节点大小约为 1000 个节点</strong>)</p>
<p>集群中的每个主节点处理 16384 个哈希槽的一个子集。 当没有集群重新配置正在进行时(即哈希槽从一个节点移动到另一个节点)，集群是稳定的。当集群稳定时，单个哈希将由单个节点提供服务(但是，服务节点可以有一个或多个副本，在网络分裂或故障的情况下替换它，并且可以用于扩展 读取陈旧数据是可接受的操作)。</p>
<h3 id="槽位"><a class="markdownIt-Anchor" href="#槽位"></a> 槽位</h3>
<p>Redis 集群投有使用一致性hash， 而是引入了 哈希槽的概念</p>
<p>Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽,集群的每个节点负责-部分hash槽</p>
<p>举个例子,比如当前集群有3个节点,那么:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240905211925284.png" alt="image-20240905211925284" /></p>
<h3 id="分片"><a class="markdownIt-Anchor" href="#分片"></a> 分片</h3>
<p><strong>分片是什么</strong>：使用Redis集群时我们会将存储的数据分散到多台redis机器上，这称为分片。简言之，集群中的每个Redis实例都被认为是整个数据的一个分片。</p>
<p><strong>如何找到给定key的分片</strong>：为了找到给定key的分片，我们对key进行CRC16(key)算法处理并通过<strong>对总分片数量取模</strong>。然后，<strong>使用确定性哈希函数</strong>，这意味着给定的key<strong>将多次始终映射到同一个分片</strong>，我们可以推断将来读取特定key的位置。</p>
<h3 id="优势-2"><a class="markdownIt-Anchor" href="#优势-2"></a> 优势</h3>
<p><strong>方便扩容和数据分派查找</strong></p>
<p>这种结构很容易添加或者咧除节点.比如如果我想<strong>新添加个节点D</strong>,我需要从<strong>节点A,B,C中得部分槽到D上,<strong>如果我想</strong>移除节点A</strong>,需要<strong>将A中的槽移到B和C节点上</strong>,然后将没有任何槽的A节点从集群中移除即可.由于<strong>从一个节点将哈希槽移动到另一个节点并不会停止服务</strong>,所以无论<strong>添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态</strong>,</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240905212706516.png" alt="image-20240905212706516" /></p>
<h2 id="槽位映射"><a class="markdownIt-Anchor" href="#槽位映射"></a> 槽位映射</h2>
<h3 id="哈希取余分区"><a class="markdownIt-Anchor" href="#哈希取余分区"></a> 哈希取余分区</h3>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(key)/MasterCount(redis服务个数)</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240905214829711.png" alt="image-20240905214829711" /></p>
<p>2亿条记录就是2亿个k,V，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式: <strong>hash(key)% N个机器台数</strong>，计算出哈希值，用来决定数据映射到哪一个节点上。</p>
<p>**优点：**简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求(并维护这些请求的信息)，起到负载均衡+分而治之的作用。</p>
<p><strong>缺点：<strong>原来规划好的节点，进行扩容或者缩容就比较麻烦了，不管扩缩，<strong>每次数据变动导致节点有变动</strong>，<strong>映射关系需要重新进行计算</strong>，在</strong>服务器个数固定不变时没有问题</strong>，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化:Hash(key)/3会变成Hash(key)/2。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</p>
<h3 id="一致性hash算法"><a class="markdownIt-Anchor" href="#一致性hash算法"></a> 一致性HASH算法</h3>
<p>设计目标是为了解决<strong>分布式缓存数据变动和映射问题</strong>，某个机器宕机了，分母数量改变了，自然取余数不OK了。</p>
<p>目的是当服务器个数发生变动时尽量减少影响客户端到服务器的映射关系</p>
<p><strong>步骤</strong></p>
<ol>
<li>
<p>算法构建一致性hash环</p>
<p>一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间， [ 0, 2<sup>32</sup>-11]，这个是一个线性空间，但是在算法中，我们通过适当的<strong>逻辑控制将它首尾相连(0= 2<sup>32</sup>)</strong>,这样让它<strong>逻辑上形成了一个环形空间</strong>。</p>
<p>它也是按照使用取模的方法，<strong>节点取模法是对节点(服务器)的数量进行取模</strong>。<strong>而一致性Hash算法是对2<sup>32</sup>取模</strong>，简单来说，<strong>一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环</strong>，如假设某哈希函数H的值空间为0-2<sup>32</sup>-1(即哈希值是一个32位无符号整形)，整个哈希环如下图:<strong>整个空间按顺时针方问组织</strong>，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2<sup>32</sup>-1，也就是说0点左侧的第一个点代表2<sup>32</sup>-1， 0和2<sup>32</sup>-1在零点中方向重合，我们把这个由2<sup>32</sup>个点组成的圆环称为Hash环。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240906204049517.png" alt="image-20240906204049517" /></p>
</li>
<li>
<p>服务器IP节点映射</p>
<p>将集群中各个IP节点映射到环上的某一个位置。</p>
<p>将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算(hash(ip))，使用IP地址哈希后在环空间的位置如下;</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240906205230516.png" alt="image-20240906205230516" /></p>
</li>
<li>
<p>key落到服务器的落键规则</p>
<p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置。<strong>从此位置沿环顺时针“行走”</strong>，<strong>第一台遇到的服务器就是其应该定位到的服务器</strong>，并将该键值对存储在该节点上。</p>
<p>如我们有Object A、Objec B、Object c、object D四个数据对象，经过哈希计算后，在环空间上的位置如下:根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到NodeC上，D被定为到Node D上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240906205430551.png" alt="image-20240906205430551" /></p>
</li>
</ol>
<p><strong>优点</strong></p>
<ol>
<li>
<p>容错性</p>
<p>假设Node C宕机，可以看到此时对象A、B、D不会受到影响。一般的，在一致性Hash算法中，如果一台服务器不可用，<strong>则受影响的数据仅仅是此服务器到其环空间中前一台服务器(即沿着逆时针方向行走遇到的第一台服务器)之问数据</strong>，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据<strong>且这些数据会转移到D进行存储</strong><br />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240906210947754.png" alt="image-20240906210947754" style="zoom: 80%;" /></p>
</li>
<li>
<p>扩展性</p>
<p>数据量增加了，<strong>需要增加一台节点NodeX</strong>，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，不会导致hash取余全部数据重新洗牌。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240906211102928.png" alt="image-20240906211102928" /></p>
</li>
</ol>
<p><strong>缺点</strong></p>
<p>数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p>
<h3 id="哈希槽分区"><a class="markdownIt-Anchor" href="#哈希槽分区"></a> 哈希槽分区</h3>
<p>**出现缘由：**一致性hash算法的数据倾斜问题，hash槽实质是一个数组，数组[0, 2<sup>14</sup>-1]形成hash slot空间</p>
<p>**作用：**解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽(slot) ，用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</p>
<p>HASH_SLOT = CRC16(key) mod 16384</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240907222739424.png" alt="image-20240907222739424" /></p>
<p>为什么redis集群的最大槽数是16384个</p>
<p>Redis集群<strong>不保证强一致性</strong>，这意味着在特定的条件下，Redis集群可能会丢掉一些被系统收到的写入请求命令</p>
<h2 id="集群环境的搭建"><a class="markdownIt-Anchor" href="#集群环境的搭建"></a> 集群环境的搭建</h2>
<h3 id="三主三从redis集群配置"><a class="markdownIt-Anchor" href="#三主三从redis集群配置"></a> 三主三从redis集群配置</h3>
<ol>
<li>
<p>新建6个独立的redis实例服务</p>
<p>master</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0 # 主机IP</span><br><span class="line">daemonize yes</span><br><span class="line">protected-mode no</span><br><span class="line">port 6381</span><br><span class="line">logfile &quot;/myredis/cluster/cluster6381.log&quot;</span><br><span class="line">pidfile /myredis/cluster6381.pid</span><br><span class="line">dir /myredis/cluster</span><br><span class="line">dbfilename dump6381.rdb</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly6381.aof&quot;</span><br><span class="line">requirepass 111111</span><br><span class="line">masterauth 111111</span><br><span class="line"># 集群打开</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 集群配置文件</span><br><span class="line">cluster-config-file nodes-6381.conf</span><br><span class="line"># 集群超时时间</span><br><span class="line">cluster-node-timeout 5000</span><br></pre></td></tr></table></figure>
<p>slave</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">daemonize yes</span><br><span class="line">protected-mode no</span><br><span class="line">port 6382</span><br><span class="line">logfile &quot;/myredis/cluster/cluster6382.log&quot;</span><br><span class="line">pidfile /myredis/cluster6382.pid</span><br><span class="line">dir /myredis/cluster</span><br><span class="line">dbfilename dump6382.rdb</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly6382.aof&quot;</span><br><span class="line">requirepass 111111</span><br><span class="line">masterauth 111111</span><br><span class="line"> </span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6382.conf</span><br><span class="line">cluster-node-timeout 5000</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动6台独立的redis实例服务</p>
</li>
</ol>
<h3 id="通过redis-cli命令为6台机器构建集群关系"><a class="markdownIt-Anchor" href="#通过redis-cli命令为6台机器构建集群关系"></a> 通过redis-cli命令为6台机器构建集群关系</h3>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a <span class="number">111111</span> --cluster create  --cluster-replicas <span class="number">1</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">111</span>.<span class="number">185</span>:<span class="number">6381</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">111</span>.<span class="number">185</span>:<span class="number">6382</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">111</span>.<span class="number">172</span>:<span class="number">6383</span> <span class="number">192</span>.<span class="number">168</span> <span class="number">111</span>.<span class="number">172</span>:<span class="number">6384</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">111</span>.<span class="number">174</span>:<span class="number">6385</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">111</span>.<span class="number">174</span>:<span class="number">6386</span></span><br></pre></td></tr></table></figure>
<p>集群构建成功之后会产生上面配置的 nodes-6382.conf的node配置文件</p>
<p><strong>CLUSTER NODES</strong>查看集群所有的node节点信息</p>
<p><strong>CLUSTER INFO</strong>查看某一个节点的集群信息</p>
<h3 id="3主3从redis集群读写"><a class="markdownIt-Anchor" href="#3主3从redis集群读写"></a> 3主3从redis集群读写</h3>
<p>通过新增两个key，可以发现有的key能够添加进去有的key会报错，这是因为<strong>使用集群后在添加key的时候有槽位限制</strong></p>
<p>**解决方式：**再启动客户端的时候添加上-c参数即可使用</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a <span class="number">111</span> -p <span class="number">6381</span> -c</span><br></pre></td></tr></table></figure>
<p><strong>CLUSTER KEYSLOT KEY</strong>：查看某一个key的槽位</p>
<h2 id="主从容错切换"><a class="markdownIt-Anchor" href="#主从容错切换"></a> 主从容错切换</h2>
<p>当主机down之后，从机会进行上位。</p>
<p>等待原先主机恢复之后，并不会继续是主机，而是会变成从机</p>
<h3 id="节点从属调整"><a class="markdownIt-Anchor" href="#节点从属调整"></a> 节点从属调整</h3>
<p>如果想要原先的主机恢复之后还是主机</p>
<ol>
<li>登录原先的主机</li>
<li>使用 <strong>CLUSTER FAILOVER</strong>，主从节点调整指令</li>
</ol>
<h2 id="主从扩容"><a class="markdownIt-Anchor" href="#主从扩容"></a> 主从扩容</h2>
<ol>
<li>
<p>新建两个实例，一主一从</p>
</li>
<li>
<p>启动两个实例，都是以master身份启动的</p>
</li>
<li>
<p>将6387加入到集群中</p>
<blockquote>
<p>将新增的6387作为master节点加入原有集群</p>
<p>redis-cli -a 密码 --cluster add-node 自己实际IP地址:6387 集群中的主机IP:6381</p>
<p>6387 就是将要作为master新增节点</p>
<p>6381 就是原来集群节点里面的领路人，相当于6387拜拜6381的码头从而找到组织加入集群</p>
<p>redis-cli -a 111111 --cluster add-node 192,168,111.174:6387 192.168.111.175:6381</p>
</blockquote>
</li>
<li>
<p>检查集群中的节点分布情况</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a <span class="number">1111</span> --cluster check <span class="number">192</span>.<span class="number">168</span>.<span class="number">111</span>.<span class="number">185</span>:<span class="number">6381</span></span><br></pre></td></tr></table></figure>
<p>发现新加入的没有分配槽位</p>
</li>
<li>
<p>重新分配槽位（reshard）</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 从新分派槽号</span><br><span class="line">redis-cli -a 密码 --cluster reshard IP地址:端口号</span><br></pre></td></tr></table></figure>
<p>输入完上述命令中之后会出现如下情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240908171114599.png" alt="image-20240908171114599" /></p>
<p>通过计算 16384 / 4 = 4096， 所以我们分出4096个槽位出俩</p>
<p>我们通过上述展示的masterID信息，获取我们想要分配的master主机ID</p>
<p>输入全部需要调整的masterID：all</p>
</li>
</ol>
<p><strong>为什么6387是3个新的区间，以前的还是连续</strong>?</p>
<p><strong>重新分配成本太高</strong>，所以前3家各自匀出来一部分，从6381/6382/6383三个旧节点分别匀出1364个坑位给新节点6387</p>
<p>分配slave节点</p>
<blockquote>
<p>命令：redis-cli -a 密码 --cluster add-node ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID</p>
<p>将6388挂载到6387上面</p>
<p>redis-cli -a 111111 --cluster add-node 192.168.111.174:6388 192.168.111.174:6387 --cluster-slave --cluster-master-id 4feb6a7ee0ed2b39ff86474cf4189ab2a554a40f-------这个是6387的编号，按照自己实际情况</p>
</blockquote>
<h2 id="主从缩容"><a class="markdownIt-Anchor" href="#主从缩容"></a> 主从缩容</h2>
<ol>
<li>
<p>检查从节点信息，获取从节点6388的节点ID</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a <span class="number">1111</span> --cluster check <span class="number">192</span>.<span class="number">168</span>.<span class="number">111</span>.<span class="number">184</span>:<span class="number">6388</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>执行删除命令</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a <span class="number">111111</span> --cluster <span class="built_in">del</span>-node <span class="number">192</span>.<span class="number">168</span>.<span class="number">111</span>.<span class="number">184</span>:<span class="number">6388</span> <span class="number">6388</span>的节点ID</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将需要删除的节点槽从新分配</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 从新分派槽号</span><br><span class="line">redis-cli -a 密码 --cluster reshard IP地址:端口号</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="Redis7/image-20240908174501688.png" alt="image-20240908174501688" /></p>
<p>6387节点槽全部分给6381，结果是6387会从master上退下来，变成6381的slave</p>
</li>
<li>
<p>最后将6387进行删除</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a <span class="number">111111</span> --cluster <span class="built_in">del</span>-node <span class="number">192</span>.<span class="number">168</span>.<span class="number">111</span>.<span class="number">184</span>:<span class="number">6387</span> <span class="number">6387</span>的节点ID</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结-5"><a class="markdownIt-Anchor" href="#总结-5"></a> 总结</h2>
<p>不在一个槽中的不支持 mget操作</p>
<p>解决方式：我们在设置值的时候，可以给值分一个组</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mset k1&#123;z&#125; v1 k2&#123;z&#125; v2 k3&#123;z&#125; v3</span><br><span class="line">mget k1&#123;z&#125; k2&#123;z&#125; k3&#123;z&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用命令-3"><a class="markdownIt-Anchor" href="#常用命令-3"></a> 常用命令</h3>
<ol>
<li>
<p>cluster-require-full-coverage</p>
<p><strong>默认YES</strong>，现在集群架构是3主3从的redis cluster由3个master平分16384个slot，每个master的小集群负责1/3的slot，对应一部分数据。cluster-require-full-coverage： 默认值 yes , 即需要集群完整性，方可对外提供服务 通常情况，如果这3个小集群中，任何一个（1主1从）挂了，你这个集群对外可提供的数据只有2/3了， 整个集群是不完整的， redis 默认在这种情况下，是不会对外提供服务的。</p>
<p>如果你的诉求是，<strong>集群不完整的话也需要对外提供服务</strong>，需要将该参数设置为no ，这样的话你挂了的那个小集群是不行了，但是其他的小集群仍然可以对外提供服务</p>
</li>
<li>
<p>CLUSTER COUNTKEYSINSLOT 槽位编号</p>
<p>1：该槽位被占用</p>
<p>0：该槽位没占用</p>
</li>
<li>
<p>CLUSTER KEYSLOT 键名称 ： 查看对应的键应该在那个槽位上</p>
</li>
</ol>
<h1 id="springboot整合redis"><a class="markdownIt-Anchor" href="#springboot整合redis"></a> SpringBoot整合Redis</h1>
<h2 id="jedis"><a class="markdownIt-Anchor" href="#jedis"></a> Jedis</h2>
<ol>
<li>
<p>引入依赖</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">	<span class="string">&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span></span><br><span class="line">	<span class="string">&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span></span><br><span class="line">	<span class="string">&lt;version&gt;4.3.1&lt;/version&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过指定的ip和端口号获取redis连接</span></span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 设置redis密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">    System.out.println(jedis.ping());</span><br><span class="line"></span><br><span class="line">    jedis.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;k1 value:&#123;&#125;&quot;</span>, jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    jedis.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;k2 value:&#123;&#125;&quot;</span>, jedis.get(<span class="string">&quot;k2&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(jedis.ttl(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">    jedis.expire(<span class="string">&quot;k1&quot;</span>, <span class="number">10L</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;list&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;list value:&#123;&#125;&quot;</span>, jedis.lrange(<span class="string">&quot;list&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;list&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练手</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">workTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取链接redis对象</span></span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询所有的key</span></span><br><span class="line">    Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;key:&#123;&#125;&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断键是否存在</span></span><br><span class="line">    System.out.println(<span class="string">&quot;jedis.exists ====&gt; &quot;</span> + jedis.exists(<span class="string">&quot;k2&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个键的存活时间</span></span><br><span class="line">    System.out.println(jedis.ttl(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个键</span></span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时设置，获取多个键值对， MAP类型</span></span><br><span class="line">    jedis.mset(<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;2&quot;</span>, <span class="string">&quot;k3&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;k4&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">    System.out.println(jedis.mget(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>, <span class="string">&quot;k4&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置List类型数据，有序，value可重复</span></span><br><span class="line">    jedis.lpush(<span class="string">&quot;myList&quot;</span>, <span class="string">&quot;list-1&quot;</span>, <span class="string">&quot;list-2&quot;</span>, <span class="string">&quot;list-3&quot;</span>,<span class="string">&quot;list-3&quot;</span>);</span><br><span class="line">    System.out.println(jedis.lrange(<span class="string">&quot;myList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置set类型数据,无序，value不重复</span></span><br><span class="line">    jedis.sadd(<span class="string">&quot;mySet&quot;</span>, <span class="string">&quot;set-1&quot;</span>, <span class="string">&quot;set-2&quot;</span>, <span class="string">&quot;set-3&quot;</span>, <span class="string">&quot;set-3&quot;</span>);</span><br><span class="line">    System.out.println(jedis.smembers(<span class="string">&quot;mySet&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置hash类型数据, key是固定的，value是kv键值对</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;myHash&quot;</span>, <span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;myHash&quot;</span>, <span class="string">&quot;hash2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">    System.out.println(jedis.hget(<span class="string">&quot;myHash&quot;</span>, <span class="string">&quot;hash1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Zset 有序</span></span><br><span class="line">    jedis.zadd(<span class="string">&quot;myZset&quot;</span>, <span class="number">60</span>, <span class="string">&quot;zset-1&quot;</span>);</span><br><span class="line">    jedis.zadd(<span class="string">&quot;myZset&quot;</span>, <span class="number">61</span>, <span class="string">&quot;zset-2&quot;</span>);</span><br><span class="line">    jedis.zadd(<span class="string">&quot;myZset&quot;</span>, <span class="number">62</span>, <span class="string">&quot;zset-3&quot;</span>);</span><br><span class="line">    System.out.println(jedis.zrange(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="lettuce"><a class="markdownIt-Anchor" href="#lettuce"></a> Lettuce</h2>
<p>Jedis缺点：每次访问redis都需要新建一个jedis对象，开销大，且线程不安全</p>
<p>当有多但是如果使用Lettuce这个客户端连接Redis服务器的时候，就不会出现上面的情况，Lettuce底层使用的是Netty,多个线程都需要连接Redis服务器的时候，可以<strong>保证只创建一个Letuce连接</strong>，使所有的线程共享这一个Lettuce连接，这样可以减少创建关闭一个Lettuce连接时候的开销，而且这种方式也是线程安全的，不会出现一个线程通过Lettuce更改Redis服务器中的数据之后而影响另一个线程的情况。</p>
<ol>
<li>
<p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.3.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myTest1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 通过Lettuce获取redis对象</span></span><br><span class="line">    <span class="type">RedisURI</span> <span class="variable">uri</span> <span class="operator">=</span> RedisURI.builder().redis(<span class="string">&quot;127.0.0.1&quot;</span>).withPort(<span class="number">6379</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建链接客户端</span></span><br><span class="line">    <span class="type">RedisClient</span> <span class="variable">redisClient</span> <span class="operator">=</span> RedisClient.create(uri);</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通过connect创建操作的command</span></span><br><span class="line">    RedisCommands&lt;String, String&gt; commands = connect.sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 String</span></span><br><span class="line">    commands.set(<span class="string">&quot;StringKey&quot;</span>, <span class="string">&quot;StringValue&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;StringValue : &#123;&#125;&quot;</span>, commands.get(<span class="string">&quot;StringKey&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 List</span></span><br><span class="line">    commands.lpush(<span class="string">&quot;ListKey&quot;</span>, <span class="string">&quot;ListValue1&quot;</span>, <span class="string">&quot;ListValue2&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;ListValue : &#123;&#125;&quot;</span>, commands.lrange(<span class="string">&quot;ListKey&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3 Hash</span></span><br><span class="line">    commands.hset(<span class="string">&quot;HashKey&quot;</span>, <span class="string">&quot;HashKey1&quot;</span>, <span class="string">&quot;HashValue1&quot;</span>);</span><br><span class="line">    commands.hset(<span class="string">&quot;HashKey&quot;</span>, <span class="string">&quot;HashKey2&quot;</span>, <span class="string">&quot;HashValue2&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;HashValue: &#123;&#125;&quot;</span>, commands.hget(<span class="string">&quot;HashKey&quot;</span>, <span class="string">&quot;HashKey1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.4 Set</span></span><br><span class="line">    commands.sadd(<span class="string">&quot;SetKey&quot;</span>, <span class="string">&quot;SetValue1&quot;</span>, <span class="string">&quot;SetValue2&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;SetValue : &#123;&#125;&quot;</span>, commands.smembers(<span class="string">&quot;SetKey&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.5 ZSet</span></span><br><span class="line">    commands.zadd(<span class="string">&quot;ZSetKey&quot;</span>,<span class="number">100.0</span>, <span class="string">&quot;ZSetValue1&quot;</span>, <span class="number">200.0</span>, <span class="string">&quot;ZSetValue2&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;ZSetValue : &#123;&#125;&quot;</span>, commands.zrange(<span class="string">&quot;ZSetKey&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 关闭链接资源</span></span><br><span class="line">    connect.close();</span><br><span class="line">    redisClient.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="redistemplate"><a class="markdownIt-Anchor" href="#redistemplate"></a> RedisTemplate !!!</h2>
<h3 id="引依赖"><a class="markdownIt-Anchor" href="#引依赖"></a> 引依赖</h3>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redisTemplate--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--swagger2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="yml配置文件"><a class="markdownIt-Anchor" href="#yml配置文件"></a> yml配置文件</h3>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7777</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">RedisConfig</span></span><br><span class="line">  <span class="attr">swagger2:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#在springboot2.6.X结合swagger2.9.X会提示documentationPluginsBootstrapper空指针异常，</span></span><br><span class="line">  <span class="comment">#原因是在springboot2.6.x中将SpringMVC默认路径匹配策略从AntPathMatcher更改为PathPatternParser,</span></span><br><span class="line">  <span class="comment">#导致出错，解决办法是atching-strategy切换回之antpathmatcher</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">pathmatch:</span></span><br><span class="line">      <span class="attr">matching-strategy:</span> <span class="string">ant_path_matcher</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">1ms</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志设置</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">com.nuyoah.demo:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">console:</span> <span class="string">%d&#123;yyyy-MM-dd</span> <span class="string">HH:mm:ss.SSS&#125;</span> [<span class="string">%thread</span>] <span class="string">%-5level</span> <span class="string">%logger-</span> <span class="string">%msg%n</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">%d&#123;yyyy-MM-dd</span> <span class="string">HH:mm:ss.SSS&#125;</span> [<span class="string">%thread</span>] <span class="string">%-5level</span> <span class="string">%logger-</span> <span class="string">%msg%n</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">../log/myLog2024/redis7</span></span><br></pre></td></tr></table></figure>
<h3 id="定义配置类"><a class="markdownIt-Anchor" href="#定义配置类"></a> 定义配置类</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nuyoah.redis7.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis序列化的工具配置类，下面这个请一定开启配置</span></span><br><span class="line"><span class="comment">     * 127.0.0.1:6379&gt; keys *</span></span><br><span class="line"><span class="comment">     * 1) &quot;ord:102&quot;  序列化过</span></span><br><span class="line"><span class="comment">     * 2) &quot;\xac\xed\x00\x05t\x00\aord:102&quot;   野生，没有序列化过</span></span><br><span class="line"><span class="comment">     * this.redisTemplate.opsForValue(); //提供了操作string类型的所有方法</span></span><br><span class="line"><span class="comment">     * this.redisTemplate.opsForList(); // 提供了操作list类型的所有方法</span></span><br><span class="line"><span class="comment">     * this.redisTemplate.opsForSet(); //提供了操作set的所有方法</span></span><br><span class="line"><span class="comment">     * this.redisTemplate.opsForHash(); //提供了操作hash表的所有方法</span></span><br><span class="line"><span class="comment">     * this.redisTemplate.opsForZSet(); //提供了操作zset的所有方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lettuceConnectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(LettuceConnectionFactory lettuceConnectionFactory)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        redisTemplate.setConnectionFactory(lettuceConnectionFactory);</span><br><span class="line">        <span class="comment">//设置key序列化方式string</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">//设置value的序列化方式json，使用GenericJackson2JsonRedisSerializer替换默认序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nuyoah.redis7.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.swagger2.enabled&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean enabled;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                       .apiInfo(apiInfo())</span><br><span class="line">                       .enable(enabled)</span><br><span class="line">                       .select()</span><br><span class="line">                       .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.nuyoah.redis7&quot;</span>)) <span class="comment">//你自己的package</span></span><br><span class="line">                       .paths(PathSelectors.any())</span><br><span class="line">                       .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                       .title(<span class="string">&quot;springboot利用swagger2构建api接口文档 &quot;</span>+<span class="string">&quot;\t&quot;</span>+ DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>).format(LocalDateTime.now()))</span><br><span class="line">                       .description(<span class="string">&quot;springboot+redis整合&quot;</span>)</span><br><span class="line">                       .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                       .termsOfServiceUrl(<span class="string">&quot;https://www.atguigu.com/&quot;</span>)</span><br><span class="line">                       .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;订单接口&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;新增订单&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        orderService.addOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;keyId&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;按照订单key获取订单&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getOrderById</span><span class="params">(<span class="meta">@PathVariable(&quot;keyId&quot;)</span> String keyId)</span> &#123;</span><br><span class="line">        orderService.getOrderById(keyId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ORDER_KEY</span> <span class="operator">=</span> <span class="string">&quot;order:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生成随机数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">keyId</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 通过UUID生成序列化ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serialNo</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置keyvalue</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> ORDER_KEY + keyId;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;我的订单&quot;</span>+serialNo;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向redis中添加数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">        log.info(<span class="string">&quot;向redis中添加一条订单， key：&#123;&#125;， value&#123;&#125;&quot;</span>,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrderById</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) redisTemplate.opsForValue().get(ORDER_KEY + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h3>
<p>如果不进行序列化则会出现 编码问题</p>
<p>键(key)和值(value)都是通过Spring提供的Serializer序列化到数据库的。</p>
<p>RedisTemplate默认使用的是JdkSerializationRedisSerializer,</p>
<p>StringRedisTemplate默认使用的是stringRedisSerializer.KEY 被序列化成这样，线上通过 KEY 去查询对应的 VALUE非常不方便</p>
<ol>
<li>
<p><strong>可以将redisTemplate替换为StringRedisTemplate来解决序列化问题</strong></p>
</li>
<li>
<p><strong>redisTemplate默认构造方法是使用JDK序列化编码器，我们需要使用String序列化编码器</strong></p>
<p>配置文件：设置lettuce的初始化配置文件，在配置RedisConfig的时候使用lettuce来进行配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  redis:</span><br><span class="line">    database: 0</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br><span class="line">    lettuce:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 8</span><br><span class="line">        max-wait: 1ms</span><br><span class="line">        max-idle: 8</span><br><span class="line">        min-idle: 0</span><br></pre></td></tr></table></figure>
<p>配置RedisConfig指定序列化编码器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis序列化的工具配置类，下面这个请一定开启配置</span></span><br><span class="line"><span class="comment">     * 127.0.0.1:6379&gt; keys *</span></span><br><span class="line"><span class="comment">     * 1) &quot;ord:102&quot;  序列化过</span></span><br><span class="line"><span class="comment">     * 2) &quot;\xac\xed\x00\x05t\x00\aord:102&quot;   野生，没有序列化过</span></span><br><span class="line"><span class="comment">     * this.redisTemplate.opsForValue(); //提供了操作string类型的所有方法</span></span><br><span class="line"><span class="comment">     * this.redisTemplate.opsForList(); // 提供了操作list类型的所有方法</span></span><br><span class="line"><span class="comment">     * this.redisTemplate.opsForSet(); //提供了操作set的所有方法</span></span><br><span class="line"><span class="comment">     * this.redisTemplate.opsForHash(); //提供了操作hash表的所有方法</span></span><br><span class="line"><span class="comment">     * this.redisTemplate.opsForZSet(); //提供了操作zset的所有方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lettuceConnectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(LettuceConnectionFactory lettuceConnectionFactory)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        redisTemplate.setConnectionFactory(lettuceConnectionFactory);</span><br><span class="line">        <span class="comment">//设置key序列化方式string</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">//设置value的序列化方式json，使用GenericJackson2JsonRedisSerializer替换默认序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="集群"><a class="markdownIt-Anchor" href="#集群"></a> 集群</h2>
<p>定义配置文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">111111</span></span><br><span class="line">	<span class="comment"># 设置集群</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">max-redirects:</span> <span class="number">3</span> <span class="comment"># 获取失败 最大重定向次数</span></span><br><span class="line">      <span class="comment"># 设置集群节点</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="number">192.168</span><span class="number">.111</span><span class="number">.175</span><span class="string">:6381,192.168.111.175:6382,192.168.111.172:6383,192.168.111.172:6384,192.168.111.174:6385,192.168.111.174:6386</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">-1ms</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>正常写入即可</strong></p>
<p>如果集群中有一个master 宕机了之后，redis服务会自动的进行主从替换，但是Springboot没有动态的感受到RedisCluster的最新集群信息，这时候再次写入就会连接超时</p>
<p><strong>SpringBoot 2.X版本，Redis默认的连接池采用 Lettuce，当Redis 集群节点发生变化后，Letture默认是不会刷新节点拓扑</strong></p>
<p>配置动态拓扑刷新</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">111111</span></span><br><span class="line">	<span class="comment"># 设置集群</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">max-redirects:</span> <span class="number">3</span> <span class="comment"># 获取失败 最大重定向次数</span></span><br><span class="line">      <span class="comment"># 设置集群节点</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="number">192.168</span><span class="number">.111</span><span class="number">.175</span><span class="string">:6381,192.168.111.175:6382,192.168.111.172:6383,192.168.111.172:6384,192.168.111.174:6385,192.168.111.174:6386</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">-1ms</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="comment"># 配置动态刷新</span></span><br><span class="line">        <span class="attr">refresh:</span></span><br><span class="line">          <span class="attr">adaptive:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">period:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">Nuyoah</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://262259.xyz/2024/04/20/Redis7/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://262259.xyz/2024/04/20/Redis7/')">Redis7</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://s2.loli.net/2022/08/16/weL31EHsON5ldDU.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/08/16/weL31EHsON5ldDU.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/08/16/2yRjVx9gFKQaidA.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/08/16/2yRjVx9gFKQaidA.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://262259.xyz/2024/04/20/Redis7/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Redis7&amp;url=http://262259.xyz/2024/04/20/Redis7/&amp;pic=https://s2.loli.net/2022/11/19/vJMKhVAUYNXRQuE.jpg?_r_=2c77c62d-27f5-863c-fa81-c49d5475ad7e" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://262259.xyz" target="_blank">Nuyoah</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/11/11/PRhut51DVxg9XBc.jpg?_r_=02db7499-72ba-2304-866d-b5c2b561abcc" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/29/SpringCloud/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/19/MkDHwvYu5p8XLBy.jpg?_r_=22a033d6-4336-6958-277e-f4d49f190e44" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringCloud</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/27/redis%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%86%85%E5%AD%98%E4%B8%8D%E5%A4%9F%E9%97%AE%E9%A2%98/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/19/qOod8SkyLhct653.jpg?_r_=532170ac-7c96-d075-fbd1-4f181c38d451" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">redis服务启动内存不够问题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display: none">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Nuyoah</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/zjhinsist" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2152889763@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#redis7%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text"> Redis7入门概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.1.</span> <span class="toc-text"> 优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD"><span class="toc-number">1.2.</span> <span class="toc-text"> 下载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.</span> <span class="toc-text"> 安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text"> 启动服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4redis"><span class="toc-number">1.5.</span> <span class="toc-text"> 删除Redis</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E7%9A%8410%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text"> Redis的10大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 类型：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%AD%97%E7%AC%A6%E4%B8%B2string"><span class="toc-number">2.1.1.</span> <span class="toc-text"> redis字符串—String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%88%97%E8%A1%A8list"><span class="toc-number">2.1.2.</span> <span class="toc-text"> redis列表—List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%93%88%E5%B8%8C%E8%A1%A8hash"><span class="toc-number">2.1.3.</span> <span class="toc-text"> redis哈希表—Hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E9%9B%86%E5%90%88set"><span class="toc-number">2.1.4.</span> <span class="toc-text"> redis集合—Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zset"><span class="toc-number">2.1.5.</span> <span class="toc-text"> redis有序集合—ZSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4geo"><span class="toc-number">2.1.6.</span> <span class="toc-text"> redis地理空间—GEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1hyperloglog"><span class="toc-number">2.1.7.</span> <span class="toc-text"> redis基数统计—HyperLogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%BD%8D%E5%9B%BEbitmap"><span class="toc-number">2.1.8.</span> <span class="toc-text"> redis位图—bitmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%BD%8D%E5%9F%9Fbitfield"><span class="toc-number">2.1.9.</span> <span class="toc-text"> redis位域—bitfield</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%B5%81stream"><span class="toc-number">2.1.10.</span> <span class="toc-text"> redis流—Stream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text"> redis常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4%E5%8F%8A%E8%90%BD%E5%9C%B0%E8%BF%90%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text"> 数据类型命令及落地运用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-number">2.3.1.</span> <span class="toc-text"> String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-number">2.3.2.</span> <span class="toc-text"> List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash"><span class="toc-number">2.3.3.</span> <span class="toc-text"> Hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-number">2.3.4.</span> <span class="toc-text"> Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zset"><span class="toc-number">2.3.5.</span> <span class="toc-text"> ZSET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bitmap%E4%BD%8D%E5%9B%BE"><span class="toc-number">2.3.6.</span> <span class="toc-text"> BitMap位图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hyperloglog%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.3.7.</span> <span class="toc-text"> HyperLogLog基数统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4geo"><span class="toc-number">2.3.8.</span> <span class="toc-text"> 地理空间GEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%B5%81stream-2"><span class="toc-number">2.3.9.</span> <span class="toc-text"> Redis流（Stream）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text"> Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#rdb%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.1.</span> <span class="toc-text"> RDB数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 作用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E9%A2%91%E7%8E%87"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 保存频率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-number">3.1.4.</span> <span class="toc-text"> 自动触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-number">3.1.5.</span> <span class="toc-text"> 手动触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.6.</span> <span class="toc-text"> 恢复文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">3.1.7.</span> <span class="toc-text"> 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">3.1.8.</span> <span class="toc-text"> 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%92%8C%E4%BF%AE%E5%A4%8Drdb%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.9.</span> <span class="toc-text"> 检查和修复RDB文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E5%BF%AB%E7%85%A7rdb"><span class="toc-number">3.1.10.</span> <span class="toc-text"> 禁用快照RDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.1.11.</span> <span class="toc-text"> Redis优化配置项详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aof%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.2.</span> <span class="toc-text"> AOF持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E9%85%8D%E7%BD%AE"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 功能配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 恢复操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%81%A2%E5%A4%8D"><span class="toc-number">3.2.2.1.</span> <span class="toc-text"> 正常恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%81%A2%E5%A4%8D"><span class="toc-number">3.2.2.2.</span> <span class="toc-text"> 异常恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">3.2.3.</span> <span class="toc-text"> 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">3.2.4.</span> <span class="toc-text"> 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.5.</span> <span class="toc-text"> AOF重写机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.5.1.</span> <span class="toc-text"> 触发机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.5.2.</span> <span class="toc-text"> 重写原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4"><span class="toc-number">3.2.5.3.</span> <span class="toc-text"> 配置命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.6.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rdb-aof%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.3.</span> <span class="toc-text"> RDB-AOF混合持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E9%A1%BA%E5%BA%8F%E5%92%8C%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 数据恢复顺序和加载流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 如何选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text"> 纯缓存模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text"> Redis事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%91%BD%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text"> Redis命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 正常执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BE%E5%BC%83%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 放弃事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%83%A8%E7%BB%88%E6%AD%A2"><span class="toc-number">4.1.3.</span> <span class="toc-text"> 全部终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E9%94%99%E8%AF%AF"><span class="toc-number">4.1.4.</span> <span class="toc-text"> 终止错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watch%E7%9B%91%E6%8E%A7"><span class="toc-number">4.1.5.</span> <span class="toc-text"> WATCH监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BE%E5%BC%83%E7%9B%91%E6%8E%A7"><span class="toc-number">4.1.6.</span> <span class="toc-text"> 放弃监控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.2.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E7%AE%A1%E9%81%93"><span class="toc-number">5.</span> <span class="toc-text"> Redis管道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">5.1.</span> <span class="toc-text"> 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text"> 执行方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.3.</span> <span class="toc-text"> 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pipeline%E4%B8%8E%E5%8E%9F%E7%94%9F%E6%89%B9%E9%87%8F%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94"><span class="toc-number">5.3.1.</span> <span class="toc-text"> pipeline与原生批量命令对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pipeline%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%AF%B9%E6%AF%94"><span class="toc-number">5.3.2.</span> <span class="toc-text"> pipeline与事务对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pipline%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.3.3.</span> <span class="toc-text"> pipline注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E8%AE%A2%E9%98%85"><span class="toc-number">6.</span> <span class="toc-text"> Redis订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">6.1.</span> <span class="toc-text"> 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#subscribe"><span class="toc-number">6.1.1.</span> <span class="toc-text"> SUBSCRIBE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#publish"><span class="toc-number">6.1.2.</span> <span class="toc-text"> PUBLISH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#psubscribe"><span class="toc-number">6.1.3.</span> <span class="toc-text"> PSUBSCRIBE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pubsub"><span class="toc-number">6.1.4.</span> <span class="toc-text"> PUBSUB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsubscribe"><span class="toc-number">6.1.5.</span> <span class="toc-text"> UNSUBSCRIBE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#punsubscribe"><span class="toc-number">6.1.6.</span> <span class="toc-text"> PUNSUBSCRIBE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">6.2.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E5%A4%8D%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text"> Redis复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-2"><span class="toc-number">7.1.</span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">7.2.</span> <span class="toc-text"> 配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="toc-number">7.3.</span> <span class="toc-text"> 常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">7.4.</span> <span class="toc-text"> 修改配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%91%BD%E4%BB%A4"><span class="toc-number">7.5.</span> <span class="toc-text"> 主从命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%BB%E4%BB%8E%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">7.5.1.</span> <span class="toc-text"> 问题—主从写入配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%89%8B%E5%8A%A8%E6%8C%87%E5%AE%9A"><span class="toc-number">7.5.2.</span> <span class="toc-text"> 问题—命令操作手动指定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-number">7.6.</span> <span class="toc-text"> 薪火相传</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-number">7.7.</span> <span class="toc-text"> 反客为主</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.8.</span> <span class="toc-text"> 原理及工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-number">7.9.</span> <span class="toc-text"> 缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E5%93%A8%E5%85%B5"><span class="toc-number">8.</span> <span class="toc-text"> Redis哨兵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-3"><span class="toc-number">8.1.</span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">8.2.</span> <span class="toc-text"> 功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text"> 使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%93%A8%E5%85%B5%E6%9C%8D%E5%8A%A1"><span class="toc-number">8.3.1.</span> <span class="toc-text"> 创建哨兵服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">8.3.2.</span> <span class="toc-text"> 文件配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8redis-%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="toc-number">8.3.3.</span> <span class="toc-text"> 启动redis 一主二从</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%93%A8%E5%85%B5"><span class="toc-number">8.3.4.</span> <span class="toc-text"> 启动哨兵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%8C%82%E6%9C%BA"><span class="toc-number">8.3.5.</span> <span class="toc-text"> 模拟挂机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E7%BB%93%E6%9E%9C"><span class="toc-number">8.3.6.</span> <span class="toc-text"> 切换结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.4.</span> <span class="toc-text"> 运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">8.5.</span> <span class="toc-text"> 使用建议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E9%9B%86%E7%BE%A4"><span class="toc-number">9.</span> <span class="toc-text"> Redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">9.1.</span> <span class="toc-text"> 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-4"><span class="toc-number">9.2.</span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%AE%97%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text"> 集群算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A7%BD%E4%BD%8D"><span class="toc-number">9.3.1.</span> <span class="toc-text"> 槽位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%89%87"><span class="toc-number">9.3.2.</span> <span class="toc-text"> 分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-2"><span class="toc-number">9.3.3.</span> <span class="toc-text"> 优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A7%BD%E4%BD%8D%E6%98%A0%E5%B0%84"><span class="toc-number">9.4.</span> <span class="toc-text"> 槽位映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%E5%88%86%E5%8C%BA"><span class="toc-number">9.4.1.</span> <span class="toc-text"> 哈希取余分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95"><span class="toc-number">9.4.2.</span> <span class="toc-text"> 一致性HASH算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%A7%BD%E5%88%86%E5%8C%BA"><span class="toc-number">9.4.3.</span> <span class="toc-text"> 哈希槽分区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA"><span class="toc-number">9.5.</span> <span class="toc-text"> 集群环境的搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%BB%E4%B8%89%E4%BB%8Eredis%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-number">9.5.1.</span> <span class="toc-text"> 三主三从redis集群配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87redis-cli%E5%91%BD%E4%BB%A4%E4%B8%BA6%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9E%84%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%85%B3%E7%B3%BB"><span class="toc-number">9.5.2.</span> <span class="toc-text"> 通过redis-cli命令为6台机器构建集群关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%B8%BB3%E4%BB%8Eredis%E9%9B%86%E7%BE%A4%E8%AF%BB%E5%86%99"><span class="toc-number">9.5.3.</span> <span class="toc-text"> 3主3从redis集群读写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%AE%B9%E9%94%99%E5%88%87%E6%8D%A2"><span class="toc-number">9.6.</span> <span class="toc-text"> 主从容错切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E4%BB%8E%E5%B1%9E%E8%B0%83%E6%95%B4"><span class="toc-number">9.6.1.</span> <span class="toc-text"> 节点从属调整</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%89%A9%E5%AE%B9"><span class="toc-number">9.7.</span> <span class="toc-text"> 主从扩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E7%BC%A9%E5%AE%B9"><span class="toc-number">9.8.</span> <span class="toc-text"> 主从缩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">9.9.</span> <span class="toc-text"> 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="toc-number">9.9.1.</span> <span class="toc-text"> 常用命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springboot%E6%95%B4%E5%90%88redis"><span class="toc-number">10.</span> <span class="toc-text"> SpringBoot整合Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jedis"><span class="toc-number">10.1.</span> <span class="toc-text"> Jedis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lettuce"><span class="toc-number">10.2.</span> <span class="toc-text"> Lettuce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redistemplate"><span class="toc-number">10.3.</span> <span class="toc-text"> RedisTemplate !!!</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E4%BE%9D%E8%B5%96"><span class="toc-number">10.3.1.</span> <span class="toc-text"> 引依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">10.3.2.</span> <span class="toc-text"> yml配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">10.3.3.</span> <span class="toc-text"> 定义配置类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">10.3.4.</span> <span class="toc-text"> 测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">10.3.5.</span> <span class="toc-text"> 序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">10.4.</span> <span class="toc-text"> 集群</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/30/LocalDate%E4%B8%8ELocalTime%E4%B8%8ELocalDateTime%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/" title="LocalDate与LocalTime与LocalDateTime的区别与联系"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/11/PRhut51DVxg9XBc.jpg?_r_=02db7499-72ba-2304-866d-b5c2b561abcc" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LocalDate与LocalTime与LocalDateTime的区别与联系"/></a><div class="content"><a class="title" href="/2025/12/30/LocalDate%E4%B8%8ELocalTime%E4%B8%8ELocalDateTime%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/" title="LocalDate与LocalTime与LocalDateTime的区别与联系">LocalDate与LocalTime与LocalDateTime的区别与联系</a><time datetime="2025-12-30T14:29:30.000Z" title="发表于 2025-12-30 22:29:30">2025-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/17/HttpServletRequest%E4%B8%ADInputStream%E8%AF%BB%E5%8F%96%E9%97%AE%E9%A2%98/" title="HttpServletRequest中InputStream读取问题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/10/An5KBXLNYlODop3.jpg?_r_=2c4d7584-e768-bb6c-3a0a-5ad27f948644" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HttpServletRequest中InputStream读取问题"/></a><div class="content"><a class="title" href="/2025/02/17/HttpServletRequest%E4%B8%ADInputStream%E8%AF%BB%E5%8F%96%E9%97%AE%E9%A2%98/" title="HttpServletRequest中InputStream读取问题">HttpServletRequest中InputStream读取问题</a><time datetime="2025-02-17T13:21:05.000Z" title="发表于 2025-02-17 21:21:05">2025-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/23/contains%E5%92%8Cfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB/" title="contains和for循环的区别"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/19/v4brSR2Dn3BjXpt.jpg?_r_=e0547e9c-26e6-a1ca-6f51-0d079d6c85a3" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="contains和for循环的区别"/></a><div class="content"><a class="title" href="/2024/11/23/contains%E5%92%8Cfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB/" title="contains和for循环的区别">contains和for循环的区别</a><time datetime="2024-11-23T13:08:43.000Z" title="发表于 2024-11-23 21:08:43">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/27/%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/" title="文件的上传和下载"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s3.bmp.ovh/imgs/2022/11/08/3b73e41bdfc1757c.png?_r_=72c3578e-ffe7-8573-6764-dc218b3f49ff" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文件的上传和下载"/></a><div class="content"><a class="title" href="/2024/10/27/%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/" title="文件的上传和下载">文件的上传和下载</a><time datetime="2024-10-27T01:50:10.000Z" title="发表于 2024-10-27 09:50:10">2024-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/15/SpringSecurity%E5%A4%8D%E4%B9%A0/" title="SpringSecurity"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/10/1dfka8LsM9ZKpVc.jpg?_r_=46ac48e8-86c9-d59d-624d-fef0a432f8c9" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringSecurity"/></a><div class="content"><a class="title" href="/2024/10/15/SpringSecurity%E5%A4%8D%E4%B9%A0/" title="SpringSecurity">SpringSecurity</a><time datetime="2024-10-15T00:39:29.000Z" title="发表于 2024-10-15 08:39:29">2024-10-15</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" href="/docs/">文档</a><a class="footer-item" title="源码" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu">源码</a><a class="footer-item" title="更新日志" href="/update/">更新日志</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Nuyoah" target="_blank">Nuyoah</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">10</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://262259.xyz/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" href="https://262259.xyz/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">管理</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://qexo.262259.xyz/" title="博客后端"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://unpkg.com/qexo-static@1.4.0/assets/img/brand/qexo.png" alt="博客后端"/><span class="back-menu-item-text">博客后端</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Gitee/" style="font-size: 0.88rem;">Gitee<sup>1</sup></a><a href="/tags/JAVA/" style="font-size: 0.88rem; font-weight: 500; color: var(--anzhiyu-lighttext)">JAVA<sup>5</sup></a><a href="/tags/JS/" style="font-size: 0.88rem;">JS<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>1</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>7</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>2</sup></a><a href="/tags/hexo/" style="font-size: 0.88rem;">hexo<sup>4</sup></a><a href="/tags/win10/" style="font-size: 0.88rem;">win10<sup>1</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/" style="font-size: 0.88rem;">个人日记<sup>1</sup></a><a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 0.88rem;">人工智能<sup>15</sup></a><a href="/tags/%E5%B7%A5%E4%BD%9C/" style="font-size: 0.88rem;">工作<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%BA%8E%E9%80%BB%E8%BE%91/" style="font-size: 0.88rem;">数字电路于逻辑<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" style="font-size: 0.88rem;">算法实现<sup>12</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">计算机基础<sup>13</sup></a></div></div><hr/></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开/关闭中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版/本站右键菜单</div></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Nuyoah 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.262259.xyz/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.262259.xyz/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.262259.xyz/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>