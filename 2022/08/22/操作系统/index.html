<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>操作系统教程 | Nuyoah</title><meta name="keywords" content="计算机基础"><meta name="author" content="Nuyoah"><meta name="copyright" content="Nuyoah"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="操作系统教程"><meta name="application-name" content="操作系统教程"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="操作系统教程"><meta property="og:url" content="http://262259.xyz/2022/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><meta property="og:site_name" content="Nuyoah"><meta property="og:description" content="操作系统第一章：初试操作系统  操作系统的概念，功能和目标 操作系统的概念：   应用程序如: QQ，IE浏览器，英雄联盟... 操作系统的功能:   负责管理协调硬件、软件等计算机资源的工作 为上层的应用程序、用户提供简单易用的服务 操作系统是系统软件，而不是硬件  裸机（纯硬件）: 如CPU，"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://s2.loli.net/2022/11/21/aDwOWz8tq3yJ1Yb.webp"><meta property="article:author" content="Nuyoah"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2022/11/21/aDwOWz8tq3yJ1Yb.webp"><meta name="description" content="操作系统第一章：初试操作系统  操作系统的概念，功能和目标 操作系统的概念：   应用程序如: QQ，IE浏览器，英雄联盟... 操作系统的功能:   负责管理协调硬件、软件等计算机资源的工作 为上层的应用程序、用户提供简单易用的服务 操作系统是系统软件，而不是硬件  裸机（纯硬件）: 如CPU，"><link rel="shortcut icon" href="https://s1.ax1x.com/2022/11/27/zUFla6.png"><link rel="canonical" href="http://262259.xyz/2022/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"404！加载失败！","backTitle":"加载成功！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.262259.xyz/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":"a665f8c80fd739329dd0d3f3fe7d90fc"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Nuyoah","link":"链接: ","source":"来源: Nuyoah","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: {"enable":true,"delay":100,"shiftDelay":200},
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Nuyoah',
  title: '操作系统教程',
  postAI: '',
  pageFillDescription: ' 操作系统第一章：初试操作系统,  操作系统的概念功能和目标,  操作系统的特征,  操作系统的发展和分类,  操作系统的运行机制和体系结构,  中断和异常,  系统调用,  操作系统第二章：进程管理,  进程的定义组成组成方式特征,  进程的状态,  进程控制,  进程通信,  线程概念多线程模型,  处理机调度的概念层次,  进程调度的时机切换与过程方式,  调度算法的评价指标,  调度算法,  FCFS（先来先服务）（First Come First Serve）,  SJF（短作业优先）（Shortest Job First）,  HRRN（高响应比优先）（Highest Response RatIO Next）,  RR（时间片轮转调度算法）（Round-Robin）,  优先级调度算法,  多级返回队列调度算法,  进程同步和进程互斥,  进程互斥的软件实现方法,  单标志法,  双标志先检查,  双标志后检查,  Peterson算法,  进程互斥硬件实现方法,  中断屏蔽方法,  TestAndSet(Ts指令/TSL指令),  Swap指令(XCHG指令),  信号量机制,  整形信号量,  记录性信号量,  用信号量实现进程互斥同步前驱关系,  用信号量实现进程互斥,  用信号量实现进程同步,  用信号量实现前驱关系,  生产者消费者问题,  多生产者-多消费者,  单生产者多消费者,  读者写者问题,  哲学家进餐,  管程,  死锁,  预防死锁,  避免死锁,  死锁的检测和解除,  操作系统第三章：内存管理,  内存的基础知识,  装入的三种方式,  链接的三种方式,  内存管理的概念,  覆盖与交换,  覆盖技术,  交换技术,  连续分配管理方式,  单一连续分配,  固定分区分配,  动态分区分配,  动态分配算法,  首次适应算法(First Fit),  最佳适应算法(Best Fit),  最坏适应算法(Worst Fit),  邻近适应算法(Next Fit),  基本分页存储管理的基本概念,  分页存储管理的基本概念,  如何实现地址的转换,  逻辑地址结构,  页表,  基本地址变换结构,  对页表项的进一步讨论,  具有快表的地址变换机构,  局部性原理,  快表机制(TLB TranslatIOn Lookaside Buffer),  引入快表之后地址的变化过程,  两级页表,  单级页表存在什么问题?如何解决?,  两级页表的原理、逻辑地址结构,  如何实现地址变换?,  两级页表问题需要注意的几个细节,  基本分段存储方式,  分段,  段表,  分段和分页管理的对比,  段页式管理方式,  虚拟内存,  虚拟内存的定义和特征,  如何实现虚拟内存技术,  请求分页管理方式,  缺页中断机构,  页面置换算法,  最佳置换算法(OPT),  先进先出算法(FIFO),  最近最久未使用置换算法(LRU),  时钟置换算法(Clock),  改进型的时钟置换算法,  页面分配策略,  页面分配置换策略,  调入页面的时机,  抖动(颠簸)现象,  工作机,  操作系统第四章：文件管理,  初识文件管理,  文件的逻辑结构,  有结构文件,  顺序文件,  索引文件,  顺序索引文件,  多级索引顺序文件,  文件目录,  文件控制块,  单级目录结构,  两极目录结构,  多级目录结构-树形目录结构,  无环图目录结构,  索引节点(FCB的改进),  文件的物理结构,  文件的分配方式：连续分配,  文件的分配方式：链接分配,  文件的分配方式：索引的分配,  文件存储空间管理,  存储空间的划分和初始化,  存储空间管理-空闲表法,  存储空间管理-位示图法,  存储空间管理–成组链接法,  文件的基本操作,  创建文件(create系统调用),  删除文件(delete系统调用),  读文件(read系统调用),  写文件(write系统调用),  打开文件(open系统调用),  关闭文件(close系统调用),  文件共享,  基于索引节点的共享方式(硬链接),  基于符号链的共享方式(软连接),  文件保护,  口令保护,  加密保护,  访问控制,  文件系统的层次结构,  磁盘的结构,  磁盘磁道扇区,  磁盘的读写操作,  盘面柱面,  磁盘的分类,  磁盘调度算法,  一次磁盘读/写操作所需要的时间,  先来先服务算法,  扫描算法,  Look算法,  循环扫描算法(C-Scan),  C-LOOK调度算法,  减少磁盘延迟时间的方法,  减少延迟时间的方法交替编号,  磁盘地址结构的设计,  减少延迟时间的方法：错位命名,  磁盘的管理,  磁盘初始化,  引导块,  坏块的管理,  操作系统第五章：I/O设备,  IO的概念和分类,  IO的概念,  IO设备分类—按使用特性分类,  IO设备分类—按传输速率分配,  IO设备分类—按信息交换的单位分类,  IO控制器,  机械部件,  电子部件,  IO控制器的组成,  内存映像IO和寄存器独立编址,  IO控制方式,  程序直接控制方式,  中断驱动方式,  DMA方式,  通道控制方式,  IO软件层次结构,  用户层软件,  设备独立性软件,  设备驱动程序,  中断处理程序,  IO核心子系统,  IO调度,  设备保护,  假脱机技术(SPOOLING技术),  什么是脱机技术,  假脱机技术–输入/输出缓冲区,  共享打印机原理分析,  设备的分配与回收,  设备分配时应考虑的因素,  静态分配与动态分配,  设备分配管理中的数据结构,  设备分配的步骤,  设备分配步骤的改进方法,  缓冲区管理,  什么是缓冲区？有什么作用？,  单缓冲,  双缓冲,  使用单双缓冲在通信时的区别,  循环缓冲区,  缓冲池操作系统第一章初试操作系统操作系统的概念功能和目标操作系统的概念应用程序如浏览器英雄联盟操作系统的功能负责管理协调硬件软件等计算机资源的工作为上层的应用程序用户提供简单易用的服务操作系统是系统软件而不是硬件裸机纯硬件如硬盘内存操作系统的定义操作系统是指控制和管理整个计算机系统的硬件和软件资源并合理地组织调度计算机的工作和资源的分配以提供给用户和其他软件方便的接口和环境它是计算机系统中最基本的系统软件操作系统的功能和目标操作系统作为系统资源的管理者这些资源包括软件硬件文件等需要提供什么功能用和朋友视频聊天的过程在各个文件夹中找到安装的位置如逐层打开文件夹找到这个程序可执行文件的存放位置文件管理双击打开需要把改程序相关数据放入内存存储器管理程序正常运行对应的进程被处理机处理处理机管理开始和朋友视频聊天需要将摄像头设备分配给进程设备管理操作系统作为用户与计算机硬件之间的接口要为其上层的用户应用程序提供简单易用的服务需要实现什么功能命令接口允许用户直接使用联机命令接口用户说一句系统做一句交互式命令接口脱机命令接口用户说一堆系统做一堆批处理命令接口程序接口允许用户通过程序间接使用由一组系统调用组成程序接口系统调用只能通过用户程序间接使用系统调用系统调用命令广义指令现代操作系统中最流行的图形用户接口所有提供给用户的接口可以统称为用户接口操作系统作为最接近硬件的层次需要在纯硬件的基础上实现什么功能需要提供的功能和目标实现对硬件机器的拓展没有任何软件支持的计算机成为裸机在裸机上安装的操作系统可以提供资源管理功能和方便用户的服务功能将裸机改造成功能更强使用更方便的机器通常把覆盖了软件的机器成为扩充机器又称之为虚拟机操作系统的特征操作系统的特征包括并发共享虚拟异步这四个特征其中并发和共享是两个最基本的特征二者互为存在条件并发其中并发指两个或多个事件在同一时间间隔内发生这些事件宏观上是同时发生的但微观上是交替发生的常考易混概念一一并行指两个或多个事件在同一时刻同时发生操作系统的并发性指计算机系统中同时存在着多个运行着的程序一个单核处理器同一时刻只能执行一个程序因此操作系统会负责协调多个程序交替执行这些程序微观上是交替执行的但是在宏观上是同时执行的事实上操作系统是伴随着多道程序技术而出现的因此操作系统和程序并发是一起出现的当今的计算机一般都是多核比如的第八代处理器就是核这意味着同一时刻可以有个程序并行执行但是操作系统的并发性依然必不可少当代人使用计算机绝对有个以上的程序需要同时工作共享共享即资源共享是指系统中的资源可供内存中多个并发执行的进程共同使用两种资源共享方式互斥共享方式同时共享方式系统中的某些资源虽然可以提供个多个进程使用但是一个时间段内只允许一个进程访问该资源例子使用和微信进行视频的时候同一时间段内摄像头只能分配给其中一个进程系统中的某些资源允许一个时间段内由多个进程同时对他进行访问所谓的同时往往是宏观上的而在微观上这些进程可能是交替的对该资源进行访问即分时共享同时共享方式使用发送文件同时使用微信发送文件宏观上看两边都在同时读取并发送文件说明两个进程都在访问硬盘资源从中读取数据微观上看两个进程是交替着访问硬盘的并发性指计算机系统中同时存在着多个运行着的程序共享性是指系统中的资源可供内存中多个并发执行的进程共同使用通过上述例子来看并发与共享的关系使用发送文件同时使用微信发送文件并发性共享性两个进程正在并发执行如果失去并发性则系统中只有一个程序正在运行则共享性失去存在的意义共享性就是让多个进程同时对它进行访问但是如果失去并发性的话又何来多个进程同时存在哪需要共享地访问硬盘资源如果失去共享性则和微信不能同时访问硬盘资源就无法实现同时发送文件也就无法并发既然不能同时访问这个文件那么同一时间只能有一个进程在运作所以也就有了并发性虚拟这里说明虚拟是指把一个物理上的实体变为若干个逻辑上的对应物物理实体前者是实际存在的而逻辑上对应物后者是用户感受到的例如一个单核可以同时开很多个文件这给我们的感觉就是看起来是有多个同时在为我进行服务这时候就用到了虚拟技术虚拟技术中的时分复用技术微观上处理机在各个微小的时间段内交替着为各个进程服务显然如果失去了并发性则一个时间段内系统中只需运行一道程序那么就失去了实现虚拟性的意义了因此没有并发性就谈不上虚拟性异步其中异步是指在多道程序环境下允许多个程序并发执行但由于资源有限进程的执行不是一贯到底的而是走走停停以不可预知的速度向前推进这就是进程的异步性显然如果失去了异步性则系统只能串行地处理各个进程每个进程的执行会一贯到底只有系统拥有并发性才有可能导以异步性操作系统的发展和分类手工操作阶段手工操作阶段每一个程序员都需要把自己写的程序用二进制写在纸带上然后通过纸带机传递给计算机等待计算机运算完毕之后再由纸带机将纸带返回回来纸带上的二进制就是计算机计算完之后的结果手工操作阶段主要缺点用户独占全机就是每一个机器同时只能为一个人服务人机速度矛盾导致资源利用率极低批处理阶段单道批处理系统多道批处理系统引入脱机输入输出技术用磁带完成并监督程序操作系统的雏形负责控制作业的输入和输出单道批处理系统引入了一个外围机从外围机中读取数据要比从人工哪读取数据快的多并且这里可以支持多人共同使用这个机器单道批处理系统主要优点缓解了一定程度的人机速度矛盾资源利用率有所提升主要缺点内存中仅能有一道程序运行只有该程序运行结束之后才能调入下一道程序有大量的时间是在空闲等待完成资源利用率依然很低操作系统开始出现多道批处理系统主要优点多道程序并发执行共享计算机资源资源利用率大幅提升和其他资源保持忙碌状态系统吞吐量增大主要缺点用户响应时间长没有人机交互功能用户提交自己的作业之后就只能等待计算机处理完成中间不能控制自己的作业执行为什么多道批处理系统能使资源利用率大幅度提升假设计算机需要处理三个作业作业一输入秒计算秒输出秒作业二输入秒计算秒输出秒作业三输入秒计算秒输出秒单道批处理技术多道批处理系统分时操作系统分时操作系统计算机以时间片为单位轮流为各个用户作业服务各个用户可通过终端与计算机进行交互主要优点用户请求可以被即时响应解决了人机交互问题允许多个用户同时使用一台计算机并且用户对计算机的操作相互独立感受不到别人的存在主要缺点不能优先处理一些紧急任务操作系统对各个用户作业都是完全公平的循环地为每个用户作业服务一个时间片不区分任务的紧急性实时操作系统实时操作系统主要优点能够优先响应一些紧急任务某些紧急任务不需时间片排队在实时操作系统的控制下计算机系统接收到外部信号后及时进行处理并且要在严格的时限内处理完事件实时操作系统的主要特点是及时性和可靠性网络操作系统网络操作系统是伴随着计算机网络的发展而诞生的能把网络中各个计算机有机地结合起来实现数据传送等功能实现网络中各种资源的共享如文件共享和各台计算机之间的通信如就是一种典型的网络操作系统网站服务器就可以使用分布式操作系统分布式操作系统主要特点是分布性和并行性系统中的各台计算机地位相同任何工作都可以分布在这些计算机上由它们并行协同完成这个任务个人计算机操作系统个人计算机操作系统如方便个人使用操作系统的运行机制和体系结构什么是指令指令和我们平时所接触的代码有什么区别语言代码需要翻译为机器指令然后才能看懂简单来说指令就是处理器能识别执行的最基本命令比如加法指令就是让进行加法运算操作系统的两种指令指令分为两种特权指令非特权指令不允许用户程序使用例如内存清零指令如果用户程序可以使用这个指令就意味着一个用户可以将其他用户的内存数据随意清零这样做显然是很危险的如普通的运算指令能够让用户使用的两种形态如何判断当前是否可以执行特权指令这就引出两种处理状态用程序状态字寄存器中的某标志位来标识当前处理器处于什么状态如为用户态为核心态用户态目态核心态管态当处于这种形态的时候表明这时候只能执行非特权指令当处于这种形态的时候表明这时候特权指令和非特权指令都可以执行程序的两种方式有些程序需要执行特权指令有些程序需要执行非特权指令这时候程序就分为两种形态内核程序应用程序操作系统的内核程序是系统的管理者既可以执行特权指令也可以执行非特权指令运行在核心态为了保证系统能安全运行普通应用程序只能执行非特权指令运行在用户态操作系统的内核操作系统中那些功能应该由内核程序实现呢时钟管理实现计算机的计时功能所有的进程切换和进程调度都需要使用时钟管理来辅助实现源语原语是一种特殊的程序是最接近硬件的部分这种程序的运行具有原子性内核是计算机上配置的底层软件是操作系统最基本最核心的部分实现操作系统内核功能的那些程序就是内核程序内核分为大内核和微内核大内核其中包含了对系统资源管理的功能而微内核中只有时钟管理中断管理和原语操作系统的体系结构问题与企业的管理问题很相似内核就是企业的管理层负责一些重要的工作只有管理层才能执行特权指令普通员工只能执行非特权指令用户态核心态之间的切换相当于普通员工和管理层之间的工作交接大内核企业初创时体量不大管理层的人会负责大部分的事情优点是效率高缺点是组织结构混乱难以维护微内核随着企业体量越来越大管理层只负责最核心的一些工作优点是组织结构清晰方便维护缺点是效率低中断和异常早期的计算机在接受一堆指令的时候等待指令处理完之后必须经过处理完成之后才能彻底离开处理器缺点各个程序只能串行的执行系统资源利用率低为了解决上述问题人们发明了操作系统作为计算机的管理者引入中断机制实现了多道程序并发执行本质发生中断就意味着需要操作系统介入开展管理工作中断的概念和作用当中断发生时立即进入核心态当中断发生后当前运行的进程暂停运行并由操作系统内核对中断进行处理对于不同的中断信号会进行不同的处理发生了中断就意味着需要操作系统介入开展管理工作由于操作系统的管理工作比如进程切换分配设备等需要使用特权指令因此要从用户态转为核心态中断可以使从用户态切换为核心态使操作系统获得计算机的控制权有了中断才能实现多道程序并发执行问用户态核心态之间的切换是怎么实现的答用户态核心态是通过中断实现的并且中断是唯一途径核心态用户态的切换是通过执行一个特权指令将程序状态字的标志位设置为用户态中断的分类外中断处理过程执行完每个指令之后都要检查当前是否有外部中断信号如果检测到外部中断信号则需要保护被中断进程的环境如程序状态字程序计数器各种通用寄存器根据中断信号类型转入相应的中断处理程序恢复原进程的环境并退出中断返回原进程继续往下执行系统调用什么是系统调用有何作用操作系统作为用户和计算机硬件之间的接口需要向上提供一些简单易用的服务主要包括命令接口和程序接口其中程序接口由一组系统调用组成系统调用是操作系统提供给应用程序程序员编程人员使用的接口可以理解为一种可供应用程序调用的特殊函数应用程序可以发出系统调用请求来获得操作系统的服务应用程序通过系统调用请求操作系统的服务系统中的各种共享资源都由操作系统统一掌管因此在用户程序中凡是与资源有关的操作如存储分配操作文件管理等都必须通过系统调用的方式向操作系统提出服务请求由操作系统代为完成这样可以保证系统的稳定性和安全性防止用户进行非法操作系统调用相关处理涉及到对系统资源的管理对进程的控制这些功能需要执行一些特权指令才能完成因此系统调用的相关处理需要在核心态下进行系统调用与库函数的区别普通应用程序可以直接使用系统调用也可以使用库函数有的库函数涉及系统调用有的不涉及编程语言向上提供库函数有时会将系统调用封装成库函数以隐藏系统调用的一些细节使上层进行系统调用更加方便操作系统向上提供系统调用裸机不涉及系统调用的库函数如的取绝对值的函数涉及系统调用的库函数如创建一个新文件的函数系统调用背后的过程传递系统调用参数执行陷入指令用户态执行系统调用相应服务程序核心态返回用户程序注意陷入指令是在用户态执行的执行陷入指令之后立即引发一个内中断从而进入核心态发出系统调用请求是在用户态而对系统调用的相应处理在核心态下进行陷入指令是唯一一个只能在用户态执行而不可在核心态执行的指令操作系统第二章进程管理进程的定义组成组成方式特征程序的定义程序就是一个指令序列早期的计算机只支持单道程序就是每一次只能进行一个程序内存中同一个时间段内只有一个程序在运行所以程序的程序段和数据段可以放在固定的位置程序的代码放在程序段内程序运行过程处理的数据放在数据段内如变量引入多通道技术之后内存中同时放入多道程序各个程序的代码运算数据存放的位置不同操作系统要怎么才能找到各程序的存放位置呢为了方便操作系统管理完成各程序并发执行引入了进程进程实体的概念系统为每个运行的程序配置一个数据结构称为进程控制块用来描述进程的各种信息如程序代码存放位置进程的定义程序段数据段三部分组成了进程实体进程映像一般情况下我们把进程实体就简称为进程例如所谓创建进程实质上是创建进程实体中的而撤销进程实质上是撤销进程实体中的注意是进程存在的唯一标志从不同的角度进程可以有不同的定义比较传统典型的定义有强调动态性进程是程序的一次执行过程进程是一个程序及其数据在处理机上顺序执行时所发生的活动进程是具有独立功能的程序在数据集合上运行的过程它是系统进行资源分配和调度的一个独立单位引入进程实体的概念后可把进程定义为进程是进程实体的运行过程是系统进行资源分配和调度的一个独立单位注严格来说进程实体和进程并不一样进程实体是静态的进程则是动态的不过除非题目专门考察二者区别否则可以认为进程实体就是进程因此我们也可以说进程由程序段数据段三部分组成进程的组成进程进程实体由程序段数据段三部分组成操作系统通过来管理进程因此中应该包含操作系统对其进行管理所需的各种信息程序段程序代码即存放在此数据段程序运行时使用产生的运算数据如全局变量局部变量宏定义的常量就存放在数据段内进程的组织在一个系统中通常有数十数百乃至数千个为了能对他们加以有效的管理应该用适当的方式把这些组织起来注进程的组成讨论的是一个进程内部由哪些部分构成的问题而进程的组织讨论的是多个进程之间的组织方式问题链接方式索引方式执行指针指向当前处于运行态执行态的进程单核计算机中同一时刻只会有一个进程处于运行态就绪队列指针指向当前处于就绪态的进程通常会把优先级高的进程放在队头阻塞队列指针指向当前处于阻塞态的进程很多操作系统还会根据阻塞原因不同再分为多个阻塞队列执行指针和链接方式一样就绪表指针阻塞表指针进程的特征进程和特征具有两个截然不同的概念相对于程序进程有以下特征进程的状态进程是程序的一次执行在这个执行过程中有时进程正在被处理有时又需要等待服务可见进程的状态是会有各种变化为了方便对各个进程的管理操作系统需要将进程合理地划分为几种状态进程的三种基本状态注意运行态单核处理机环境下每一时刻最系只有一个进程处于运行态双核环境下可以同时有两个进程处于运行态就绪态进程已经有了除了处理机外所有需要的资源一旦获得处理机即可立即进入运行态开始运行即万事具备只欠阻塞态如等待操作系统分配打印机等待读磁盘操作的结果是计算机中最昂贵的部件为了提高的利用率需要先将其他进程需要的资源分配到位才能得到的服务另外两种状态创建态又称新建态进程正在被创建操作系统为进程分配资源初始化终止态又称结束态进程正在从系统中撤销操作系统会回收进程拥有的资源撤销进程状态的转换进程控制进程控制的主要工能是对系统中所有进程实施有效的管理它具有创建新进程撤销已有进程实现进程状态转变等功能简化理解进程控制就是要实现进程状态的转换如何实现进程控制用原语实现进程控制原语的特点是执行期间不允许中断只能一气呵成这种不可被中断的操作即原子操作原语采用关中断指令和开中断指令实现显然关开中断指令的权限非常大必然是只允许在核心态下执行的特权指令进程控制相关原语学习技巧进程控制会导致进程状态的转换无论哪个原语要做的无非三类事情更新中的信息如修改进程状态标志将运行环境保存到从恢复运行环境所有的进程控制原语一定都会修改进程状态标志剥夺当前运行进程的使用权必然需要保存其运行环境某进程开始运行前必然要恢复期运行环境将插入合适的队列分配回收资源进程通信什么事进程通信顾名思义进程通讯就是指进程之间的信息交换进程是分配系统资源的单位包括内存地址空间因此各进程拥有的内存地址空间相互独立为了保证进程的安全一个进程不能直接访问另一个进程的地址空间但是进程之间的信息交换又是必须要实现的为了保证进程之间的安全通信操作系统提供了一些方法进程通讯分为三种共享存储消息传递管道通信共享存储消息传递管道通信两个进程对共享空间的访问必须是互斥的互斥访问通过操作系统提供的工具实现操作系统只负责提供共享空间和同步互斥工具如操作共享存储分为两种基于数据结构的共享基于数据结构的共享比如共享空间里只能放一个长度为的数组这种共享方式速度慢限制多是一种低级通信方式基于存储区的共享基于存储区的共享在内存中画出一块共享存储区数据的形式存放位置都由进程控制而不是操作系统相比之下这种共享方式速度更快是一种高级通信方式进程之间的数据交换以格式化的信息为单位进程通过操作系统提供的发送消息接收消息两个原语进行数据交换格式化信息分为消息头消息头包括发送进程接受进程消息类型消息长度等格式化的信息计算机网络中发送的报文其实就是一种格式化的消息消息体消息传递分为直接通讯传递消息直接挂到接收进程的消息缓冲队列上间接通讯传递消息要先发送到中间实体信箱中因此也称为信箱通讯方式管道是指用于连接读写进程的一个共享文件又名文件其实就是在内存中开辟个大小固定的缓冲区管道只能采用半双工通信某一时间段内只能实现单向的传输如果要实现双向同时通信则需要设置两个管道各进程要互斥的访问管道数据以字符流的形式写入管道当管道写满时写进程的系统调用将被阻塞等待读进程将数据取走当读进程将数据全部取走后管道变空此时读进程的系统调用将被阻塞如果没写满就不允许读如果没读空就不允许写数据一旦被读出就从管道中被抛弃这就意味着读进程最多只能有一个否则可能会有读错数据的情况线程概念多线程模型什么是线程为什么要引入线程在没有进程之前一次只能为一个程序进行服务引入进程之后可以一次性为多个进程进行服务例如原先玩和听音乐只能选择其中一个运行但是引入进程之后我们就可以边听音乐边玩但是有许多功能例如视频聊天文字聊天如果让一个进程同时进行不同的功能呢这时候就需要引入线程可以把线程理解为轻量级进程线程是一个基本的执行单元也是程序执行流的最小单位引入线程之后不仅是进程之间可以并发进程内的各线程之间也可以并发从而进一步提升了系统的并发度使得一个进程内也可以并发处理各种任务如视频文字聊天传文件引入线程后进程只作为除之外的系统资源的分配单元如打印机内存地址空间等都是分配给进程的线程的属性线程是处理机调度的单位多计算机中各个线程可占用不同的每个线程都有一个线程线程控制块线程也有就绪阻塞运行三种基本状态线程几乎不拥有系统资源同一进程的不同线程间共享进程的资源由于共享内存地址空间同一进程中的线程间通信甚至无需系统干预同一进程中的线程切换不会引起进程切换不同进程中的线程切换会引起进程切换切换同进程内的线程系统开销很小切换进程系统开销较大线程的实现方式用户级线程内核级线程用户级线程由应用程序通过线程库实现所有的线程管理工作都由应用程序负责包括线程切换用户级线程中线程切换可以在用户态下即可完成无需操作系统干预在用户看来是有多个线程但是在操作系统内核看来并意识不到线程的存在用户级线程对用户不透明对操作系统透明可以这样理解用户级线程就是从用户视角看能看到的线程内核级线程的管理工作由操作系统内核完成线程调度切换等工作都由内核负责因此内核级线程的切换必然需要在核心态下才能完成可以这样理解内核级线程就是从操作系统内核视角看能看到的线程在同时支持用户级线程和内核级线程的系统中可采用二者组合的方式将个用户级线程映射到个内核级线程上重点操作系统只看得见内核级线程因此只有内核级线程才是处理机分配的单位例如下边这个模型中该进程由两个内核级线程三个用户级线程在用户看来这个进程中有三个线程但即使该进程在一个核处理机的计算机上运行也最多只能被分配到两个核最多只能有两个用户线程并行执行多线程模型多对一模型一对一模型多对多模型多对一模型多个用户及线程映射到一个内核级线程每个用户进程只对应一个内核级线程优点用户级线程的切换在用户空间即可完快不需要切换到核心态线程管理的系统开销小效率高缺点当一个用户级线程被阻塞后整个进程都会被阻塞并发度不高多个线程不可在多核处理机上并行运行一对一模型一个用户及线程映射到一个内核级线程每个用户进程有与用户级线程同数量的内核级线程优点当一个线程被阻塞后别的线程还可以继续执行并发能力强多线程可在多核处理机上并行执行缺点一个用户进程会占用多个内核级线程线程切换由操作系统内核完成需要切换到核心态因此线程管理的成本高开销大多对多模型用户级线程映射到个内核级线程每个用户进程对应个内核级线程克服了多对一模型并发度不高的缺点又克服了一对一模型中一个用户进程占用太多内核级线程开销太大的缺点处理机调度的概念层次当有一堆任务要处理但由于资源有限这些事情没法同时处理这就需要确定某种规则来决定处理这些任务的顺序这就是调度研究的问题在多道程序系统中进程的数量往往是多于处理机的个数的这样不可能同时并行地处理各个进程处理机的调度从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行以实现进程的并发执行调度的三个层次高级调度中级调度低级调度高级调度作业调度按一定的原则从外存上处于后备队列的作业中挑选一个或多个作业给他们分配内存等必要资源并建立相应的进程建立以使它们获得竞争处理机的权利高级调度是辅存外存与内存之间的调度每个作业只调入一次调出一次作业调入时会建立相应的作业调出时才撤销高级调度主要是指调入的问题因为只有调入的时机需要操作系统来确定但调出的时机必然是作业运行结束才调出引入了虚拟存储技术之后可将暂时不能运行的进程调至外存等待等它重新具备了运行条件且内存又稍有空闲时再重新调入内存这么做的目的是为了提高内存利用率和系统吞吐量暂时调到外存等待的进程状态为挂起状态值得注意的是并不会一起调到外存而是会常驻内存中会记录进程数据在外存中的存放位置进程状态等信息操作系统通过内存的来保持对各个进程的监控管理被挂起的进程会被放到的挂起队列中中级调度内存调度就是要决定将哪个处于挂起状态的进程重新调入内存一个进程可能会被多次调出调入内存因此中级调度发生的频率要比高级调度更高暂时调到外存等待的进程状态为挂起状态挂起态挂起态又可以进一步细分为就绪挂起阻塞挂起两种状态五状态模型七状态模型注意挂起和阻塞的区别两种状态都是暂时不能获得的服务但挂起态是将进程映像调到外存去了而阻塞态下进程映像还在内存中有的操作系统会把就绪挂起阻塞挂起分为两个挂起队列甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列低级调度进程调度其主要任务是按照某种方法和策略从就绪队列中选取一个进程将处理机分配给它进程调度是操作系统中最基本的一种调度在一般的操作系统中都必须配置进程调度进程调度的频率很高一般几十毫秒一次进程调度的时机切换与过程方式进程调度的时机进程调度低级调度按照某种算法从就绪队列中选择一个进程为其分配处理机需要进行进程调度和切换的情况当前运行的进程主动放弃处理机进程正常终止运行过程中发生异常而终止进程主动请求阻塞如等待当前运行的进程被动放弃处理机分给进程的时间片用完有更紧急的事需要处理如中断有更高优先级的进程进入就绪队列不能进行进程调度和切换的情况在处理中断的过程中中断处理过程复杂与硬件密切相关很难做到在中断处理过程中进行进程切换进程在操作系统内核程序临界区中在原子操作过程中原语原子操作不可中断要一气呵成如之前讲过的修改中进程状态标志并把放到相应队列临界资源一个时间段内只允许一个进程使用的资源各进程需要互斥地访问临界资源临界区访问临界资源的那段代码内核程序临界区一般是用来访问某种内核数据结构的比如进程的就绪队列由各就绪进程的组成当一个程序处于内核程序临界区时如果还没退出临界区还没解锁就进行进程调度但是进程调度相关的程序也需要访问就绪队列但此时就绪队列被锁住了因此又无法顺利进行进程调度内核程序临界区访问的临界资源如果不尽快释放的话极有可能影响到操作系统内核的其他管理工作因此在访问内核程序临界区期间不能进行调度与切换当一个程序处理普通临界区的时候在打印机打印完成之前进程一直处于临界区内临界资源不会解锁但打印机又是慢速设备此时如果一直不允许进程调度的话就会导致一直空闲普通临界区访问的临界资源不会直接影响操作系统内核的管理工作因此在访问普通临界区时可以进行调度与切换进程调度的方式非剥夺调度方式又称非抢占方式即只允许进程主动放弃处理机在运行过程中即便有更紧迫的任务到达当前进程依然会继续使用处理机直到该进程终止或主动要求进入阻塞态实现简单系统开销小但是无法及时处理紧急任务适合于早期的批处理系统剥夺调度方式又称抢占方式当一个进程正在处理机上执行时如果有一个更重要或更紧迫的进程需要使用处理机则立即暂停正在执行的进程将处理机分配给更重要紧迫的那个进程可以优先处理更紧急的进程也可实现让各进程按时间片轮流执行的功能通过时钟中断适合于分时操作系统实时操作系统进程切换的方式和过程狭义的进程调度与进程切换的区别狭义的进程调度指的是从就绪队列中选中一个要运行的进程这个进程可以是刚刚被暂停执行的进程也可能是另一个进程后一种情况就需要进程切换进程切换是指一个进程让出处理机由另一个进程占用处理机的过程广义的进程调度包含了选择一个进程和进程切换两个步骤进程切换的过程主要完成了对原来运行进程各种数据的保存对新的进程各种数据的恢复如程序计数器程序状态字各种数据寄存器等处理机现场信息这些信息一般保存在进程控制块注意进程切换是有代价的因此如果过于频繁的进行进程调度切换必然会使整个系统的效率降低使系统大部分时间都花在了进程切换上而真正用于执行进程的时间减少调度算法的评价指标利用率系统吞吐量周转时间等待时间响应时间利用率指忙碌的时间占总时间的比例系统吞吐量单位时间内完成作业的数量系统吞吐量总共完成了多少道作业总共花了多少时间某计算机系统处理完道作业共花费秒则系统吞吐量为道秒对于计算机的用户来说他很关心自己的作业从提交到完成花了多少时间周转时间是指从作业被提交给系统开始到作业完成为止的这段时间间隔它包括四个部分作业在外存后备队列上等待作业调度高级调度的时间进程在就绪队列上等待进程调度低级调度的时间进程在上执行的时间进程等待操作完成的时间后三项在一个作业的整个处理过程中可能发生多次对于用户来说更关心自己的单个作业的周转时间作业周转时间作业完成时间作业提交时间对于操作系统来说更关心系统的整体表现因此更关心所有作业周转时间的平均值平均周转时间各作业周转时间之和作业数带权周转时间作业周转时间作业实际运行的时间作业完成时间作业提交时间作业实际运行的时间带权周转时间必然带权周转时间与周转时间都是越小越好平均带权周转时间各作业带权周转时间之和作业数计算机的用户希望自己的作业尽可能少的等待处理机等待时间指进程作业处于等待处理机状态时间之和等待时间越长用户满意度越低对于进程来说等待时间就是指进程建立后等待被服务的时间之和在等待完成的期间其实进程也是在被服务的所以不计入等待时间对于作业来说不仅要考虑建立进程后的等待时间还要加上作业在外存后备队列中等待的时间一个作业总共需要被服务多久被设备服务多久一般是确定不变的因此调度算法其实只会影响作业进程的等待时间当然与前面指标类似也有平均等待时间来评价整体性能对于计算机用户来说会希望自己的提交的请求比如通过键盘输入了一个调试命令尽早地开始被系统服务回应响应时间指从用户提交请求到首次产生响应所用的时间调度算法先来先服务先来先服务算法思想主要从公平的角度考虑类似于我们生活中排队买东西的例子算法规则按照作业进程到达的先后顺序进行服务用于作业进程调度用于作业调度时考虑的是哪个作业先到达后备队列用于进程调度时考虑的是哪个进程先到达就绪队列是否可抢占非抢占式的算法优缺点优点公平算法实现简单缺点排在长作业进程后面的短作业需要等待很长时间带权周转时间很大对短作业来说用户体验不好即算法对长作业有利对短作业不利排队买奶茶是否会导致饥饿不会某进程作业长期得不到服务短作业优先短作业优先算法思想追求最少的平均等待时间最少的平均周转时间最少的平均平均带权周转时间算法规则最短的作业进程优先得到服务所谓最短是指要求服务时间最短用于作业进程调度即可用于作业调度也可用于进程调度用于进程调度时称为短进程优先算法是否可以抢占和是非抢占式的算法但是也有抢占式的版本一一最短剩余时间优先算法优缺点优点最短的平均等待时间平均周转时间缺点不公平对短作业有利对长作业不利可能产生饥饿现象另外作业进程的运行时间是由用户提供的并不一定真实不一定能做到真正的短作业优先是否会导致饥饿会如果源源不断地有短作业进程到来可能使长作业进程长时间得不到服务产生饥饿现象如果一直得不到服务则称为饿死注意如果题目中未特别说明所提到的短作业进程优先算法默认是非抢占式的很多书上都会说调度算法的平均等待时间平均周转时间最少严格来说这个表述是错误的不严谨的之前的例子表明最短剩余时间优先算法得到的平均等待时间平均周转时间还要更少应该加上一个条件在所有进程同时可运行时采用调度算法的平均等待时间平均周转时间最少或者说在所有进程都几乎同时到达时采用调度算法的平均等待时间平均周转时间最少如果不加上述前提条件则应该说抢占式的短作业进程优先调度算法最短剩余时间优先算法的平均等待时间平均周转时间最少虽然严格来说的平均等待时间平均周转时间并不一定最少但相比于其他算法如依然可以获得较少的平均等待时间平均周转时间如果选择题中遇到算法的平均等待时间平均周转时间最少的选项那最好判断其他选项是不是有很明显的错误如果没有更合适的选项那也应该选择该选项高响应比优先高响应比优先算法的来源算法是在每次调度的时候选择一个等待时间最长的作业进程为其服务但是没有考虑到作业的运行时间因此导致了对短作业不友好的问题算法是选择一个执行时间最短的作业为其服务但是又完全不考虑各个作业的等待时间因此导致了对长作业不友好的问题甚至还会造成饥饿问题考虑到上面两个问题的出现高响应比优先算法就应运而生算法思想要综合考虑作业进程的等待时间和要求服务的时间算法规则在每次调度时先计算各个作业进程的响应比选择响应比最高的作业进程为其服务响应比等待时间要求服务时间要求服务时间响应比用于作业进程调度即可用于作业调度也可用于进程调度是否可以抢占非抢占式的算法因此只有当前运行的作业进程主动放弃处理机时才需要调度才需要计算响应比优缺点综合考虑了等待时间和运行时间要求服务时间等待时间相同时要求服务时间短的优先的优点要求服务时间相同时等待时间长的优先的优点对于长作业来说随着等待时间越来越久其响应比也会越来越大从而避免了长作业饥饿的问题是否会导致饥饿不会时间片轮转调度算法算法思想公平地轮流地为各个进程服务让每个进程在一定时间间隔内都可以得到响应算法规则按照各进程到达就绪队列的顺序轮流让各个进程执行一个时间片如若进程未在一个时间片内执行完则剥夺处理机将进程重新放到就绪队列队尾重新排队用于作业进程调度用于进程调度只有作业放入内存建立了相应的进程后才能被分配处理机时间片是否可抢占若进程未能在时间片内运行完将被强行剥夺处理机使用权因此时间片轮转调度算法属于抢占式的算法由时钟装置发出时钟中断来通知时间片已到优缺点优点公平响应快适用于分时操作系统缺点由于高频率的进程切换因此有一定开销不区分任务的紧急程度是否会导致饥饿不会时间片太大或太小分别有什么影响如果时间片太大使得每个进程都可以在一个时间片内就完成则时间片轮转调度算法退化为先来先服务调度算法并且会增大进程响应时间因此时间片不能太大另一方面进程调度切换是有时间代价的保存恢复运行环境因此如果时间片太小会导致进程切换过于频繁系统会花大量的时间来处理进程切换从而导致实际用于进程执行的时间比例减少可见时间片也不能太小优先级调度算法算法思想随着计算机的发展特别是实时操作系统的出现越来越多的应用场景需要根据任务的紧急程度来决定处理顺序算法规则调度时选择优先级最高的作业进程用于作业进程调度既可用于作业调度也可用于进程调度甚至还会用于在之后会学习的调度中是否可抢占抢占式非抢占式都有做题时的区别在于非抢占式只需在进程主动放弃处理机时进行调度即可而抢占式还需在就绪队列变化时检查是否会发生抢占优缺点优点用优先级区分紧急程度重要程度适用于实时操作系统可灵活地调整对各种作业进程的偏好程度缺点若源源不断地有高优先级进程到来则可能导致饥饿是否会导致饥饿会就绪队列未必只有一个可以按照不同优先级来组织另外也可以把优先级高的进程排在更靠近队头的位置根据优先级是否可以动态改变可将优先级分为静态优先级和动态优先级两种静态优先级创建进程时确定之后一直不变动态优先级创建进程时有一个初始值之后会根据情况动态地调整优先级如何合理的设置各类进程的优先级系统进程优先级高于用户进程前台进程优先级高于后台进程操作系统更偏好型进程或称繁忙型进程与型进程相对的是计算型进程或称繁忙型进程设备和可以并行工作如果优先让繁忙型进程优先运行的话则越有可能让设备尽早地投入工作则资源利用率系统吞吐量都会得到提升如果采用的是动态优先级什么时候应该调整可以从追求公平提升资源利用率等角度考虑如果某进程在就绪队列中等待了很长时间则可以适当提升其优先级如果某进程占用处理机运行了很长时间则可适当降低其优先级多级返回队列调度算法算法来源算法的优点是公平算法的优点是能尽快处理完短作业平均等待周转时间等参数很优秀时间片轮转调度算法可以让各个进程得到及时的响应优先级调度算法可以灵活地调整各种进程被服务的机会能否对上述几个算法做一个折中的权衡得到一个综合表现优秀的算法呢算法思想对其他调度算法的折中权衡算法规则设置多级就绪队列各级队列优先级从高到低时间片从小到大新进程到达时先进入第级队列按原则排队等待分配时间片若用完时间片进程还未结束则进程进入下一级队列队尾如果此时已经是在最下级的队列则重新放回该队列队尾只有第级队列为空时才会为级队头的进程分配时间片用于作业进程调度用于进程调度是否可抢占抢占式的算法在级队列的进程运行过程中若更上级的队列级中进入了一个新进程则由于新进程处于优先级更高的队列中因此新进程会抢占处理机原来运行的进程放回级队列队尾优缺点对各类型进程相对公平的优点每个新到达的进程都可以很快就得到响应的优点短进程只用较少的时间就可完成的优点不必实现估计进程的运行时间避免用户作假可灵活地调整对各类进程的偏好程度比如密集型进程密集型进程拓展可以将因而阻塞的进程重新放回原队列这样型进程就可以保持较高优先级是否会导致饥饿会算法运行过程进程同步和进程互斥知识点回顾进程具有异步性的特征异步性是指各并发执行的进程以各自独立的不可预知的速度向前推进进程同步读进程和写进程并发地运行由于并发必然导致异步性因此写数据和读数据两个操作执行的先后顺序是不确定的而实际应用中又必须按照写数据读数据的顺序来执行的写满才能读读完才能写如何解决这种异步问题就是进程同步所讨论的内容同步亦称直接制约关系它是指为完成某种任务而建立的两个或多个进程这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系进程间的直接制约关系就是源于它们之间的相互合作进程互斥我们把一个时间段内只允许一个进程使用的资源称为临界资源许多物理设备比如摄像头打印机都属于临界资源此外还有许多变量数据内存缓冲区等都属于临界资源对临界资源的访问必须互斥地进行互斥亦称间接制约关系进程互斥指当一个进程访问某临界资源时另一个想要访问该临界资源的进程必须等待当前访问临界资源的进程访问结束释放该资源之后另一个进程才能去访问临界资源上厕所排队马桶是临界资源每个人只能互斥地访问访问的时候把厕所门锁上进入区临界区退出区剩余区进入区临界区退出区剩余区负责检查是否可进入临界区若可进入则应没置正在访问临界资源的标志可理解为上锁以阻止其他进程同时进入临界区访问临界资源的那段代码负责解除正在访间临界资源的标志可理解为解锁作其他处理注意临界区是进程中访问临界资源的代码段进入区和退出区是负责实现互斥的代码段临界区也可称为临界段为了实现对临界资源的互斥访问同时保证系统整体性能需要遵循以下原则空闲让进临界区空闲时可以允许一个请求进入临界区的进程立即进入临界区忙则等待当已有进程进入临界区时其他试图进入临界区的进程必须等待有限等待对请求访问的进程应保证能在有限时间内进入临界区保证不会饥饿让权等待当进程不能进入临界区时应立即释放处理机防止进程忙等待进程互斥的软件实现方法单标志法算法思想两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程也就是说每个进程进入临界区的权限只能被另一个进程赋予进程进入区临界区退出区剩余区进程进入区临界区退出区剩余区表示当前允许进入临界区的进程号而只有当前允许进入临界区的进程在访问了临界区之后才会修改的值也就是说对于临界区的访问一定是按这样轮流访问这种必须轮流访问带来的问题是如果此时允许进入临界区的进程是而一直不访问临界区那么虽然此时临界区空闲但是并不允许访问因此单标志法存在的主要问题是违背空闲让进原则双标志先检查算法思想设置一个布尔型数组数组中各个元素用来标记各进程想进入临界区的意愿比如意味着号进程现在想要进入临界区每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区如果没有则把自身对应的标志设为之后开始访问临界区表示进入临界区意愿的数组刚开始设置两个进程都不想进入临界区进程进程如果此时想要进入临界区就一直循环等待标记进程想要进入临界区访问临界区访问完临界区修改标记为不想进入临界区若按照的顺序执行和将会同时访问临界因此双标志先检查法的主要问题是违反忙则等待原则原因在于进入区的检查和上锁两个处理不是一气呵成的检查后上锁前可能发生进程切换双标志后检查算法思想双标志先检查法的改版前一个算法的问题是先检查后上锁但是这两个操作又无法一气呵成因此导致了两个进程同时进入临界区的问题因此人们又想到先上锁后检查的方法来避免上述问题表示进入临界区意愿的数组刚开始设置两个进程都不想进入临界区进程进程如果此时想要进入临界区就一直循环等待标记进程想要进入临界区访问临界区访问完临界区修改标记为不想进入临界区若按照的顺序执行和将都无法进入临界区因此双标志后检查法虽然解决了忙则等待的问题但是又违背了空闲让进和有限等待原则会因各进程都长期无法访问临界资源而产生饥饿现象两个进程都争着抢着想要进入临界区但是谁也不让谁最后谁也无法进入临界区算法算法思想双标志后检查法中两个进程都争着想进入临界区但是谁也不让谁最后谁都无法进入临界区想到了一种方法如果双方都争着想进入临界区那可以让进程尝试孔融让梨主动让对方先使用临界区表示进入临界区意愿的数组表示优先让那个进程进入临界进程进程表示自己想要进入临界区可以让对方优先进入临界区对方想进且最后一次是自己让梨那自己就循环等待访问完临界区表示自己不想访问临界区了进入区主动争取主动谦让检查对方是否也想使用且最后一次是不是自己说了客气话算法用软件方法解决了进程互斥问题遵循了空闲让进忙则等待有限等待三个原则但是依然未遵循让权等待的原则算法相较于之前三种软件解决方案来说是最好的但依然不够好进程互斥硬件实现方法中断屏蔽方法利用开关中断指令实现与原语的实现思想相同即在某进程开始访问临界区到结束访问为止都不允许被中断也就不能发生进程切换因此也不可能发生两个同时访问临界区的情况关中断关中断后即不允许当前进程被中断也必然不会发生进程切换临界区开中断直到当前进程访问完临界区再执行开中断指令才有可能有别的进程上处理机并访问临界区优点简单高效缺点不适用于多处理机只适用于操作系统内核进程不适用于用户进程因为开关中断指令只能运行在内核态这组指令如果能让用户随意使用会很危险指令指令简称指令也有地方称为指令或指令指令是用硬件实现的执行的过程不允许被中断只能一气呵成以下是用语言描述的逻辑布尔型共享变量表示当前临界区是否被加锁表示已加锁表示未加锁用来存放原来的值无论之前是否已经加锁都将设置为返回原来的值以下是使用指令实现互斥的算法逻辑上锁并检查临界区代码段解锁剩余代码段若刚开始是则返回的值为循环条件不满足直接跳过循环进入临界区若刚开始是则执行后返回的值为循环条件满足会一直循环直到当前访问临界区的进程在退出区进行解锁相比软件实现方法指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作优点实现简单无需像软件实现方法那样严格检查是否会有逻辑漏洞适用于多处理机环境缺点不满足让权等待原则暂时无法进入临界区的进程会占用并循环执行指令从而导致忙等指令指令有的地方也叫指令或简称指令指令是用硬件实现的执行的过程不允许被中断只能一气呵成以下是用语言描述的逻辑指令作用是交换两个变量的值以下是用指令实现互斥的算法逻辑表示当前临界区是否被上锁临界区代码段解锁剩余代码段逻辑上来看和并无太大区别都是先记录下此时临界区是否已经被上锁记录在变量上再将上锁标记设置为最后检查如果为则说明之前没有别的进程对临界区上锁则可跳出循环进入临界区优点实现简单无需像软件实现方法那样严格检查是否会有逻辑漏洞适用于多处理机环境缺点不满足让权等待原则暂时无法进入临界区的进程会占用并循环执行指令从而导致忙等信号量机制用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作从而很方便的实现了进程互斥进程同步信号量其实就是一个变量可以是一个整数也可以是更复杂的记录型变量可以用一个信号量来表示系统中某种资源的数量比如系统中只有一台打印机就可以设置一个初值为的信号量原语是一种特殊的程序段其执行只能一气呵成不可被中断原语是由关中断开中断指令实现的软件解决方案的主要问题是由进入区的各种操作无法一气呵成因此如果能把进入区退出区的操作都用原语实现使这些操作能一气呵成就能避免问题一对原语原语和原语可以把原语理解为我们自己写的函数函数名分别为和括号里的信号量其实就是函数调用时传入的一个参数原语常简称为操作来目荷兰语测试和增加因此做题的时候常常把两个操作分别写为整形信号量用一个整数型的变量作为信号量用来表示系统中某种资源的数量与普通整数变量的区别对信号量的操作只有三种即初始化操作操作初始化整形信号量表示当前系统中可用的打印机资源数检查和上锁一气呵成避免了并发异步导致的问题存在的问题不满足让权等待原则会发生忙等原语相当于进入区如果资源数不够就一直循环等待如果资源数够则占用一个资源原语相当于退出区使用完资源之后在退出区释放资源进程进入区申请资源使用打印机资源临界区访问资源退出区释放资源进程进入区申请资源使用打印机资源临界区访问资源退出区释放资源进程进入区申请资源使用打印机资源临界区访问资源退出区释放资源记录性信号量整型信号量的缺陷是存在忙等问题因此人们又提出了记录型信号量即用记录型数据结构表示的信号量记录性信号量的定义剩余资源数等待队列某进程需要使用资源的时候通过原语申请如果剩余资源数不够使用原语使进程从运行态进入阻塞态并把挂到信号量的等待队列即阻塞队列中进程使用完资源之后通过原语释放释放资源后若还有别的进程在等待这种资源则使用原语唤醒等待队列中的一个进程该进程从阻塞态变为就绪态在考研题目中也可以记为这对原语可用于实现系统资源的申请和释放的初值表示系统中某种资源的数目对信号量的一次操作意味着进程请求一个单位的该类资源因此需要执行表示资源数减当时表示该类资源已分配完毕因此进程应调用原语进行自我阻塞当前运行的进程从运行态阻塞态主动放弃处理机并插入该类资源的等待队列中可见该机制遵循了让权等待原则不会出现忙等现象对信号量的一次操作意味着进程释放一个单位的该类资源因此需要执行表示资源数加若加后仍是表示依然有进程在等待该类资源因此应调用原语唤醒等待队列中的第一个进程被唤醒进程从阻塞态就绪态用信号量实现进程互斥同步前驱关系用信号量实现进程互斥分析并发进程的关键活动划定临界区如对临界资源打印机的访问就应该放在临界区设置互斥信号量初值为在临界区之前执行在临界区之后执行信号量机制实现互斥要会自己定义记录型信号量但如果题目中没特别说明可以把信号量的声明简写成这种形式初始化信号量使用临界资源前需要加锁临界区代码段使用临界资源后需要解锁临界区代码段注意对不同的临界资源需要设置不同的互斥信号量操作必须成对出现缺少就不能保证临界资源的互斥访问缺少会导致资源永不被释放等待进程永不被唤醒用信号量实现进程同步进程同步要让各并发进程按要求有序地推进代码代码代码代码代码代码比如并发执行由于存在异步性因此二者交替推进的次序是不确定的若的代码要基于的代码和代码的运行结果才能执行那么我们就必须保证代码一定是在代码之后才会执行这就是进程同步问题让本来异步并发的进程互相配合有序推进用信号量实现进程同步分析什么地方需要实现同步关系即必须保证一前一后执行的两个操作或两句代码设置同步信号量初始为在前操作之后执行在后操作之前执行信号量机制实现同步初始化同步信号量初始值为代码代码代码代码代码代码若先执行到操作则后之后当执行到操作时由于表示有可用资源会执行的值变回进程不会执行原语而是继续往下执行代码若先执行到操作由于后表示此时没有可用资源因此操作中会执行原语主动请求阻塞之后当执行完代码继而执行操作使变回由于此时有进程在该信号量对应的阻塞队列中因此会在操作中执行原语唤醒进程这样就可以继续执行代码了用信号量实现前驱关系进程中有句代码中有句代码中有句代码这些代码要求按如下前驱图所示的顺序来执行其实每一对前驱关系都是一个进程同步问题需要保证一前一后的操作因此要为每一对前驱关系各设置一个同步变量在前操作之后对相应的同步变量执行操作在后操作之前对相应的同步变量执行操作生产者消费者问题系统中有一组生产者进程和一组消费者进程生产者进程每次生产一个产品放入缓冲区消费者进程每次从缓冲区中取出一个产品并使用注这里的产品理解为某种数据生产者消费者共享一个初始为空大小为的缓冲区只有缓冲区没满时生产者才能把产品放入缓冲区否则必须等待只有缓冲区不空时消费者才能从中取出产品否则必须等待缓冲区是临界资源各进程必须互斥地访问如何用信号量机制操作实现生产者消费者进程的这些功能呢信号量机制可实现互斥同步对一类系统资源的申请和释放互斥设置初值为的互斥信号量同步设置初值为的同步信号量实现前一后对一类系统资源的申请和释放设置一个信号量初始值即为资源的数量本质上也属于同步问题若无空闲资源则申请资源的进程需要等待别的进程释放资源后才能继续往下执行实现方法生产者消费者共享一个初始为空大小为的缓冲区只有缓冲区没满时生产者才能把产品放入缓冲区否则必须等待只有缓冲区不空时消费者才能从中取出产品否则必须等待缓冲区是临界资源各进程必须互斥地访问互斥信号量实现对缓冲区的互斥访问同步信号量表示空闲缓冲区的数量同步信号量表示产品的数量也即非空缓冲区的数量生产一个产品消耗一个空闲缓冲区把产记放入缓冲区增加一个产品实现互斥是在同一进程中进行对操作消耗一个产品非空缓冲区从缓冲区取出一个产品增加一个空闲缓冲区使用产品实现两进程的同步关系是在其中一个进程中执行另一进程中执行能否改变相邻的操作顺序生产一个产品把产记放入缓冲区从缓冲区取出一个产品增加一个空闲缓冲区使用产品若此时缓冲区内已经放满产品则表明这时候只允许消费者来进行访问缓冲区则生产者进程执行给缓冲区上锁使变为再执行由于已没有空闲缓冲区因此生产者被阻塞由于生产者阻塞因此切换回消费者进程消费者进程执行由于为即生产者还没释放对临界资源的锁因此消费者也被阻塞这就造成了生产者等待消费者释放空闲缓冲区而消费者又等待生产者释放临界区的情况生产者和消费者循环等待被对方唤醒出现死锁同样的若缓冲区中没有产品即按的顺序执行就会发生死锁因此实现互斥的操作一定要在实现同步的操作之后操作不会导致进程阻塞因此两个操作顺序可以交换总结操作题目的解题思路关系分析找出题目中描述的各个进程分析它们之间的同步互斥关系整理思路根据各进程的操作流程确定操作的大致顺序设置信号量设置需要的信号量并根据题目条件确定信号量初值互斥信号量初值一般为同步信号量的初始值要看对应资源的初始值是多少生产者消费者问题是一个互斥同步的综合问题对于初学者来说最难的是发现题目中隐含的两对同步关系有时候是消费者需要等待生产者生产有时候是生产者要等待消费者消费这是两个不同的一前一后问题因此也需要设置两个同步信号量易错点实现互斥和实现同步的两个操作的先后顺序多生产者多消费者桌子上有一只盘子每次只能向其中放入一个水果爸爸专向盘子中放苹果妈妈专向盘子中放橘子儿子专等着吃盘子中的橘子女儿专等着吃盘子中的苹果只有盘子空时爸爸或妈妈才可向盘子中放一个水果仅当盘子中有自己需要的水果时儿子或女儿可以从盘子中取出水果实现方法盘子中有几个苹果盘子中有几个橘子盘子中还可以放多少个水果当缓冲区之后一个的时候可以不是用这个变量实现互斥访问盘子缓冲区父亲准备一个苹果把萃果放入盘子母亲准备一个橘子把橘子放入盘子女儿从盘中取出苹果吃掉苹果儿子从盘中取出橘子吃掉橘子当缓冲区有两个的时候如果不设置缓冲区互斥访问量的时候可能会出现两个生产者同时访问同一块内存可能发生覆盖的情况但是需要注意的是实现互斥的操作一定要在实现同步的操作之后否则可能引起死锁单生产者多消费者假设一个系统有三个抽烟者进程和一个供应者进程每个抽烟者不停地卷烟并抽掉它但是要卷起并抽掉一支烟抽烟者需要有三种材料烟草纸和胶水三个抽烟者中第一个拥有烟草第二个拥有纸第三个拥有胶水供应者进程无限地提供三种材料供应者每次将两种材料放桌子上拥有剩下那种材料的抽烟者卷一根烟并抽掉它并给供应者进程一个信号告诉完成了供应者就会放另外两种材料再桌上这个过程一直重复让三个抽烟者轮流地抽烟关系分析找出题目中描述的各个进程分析它们之间的同步互斥操作互斥桌子可以抽象为容量为的缓冲区要互斥访问同步所有操作都做完之后才能让下一个进行需要按照特定的顺序桌上有组合一第一个抽烟者取走东西桌上有组合二第二个抽烟者取走东西桌上有组合三第三个抽烟者取走东西发出完成信号供应者将下一个组合放到桌上整理思路根据各进程的操作流程确定操作的大致顺序先后设置信号量设置需要的信号量并根据题目条件确定信号量初值互斥信号量初值一般为同步信号量的初始值要看对应资源的初始值是多少实现方法桌上组合一的数量桌上组合二的数量桌上组合三的数量抽烟是否完成用于实现三个抽烟者轮流抽烟将组合一放桌上将组合二放桌上将组合三放桌上实现三个抽象轮流抽象抽象从桌上拿走组合一卷烟抽掉从桌上拿走组合二卷烟抽掉从桌上拿走组合三卷烟抽掉读者写者问题有读者和写者两组并发进程共享一个文件当两个或两个以上的读进程同时访问共享数据时不会产生副作用但若某个写进程和其他进程读进程或写进程同时访问共享数据时则可能导致数据不一致的错误因此要求允许多个读者可以同时对文件执行读操作与消费者进程不同读者进程在读数据后并不会将数据清空并不会改变数据因此多个读者可同时访问共享数据只允许一个写者往文件中写信息任一写者在完成写操作之前不允许其他读者或写者工作写者执行写操作前应让已有的读者和写者全部退出两个写进程同时共享数据可能导致数据错误覆盖的问题两类进程写进程读进程互斥关系写进程写进程写进程读进程读进程与读进程不存在互斥问题写者进程和任何进程都互斥设置一个互斥信号量在写者访问共享文件前后分别执行操作读者进程和写者进程也要互斥因此读者访问共享文件前后也要对执行操作如果所有读者进程在访问共享文件之前都执行操作那么会导致各个读进程之间也无法同时访问文件和其实就是对共享文件的加锁和解锁既然各个读进程需要同时访问而读进程与写进程又必须互斥访问那么我们可以让第一个访问文件的读进程加锁让最后一个访问完文件的读进程解锁可以设置一个整数变量来记录当前有几个读进程在访问文件如何实现用于实现对文件的互斥访问表示当前是否有进程在访问共享文件记录当前有几个读进程在访问文件用户保证对变量的互斥访问用于实现写优先写之前加锁写文件写之后解锁第一个读进程负责加锁访问文件的读进程数读文件访问文件的读进程数最后一个读进程负责解锁思考若两个读进程并发执行则两个读进程有可能先后执行从而使第二个读进程阻塞的情况如何解决出现上述问题的原因在于对变量的检查和赋值无法一气呵成因此可以设置另一个互斥信号量来保证各读进程对的访问是互斥的各进程互斥访问第一个读进程负责加锁访问文件的读进程数读文件各进程互斥访问访问文件的读进程数最后一个读进程负责解锁潜在的问题只要有读进程还在读写进程就要一直阻塞等待可能饿死因此这种算法中读进程是优先的如果第一个读进程加锁之后后来读进程来之后直接读就行如果有源源不断的读进程来的话可能会导致写文件饥饿解决方法我们可以在加锁之前在进行一个读进程和写进程都服从的操作如果一个读进程进入的话先执行这时候如果有一个写进程进来的话我们先执行但由于这时候还没有释放所以会被阻塞到这里这时候如果再有一个读进程进来的话因为在写进程哪里使用了所以下一个读进程需要阻塞到这里直到写进程写入完毕之后之后下一个读进程才能够读入写之前加锁写文件写之后解锁各进程互斥访问第一个读进程负责加锁访问文件的读进程数读文件各进程互斥访问访问文件的读进程数最后一个读进程负责解锁知识回顾读者写者问题为我们解决复杂的互斥问题提供了一个参考思路其核心思想在于设置了一个计数器用来记录当前正在访问共享文件的读进程数我们可以用的值来判断当前进入的进程是否是第一个最后一个读进程从而做出不同的处理另外对变量的检查和赋值不能一气呵成导致了一些错误如果需要实现一气呵成自然应该想到用互斥信号量哲学家进餐一张圆桌上坐着名哲学家每两个哲学家之间的桌上摆一根筷子桌子的中间是一碗米饭哲学家们倾注毕生的精力用于思考和进餐哲学家在思考时并不影响他人只有当哲学家饥饿时才试图拿起左右两根筷子一根一根地拿起如果筷子已在他人手上则需等待饥饿的哲学家只有同时拿起两根筷子才可以开始进餐当进餐完毕后放下筷子继续思考号哲学家的进程拿左拿右吃饭放左放右思考可能会导致死锁问题如果个哲学家并发地拿起自己左手边的筷子每位哲学家循环等待右达的人放下筷子阻塞发生死锁解决方法可以对哲学家进程施加一些限制条件比如最多允许四个哲学家同时进餐这样可以保证至少有一个哲学家是可以拿到左右两只筷子的要求奇数号哲学家先拿左边的筷子然后再拿右边的筷子而偶数号哲学家刚好相反用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭那么只会有其中一个可以拿起第一只筷子另一个会直接阻塞这避免了占有一支后再等待另一只的情况仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子互斥地取筷子号哲学家的进程拿左拿右吃饭放左放右思考哲学家进餐问题的关键在于解决进程死锁这些进程之间只存在互斥关系但是与之前接触到的互斥关系不同的是每个进程都需要同时持有两个临界资源因此就有死锁问题的隐患如果在考试中遇到了一个进程需要同时持有多个临界资源的情况应该参考哲学家问题的思想分析题中给出的进程之间是否会发生循环等待是否会发生死锁管程管程的定义和基本特征管程是一种特殊的软件模块有这些部分组成局部于管程的共享数据结构说明对该数据结构进行操作的一组过程对局部于管程的共享数据设置初始值的语句管程有一个名字管程的基本特征局部于管程的数据只能被局部于管程的过程所访问一个进程只有通过调用管程内的过程才能进入管程访问共享数据每次仅允许一个进程在管程内执行某个内部过程管程操作管程中设置条件变量和等待唤醒操作已解决同步问题条件变量用来实现同步排队缓冲区产品的个数由编译器负责实现各进程互斥地进入管程中的过程把产品放入缓冲区从缓冲区中取出一个产品生产者进程生产一个产品消费者进程消费产品每次仅允许一个进程在管程内执行某个内部过程例两个生产者进程并发执行依次调用了过程例两个消费者进程先执行生产者进程后执行用管程解决生产者和消费者问题引入管程的目的无非就是要更方便地实现进程互斥和同步需要在管程中定义共享数据如生产者消费者问题的缓冲区需要在管程中定义用于访问这些共享数据的入口一其实就是一些函数如生产者消费者问题中可以定义一个函数用于将产品放入缓冲区再定义一个函数用于从缓冲区取出产品只有通过这些特定的入口才能访问共享数据管程中有很多入口但是每次只能开放其中一个入口并且只能让一个进程或线程进入如生产者消费者问题中各进程需要互斥地访问共享缓冲区管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区注意这种互斥特性是由编译器负责实现的程序员不用关心可在管程中设置条件变量及等待唤醒操作以解决同步问题可以让一个进程或线程在条件变量上等待此时该进程应先释放管程的使用权也就是让出入口可以通过唤醒操作将等待在条件变量上的进程或线程唤醒程序员可以用某种特殊的语法定义一个管程比如之后其他程序员就可以使用这个管程提供的特定入口很方便地使用实现进程同步互斥了中如果用关键字来描述一个函数那么这个函数同一时间段内只能被一个线程调用每次只能有一个线程进入函数如果多个线程同时调用函数则后来者需要排队等待死锁什么是死锁在并发环境下各进程因竞争资源而造成的一种互相等待对方手里的资源导致各进程都阻塞都无法向前推进的现象就是死锁发生死锁后若无外力干涉这些进程都将无法向前推进进程死锁饥饿死循环的区别死锁各进程互相等待对方手里的资源导致各进程都阻塞无法向前推进的现象饥饿由于长期得不到想要的资源某进程无法向前推进的现象比如在短进程优先算法中若有源源不断的短进程到来则长进程将一直得不到处理机从而发生长进程饥饿死循环某进程执行过程中一直跳不出某个循环的现象有时是因为程序逻辑导致的有时是程序员故意设计的类别区别死锁死锁一定是循环等待对方手里的资源导致的因此如果有死锁现象那至少有两个或两个以上的进程同时发生死锁另外发生死锁的进程一定处于阻塞态饥饿可能只有一个进程发生饥饿发生饥饿的进程既可能是阻塞态如长期得不到需要的设备也可能是就绪态长期得不到处理机死循环可能只有一个进程发生死循环死循环的进程可以上处理机运行可以是运行态只不过无法像期待的那样顺利推进死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的而死循环是由代码逻辑的错误导致的死锁和饥饿是管理者操作系统的问题死循环是被管理者的问题死锁产生的必要条件产生死锁必须同时满足一下四个条件只要其中任一条件不成立死锁就不会发生互斥条件只有对必须互斥使用的资源的争抢才会导致死锁如哲学家的筷子打印机设备像内存扬声器这样可以同时让多个进程使用的资源是不会导致死锁的因为进程不用阻塞等待这种资源不剥夺条件进程所获得的资源在未使用完之前不能由其他进程强行夺走只能主动释放请求和保持条件进程已经保持了至少一个资源但又提出了新的资源请求而该资源又被其他进程占有此时请求进程被阻塞但又对自己已有的资源保持不放循环等待条件存在一种进程资源的循环等待链链中的每一个进程已获得的资源同时被下一个进程所请求注意发生死锁时一定有循环等待但是发生循环等待时未必死锁循环等待是死锁的必要不充分条件如果同类资源数大于则即使有循环等待也未必发生死锁但如果系统中每类资源都只有一个那循环等待就是死锁的充分必要条件了什么时候会发生死锁对系统资源的竞争各进程对不可剥夺的资源如打印机的竞争可能引起死锁对可剥夺的资源的竞争是不会引起死锁的进程推进顺序非法请求和释放资源的顺序不当也同样会导致死锁例如并发执行的进程分别申请并占有了资源之后进程又紧接着申请资源而进程又申请资源两者会因为申请的资源被对方占有而阻塞从而发生死锁信号量的使用不当也会造成死锁如生产者消费者问题中如果实现互斥的操作在实现同步的操作之前就有可能导致死锁可以把互斥信号量同步信号量也看做是一种抽象的系统资源总之对不可剥夺资源的不合理分配可能导致死锁死锁的处理策略预防死锁破坏死锁产生的四个必要条件中的一个或几个避免死锁用某种方法防止系统进入不安全状态从而避免死锁银行家算法死锁的检测和解除允许死锁的发生不过操作系统会负责检测出死锁的发生然后采取某种措施解除死锁预防死锁破坏互斥性条件互斥条件只有对必须互斥使用的资源的争抢才会导致死锁如果把只能互斥使用的资源改造为允许共享使用则系统不会进入死锁状态比如技术操作系统可以采用技术把独占设备在逻辑上改造成共享设备比如用技术将打印机改造为共享设备入该策略的缺点并不是所有的资源都可以改造成可共享使用的资源并且为了系统安全很多地方还必须保护这种互斥性因此很多时候都无法破坏互斥条件破会不剥夺条件不剥夺条件进程所获得的资源在未使用完之前不能由其他进程强行夺走只能主动释放破坏不剥夺条件方案一当某个进程请求新的资源得不到满足时它必须立即释放保持的所有资源待以后需要时再重新申请也就是说即使某些资源尚未使用完也需要主动释放从而破坏了不可剥夺条件得不到的就放手方案二当某个进程需要的资源被其他进程所占有的时候可以由操作系统协助将想要的资源强行剥夺这种方式一般需要考虑各进程的优先级比如剥夺调度方式就是将处理机资源强行剥夺给优先级更高的进程使用得不到的就把他抢过来该策略的缺点实现起来比较复杂释放已获得的资源可能造成前一阶段工作的失效因此这种方法一般只适用于易保存和恢复状态的资源如反复地申请和释放资源会增加系统开销降低系统吞吐量若采用方案一意味着只要暂时得不到某个资源之前获得的那些资源就都需要放弃以后再重新申请如果一直发生这样的情况就会导致进程饥饿破坏请求和保持条件请求和保持条件进程已经保持了至少一个资源但又提出了新的资源请求而该资源又被其他进程占有此时请求进程被阻塞但又对自己已有的资源保持不放可以采用静态分配方法即进程在运行前一次申请完它所需要的全部资源在它的资源未满足前不让它投入运行一旦投入运行后这些资源就一直归它所有该进程就不会再请求别的任何资源了该策略实现起来简单但也有明显的缺点有些资源可能只需要用很短的时间因此如果进程的整个运行期间都一直保持着所有资源就会造成严重的资源浪费资源利用率极低另外该策略也有可能导致某些进程饥饿例如上面这个程序如果有源源不断的进程涌入过来的话可能会导致类进程饥饿破坏循环等待条件循环等待条件存在一种进程资源的循环等待链链中的每一个进程已获得的资源同时被下一个进程所请求可采用顺序资源分配法首先给系统中的资源编号规定每个进程必须按编号递增的顺序请求资源同类资源即编号相同的资源一次申请完原理分析一个进程只有已占有小编号的资源时才有资格申请更大编号的资源按此规则已持有大编号资源的进程不可能逆向地回来申请小编号的资源从而就不会产生循环等待的现象该策略的缺点不方便增加新的设备因为可能需要重新分配所有的编号进程实际使用资源的顺序可能和编号递增顺序不一致会导致资源浪费必须按规定次序申请资源用户编程麻烦避免死锁安全序列所谓安全序列就是指如果系统按照这种序列分配资源则每个进程都能顺利完成只要能找出一个安全序列系统就是安全状态当然安全序列可能有多个如果分配了资源之后系统中找不出任何一个安全序列系统就进入了不安全状态这就意味着之后可能所有进程都无法顺利的执行下去当然如果有进程提前归还了一些资源那系统也有可能重新回到安全状态不过我们在分配资源之前总是要考虑到最坏的情况如果系统处于安全状态就一定不会发生死锁如果系统进入不安全状态就可能发生死锁处于不安全状态未必就是发生了死锁但发生死锁时一定是在不安全状态因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态以此决定是否答应资源分配请求这也是银行家算法的核心思想银行家算法资源总数此时系统是否处于安全状态思路尝试找出一个安全序列依次检查剩余可用资源是否能满足各进程的需求可满足需求将加入安全序列并更新剩余可用资源值为依次检查剩余可用资源是否能满足剩余进程不包括已加入安全序列的进程的需求可满足需求将加入安全序列并更新剩余可用资源值为依次检查剩余可用资源是否能满足剩余进程不包括已加入安全序列的进程的需求以此类推共五次循环检查即可将个进程都加入安全序列中最终可得一个安全序列该算法称为安全性算法可以很方便地用代码实现以上流程每一轮检查都从编号较小的进程开始检查实际做题时可以更快速的得到安全序列手算算法实际做题手算时可用更快速的方法找到一个安全序列经对比发现可满足说明无论如何这两个进程的资源需求一定是可以依次被满足的因此一定可以顺利的执行完并归还资源可把先加入安全序列剩下的都可被满足同理这些进程都可以加入安全序列于是个进程全部加入安全序列说明此时系统处于安全状态暂不可能发生死锁在看一个找不到安全序列的例子资源总数经对比发现可满足说明无论如何这两个进程的资源需求一定是可以依次被满足的因此一定可以顺利的执行完并归还资源可把先加入安全序列剩下的需要需要需要任何一个进程都不能被完全满足于是无法找到任何一个安全序列说明此时系统处于不安全状态有可能发生死锁具体流程假设系统中有个进程种资源每个进程在运行前先声明对各种资源的最大需求数则可用一个的矩阵可用二维数组实现表示所有进程对各种资源的最大需求数不妨称为最大需求矩阵表示进程最多需要个资源同理系统可以用一个的分配矩阵表示对所有进程的资源分配情况一矩阵表示各进程最多还需要多少各类资源另外还要用一个长度为的一维数组表示当前系统中还有多少可用资源某进程向系统申请资源可用一个长度为的一维数组表示本次申请的各种资源量可用银行家算法预判本次分配是否会导致系统进入不安全状态如果便转向否则认为出错因为它所需要的资源数已超过它所宣布的最大值如果便转向否则表示尚无足够资源必须等待系统试探着把资源分配给进程并修改相应的数据并非真的分配修改数值只是为了做预判操作系统执行安全性算法检查此次资源分配后系统是否处于安全状态若安全才正式分配否则恢复相应数据让进程阻塞等待回顾数据结构长度为的一维数组表示还有多少可用资源矩阵表示各进程对资源的最大需求数矩阵表示已经给各进程分配了多少资源矩阵表示各进程最多还需要多少资源用长度为的一位数组表示进程此次申请的各种资源数银行家算法步骤检查此次申请是否超过了之前声明的最大需求数检查此时系统剩余的可用资源是否还能满足这次请求试探着分配更改各数据结构用安全性算法检查此次分配是否会导致系统进入不安全状态安全性算法步骤检查当前的剩余可用资源是否能满足某个进程的最大需求如果可以就把该进程加入安全序列并把该进程持有的资源全部回收不断重复上述过程看最终是否能让所有进程都加入安全序列系统处于不安全状态未必死锁但死锁时一定处于不安全状态系统处于安全状态一定不会死锁死锁的检测和解除死锁的检测为了能对系统是否已发生了死锁进行检测必须用某种数据结构来保存资源的请求和分配信息提供一种算法利用上述信息来检测系统是否已进入死锁状态一般用矩形表示资源结点矩形中的小圆代表该类资源的数量为了能对系统是否已发生了死锁进行检测必须用某种数据结构来保存资源的请求和分配信息提供一种算法利用上述信息来检测系统是否已进入死锁状态如果系统中剩余的可用资源数足够满足进程的需求那么这个进程暂时是不会阻塞的可以顺利地执行下去如果这个进程执行结束了把资源归还系统就可能使某些正在等待资源的进程被激活并顺利地执行下去相应的这些被激活的进程执行完了之后又会归还一些资源这样可能又会激活另外一些阻塞的进程如果按上述过程分析最终能消除所有边就称这个图是可完全简化的此时一定没有发生死锁相当于能找到一个安全序列如果最终不能消除所有边那么此时就是发生了死锁最终还连着边的那些进程就是处于死锁状态的进程像上面这个图可以按照这个方式进行的话就可以消除所有的边检测死锁的算法在资源分配图中找出既不阻塞又不是孤点的进程即找出一条有向边与它相连且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量如下图中没有空闲资源有一个空闲资源若所有的连接该进程的边均满足上述条件则这个进程能继续运行直至完成然后释放它所占有的所有资源消去它所有的请求边和分配边使之称为孤立的结点在下图中是满足这一条件的进程结点于是将的所有边消去进程所释放的资源可以唤醒某些因等待这些资源而阻塞的进程原来的阻塞进程可能变为非阻塞进程在下图中就满足这样的条件根据中的方法进行一系列简化后若能消去途中所有的边则称该图是可完全简化的那么此时系统死锁死锁定理如果某时刻系统的资源分配图是不可完全简化的那么此时系统死锁死锁的解除一旦检测出死锁的发生就应该立即解除死锁补充并不是系统中所有的进程都是死锁状态用死锁检测算法化简资源分配图后还连着边的那些进程就是死锁进程解除死锁的主要方法有资源剥夺法挂起暂时放到外存上某些死锁进程并抢占它的资源将这些资源分配给其他的死锁进程但是应防止被挂起的进程长时间得不到资源而饥饿撤销进程法或称终止进程法强制撤销部分甚至全部死锁进程并剥夺这些进程的资源这种方式的优点是实现简单但所付出的代价可能会很大因为有些进程可能已经运行了很长时间已经接近结束了一旦被终止可谓功亏一篑以后还得从头再来进程回退法让一个或多个死锁进程回退到足以避免死锁的地步这就要求系统要记录进程的历史信息设置还原点如何决定对那个进程执行操作进程优先级已执行多长时间还要多久能完成进程已经使用了多少资源进程是交互式的还是批处理式的操作系统第三章内存管理内存的基础知识什么是内存有何作用内存是用于存放数据的硬件程序执行前需要先放到内存中才能被处理思考在多道程序环境下系统中会有多个程序并发执行也就是说会有多个程序的数据需要同时放到内存中那么如何区分各个程序的数据是放在什么地方的呢方案给内存的存储单元编地址内存中也有一个一个的小房间每个小房间就是一个存储单元如果计算机按字节编址则每个存储单元大小为字节即即个二进制位如果字长为位的计算机按字编址则每个存储单元大小为个字每字的大小为个二进制位逻辑地址和物理地址我们写的代码要翻译成能识别的指令这些指令会告诉应该去内存的哪个地址存取数据这个数据应该做什么样的处理在这个例子中指令中直接给出了变量的实际存放地址物理地址但实际在生成机器指令的时候并不知道该进程的数据会被放到什么位置所以编译生成的指令中一般是使用逻辑地址相对地址宿舍四个人一起出去旅行四个人的学号尾号分别是住酒店时酒店给你们安排了个房号相连的房间四个人按学号递增次序入住房间比如号同学分别入住了号房间四个人的编号其实是一个相对位置而各自入住的房间号是一个绝对位置只要知道号同学住的是房号为的房间那么号同学的房号一定是也就是说只要知道各个同学的相对位置和起始房号就一定可以算出所有同学的绝对位置指令中的地址也可以采用这种思想编译时产生的指令只关心相对地址实际放入内存中时再想办法根据起始位置得到绝对地址编译时只需确定变量存放的相对地址是也就是说相对于进程在内存中的起始地址而言的地址想要找到在内存中的实际存放位置只需要用进程的起始地址即可相对地址又称逻辑地址绝对地址又称物理地址逻辑地址和物理地址的互相转换编译由编译程序将用户源代码编译成若干个目标模块编译就是把高级语言翻译为机器语言注意这里面的地址是逻辑地址链接由链接程序将编译后形成的一组目标模块以及所需库函数链接在一起形成一个完整的装入模块装入装载由装入程序将装入这时候的地址是完整的逻辑地址模块装入内存运行这时候的地址是物理地址如上面图片中所表达的如果从内存地址为的地址开始依此执行装入模块中的指令的话如果不进行逻辑地址的转换那么这时候会向地址为的地址写入数据会导致程序出错装入的三种方式用三种不同的方法完成逻辑地址到物理地址的转换绝对装入静态重定位动态重定位装入的三种方式绝对装入绝对装入在编译时如果知道程序将放到内存中的哪个位置编译程序将产生绝对地址的目标代码装入程序按照装入模块中的地址将程序和数据装入内存如果知道装入模块要从地址为的地方开始存放绝对装入只适用于单道程序环境因为单道程序环境在同一时刻只会有一个程序在运行我们可以规定每个程序的起始位置程序中使用的绝对地址可在编译或汇编时给出也可由程序员直接赋予通常情况下都是编译或汇编时再转换为绝对地址静态重定位静态重定位又称可重定位装入编译链接后的装入模块的地址都是从开始的指令中使用的地址数据存放的地址都是相对于起始地址而言的逻辑地址可根据内存的当前情况将装入模块装入到内存的适当位置装入时对地址进行重定位将逻辑地址变换为物理地址地址变换是在装入时一次完成的静态重定位的特点是在一个作业装入内存时必须分配其要求的全部内存空间如果没有足够的内存就不能装入该作业作业一旦进入内存后在运行期间就不能再移动也不能再申请内存空间动态重定位动态重定位又称动态运行时装入编译链接后的装入模块的地址都是从开始的装入程序把装入模块装入内存后并不会立即把逻辑地址转换为物理地址而是把地址转换推迟到程序真正要执行时才进行因此装入内存后所有的地址依然是逻辑地址这种方式需要一个重定位寄存器的支持采用动态重定位时允许程序在内存中发生移动优点可将程序分配到不连续的存储区中在程序运行前只需装入它的部分代码即可投入运行然后在程序运行期间根据需要动态申请分配内存便于程序段的共享可以向用户提供一个比存储空间大得多的地址空间链接的三种方式静态链接静态链接在程序运行之前先将各目标模块及它们所需的库函数连接成一个完整的可执行文件装入模块之后不再拆开装入时动态链接装入时动态链接将各目标模块装入内存时边装入边链接的链接方式运行时动态链接运行时动态链接在程序执行中需要该目标模块时其优点是便于修改和更新便于实现对目标模块的共享内存管理的概念内存空间的分配与回收操作系统要怎么记录哪些内存区域已经被分配出去了哪些又还空闲如果一个进程过来之后内存中有许多位置都是空闲的要怎么确定放的位置当进程结束之后如何将进程占用的内存进行回收内存空间的扩展操作系统需要提供某种技术从逻辑上对内存空间进行扩充操作系统的虚拟性地址的转换操作系统需要提供地址转换功能负责程序的逻辑地址与物理地址的转换为了使编程更方便程序员写程序时应该只需要关注指令数据的逻辑地址而逻辑地址到物理地址的转换这个过程称为地址重定位应该由操作系统负责这样就保证了程序员写程序时不需要关注物理内存的实际情况内存保护操作系统需要提供内存保护功能保证各进程在各自存储空间内运行互不干扰每个进程都只能访问自己的内存空间不能够访问其他进程的或者是操作系统的内存保护可采取两种方法方法一在中设置一对上下限寄存器存放进程的上下限地址进程的指令要访问某个地址时检查是否越界方法二采用重定位寄存器又称基址寄存器和界地址寄存器又称限长寄存器进行越界检查重定位寄存器中存放的是进程的起始物理地址界地址寄存器中存放的是进程的最大逻辑地址覆盖与交换覆盖技术早期的计算机内存很小比如推出的第一台机最大只支持大小的内存因此经常会出现内存大小不够的情况后来人们引入了覆盖技术用来解决程序大小超过物理内存总和的问题覆盖技术的思想将程序分为多个段多个模块常用的段常驻内存不常用的段在需要时调入内存内存中分为一个固定区和若干个覆盖区需要常驻内存的段放在固定区中调入后就不再调出除非运行结束不常用的段放在覆盖区需要用到时调入内存用不到时调出内存和只能由调用在同一时间段只能有一个进程使用同理在同一时间段只能由一个程序唤醒按照自身逻辑结构让那些不可能同时被访问的程序段共享同一个覆盖区必须由程序员声明覆盖结构操作系统完成自动覆盖缺点对用户不透明增加了用户编程负担覆盖技术只用与早期操作系统现在已经成为历史交换技术交换对换技术的设计思想内存空间紧张时系统将内存中某些进程暂时换出外存把外存中某些已具备运行条件的进程换入内存进程在内存与磁盘间动态调度中级调度内存调度就是要决定将哪个处于挂起状态的进程重新调入内存在进程调出内存的时候不会跟着一起调出因为还需要在内存中控制程序的调入暂时换出外存等待的进程状态为挂起状态挂起态挂起态又可以进一步细分为就绪挂起阻塞挂起两种状态应该在外存磁盘的什么位置保存被换出的进程具有对换功能的操作系统中通常把磁盘空间分为文件区和对换区两部分文件区主要用于存放文件主要追求存储空间的利用率因此对文件区空间的管理采用离散分配方式对换区空间只占磁盘空间的小部分被换出的进程数据就存放在对换区由于对换的速度直接影响到系统的整体速度因此对换区空间的管理主要追求换入换出速度因此通常对换区采用连续分配方式学过文件管理章节后即可理解总之对换区的速度比文件区的更快什么时候应该交换交换通常在许多进程运行且内存吃紧时进行而系统负荷降低就暂停例如在发现许多进程运行时经常发生缺页就说明内存紧张此时可以换出一些进程如果缺页率明显下降就可以暂停换出应该换出哪些进程可优先换出阻塞进程可换出优先级低的进程为了防止优先级低的进程在被调入内存后很快又被换出有的系统还会考虑进程在内存的驻留时间注意会驻内存不会被换出外存连续分配管理方式单一连续分配在单一连续分配方式中内存被分为系统区和用户区系统区通常位于内存的低地址部分用于存放操作系统相关数据用户区用于存放用户进程相关数据内存中只能有一道用户程序用户程序独占整个用户区空间优点实现简单无外部碎片可以采用覆盖技术扩充内存不一定需要采取内存保护早期的操作系统缺点只能用于单用户单任务的操作系统中有内部碎片存储器利用率极低内部碎片内存已经给这个用户分配了但是用户没有使用内存利用率低固定分区分配世纪年代出现了支持多道程序的系统为了能在内存中装入多道程序且这些程序之间又不会相互干扰于是将整个用户空间划分为若干个固定大小的分区在每个分区中只装入一道作业这样就形成了最早的最简单的一种可运行多道程序的内存管理方式分区方式分区大小相等缺乏灵活性但是很适合用于用一台计算机控制多个相同对象的场合比如钢铁厂有个相同的炼钢炉就可把内存分为个大小相等的区域存放个炼钢炉控制程序分区大小不等增加了灵活性可以满足不同大小的进程需求根据常在系统中运行的作业大小情况进行划分比如划分多个小分区适量中等分区少量大分区操作系统需要建立一个数据结构分区说明表来实现各个分区的分配与回收每个表项对应一个分区通常按分区大小排列每个表项包括对应分区的大小起始地址状态是否已分配用数据结构的数组或链表即可表示这表当某用户程序要装入内存时由操作系统内核程序根据用户程序大小检索该表从中找到一个能满足大小的未分配的分区将之分配给该程序然后修改状态为已分配优点实现简单无外部碎片缺点当用户程序太大时可能所有的分区都不能满足需求此时不得不采用覆盖技术来解决但这又会降低性能会产生内部碎片内存利用率低动态分区分配动态分区分配又称为可变分区分配这种分配方式不会预先划分内存分区而是在进程装入内存时根据进程的大小动态地建立分区并使分区的大小正好适合进程的需要因此系统分区的大小和数目是可变的假设某计算机内存大小为系统区用户区共系统要用什么样的数据结构记录内存的使用情况空闲分区表空闲分区表每个空闲分区对应一个表项表项中包含分区号分区大小分区起始地址等信息空闲分区链空闲分区链每个分区的起始部分和末尾部分分别设置前向指针和后向指针起始部分处还可记录分区大小等信息当很多个空闲分区都能满足需求时应该选择哪个分区进行分配当一个新进程过来之后如果多个空闲地方都满足这个进程的话我们应该选择使用最大的分区进行分配还是用最小的分区进行分配又或者用地址最低的部分进行分配把一个新作业装入内存时须按照一定的动态分区分配算法从空闲分区表或空闲分区链中选出一个分区分配给该作业由于分配算法算法对系统性能有很大的影响因此人们对它进行了广泛的研究如何进行分区的分配与回收操作情况一回收区的后面有一个相邻的空闲分区两个空闲分区合并为一个情况二回收区的前面有一个相邻的空闲分区两个空闲分区合并为一个情况三回收区前后都有一个空闲分区三个相邻的分区合并为一个情况四回收区前后都没有空闲分区新增一个表项注各表项的顺序不一定按照地址递增顺序排列具体的排列方式需要依据动态分区分配算法来确定动态分区分配又称为可变分区分配这种分配方式不会预先划分内存分区而是在进程装入内存时根据进程的大小动态地建立分区并使分区的大小正好适合进程的需要因此系统分区的大小和数目是可变的动态分区分配没有内部碎片但是有外部碎片内部碎片分配给某进程的内存区域中如果有些部分没有用上外部碎片是指内存中的某些空闲分区由于太小而难以利用如果内存中空闲空间的总和本来可以满足某进程的要求但由于进程需要的是一整块连续的内存空间因此这些碎片不能满足进程的需求可以通过紧凑拼凑技术来解决外部碎片动态分配算法首次适应算法算法思想每次都从低地址开始查找找到第一个能满足大小的空闲分区如何实现空闲分区以地址递增的次序排列每次分配内存时顺序查找空闲分区链或空闲分区表找到大小能满足要求的第一个空闲分区最佳适应算法算法思想由于动态分区分配是一种连续分配方式为各进程分配的空间必须是连续的一整片区域因此为了保证当大进程到来时能有连续的大片空间可以尽可能多地留下大片的空闲区即优先使用更小的空闲区如何实现空闲分区按容量递增次序链接每次分配内存时顺序查找空闲分区链或空闲分区表找到大小能满足要求的第一个空闲分区缺点每次都选最小的分区进行分配会留下越来越多的很小的难以利用的内存块因此这种方法会产生很多的外部碎片最坏适应算法又称最大适应算法算法思想为了解决最佳适应算法的问题一一即留下太多难以利用的小碎片可以在每次分配时优先使用最大的连续空闲区这样分配后剩余的空闲区就不会太小更方便使用如何实现空闲分区按容量递减次序链接每次分配内存时顺序查找空闲分区链或空闲分区表找到大小能满足要求的第一个空闲分区缺点每次都选最大的分区进行分配虽然可以让分配后留下的空闲区更大更可用但是这种方式会导致较大的连续空闲区被迅速用完如果之后有大进程到达就没有内存分区可用了邻近适应算法算法思想首次适应算法每次都从链头开始查找的这可能会导致低地址部分出现很多小的空闲分区而每次分配查找时都要经过这些分区因此也增加了查找的开销如果每次都从上次查找结束的位置开始检索就能解决上述问题如何实现空闲分区以地址递增的顺序排列可排成一个循环链表每次分配内存时从上次查找结束的位置开始查找空闲分区链或空闲分区表找到大小能满足要求的第一个空闲分区首次适应算法每次都要从头查找每次都需要检索低地址的小分区但是这种规则也决定了当低地址部分有更小的分区可以满足需求时会更有可能用到低地址部分的小分区也会更有可能把高地址部分的大分区保留下来最佳适应算法的优点邻近适应算法的规则可能会导致无论低地址高地址部分的空闲分区都有相同的概率被使用也就导致了高地址部分的大分区更可能被使用划分为小分区最后导致无大分区可用最大适应算法的缺点算法算法思想分区排列顺序优点缺点首次适应从头到尾找到合适的分区空闲分区以地址递增次序排列综合看性能最好算法开销小回收分区后一般不需要对空闲分区队列重新排序最佳适应优先使用更小的分区以保留更多大的分区空闲分区以容量递增次序排列会有更多的大分区被保留下来更能满足大进程需求会产生很多太小的难以利用的碎片算法开销大回收分区后可能需要对空闲分区队列重新排序最坏适应优先使用更大的分区以防止生产太小不可使用的碎片空闲分区以容量递减次序排列可以减少难以利用的小碎片大分区容易被用完不利于大进程算法开销大原因同上临近适应由首次适应演变而来每次从上次查完之后的位置开始查找空闲分区以地址递增次序排列可排列成循环链表不用每次都从低地址的小分区开始检索算法开销小原因同首次适应算法会使高地址的大分区也被用完基本分页存储管理的基本概念思考连续分配的缺点考虑支持多道程序的两种连续分配方式固定分区分配缺乏灵活性会产生大量的内部碎片内存的利用率很低动态分区分配会产生很多外部碎片虽然可以用紧凑技术来处理但是紧凑的时间代价很高如果允许将一个进程分散地装入到许多不相邻的分区中便可充分地利用内存而无需再进行紧凑连续分配为用户进程分配的必须是一个连续的内存空间非连续分配为用户进程分配的可以是一些分散的内存空间分页存储管理的基本概念将内存空间分为一个个大小相等的分区比如每个分区每个分区就是一个页框或称页帧内存块物理块每个页框有一个编号即页框号或者内存块号页帧号物理块号页框号从开始将用户进程的地址空间也分为与页框大小相等的一个个区域称为页或页面每个页面也有一个编号即页号页号也是从开始注进程的最后一个页面可能没有一个页框那么大因此页框不能太大否则可能产生过大的内部碎片操作系统以页框为单位为各个进程分配内存空间进程的每个页面分别放入一个页框中也就是说进程的页面与内存的页框有一一对应的关系各个页面不必连续存放也不必按先后顺序来可以放到不相邻的各个页框中如何实现地址的转换如果这时候正在执行指令我们需要去寻找地址为的页面我们如何将这个逻辑地址改变成物理地址逻辑地址为的内存单元应该在号页该页在内存中的起始位置为逻辑地址为的内存单元相对于该页的起始地址而言偏移量应该是逻辑地址转换成物理地址要算出逻辑地址对应的页号要知道该页号对应页面在内存中的起始地址要算出逻辑地址在页面内的偏移量物理地址页面地址页内偏移量页号页内偏移量的计算页号逻辑地址页面长度取除法的整数部分页内偏移量逻辑地址页面长度取除法的余数部分页面在内存中的起始位置操作系统需要用某种数据结构记录进程各个页面的起始位置在计算机中为了方便计算页号页内偏移量页面大小一般使用的整数幂假设用个二进制位表示逻辑地址页面大小为号页的逻辑地址空间应该是用二进制表示应该是号页的逻辑地址空间应该是用二进制表示应该是号页的逻辑地址空间应该是用二进制表示应该是前面是页号后面是页内偏移量逻辑地址用二进制表示应该是若号页在内存中的起始地址为则逻辑地址对应的物理地址应该是结论如果每个页面大小为用二进制数表示逻辑地址则末尾位即为页内偏移量其余部分就是页号因此如果让每个页面的大小为的整数幂计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量逻辑地址结构页号页内偏移量地址结构包含两个部分前一部分为页号后一部分为页内偏移量在上图所示的例子中地址长度为位其中位为页内偏移量或称页内地址位为页号如果有位表示页内偏移量则说明该系统中一个页面的大小是个内存单元如果有位表示页号则说明在该系统中一个进程最多允许有个页面页表为了能知道进程的每个页面在内存中存放的位置操作系统要为每个进程建立一张页表一个进程对应一张页表进程的每一页对应一个页表项每个页表项由页号和块号组成页表记录进程页面和实际存放的内存块之间的对应关系每个页表项的长度是相同的页号是隐含的为什么页号是隐藏的各页表项会按顺序连续地存放在内存中如果该页表在内存中存放的起始地址为则号页对应的页表项一定是存放在内存地址为因此页表中的页号可以是隐含的只需要知道页表存放的起始地址和页表项长度即可找到各个页号对应的页表项存放的位置基本地址变换结构重点理解记忆基本地址变换机构用于实现逻辑地址到物理地址转换的一组硬件机构的原理和流程基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址通常会在系统中设置一个页表寄存器存放页表在内存中的起始地址和页表长度进程未执行时页表的始址和页表长度放在进程控制块中当进程被调度时作系统内核会把它们放到页表寄存器中注意页面大小是的整数幂设页面大小为逻辑地址到物理地址的变换过程如下计算页号和页内偏移量如果用十进制数手算则但是在计算机实际运行时逻辑地址结构是固定不变的因此计算机硬件可以更快地得到二进制表示的页号页内偏移量比较页号和页表长度若则产生越界中断否则继续执行注意页号是从开始的而页表长度至少是因此时也会越界页表中页号对应的页表项地址页表起始地址页号页表项长度取出该页表项内容即为内存块号注意区分页表项长度页表长度页面大小的区别页表长度指的是这个页表中总共有几个页表项即总共有几个页页表项长度指的是每个页表项占多大的存储空间页面大小是一个页面占多大的存储空间计算物理块号页面长度页内偏移量用得到的物理地址去访存如果内存块号页面偏移量是用二进制表示的那么把二者拼接起来就是最终的物理地址了若页面大小为字节页号对应的内存块号将逻辑地址转换为物理地址等价描述某系统按字节寻址逻辑地址结构中页内偏移量占位页号对应的内存块号将逻辑地址转换为物理地址页内偏移量占用位数就是偏移量占用的位数偏移量一共有几位偏移量的位数决定了页面的大小计算页号页内偏移量页号页内偏移量根据题中条件可知页号没有越界其存放的内存块号物理地址在分页存储管理页式管理的系统中只要确定了每个页面的大小逻辑地址结构就确定了因此页式管理中地址是一维的即只要给出一个逻辑地址系统就可以自动地算出页号页内偏移量两个部分并不需要显式地告诉系统这个逻辑地址中页内偏移量占多少位对页表项的进一步讨论每个页表项的长度是相同的页号是隐含的假设某系统物理内存大小为页面大小为的内存总共会被分为个内存块因此内存块号的范围应该是因此至少要个二进制位才能表示这么多的内存块号因此至少要个字节才够每个字节个二进制位个字节共个二进制位各页表项会按顺序连续地存放在内存中如果该页表在内存中存放的起始地址为则号页对应的页表项是存放在内存地址为一个页面为则每个页框可以存放个页表项但是这个页框会剩余页内碎片因此号页表项存放的地址为如果每个页表项占字节则每个页框刚好可存放个而表项号页表项虽然是存放在下一个页框中的但是它的地址依然可以用得出结论理论上页表项长度为即可表示内存块号的范围但是为了方便页表的查询常常会让一个页表项占更多的字节使得每个页面恰好可以装得下整数个页表项具有快表的地址变换机构局部性原理这个程序执行时会很频繁地访问号号内存块时间局部性如果执行了程序中的某条指令那么不久后这条指令很有可能再次执行如果某个数据被访问过不久之后该数据很可能再次被访问因为程序中存在大量的循环空间局部性一旦程序访问了某个存储单元在不久之后其附近的存储单元也很有可能被访问因为很多数据在内存中都是连续存放的上小节介绍的基本地址变换机构中每次要访问一个逻辑地址都需要查询内存中的页表由于局部性原理可能连续很多次查到的都是同一个页表项既然如此能否利用这个特性减少访问页表的次数呢快表机制快表又称联想寄存器是一种访问速度比内存快很多的高速缓冲存储器用来存放当前访问的若干页表项以加速地址变换的过程与此对应内存中的页表常称为慢表引入快表之后地址的变化过程给出逻辑地址由某个硬件算得页号页内偏移量将页号与快表中的所有页号进行比较如果找到匹配的页号说明要访问的页表项在快表中有副本则直接从中取出该页对应的内存块号再将内存块号与页内偏移量拼接形成物理地址最后访问该物理地址对应的内存单元因此若快表命中则访问某个逻辑地址仅需一次访存即可如果没有找到匹配的页号则需要访问内存中的页表找到对应页表项得到页面存放的内存块号再将内存块号与页内偏移量拼接形成物理地址最后访问该物理地址对应的内存单元因此若快表未命中则访问某个逻辑地址需要两次访存注意在找到页表项后应同时将其存入快表但若快表已满则必须按照一定的算法对旧的页表项进行替换由于查询快表的速度比查询页表的速度快很多因此只要快表命中就可以节省很多时间因为局部性原理一船来说快表的合中率可以达到以上例某系统使用基本分页存储管理并采用了具有快表的地址变换机构访问一次快表耗时访问一次内存耗时若快表的命中率为那么访问一个逻辑地址的平均耗时是多少有的系统支持快表和慢表同时查找如果是这样平均耗时应该是若未采用快表机制则访问一个逻辑地址需要显然引入快表机制后访问一个逻辑地址的速度快多了地址变换过程访问一个逻辑地址的访问速度基本地址变化机构算页号页内偏移量检查页号合法性查页表找到页面存放的内存块号根据内存块号与页内偏移量得到物理地址访问目标内存单元两次访问具有快表的地址变换机构算页号页内偏移量检查页号合法性查快表若命中即可知道页面存放的内存块号可直接进行若未命中则进行查页表找到页面存放的内存块号并且将页表项复制到快表中根据内存块号与页内偏移量得到物理地址访问目标内存单元快表命中只需一次访存快表未命中需要两次访存两级页表单级页表存在什么问题如何解决某计算机系统按字节寻址支持位的逻辑地址采用分页存储管理页面大小为页表项长度为因此页内地址要用位表示剩余位表示页号因此该系统中用户进程最多有页相应的一个进程的页表中最多会有个页表项所以一个页表最大需要共需要个页框存储该页表根据局部性原理可知很多时候进程在一段时间内只需要访问某几个页面就可以正常运行了因此没有必要让整个页表都常驻内存如何解决单级页表的问题页表必须连续存放因此当页表很大时需要占用很多个连续的页框没有必要让整个页表常驻内存因为进程在一段时间内可能只需要访问某几个特定的页面解决方法虚拟内存是计算机系统内存管理的一种技术使得应用程序以为它拥有连续可用的内存空间而实际上它通常是被分割成多个物理内存块还有部分暂时存储在外存上这种技术使得大型程序编写更加方便对真正的物理内存使用也更有效率可将长长的页表进行分组使每个内存块刚好可以放入一个分组比如上个例子中页面大小每个页表项每个页面可存放个页表项因此每个连续的页表项为一组每组刚好占一个内存块再讲各组离散地放到各个内存块中另外要为离散分配的页表再建立一张页表称为页目录表或称外层页表或称顶层页表两级页表的原理逻辑地址结构位逻辑地址空间页表项大小为页面大小为则页内地址占位单级页表结构的逻辑地址结构页号页内偏移量多级页表的逻辑地址结构一级页号二级页号页内偏移量如何实现地址变换按照地址结构将逻辑地址拆分成三部分从中读出页目录表始址再根据一级页号查页目录表找到下一级页表在内存中的存放位置根据二级页号查表找到最终想访问的内存块号结合页内偏移量得到物理地址最终要访问的内存块号为该内存块的起始地址为页内偏移量为最终的物理地址为两级页表问题需要注意的几个细节若采用多级页表机制则各级页表的大小不能超过一个页面例某系统按字节编址采用位逻辑地址页面大小为页表项大小为假设采用纯页式存储则要采用级页表页内偏移量为位页面大小按字节编址因此页内偏移量为位页号位页面大小页表项大小则每个页面可存放个页表项因此各级页表最多包含个页表项需要位二进制位才能映射到个页表项因此每一级的页表对应页号应为位总共位的页号至少要分为三级两级贝表的访存次数分析假设没有快表机构第一次访存访问内存中的页目录表第二次访存访问内存中的二级页表第三次访存访问目标内存单元基本分段存储方式分段进程的地址空间按照程序自身的逻辑关系划分为若干个段每个段都有一个段名在低级语言中程序员使用段名来编程每段从开始编址内存分配规则以段为单位进行分配每个段在内存中占据连续空间但各段之间可以不相邻由于是按逻辑功能模块划分用户编程更方便程序的可读性更高将分段中单元内的值读入寄存器写程序时使用的段名会被编译程序翻译成对应段号将寄存器的内容存入分段的单元中单元单元会被编译程序翻译成段内地址分段系统的逻辑地址由段号段名和段内地址段内偏移量所组成如段号段内地址段号的位数决定了每个进程最多可以分几个段段内地址位数决定了每个段的最大长度是多少在上述例子中若系统是按字节寻址的则段号占位因此在该系统中每个进程最多有个段段内地址占位因此每个段的最大长度是段表问题程序分多个段各段离散地装入内存为了保证程序能正常运行就必须能从物理内存中找到各个逻辑段的存放位置为此需为每个进程建立一张段映射表简称段表每个段对应一个段表项其中记录了该段在内存中的起始位置又称基址和段的长度各个段表项的长度是相同的例如某系统按字节寻址采用分段存储管理逻辑地址结构为段号位段内地址位因此用位即可表示最大段长物理内存大小为可用位表示整个物理内存地址空间因此可以让每个段表项占位即由于段表项长度相同因此段号可以是隐含的不占存储空间若段表存放的起始地址为则号段对应的段表项存放的地址为分段和分页管理的对比页是信息的物理单位分页的主要目的是为了实现离散分配提高内存利用率分页仅仅是系统管理上的需要完全是系统行为对用户是不可见的段是信息的逻辑单位分段的主要目的是更好地满足用户需求一个段通常包含着一组属于一个逻辑模块的信息分段对用户是可见的用户编程时需要显式地给出段名页的大小固定且由系统决定段的长度却不固定决定于用户编写的程序分页的用户进程地址空间是一维的程序员只需给出一个记忆符即可表示一个地址分段的用户进程地址空间是二维的程序员在标识一个地址时既要给出段名也要给出段内地址分段比分页更容易实现信息的共享和保护不能被修改的代码称为纯代码或可重入代码不属于临界资源这样的代码是可以共享的可修改的代码是不能共享的比如有一个代码段中有很多变量各进程并发地同时访问可能造成数据不一致只需让各进程的段表项指向同一个段即可实现共享分页式共享操作其中绿色的代码段表示可共享数据如果让消费者进程的某个页表项指向这个页面显然不合理因为这个页面中的橙色部分是不允许共享的只有绿色部分可以页面不是按逻辑模块划分的这就很难实现共享访问一个逻辑地址需要的访问内存的次数分页单级页表第一次访存一一查内存中的页表第二次访存一一访问目标内存单元总共两次访存分段第一次访存一一查内存中的段表第二次访存一一访问目标内存单元总共两次访存与分页系统类似分段系统中也可以引入快表机构将近期访问过的段表项放到快表中这样可以少一次访问加快地址变换速度段页式管理方式分页和分段的优缺点分析优点缺点分页管理内存空间利用率高不会产生外部碎片只会产生少量的页内碎片不方便按照逻辑模块实现信息的共享和保护分段管理很方便按照逻辑模块实现信息的共享和保护如果段长过大为其分配很大的连续空间会很不方便另外段式管理会产生外部碎片虽然可以使用紧凑来解决但是会花费大量的时间段页式管理集合了分页管理和分段管理的优点段页式管理的逻辑地址结构段号的位数决定了每个进程最多可以分几个段页号位数决定了每个段最大有多少页页内偏移量决定了页面大小内存块大小是多少在上述例子中若系统是按字节寻址的则段号占位因此在该系统中每个进程最多有个段页号占位因此每个段最多有页页内偏移量占位因此每个页面每个内存块大小为分段对用户是可见的程序员编程时需要显式地给出段号段内地址而将各段分页对用户是不可见的系统会根据段内地址自动划分页号和页内偏移量因此段页式管理的地址结构是二维的每个段对应一个段表项每个段表项由段号页表长度页表存放块号页表起始地址组成每个段表项长度相等段号是隐含的每个页面对应一个页表项每个页表项由页号页面存放的内存块号组成每个页表项长度相等页号是隐含的一个程序对应一个段表项一个段表对应着多个页表那么在段页式管理的时候一个程序对应着多个页表其中重要的是第四步检查页号是否越界因为每一个段可能对应着多个页面所以这里需要检查一下页号是否越界了虚拟内存传统储存管理的缺点一次性作业必须一次性全部装入内存后才能开始运行这会造成两个问题作业很大时不能全部装入内存导致大作业无法运行当大量作业要求运行时由于内存无法容纳所有作业因此只有少量作业能运行导致多道程序并发度下降驻留性一旦作业被装入内存就会一直驻留在内存中直至作业运行结束事实上在一个时间段内只需要访问作业的一小部分数据即可正常运行这就导致了内存中会驻留大量的暂时用不到的数据浪费了宝贵的内存资源局部性原理时间局部性如果执行了程序中的某条指令那么不久后这条指令很有可能再次执行如果某个数据被访问过不久之后该数据很可能再次被访问因为程序中存在大量的循环空间局部性一旦程序访问了某个存储单元在不久之后其附近的存储单元也很有可能被访问因为很多数据在内存中都是连续存放的并且程序的指令也是顺序地在内存中存放的高速缓冲技术的思想将近期会频繁访问到的数据放到更高速的存储器中暂时用不到的数据放在更低速存储器中虚拟内存的定义和特征基于局部性原理在程序装入时可以将程序中很快会用到的部分装入内存暂时用不到的部分留在外存就可以让程序开始执行在程序执行过程中当所访问的信息不在内存时由操作系统负责将所需信息从外存调入内存然后继续执行程序若内存空间不够由操作系统负责将内存中暂时用不到的信息换出到外存在操作系统的管理下在用户看来似乎有一个比实际内存大得多的内存这就是虚拟内存操作系统虚拟性的一个体现实际的物理内存大小没有变只是在逻辑上进行了扩充易混知识点虚拟内存的最大容量是由计算机的地址结构寻址范围确定的虚拟内存的实际容量内存和外存容量之和寻址范围如某计算机地址结构为位按字节编址内存大小为外存大小为则虚拟内存的最大容量为虚拟内存的实际容量虚拟内存有一下三个主要特征多次性无需在作业运行时一次性全部装入内存而是允许被分成多次调入内存对换性在作业运行时无需一直常驻内存而是允许在作业运行过程中将作业换入换出虚拟性从逻辑上扩充了内存的容量使用户看到的内存容量远大于实际的容量如何实现虚拟内存技术虚拟内存技术允许一个作业分多次调入内存如果采用连续分配方式会不方便实现因此虚拟内存的实现需要建立在离散分配的内存管理方式基础上请求分页和基本分页的主要区别在程序执行过程中当所访问的信息不在内存时由操作系统负责将所需信息从外存调入内存然后继续执行程序操作系统要提供请求调页或请求调段功能若内存空间不够由操作系统负责将内存中暂时用不到的信息换出到外存操作系统要提供页面置换或段置换的功能请求分页管理方式请求分页存储管理与基本分页存储管理的主要区别在程序执行过程中当所访问的信息不在内存时由操作系统负责将所需信息从外存调入内存操作系统需要提供请求调页功能将缺失的页面从外存调入内存然后继续执行程序若内存空间不够由操作系统负责将内存中暂时用不到的信息换出到外存与基本分页管理相比请求分页管理中为了实现请求调页操作系统需要知道每个页面是否已经调入内存如果还没调入那么也需要知道该页面在外存中存放的位置当内存空间不够时要实现页面置换操作系统需要通过某些指标来决定到底换出哪个页面有的页面没有被修改过就不用再浪费时间写回外存有的页面修改过就需要将外存中的旧数据覆盖因此操作系统也需要记录各个页面是否被修改的信息缺页中断机构假设此时要访问逻辑地址页号页内偏移量在请求分页系统中每当要访问的页面不在内存时便产生一个缺页中断然后由操作系统的缺页中断处理程序处理中断此时缺页的进程阻塞放入阻塞队列调页完成后再将其唤醒放回就绪队列如果内存中有空闲块则为进程分配一个空闲块将所缺页面装入该块并修改页表中相应的页表项如果内存中没有空闲块则由页面置换算法选择一个页面淘汰若该页面在内存期间被修改过则要将其写回外存未修改过的页面不用写回外存页面置换算法请求分页存储管理与基本分页存储管理的主要区别在程序执行过程中当所访问的信息不在内存时由操作系统负责将所需信息从外存调入内存然后继续执行程序若内存空间不够由操作系统负责将内存中暂时用不到的信息换出到外存用页面置换算法决定应该先换出那个页面最佳置换算法最佳置换算法每次选择淘汰的页面将是以后永不使用或者在最长时间内不再被访问的页面这样可以保证最低的缺页率例假设系统为某进程分配了三个内存块并考虑到有一下页面号引用串会依次访问这些页面当执行到第四步访问页面二的时候选择从中淘汰一页按最佳置换的规则往后寻找最后一个出现的页号就是要淘汰的页面整个过程缺页中断发生了次页面置换发生了次注意缺页时未必发生页面置换若还有可用的空闲内存块就不用进行页面置换缺页率最佳置换算法可以保证最低的缺页率但实际上只有在进程执行的过程中才能知道接下来会访问到的是哪个页面操作系统无法提前预判页面访问序列因此最佳置换算法是无法实现的先进先出算法先进先出置换算法每次选择淘汰的页面是最早进入内存的页面实现方法把调入内存的页面根据调入的先后顺序排成一个队列需要换出页面时选择队头页面即可队列的最大长度取决于系统为进程分配了多少个内存块例假设系统为某进程分配了四个内存块并考虑到有以下页面号引用串访问页面内存块内存块内存块内存块是否缺页分配四个内存块时缺页次数次分配三个内存块时缺页次数次异常当为进程分配的物理块数增大时缺页次数不减反增的异常现象只有算法会产生异常另外算法虽然实现简单但是该算法与进程实际运行时的规律不适应因为先进入的页面也有可能最经常被访问因此算法性能差最近最久未使用置换算法最近最久未使用置换算法每次淘汰的页面是最近最久未使用的页面实现方法赋予每个页面对应的页表项中用访问字段记录该页面自上次被访问以来所经历的时间当需要淘汰一个页面时选择现有页面中值最大的即最近最久未使用的页面例假设系统为某进程分配了四个内存块并考虑到有以下页面号引用串在手动做题时若需要淘汰页面可以逆向检查此时在内存中的几个页面号在逆向扫描过程中最后一个出现的页号就是要淘汰的页面该算法的实现需要专门的硬件支持虽然算法性能好但是实现困难时钟置换算法最佳置换算法性能最好但无法实现先进先出置换算法实现简单但算法性能差最近最久未使用置换算法性能好是最接近算法性能的但是实现起来需要专门的硬件支持算法开销大时钟置换算法是一种性能和开销较均衡的算法乂称算法或最近未使用算法简单的算法实现方法为每个页面设置一个访问位再将内存中的页面都通过链接指针链接成一个循环队列当某页被访问时其访问位置为当需要淘汰一个页面时只需检查页的访问位如果是就选择该页换出如果是则将它置为暂不换出继续检查下一个页面若第一轮扫描中所有页面都是则将这些页面的访问位依次置为后再进行第二轮扫描第二轮扫描中一定会有访问位为的页面因此简单的算法选择一个淘汰页面最多会经过两轮扫描例假设系统为某进程分配了五个内存块并考虑到有以下页面号引用串当经过之后所有内存块的访问位都被置为所以在放入第六个元素的时候需要循环找出访问位为的经过一轮寻找之后发现没有访问位为的但是在我们寻找的过程中会将访问位为的转换为改进型的时钟置换算法简单的时钟置换算法仅考虑到一个页面最近是否被访问过事实上如果被淘汰的页面没有被修改过就不需要执行操作写回外存只有被淘汰的页面被修改过时才需要写回外存因此除了考虑一个页面最近有没有被访问过之外操作系统还应考虑页面有没有被修改过在其他条件都相同时应优先淘汰没有修改过的页面避免操作这就是改进型的时钟置换算法的思想修改位表示页面没有被修改过修改位表示页面被修改过为方便讨论用访问位修改位的形式表示各页面状态如表示一个页面近期被访问过且被修改过算法规则将所有可能被置换的页面排成一个循环队列第一轮从当前位置开始扫描到第一个的帧用于替换本轮扫描不修改任何标志位第一优先级最近没访问且没修改的页面第二轮若第一轮扫描失败则重新扫描查找第一个的帧用于替换本轮将所有扫描过的帧访问位设为第二优先级最近没访问但修改过的页面第三轮若第二轮扫描失败则重新扫描查找第一个的帧用于替换本轮扫描不修改任何标志位第三优先级最近访问过但没修改的页面第四轮若第三轮扫描失败则重新扫描查找第一个的帧用于替换第四优先级最近访问过且修改过的页面由于第二轮已将所有帧的访问位设为因此经过第三轮第四轮扫描一定会有一个帧被选中因此改进型置换算法选择一个淘汰页面最多会进行四轮扫描页面分配策略驻留集驻留集指请求分页存储管理中给进程分配的物理块的集合在采用了虚拟存储技术的系统中驻留集大小一般小于进程的总大小考虑一个极端情况若某进程共有个页面则该进程的驻留集大小为时进程可以全部放入内存运行期间不可能再发生缺页若驻留集大小为则进程运行期间必定会极频繁地缺页若驻留集太小会导致缺页频繁系统要花大量的时间来处理缺页实际用于进程推进的时间很少驻留集太大又会导致多道程序并发度下降资源利用率降低所以应该选择一个合适的驻留集大小页面分配置换策略固定分配操作系统为每个进程分配一组固定数目的物理块在进程运行期间不再改变即驻留集大小不变可变分配先为每个进程分配一定数目的物理块在进程运行期间可根据情况做适当的增加或减少即驻留集大小可变局部置换发生缺页时只能选进程自己的物理块进行置换全局置换可以将操作系统保留的空闲物理块分配给缺页进程也可以将别的进程持有的物理块置换到外存再分配给缺页进程全局置换意味着一个进程拥有的物理块数量必然会改变因此不可能是固定分配固定分配局部置换系统为每个进程分配一定数量的物理块在整个运行期间都不改变若进程在运行中发生缺页则只能从该进程在内存中的页面中选出一页换出然后再调入需要的页面这种策略的缺点是很难在刚开始就确定应为每个进程分配多少个物理块才算合理采用这种策略的系统可以根据进程大小优先级或是根据程序员给出的参数来确定为一个进程分配的内存块数可变分配全局置换刚开始会为每个进程分配一定数量的物理块操作系统会保持一个空闲物理块队列当某进程发生缺页时从空闲物理块中取出一块分配给该进程若已无空闲物理块则可选择一个未锁定的页面换出外存再将该物理块分配给缺页的进程采用这种策略时只要某进程发生缺页都将获得新的物理块仅当空闲物理块用完时系统才选择一个未锁定的页面调出被选择调出的页可能是系统中任何一个进程中的页因此这个被选中的进程拥有的物理块会减少缺页率会增加可变分配局部置换刚开始会为每个进程分配一定数量的物理块当某进程发生缺页时只允许从该进程自己的物理块中选出一个进行换出外存如果进程在运行中频繁地缺页系统会为该进程多分配几个物理块直至该进程缺页率趋势适当程度反之如果进程在运行中缺页率特别低则可适当减少分配给该进程的物理块可变分配全局置换只要缺页就络分配新物理块可变分配局部置换要根据发生缺页的频率来动态地增加或减少进程的物理块调入页面的时机预调页策略根据局部性原理主要指空间局部性即如果当前访问了某个内存单元在之后很有可能会接着访问与其相邻的那些内存单元一次调入若干个相邻的页面可能比一次调入一个页面更高效但如果提前调入的页面中大多数都没被访问过则又是低效的因此可以预测不久之后可能访问到的页面将它们预先调入内存但目前预测成功率只有左右故这种策略主要用于进程的首次调入运行前调入由程序员指出应该先调入哪些部分请求调页策略进程在运行期间发现缺页时才将所缺页面调入内存运行时调入由这种策略调入的页面一定会被访问到但由于每次只能调入一页而每次调页都要磁盘操作因此开销较大系统拥有足够的对换区空间页面的调入调出都是在内存与对换区之间进行这样可以保证页面的调入调出速度很快在进程运行前需将进程相关的数据从文件区复制到对换区系统缺少足够的对换区空间凡是不会被修改的数据都直接从文件区调入由于这些页面不会被修改因此换出时不必写回磁盘下次需要时再从文件区调入即可对于可能被修改的部分换出时需写回磁盘对换区下次需要时再从对换区调入方式运行之前进程有关的数据全部放在文件区故未使用过的页面都可从文件区调入若被使用过的页面需要换出则写回对换区下次需要时从对换区调入抖动颠簸现象刚刚换出的页面马上又要换入内存刚刚换入的页面马上又要换出外存这种频繁的页面调度行为称为抖动或颠簸产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数分配给进程的物理块不够为进程分配的物理块太少会使进程发生抖动现象为进程分配的物理块太多又会降低系统整体的并发度降低某些资源的利用率为了研究为应该为每个进程分配多少个物理块提出了进程工作集的概念工作机驻留集指请求分页存储管理中给进程分配的内存块的集合工作集指在某段时间间隔里进程实际访问页面的集合操作系统会根据窗口尺寸来算出工作集例某进程的页面访问序列如下窗口尺寸为各时刻的工作集为工作集大小可能小于窗口尺寸实际应用中操作系统可以统计进程的工作集大小根据工作集大小给进程分配若干内存块如窗口尺寸为经过一段时间的监测发现某进程的工作集最大为那么说明该进程有很好的局部性可以给这个进程分配个以上的内存块即可满足进程的运行需要一般来说驻留集大小不能小于工作集大小否则进程运行过程中将频繁缺页拓展基于局部性原理可知进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的因此可以根据进程近期访问的页面集合工作集来设计一种页面置换算法一一选择一个不在工作集中的页面进行淘汰操作系统第四章文件管理初识文件管理文件的属性一个文件有哪些属性文件名由创建文件的用户决定文件名主要是为了方便用户找到文件同一目录下不允许有重名文件标识符一个系统内的各文件标识符唯一对用户来说毫无可读性因此标识符只是操作系统用于区分各个文件的一种内部名称类型指明文件的类型位置文件存放的路径让用户使用在外存中的地址操作系统使用对用户不可见大小指明文件大小创建时间上次修改时间文件所有者信息保护信息对文件进行保护的访问控制信息文件内部数据组织方式操作系统向上提供的功能可以创建文件点击新建后图形化交互进程在背后调用了系统调用可以读文件将文件数据读入内存才能让处理双击后记事本应用程序通过操作系统提供的读文件功能即系统调用将文件数据从外存读入内存并显示在屏幕上可以写文件将更改过的文件数据写回外存我们在记事本应用程序中编辑文件内容点击保存后记事本应用程序通过操作系统提供的写文件功能即系统调用将文件数据从内存写回外存可以删除文件点了删除之后图形化交互进程通过操作系统提供的删除文件功能即系统调用将文件数据从外存中删除文件应该如何存放到外存与内存一样外存也是由一个个存储单元组成的每个存储单元可以存储一定量的数据如每个存储单元对应一个物理地址类似于内存分为一个个内存块外存会分为一个个块磁盘块物理块每个磁盘块的大小是相等的每块一般包含的整数幂个地址如本例中一块包含个地址即同样类似的是文件的逻辑地址也可以分为逻辑块号块内地址操作系统同样需要将逻辑地址转换为外存的物理地址物理块号块内地址的形式块内地址的位数取决于磁盘块的大小操作系统以块为单位为文件分配存储空间因此即使一个文件大小只有但它依然需要占用的磁盘块外存中的数据读入内存时同样以块为单位文件的逻辑结构所谓的逻辑结构就是指在用户看来文件内部的数据应该是如何组织起来的而物理结构指的是在操作系统看来文件的数据是如何存放在外存中的类似于数据结构的逻辑结构和物理结构如线性表就是一种逻辑结构在用户角度看来线性表就是一组有先后关系的元素序列如线性表这种逻辑结构可以用不同的物理结构实现如顺序表链表顺序表的各个元素在逻辑上相邻在物理上也相邻而链表的各个元素在物理上可以是不相邻的因此顺序表可以实现随机访问而链表无法实现随机访问可见算法的具体实现与逻辑结构物理结构都有关文件也一样文件操作的具体实现与文件的逻辑结构物理结构都有关有结构文件按文件是否有结构分类可以分为无结构文件有结构文件两种无结构文件文件内部的数据就是一系列二进制流或字符流组成又称流式文件如操作系统中的文件有结构文件由一组相似的记录组成又称记录式文件每条记录又若干个数据项组成如数据库表文件一般来说每条记录有一个数据项可作为关键字根据各条记录的长度占用的存储空间是否相等又可分为定长记录和可变长记录两种这个有结构文件由可变长记录组成由于各个学生的特长存在很大区别因此特长这个数据项的长度不确定这就导致了各条记录的长度也不确定当然没有特长的学生甚至可以去掉特长数据项顺序文件顺序文件文件中的记录一个接一个地顺序排列逻辑上记录可以是定长的或可变长的各个记录在物理上可以顺序存储或链式存储假设已经知道了文件的起始地址也就是第一个记录存放的位思考能否快速找到第个记录对应的地址即能否实现随机存取思考能否快速找到某个关键字对应的记录存放的位置顺序可边长结构虽然我们可以得出每一条记录是顺序存储的但是这条记录的长度却不是固定的这时候我们需要使用一个可边长记录表来记录每条记录的长度因为每条记录的长度都不是固定的所以不能够直接找到第条记录的位置结论定长记录的顺序文件若物理上采用顺序存储则可实现随机存取若能再保证记录的顺序结构则可实现快速检索即根据关键字快速找到对应记录注一般来说考试题目中所说的顺序文件指的是物理上顺序存储的顺序文件之后的讲解中提到的顺序文件也默认如此可见顺序文件的缺点是增加删除一个记录比较难如果是串结构则相对简单索引文件对于可变长记录文件要找到第个记录必须先顺序第查找前个记录但是很多应用场景中又必须使用可变长记录如何解决这个问题索引表本身是定长记录的顺序文件因此可以快速找到第个记录对应的索引项可将关键字作为索引号内容若按关键字顺序排列则还可以支持按照关键字折半查找每当要增加删除一个记录时需要对索引表进行修改由于索引文件有很快的检索速度因此主要用于对信息处理的及时性要求比较高的场合另外可以用不同的数据项建立多个索引表如学生信息表中可用关键字学号建立一张索引表也可用姓名建立一张索引表这样就可以根据姓名快速地检索文件了就支持根据某个数据项建立索引的功能顺序索引文件思考索引文件的缺点每个记录对应一个索引表项因此索引表可能会很大比如文件的每个记录平均只占而每个索引表项占个字节那么索引表都要比文件内容本身大倍这样对存储空间的利用率就太低了索引顺序文件是索引文件和顺序文件思想的结合索引顺序文件中同样会为文件建立一张索引表但不同的是并不是每个记录对应一个索引表项而是一组记录对应一个索引表项检索效率若一个顺序文件有个记录则根据关键字检索文件只能从头开始顺序查找这里指的并不是定长记录顺序结构的顺序文件平均须查找个记录若采用索引顺序文件结构可把个记录分为组每组个记录则需要先顺序查找索引表找到分组共个分组因此索引表长度为平均需要查次找到分组后再在分组中顺序查找记录每个分组个记录因此平均需要查次可见采用索引顺序文件结构后平均查找次数减少为次多级索引顺序文件为了进一步提高检索效率可以为顺序文件建立多级索引表例如对于一个含个记录的文件可先为该文件建立一张低级索引表每个记录为一组故低级索引表中共有个表项即个定长记录再把这个定长记录分组每组个为其建立顶级索引表故顶级索引表中共有个表项文件目录目录文件中的一条记录就是文件控制块的有序集合称为文件目录一个就是一个文件目录项中包含了文件的基本信息文件名物理地址逻辑结构物理结构等存取控制信息是否可读可写禁止访问的用户名单等使用信息如文件的建立时间修改时间等最重要最基本的还是文件名文件存放的物理地址实现了文件名和文件之间的映射使用户用户程序可以实现按名存取文件控制块文件控制块就是的集合需要对目录进行哪些操作搜索当用户要使用一个文件时系统要根据文件名搜索目录找到该文件对应的目录项创建文件创建一个新文件时需要在其所属的目录中增加一个目录项删除文件当删除一个文件时需要在目录中删除相应的目录项显示目录用户可以请求显示目录的内容如显示该目录中的所有文件及相应属性修改目录某些文件属性保存在目录中因此这些属性变化时需要修改相应的目录项如文件重命名单级目录结构早期操作系统并不支持多级目录整个系统中只建立一张目录表每个文件占一个目录项每个文件占一个目录项单级目录实现了按名存取但是不允许文件重名在创建一个文件时需要先检查目录表中有没有重名文件确定不重名后才能允许建立文件并将新文件对应的目录项插入目录表中显然单级目录结构不适用于多用户操作系统两极目录结构早期的多用户操作系统采用两级目录结构分为主文件目录和用户文件目录允许不同用户的文件重名文件名虽然相同但是对应的其实是不同的文件两级目录结构允许不同用户的文件重名也可以在目录上实现实现访问限制检查此时登录的用户名是否匹配但是两级目录结构依然缺乏灵活性用户不能对自己的文件进行分类多级目录结构树形目录结构用户或用户进程要访问某个文件时要用文件路径名标识文件文件路径名是个字符串各级目录之间用隔开从根目录出发的路径称为绝对路径例如自拍的绝对路径是照片自拍系统根据绝对路径一层一层地找到下一级目录刚开始从外存读入根目录的目录表找到照片目录的存放位置后从外存读入对应的目录表再找到目录的存放位置再从外存读入对应目录表最后才找到文件自拍的存放位置整个过程需要次读磁盘操作例如此时已经打开了照片的目录文件也就是说这张目录表已调入内存那么可以把它设置为当前目录当用户想要访问某个文件时可以使用从当前目录出发的相对路径在中表示当前目录因此如果照片是当前目录则自拍的相对路径为自拍从当前路径出发只需要查询内存中的照片目录表即可知道目录表的存放位置从外存调入该目录即可知道自拍存放的位置了可见引入当前目录和相对路径后磁盘的次数减少了这就提升了访问文件的效率无环图目录结构在树形目录结构的基础上增加一些指向同一节点的有向边使整个目录成为一个有向无环图可以更方便地实现多个用户间的文件共享可以用不同的文件名指向同一个文件甚至可以指向同一个目录共享同一目录下的所有内容需要为每个共享结点设置一个共享计数器用于记录此时有多少个地方在共享该结点用户提出删除结点的请求时只是删除该用户的并使共享计数器减并不会直接删除共享结点只有共享计数器减为时才删除结点注意共享文件不同于复制文件在共享文件中由于各用户指向的是同一个文件因此只要其中一个用户修改了文件数据那么所有用户都可以看到文件数据的变化索引节点的改进其实在查找各级目录的过程中只需要用到文件名这个信息有文件名匹配时才需要读出文件的其他信息因此可以考虑让目录表瘦身来提升效率思考有何好处假设一个是磁盘块的大小为则每个盘块中只能存放个若一个文件目录中共有个目录项则共需要占用个盘块因此按照某文件名检索该目录平均需要查询个目录项若使用索引结点机制文件名占索引结点指针站则每个盘块可存放个目录项那么按文件名检索目录平均只需耍读入个磁盘块显然这将大大提升文件检索速度当找到文件名对应的目录项时才需要将索引结点调入内存索引结点中记录了文件的各种信息包括文件在外存中的存放位置根据存放位置即可找到文件存放在外存中的索引结点称为磁盘索引结点当索引结点放入内存后称为内存索引结点相比之下内存索引结点中需要增加一些信息比如文件是否被修改此时有几个进程正在访问该文件等文件的物理结构文件块磁盘块类似于内存分页磁盘中的存储单元也会被分为一个个块磁盘块物理块很多操作系统中磁盘块的大小与内存块页面的大小相同在内存管理中进程的逻辑地址空间被分为一个一个页面同样的在外存管理中为了方便对文件数据的管理文件的逻辑地址空间也被分为了一个一个的文件块于是文件的逻辑地址也可以表示为逻辑块号块内地址的形式文件的分配方式连续分配连续分配方式要求每个文件在磁盘上占有一组连续的块用户通过逻辑地址来操作自己的文件操作系统如何实现从逻辑地址到物理地址的映射逻辑块号块内地址物理块号块内地址只需转换块号就行块内地址保持不变用户给出要访问的逻辑块号操作系统找到该文件对应的目录项物理块号起始块号逻辑块号例如我想要找到文件中逻辑块号为的地址我们先要找到对应的中的起始块号然后最后得出逻辑地址为可以直接算出逻辑块号对应的物理块号因此连续分配支持顺序访问和直接访间即随机访问读取某个磁盘块时需要移动磁头访问的两个磁盘块相隔越远移动磁头所需时间就越长结论连续分配的文件在顺序读写时速度最快物理上连续分配的文件占用了连续的三个块橙色区域为其他文件已经占用的磁盘块绿色区域为空闲磁盘块若此时文件要拓展需要再增加一个磁盘块总共需要连续的个磁盘块由于采用连续结构因此文件占用的磁盘块必须是连续的因此只能将文件全部迁移到绿色区域结论物理上采用连续分配的文件不方便拓展橙色区域为非空闲块绿色区域为空闲磁盘块若此时创建的新文件大小为个块那么无法为其分配足够的存储空间结论物理上采用连续分配可以用紧凑来处理碎片但是需要耗费很大的时间代价优点支持顺序访问和直接访问即随机访问连续分配的文件在顺序访问时速度最快缺点不方便文件拓展存储空间利用率低会产生磁盘碎片文件的分配方式链接分配链接分配采取离散分配的方式可以为文件分配离散的磁盘块分为隐式链接和显式链接两种隐式链接目录中记录了文件存放的起始块号和结束块号当然也可以增加一个字段来表示文件的长度除了文件的最后一个磁盘块之外每个磁盘块中都会保存指向下一个盘块的指针这些指针用户是透明的用户给出要访问的逻辑块号操作系统找到该文件对应的目录项从目录项中找到起始块号即号块将号逻辑块读入内存由此知道号逻辑块存放的物理块号于是读入号逻辑块再找到号逻辑块的存放位置以此类推因此读入号逻辑块总共需要次磁盘结论采用链式分配隐式链接方式的文件只支持顺序访问不支持随机访问查找效率低另外指向下一个盘块的指针也需要耗费少量的存储空间结论采用隐式链接的链接分配方式很方便文件拓展另外所有的空闲磁盘块都可以被利用不会有碎片问题外存利用率高隐式链接除文件的最后一个盘块之外每个盘块中都存有指向下一个盘块的指针文件目录包括文件第一块的指针和最后一块的指针优点很方便文件拓展不会有碎片问题外存利用率高缺点只支持顺序访问不支持随机访问查找效率低指向下一个盘块的指针也需要耗费少量的存储空间显示链接把用于链接文件各物理块的指针显式地存放在一张表中即文件分配表目录中只需记录文件的起始块号假设某个新创建的文件依次存放在磁盘块假设某个新创建的文件依次存放在磁盘块注意一个磁盘仅设置一张开机时并常驻内存的各个表项在物理上连续存储且每一个表项长度相同因此物理块号字段可以是隐含的如何实现文件的逻辑块号到物理块号的转变用户给出要访问的逻辑块号操作系统找到该文件对应的目录项从目录项中找到起始块号若则查询内存中的文件分配表往后找到号逻辑块对应的物理块号逻辑块号转换成物理块号的过程不需要读磁盘操作结论采用链式分配显式链接方式的文件支持顺序访问也支持随机访问想访问号逻辑块时并不需要依次访问之前的号逻辑块由于块号转换的过程不需要访问磁盘因此相比于隐式链接来说访问速度快很多显然显式链接也不会产生外部碎片也可以很方便地对文件进行拓展显式链接一一把用于链接文件各物理块的指针显式地存放在一张表中即文件分配表一个磁盘只会建立一张文件分配表开机时文件分配表放入内存并常驻内存优点很方便文件拓展不会有碎片问题外存利用率高并且支持随机访问相比于隐式链接来说地址转换时不需要访问磁盘因此文件的访问效率更高缺点文件分配表的需要占用一定的存储空间文件的分配方式索引的分配索引分配允许文件离散地分配在各个磁盘块中系统会为每个文件建立一张索引表索引表中记录了文件的各个逻辑块对应的物理块索引表的功能类似于内存管理中的页表一一建立逻辑页面到物理页之间的映射关系索引表存放的磁盘块称为索引块文件数据存放的磁盘块称为数据块假设某个新创建的文件的数据依次存放在磁盘块号磁盘块作为的索引块索引块中保存了索引表的内容注在显式链接的链式分配方式中文件分配表是一个磁盘对应一张而索引分配方式中索引表是一个文件对应一张可以用固定的长度表示物理块号如假设磁盘总容量为磁盘块大小为则共有个磁盘块则可用表示磁盘块号因此索引表中的逻辑块号可以是隐含的从目录项中可知索引表存放位置将索引表从外存读入内存并查找索引表即可知号逻辑块在外存中的存放位置可见索引分配方式可以支持随机访问文件拓展也很容易实现只需要给文件分配一个空闲块并增加一个索引表项即可但是索引表需要占用一定的存储空间若每个磁盘块一个索引表项则一个磁盘块只能存放个索引项如果一个文件的大小超过了块那么一个磁盘块是装不下文件的整张索引表的如何解决这个问题链接方案多层索引混合索引链接方案链接方案如果索引表太大一个索引块装不下那么可以将多个索引块链接起来存放假设磁盘块大小为一个索引表项占则一个磁盘块只能存放个索引项若一个文件大小为该文件共有个块也就对应个索引项也就需要个索引块来存储这些索引块用链接方案连起来若想要访问文件的最后一个逻辑块就必须找到最后一个索引块第个索引块而各个索引块之间是用指针链接起来的因此必须先顺序地读入前个索引块索引分配多层索引建立多层索引原理类似于多级页表使第一层索引块指向第二层的索引块还可根据文件大小的要求再建立第三层第四层索引块假设磁盘块大小为一个索引表项占则一个磁盘块只能存放个索引项若某文件采用两层索引则该文件的最大长度可以到可根据逻辑块号算出应该查找索引表中的哪个表项如要访问号逻辑块则因此可以先将一级索引表调入内存查询号表项将其对应的二级索引表调入内存再查询二级索引表的号表项即可知道号逻辑块存放的磁盘块号了访问目标数据块需要次磁盘若采用三层索引则文件的最大长度为类似的访问目标数据块采用层索引结构且顶级索引表未调内存则访问一个数据块只需要读磁盘操作混合索引混合索引多种索引分配方式的结合例如一个文件的顶级索引表中既包含直接地址索引直接指向数据块又包含一级间接索引指向单层索引表还包含两级间接索引指向两层索引表索引分配允许文件离散地分配在各个磁盘块中系统会为每个文件建立一张索引表索引表中记录了文件的各个逻辑块对应的物理块索引表的功能类似于内存管理中的页表建立逻辑页面到物理页之间的映射关系索引表存放的磁盘块称为索引块文件数据存放的磁盘块称为数据块若文件太大索引表项太多可以采取以下三种方法解决链接方案如果索引表太大一个索引块装不下那么可以将多个索引块链接起来存放缺点若文件很大索引表很长就需要将很多个索引块链接起来想要找到号索引块必须先依次读入号索引块这就导致磁盘次数过多查找效率低下多层索引建立多层索引原理类似于多级页表使第一层索引块指向第二层的索引块还可根据文件大小的要求再建立第三层第四层索引块采用层索引结构且顶级索引表未调入内存则访问一个数据块只需要次读磁盘操作缺点即使是小文件访问一个数据块依然需要次读磁盘操作混合索引多种索引分配方式的结合例如一个文件的顶级索引表中既包含直接地址索引直接指向数据块又包含一级间接索引指向单层索引表还包含两级间接索引指向两层索引表优点对于小文件来说访问一个数据块所需的读磁盘次数更少超级超级超级重要考点要会根据多层索引混合索引的结构计算出文件的最大长度各级索引表最大不能超过一个块要能自己分析访问某个数据块所需要的读磁盘次数中会存有指向顶级索引块的指针因此可以根据读入顶级索引块每次读入下一级的索引块都需要一次读他盘操作另外要注意题目条件一一顶级索引块是否已调入内存文件存储空间管理文件存储空间管理就是对空闲磁盘块的管理存储空间的划分和初始化存储空间管理空闲表法适用于连续分配的方式如何分配磁盘块与内存管理中的动态分区分配很类似为一个文件分配连续的存储空间同样可采用首次适应最佳适应最坏适应等算法来决定要为文件分配哪个区间如何回收磁盘块与内存管理中的动态分区分配很类似当回收某个存储区时需要有四种情况回收区的前后都没有相邻空闲区回收区的前后都是空闲区回收区前面是空闲区回收区后面是空闲区总之回收时需要注意表项的合并问题空闲盘块链操作系统保存着链头链尾指针如何分配若某文件申请个盘块则从链头开始依次摘下个盘块分配并修改空闲链的链头指针如何回收回收的盘块依次挂到链尾并修改空闲链的链尾指针适用于离散分配的物理结构为文件分配多个盘块时可能要重复多次操作空闲盘区链如何分配若某文件申请个盘块则可以采用首次适应最佳适应等算法从链头开始检索按照算法规则找到一个大小符合要求的空闲盘区分配给文件若没有合适的连续空闲块也可以将不同盘区的盘块同时分配给一个文件注意分配后可能要修改相应的链指针盘区大小等数据如何回收若回收区和某个空闲盘区相邻则需要将回收区合并到空闲盘区中若回收区没有和任何空闲区相邻将回收区作为单独的一个空闲盘区挂到链尾离散分配连续分配都适用为一个文件分配多个盘块时效率更高存储空间管理位示图法位示图每个二进制位对应一个盘块在本例中代表盘块空闲代表盘块已分配位示图一般用连续的字来表示如本例中一个字的字长是位字中的每一位对应一个盘块因此可以用字号位号对应一个盘块号当然有的题目中也描述为行号列号重要重要重要要能自己推出盘块号与字号位号相互转换的公式注意题目条件盘块号字号位号到底是从开始还是从开始如本例中盘块号字号位号从开始若表示字长则字号位号的二进制位对应的盘块号号盘块对应的字号位号如何分配若文件需要个块顺序扫描位示图找到个相邻或不相邻的根据字号位号算出对应的盘块号将相应盘块分配给文件将相应位设置为如何回收根据回收的盘块号计算出对应的字号位号将相应二进制位设为存储空间管理成组链接法空闲表法空闲链表法不适用于大型文件系统因为空闲表或空闲链表可能过大系统中采用了成组链接法对磁盘空闲块进行管理文件卷的目录区中专门用一个磁盘块作为超级块当系统启动时需要将超级块读入内存并且要保证内存与外存中的超级块数据一致如何分配需要个空闲块检查第一个分组的块数是否足够因此是足够的分配第一个分组中的个空闲块并修改相应数据需要个空闲块检查第一个分组的块数是否足够是足够的分配第一个分组中的个空闲块但是由于号块内存放了再下一组的信息因此号块的数据需要复制到超级块中如何回收假设每个分组最多为个空闲块此时第一个分组已有个块还要再回收一块假设每个分组最多为个空闲块此时第一个分组已有个块还要再回收一块需要将超级块中的数据复制到新回收的块中并修改超级块的内容让新回收的块成为第一个分组文件的基本操作创建文件系统调用进行系统调用时需要提供的几个主要参数所需的外存空间大小如一个盘块即文件存放路径文件名这个地方默认为新建文本文档操作系统在处理系统调用时主要做了两件事在外存中找到文件所需的空间结合上小节学习的空闲链表法位示图成组链接法等管理策略找到空闲空间根据文件存放路径的信息找到该目录对应的目录文件此处就是目录在目录中创建该文件对应的目录项目录项中包含了文件名文件在外存中的存放位置等信息删除文件系统调用进行系统调用时需要提供的几个主要参数文件存放路径文件名操作系统在处理系统调用时主要做了几件事根据文件存放路径找到相应的目录文件从目录中找到文件名对应的目录项根据该目录项记录的文件在外存的存放位置文件大小等信息回收文件占用的磁盘块回收磁盘块时根据空闲表法空闲链表法位图法等管理策略的不同需要做不同的处理从目录表中删除文件对应的目录项读文件系统调用进程使用系统调用完成写操作需要指明是哪个文件在支持打开文件操作的系统中只需要提供文件在打开文件表中的索引号即可还需要指明要读入多少数据如读入指明读入的数据要放在内存中的什么位置操作系统在处理系统调用时会从读指针指向的外存中将用户指定大小的数据读入用户指定的内存区域中写文件系统调用进程使用系统调用完成写操作需要指明是哪个文件在支持打开文件操作的系统中只需要提供文件在打开文件表中的索引号即可还需要指明要写出多少数据如写出写回外存的数据放在内存中的什么位置操作系统在处理系统调用时会从用户指定的内存区域中将指定大小的数据写回写指针指向的外存打开文件系统调用在很多操作系统中在对文件进行操作之前要求用户先使用系统调用打开文件需要提供的几个主要参数文件存放路径文件名要对文件的操作类型如只读读写等操作系统在处理系统调用时主要做了几件事根据文件存放路径找到相应的目录文件从目录中找到文件名对应的的目录项并检查该用户是否有指定的操作权限将目录项复制到内存中的打开文件表中并将对应表目的编号返回给用户之后用户使用打开文件表的编号来指明要操作的文件将目录表从外存中复制到内存中以后用户在访问文件的时候就不需要从新从外存中读取了关闭文件系统调用进程使用完文件后要关闭文件操作系统在处理系统调用时主要做了几件事将进程的打开文件表相应表项删除回收分配给该文件的内存空间等资源系统打开文件表的打开计数器减若则删除对应表项文件共享注意多个用户共享同一个文件意味着系统中只有一份文件数据并且只要某个用户修改了该文件的数据其他用户也可以看到文件数据的变化如果是多个用户都复制了同一个文件那么系统中会有好几份文件数据其中一个用户修改了自己的那份文件数据对其他用户的文件数据并没有影响基于索引节点的共享方式硬链接知识回顾索引结点是一种文件目录瘦身策略由于检索文件时只需用到文件名因此可以将除了文件名之外的其他信息放到索引结点中这样目录项就只需要包含文件名索引结点指针索引结点中设置一个链接计数变量用于表示链接到本索引结点上的用户目录项数若说明此时有两个用户目录项链接到该索引结点上或者说是有两个用户在共享此文件若某个用户决定删除该文件则只是要把用户目录中与该文件对应的目录项删除且索引结点的值减若说明还有别的用户要使用该文件暂时不能把文件数据删除否则会导致指针悬空当的时候系统负责删除文件基于符号链的共享方式软连接当访问时操作系统判断文件属于类型文件于是会根据其中记录的路径层层查找目录最终找到的目录表中的表项于是就找到了文件的索引结点文件保护口令保护为文件设置一个口令如用户请求访问该文件时必须提供口令口令一般存放在文件对应的或索引结点中用户访问文件前需要先输入口令操作系统会将用户提供的口令与中存储的口令进行对比如果正确则允许该用户访问文件优点保存口令的空间开销不多验证口令的时间开销也很小缺点正确的口令存放在系统内部不够安全加密保护使用某个密码对文件进行加密在访问文件时需要提供正确的密码才能对文件进行正确的解密一个最简单的加密算法异或加密假设用于加密解密的密码为优点保密性强不需要在系统中存储密码缺点编码译码或者说加密解密要花费一定时间访问控制在每个文件的或索引结点中增加一个访问控制列表该表中记录了各个用户可以对该文件执行哪些操作有的计算机可能会有很多个用户因此访问控制列表可能会很大可以用精简的访问列表解决这个问题精简的访问列表以组为单位标记各组用户可以对文件执行哪些操作如分为系统管理员文件主文件主的伙伴其他用户几个分组当某用户想要访问文件时系统会检查该用户所属的分组是否有相应的访问权限若想要让某个用户能够读取文件只需要把该用户放入文件主的伙伴这个分组即可文件系统的层次结构用一个例子来辅助记忆文件系统的层次结构假设某用户请求删除文件工作目录学生信息的最后条记录用户需要通过操作系统提供的接口发出上述请求一一用户接口由于用户提供的是文件的存放路径因此需要操作系统一层一层地查找目录找到对应的目录项一一文件目录系统不同的用户对文件有不同的操作权限因此为了保证安全需要检查用户是否有访问权限存取控制模块存取控制验证层验证了用户的访问权限之后需要把用户提供的记录号转变为对应的逻辑地址一一逻辑文件系统与文件信息缓冲区知道了目标记录对应的逻辑地址后还需要转换成实际的物理地址一一物理文件系统要删除这条记录必定要对磁盘设备发出请求一一设备管理程序模块删除这些记录后会有一些盘块空闲因此要将这些空闲盘块回收一一辅助分配模块磁盘的结构磁盘磁道扇区磁盘磁盘的表面由一些磁性物质组成可以用这些磁性物质来记录二进制数据磁盘的读写操作需要把磁头移动到想要读写的扇区所在的磁道磁盘会转起来让目标扇区从磁头下面划过才能完成对扇区的读写操作盘面柱面一个盘片可能对应着两个面上面和下面每个盘面对应一个磁头所有的磁头都是连在同一个磁臂上的因此所有磁头只能共进退所有盘面中相对位置相同的磁道组成柱面可用柱面号盘面号扇区号来定位任意一个磁盘块在文件的物理结构小节中我们经常提到文件数据存放在外存中的几号块这个块号就可以转换成柱面号盘面号扇区号的地址形式可根据该地址读取一个块根据柱面号移动磁臂让磁头指向指定柱面激活指定盘面对应的磁头磁盘旋转的过程中指定的扇区会从磁头下面划过这样就完成了对指定扇区的读写磁盘的分类磁头可以移动的称为活动头磁盘磁臂可以来回伸缩来带动磁头定位磁道磁头不可移动的称为固定头磁盘这种磁盘中每个磁道有一个磁头磁盘调度算法一次磁盘读写操作所需要的时间寻找时间寻道时间在读写数据前将磁头移动到指定磁道所花的时间启动磁头臂是需要时间的假设耗时为移动磁头也是需要时间的假设磁头匀速移动每跨越一个磁道耗时为总共需要跨越条磁道则寻道时间延迟时间通过旋转磁盘使磁头定位到目标扇区所需要的时间设磁盘转速为单位转秒或转分则平均所需的延迟时间传输时间从磁盘读出或向磁盘写入数据所经历的时间假设磁盘转速为此次读写的字节数为每个磁道上的字节数为则传输时间总的平均存取时间延迟时间和传输时间都与磁盘转速相关且为线性相关而转速是硬件的固有属性因此操作系统也无法优化延迟时间和传输时间只能够通过优化寻找时间来进行优化先来先服务算法根据进程请求访问磁盘的先后顺序进行调度假设磁头的初始位置是号磁道有多个进程先后陆续地请求访问号磁道按照的规则按照请求到达的顺序磁头需要依次移动到号磁道磁头总共移动了个磁道响应一个请求平均需要移动个磁道平均寻找长度优点公平如果请求访问的磁道比较集中的话算法性能还算过的去缺点如果有大量进程竞争使用磁盘请求访问的磁道很分散则在性能上很差寻道时间长算法会优先处理的磁道是与当前磁头最近的磁道可以保证每次的寻道时间最短但是并不能保证总的寻道时间最短其实就是贪心算法的思想只是选择眼前最优但是总体未必最优假设磁头的初始位置是号磁道有多个进程先后陆续地请求访问号磁道磁头总共移动了个磁道响应一个请求平均需要移动个磁道平均寻找长度优点性能较好平均寻道时间短缺点可能产生饥饿现象本例中如果在处理号磁道的访问请求时又来了一个号磁道的访问请求处理号磁道的访问请求时又来了一个号磁道的访问请求如果有源源不断的号号磁道的访问请求到来的话号磁道的访问请求就永远得不到满足从而产生饥饿现象产生饥饿的原因磁头在一个小区域内来回跳动扫描算法算法会产生饥饿的原因在于磁头有可能在一个小区域内来回来去地移动为了防止这个问题可以规定只有磁头移动到最外侧磁道的时候才能往内移动移动到最内侧磁道的时候才能往外移动这就是扫描算法的思想由于磁头移动的方式很像电梯因此也叫电梯算法假设某磁盘的磁道为号磁头的初始位置是号磁道且此时磁头正在往磁道号增大的方向移动有多个进程先后陆续地请求访问号磁道磁头总共移动了个磁道响应一个请求平均需要移动个磁道平均寻找长度优点性能较好平均寻道时间较短不会产生饥饿现象缺点只有到达最边上的磁道时才能改变磁头移动方向事实上处理了号磁道的访问请求之后就不需要再往右移动磁头了算法对于各个位置磁道的响应频率不平均如假设此时磁头正在往右移动且刚处理过号磁道那么下次处理号磁道的请求就需要等磁头移动很长一段距离而响应了号磁道的请求之后很快又可以再次响应号磁道的请求了算法在扫描算法中只有到达最边上的磁道时才能改变磁头移动方向事实上处理了号磁道的访问请求之后就不需要再往右移动磁头了调度算法就是为了解决这个问题如果在磁头移动方向上已经没有别的请求就可以立即改变磁头移动方向边移动边观察因此叫假设某磁盘的磁道为号磁头的初始位置是号磁道且此时磁头正在往磁道号增大的方向移动有多个进程先后陆续地请求访问号磁道磁头总共移动了个磁道响应一个请求平均需要移动个磁道平均寻找长度优点比起算法来不需要每次都移动到最外侧或最内侧才改变磁头方向使寻道时间进一步缩短循环扫描算法算法对于各个位置磁道的响应频率不平均而算法就是为了解决这个问题规定只有磁头朝某个特定方向移动时才处理磁道访问请求而返回时直接快速移动至起始端而不处理任何请求假设某磁盘的磁道为号磁头的初始位置是号磁道且此时磁头正在往磁道号增大的方向移动有多个进程先后陆续地请求访问号磁道磁头总共移动了个磁道响应一个请求平均需要移动个磁道平均寻找长度优点比起来对于各个位置磁道的响应频率很平均缺点只有到达最边上的磁道时才能改变磁头移动方向事实上处理了号磁道的访问请求之后就不需要再往右移动磁头了并且磁头返回时其实只需要返回到号磁道即可不需要返回到最边缘的磁道另外比起算法来平均寻道时间更长调度算法算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向并且磁头返回时不定需要返回到最边缘的磁道上算法就是为了解决这个问题如果磁头移动的方向上已经没有磁道访问请求了就可以立即让磁头返回并且磁头只需要返回到有磁道访问请求的位置即可假设某磁盘的磁道为号磁头的初始位置是号磁道且此时磁头正在往磁道号增大的方向移动有多个进程先后陆续地请求访问号磁道磁头总共移动了个磁道响应一个请求平均需要移动个磁道平均寻找长度优点比起算法来不需要每次都移动到最外侧或最内侧才改变磁头方向使寻道时间进一步缩短减少磁盘延迟时间的方法假设要连续读取橙色区域的扇区磁头读取一块的内容也就是一个扇区的内容后需要一小段时间处理而盘片又在不停地旋转因此如果号扇区相邻着排列则读完号扇区后无法连续不断地读入号扇区必须等盘片继续旋转号扇区再次划过磁头才能完成扇区读入结论磁头读入一个扇区数据后需要一小段时间处理如果逻辑上相邻的扇区在物理上也相邻则读入几个连续的逻辑扇区可能需要很长的延迟时间减少延迟时间的方法交替编号若采用交替编号的策略即让逻辑上相邻的扇区在物理上有一定的间隔可以使读取连续的逻辑扇区所需要的延迟时间更小磁盘地址结构的设计思考为什么磁盘的物理地址是柱面号盘面号扇区号而不是盘面号柱面号扇区号答读取地址连续的磁盘块时采用柱面号盘面号扇区号的地址结构可以减少磁头移动消耗的时间假设某磁盘有个柱面磁道假设最内侧柱面磁道号为个盘面个扇区则可用个二进制位表示柱面个二进制位表示盘面个二进制位表示扇区若物理地址结构是盘面号柱面号扇区号且需要连续读取物理地址的扇区转两圈可读完之后再读取物理地址相邻的区域即需要启动磁头臂将磁头移动到下一个磁道若物理地址结构是柱面号盘面号扇区号且需要连续读取物理地址的扇区由盘面的磁头读入数据之后再读取物理地址相邻的区域即由于柱面号磁道号相同只是盘面号不同两者的区别就是如果是连续存储的话第一种编址方式是存满一个盘面之后再存放下一个盘面第二种编址方式是存完这个盘面的这个柱面之后在存放下一个盘面相同位置的柱面减少延迟时间的方法错位命名方案一若相邻的盘面相对位置相同处扇区编号相同如果不采用错位命名的话就会呈现下面这种情况号盘面的号扇区对应着一号盘面的号扇区如果我们读取的是这时候我们经过了号页面的两圈旋转这时候应该访问但是这时候一号的盘面的指针需要休息这时候我们不能够读取该位置的数据需要从新转一圈之后才能读取这样会大大延长读取时间注意所有盘面都是一起连轴转的读取完磁盘块之后需要短暂的时间处理而盘面又在不停地转动因此当第一次划过号盘面的磁头下方时并不能读取数据只能再等该扇区再次划过磁头方案二错位命名由于采用错位命名法因此读取完磁盘块之后还有一段时间处理当第一次划过号盘面的磁头下方时就可以直接读取数据从而减少了延迟时间磁盘的管理磁盘初始化磁盘初始化进行低级格式化物理格式化将磁盘的各个磁道划分为扇区一个扇区通常可分为头数据区域如大小尾三个部分组成管理扇区所需要的各种数据结构般存放在头尾两个部分包括扇区校验码如奇偶校验循环冗余校验码等校验码用于校验扇区中的数据是否发生错误将磁盘分区每个分区由若干柱面组成即分为我们熟悉的盘盘盘进行逻辑格式化创建文件系统包括创建文件系统的根目录初始化存储空间管理所用的数据结构如位示图空闲分区表引导块计算机开机时需要进行一系列初始化的工作这些初始化工作是通过执行初始化程序自举程序完成的初始化程序可以放在只读存储器中中的数据在出厂时就写入了并且以后不能再修改注般是出厂时就集成在主板上的初始化程序程序自举程序放在中存在什么问题万一需要更新自举程序将会很不方便因为中的数据无法更改如何解决呢采用自举装入程序中只存放很小的自举装入程序开机时计算机先运行自举装入程序通过执行该程序就可找到引导块并将完整的自举程序读入内存完成初始化完整的自举程序放在磁盘的启动块即引导块启动分区上启动块位于磁盘的固定位置拥有启动分区的磁盘称为启动磁盘或系统磁盘盘坏块的管理坏了无法正常使用的扇区就是坏块这属于硬件故障操作系统是无法修复的应该将坏块标记出来以免错误地使用到它对于简单的磁盘可以在逻辑格式化时建立文件系统时对整个磁盘进行坏块检查标明哪些扇区是坏扇区比如在表上标明在这种方式中坏块对操作系统不透明对于复杂的磁盘磁盘控制器磁盘设备内部的一个硬件部件会维护一个坏块链表在磁盘出厂前进行低级格式化物理格式化时就将坏块链进行初始化会保留一些备用扇区用于替换坏块这种方案称为扇区备用且这种处理方式中坏块对操作系统透明操作系统第五章设备的概念和分类的概念就是输入输出设备就是可以将数据输入到计算机或者可以接收计算机输出数据的外部设备属于计算机中的硬件部件操作向外部设备写出数据操作从外部设备读入数据设备分类按使用特性分类人机交互类外部设备数据速度传输慢鼠标键盘打印机等一一用于人机交互存储设备数据传输块移动硬盘光盘等一一用于数据存储网络设备通讯数据传输速度介于上述两者之间调制解调器等一一用于网络通信设备分类按传输速率分配低速设备鼠标键盘一一传输速率为每秒几个到几百字节中速设备如激光打印机等一一传输速率为每秒数千至上万个字节高速设备如磁盘等一一传输速率为每秒数千字节至千兆字节的设备设备分类按信息交换的单位分类块设备如磁盘等一一数据传输的基本单位是块传输速率较高可寻址即对它可随机地读写任一块字符设备鼠标键盘等一一数据传输的基本单位是字符传输速率较慢不可寻址在输入输出时常采用中断驱动方式控制器机械部件设备的机械部件主要用来执行具体操作如我们看得见摸得着的鼠标键盘的按钮显示器的屏移动硬盘的磁臂磁盘盘面设备的电子部件通常是一块插入主板扩充槽的印刷电路板电子部件无法直接控制设备的机械部件因此设备还要有一个电子部件作为和设备机械部件之间的中介用于实现对设备的控制这个电子部件就是控制器又称设备控制器可控制控制器又由控制器来控制设备的机械部件控制器的功能接受和识别发出的命令如发来的命令控制器中会有相应的控制寄存器来存放命令和参数向报告设备的状态控制器中会有相应的状态寄存器用于记录设备的当前状态如表示空闲表示忙碌数据交换控制器中会设置相应的数据寄存器输出时数据寄存器用于暂存发来的数据之后再由控制器传送设备输入时数据寄存器用于暂存设备发来的数据之后从数据寄存器中取走数据地址识别类似于内存的地址为了区分设备控制器中的各个寄存器也需要给各个寄存器设置一个特定的地址控制器通过提供的地址来判断要读写的是哪个寄存器控制器的组成与控制器的接口用于实现与控制器之间的通信通过控制线发出命令通过地址线指明要操作的设备通过数据线来取出输入数据或放入输出数据逻辑负责接收和识别的各种命令如地址译码并负责对设备发出命令控制器与设备的接口用于实现控制器与设备之间的通信值得注意的小细节一个控制器可能会对应多个设备数据寄存器控制寄存器状态寄存器可能有多个如每个控制状态寄存器对应一个具体的设备且这些寄存器都要有相应的地址才能方便操作有的计算机会让这些寄存器占用内存地址的一部分称为内存映像另一些计算机则采用专用地址即寄存器独立编址内存映像和寄存器独立编址内存映射控制器中的寄存器与内存地址统一编址优点简化了指令可以采用对内存进行操作的指令来对控制器进行操作寄存器独立编制控制器中的寄存器使用单独的地址缺点需要设置专门的指令来实现对控制器的操作不仅要指明寄存器的地址还要指明控制器的编号控制方式分为四种程序直接控制方式中断驱动方式方式通道控制方式需要注意的问题完成一次读写操作的流程干预的频率数据传送的单位数据的流向主要缺点和主要优点程序直接控制方式向控制器发出读指令于是设备启动并且状态寄存器设为未就绪轮询检查控制器的状态其实就是在不断地执行程序的循环若状态位一直是说明设备还没准备好要输入的数据于是会不断地轮询输入设备准备好数据后将数据传给控制器并报告自身状态控制器将输入的数据放到数据寄存器中并将状态改为已就绪发现设备已就绪即可将数据寄存器中的内容读入的寄存器中再把寄存器中的内容放入内存若还要继续读入数据则继续发出读指令详细信息完成一次读写操作的流程见右图轮询干预的频率很频繁操作开始之前完成之后需要介入并且在等待完成的过程中需要不断地轮询检查数据传送的单位每次读写一个字数据的流向读操作数据输入设备寄存器内存写操作数据输出内存设备每个字的读写都需要的帮助主要缺点和主要优点优点实现简单在读写指令之后加上实现循环检查的一系列指令即可因此才称为程序直接控制方式缺点和设备只能串行工作需要一直轮询检查长期处于忙等状态利用率低中断驱动方式引入中断机制由于设备速度很慢因此在发出读写命令后可将等待的进程阻塞先切换到别的进程执行当完成后控制器会向发出一个中断信号检测到中断信号后会保存当前进程的运行环境信息转去执行中断处理程序处理该中断处理中断的过程中从控制器读一个字的数据传送到寄存器再写入主存接着恢复等待的进程或其他进程的运行环境然后继续执行注意会在每个指令周期的末尾检查中断中断处理过程中需要保存恢复进程的运行环境这个过程是需要一定时间开销的可见如果中断发生的频率太高也会降低系统性能完成一次读写操作的流程见上图中断干预的频率每次操作开始之前完成之后需要介入在等待完成的过程中可以切换到别的进程执行数据传送的单位每次读写一个字数据的流向读操作数据输入设备内存写操作数据输出内存设备主要缺点和主要优点优点与程序直接控制方式相比在中断驱动方式中控制器会通过中断信号主动报告已完成不再需要不停地轮询和设备可并行工作利用率得到明显提升缺点每个字在设备与内存之间的传输都需要经过而频繁的中断处理会消耗较多的时间方式数据寄存器暂存从设备到内存或从内存到设备的数据内存地址寄存器在输入时表示数据应放到内存中的什么位置输出时表示要输出的数据放在内存中的什么位置数据计数器表示剩余要读写的字节数命令状态寄存器用于存放发来的命令或设备的状态信息虽然宏观上是一块一块的读入但是在微观上还是一个字节一个字节的进行读入的读入的字节现在放在中然后通过放到内存中完成一次读写操作的流程见右图干预的频率仅在传送一个或多个数据块的开始和结束时才需要千预数据传送的单位每次读写一个或多个块注意每次读写的只能是连续的多个块如果不是连续的话我们需要给出多条指令数据的流向不再需要经过读操作数据输入设备内存写操作数据输出内存设备主要缺点和主要优点优点数据传输以块为单位介入频率进一步降低数据的传输不再需要先经过再写入内存数据传输效率进一步增加和设备的并行性得到提升缺点每发出一条指令只能读写一个或多个连续的数据块通道控制方式通道一种硬件可以理解为是弱鸡版的通道可以识别并执行一系列通道指令与相比通道可以执行的指令很单一并且通道程序是放在主机内存中的也就是说通道与共享内存向通道发出指令指明通道程序在内存中的位置并指明要操作的是哪个设备之后就切换到其他进程执行了通道执行内存中的通道程序其中指明了要读入写出多少数据读写的数据应放在内存的什么位置等信息通道执行完规定的任务后向发出中断信号之后对中断进行处理完成一次读写操作的流程见右图干预的频率极低通道会根据的指示执行相应的通道程序只有完成一组数据块的读写后才需要发出中断信号请求干预数据传送的单位每次读写一组数据块数据的流向在通道的控制下进行读操作数据输入设备内存写操作数据输出内存设备软件层次结构软件层次结构用户层软件设备独立性软件设备驱动程序中断处理程序硬件越上面的层次越接近用户越下面的层次越接近硬件每一层会利用其下层提供的服务实现某些功能并屏蔽实现的具体细节向高层提供服务封装思想用户层软件用户层软件实现了与用户交互的接口用户可直接使用该层提供的与操作相关的库函数对设备进行操作用户层软件将用户请求翻译成格式化的请求并通过系统调用请求操作系统内核的服务会被翻译成等价的系统调用当然用户层软件也会在系统调用时填入相应参数操作系统向外提供的一系列系统调用但是由于系统调用的格式严格使用麻烦因此在用户层上封装了一系列更方便的库函数接口供用户使用设备独立性软件设备独立性软件又称设备无关性软件与设备的硬件特性无关的功能几乎都在这一层实现主要实现功能向上层提供统一的调用接口如系统调用设备的保护原理类似与文件保护设备被看做是一种特殊的文件不同用户对各个文件的访问权限是不一样的同理对设备的访问权限也不一样差错处理设备独立性软件需要对一些设备的错误进行处理设备的分配与回收数据的缓冲与管理可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异建立逻辑设备名到物理设备名的映射关系根据设备类型选择调用相应的驱动程序用户或用户层软件发出操作相关系统调用的系统调用时需要指明此次要操作的设备的逻辑设备名去学校打印店打印时需要选择打印机打印机打印机其实这些都是逻辑设备名其中设备独立性软件需要通过逻辑设备表来确定逻辑设备对应的物理设备并找到该设备对应的设备驱动程序设备被当做一种特殊的文件不同类型的设备需要有不同的驱动程序处理操作系统系统可以采用两种方式管理逻辑设备表第一种方式整个系统只设置一张这就意味着所有用户不能使用相同的逻辑设备名因此这种方式只适用于单用户操作系统第二种方式为每个用户设置一张各个用户使用的逻辑设备名可以重复适用于多用户操作系统系统会在用户登录时为其建立一个用户管理进程而就存放在用户管理进程的中为什么不同的设备需要不同的设备驱动程序答不同设备的内部硬件特性也不同这些特性只有厂家才知道因此厂家须提供与设备相对应的驱动程序执行驱动程序的揩令序列来完成设置设备寄存器检查设备状态等工作设备驱动程序主要负责对硬件设备的具体控制将上层发出的一系列命令如转化成特定设备能听得懂的一系列操作包括设置设备寄存器检查设备状态等不同的设备有不同的硬件特性具体细节只有设备的厂家才知道因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序驱动程序一般会以一个独立进程的方式存在设备驱动程序会直接和硬件打交道中断处理程序当任务完成时控制器会发送一个中断信号系统会根据中断信号类型找到相应的中断处理程序并执行中断处理程序的处理流程如下中断处理程序也会直接的和硬件打交道理解并记住软件各个层次之间的顺序要能够推理判断某个处理应该是在哪个层次完成的最常考的是设备独立性软件设备驱动程序这两层只需理解一个特点即可直接涉及到硬件具体细节且与中断无关的操作肯定是在设备驱动程序层完成的没有涉及硬件的对各种设备都需要进行的管理工作都是在设备独立性软件层完成的核心子系统核心子系统实现的功能主要是上面讲的设备独立性软件设备驱动软件中断处理程序这三层实现的功能调度调度用某种算法确定一个好的顺序来处理各个请求如磁盘调度先来先服务算法最短寻道优先算法算法算法算法算法当多个磁盘请求到来时用某种调度算法确定满足请求的顺序同理打印机等设备也可以用先来先服务算法优先级算法短作业优先等算法来确定调度顺序设备保护操作系统需要实现文件保护功能不同的用户对各个文件有不同的访问权限如只读读和写等在系统中设备被看做是一种特殊的文件每个设备也会有对应的当用户请求访问某个设备时系统根据中记录的信息来判断该用户是否有相应的访问权限以此实现设备保护的功能参考文件保护小节假脱机技术技术什么是脱机技术手工操作阶段主机直接从设备获得数据由于设备速度慢主机速度很快人机速度矛盾明显主机要浪费很多时间来等待设备批处理阶段引入了脱机输入输出技术用磁带完成引入脱机技术后缓解了与慢速设备的速度矛盾另一方面即使在忙碌也可以提前将数据输入到磁带即使慢速的输出设备正在忙碌也可以提前将数据输出到磁带在外围控制机的控制下慢速输入设备的数据先被输入到更快速的磁带上之后主机可以从快速的磁带上读入数据从而缓解了速度矛盾为什么称为脱机脱离主机的控制进行的输入输出操作假脱机技术输入输出缓冲区假脱机技术又称技术是用软件的方式模拟脱机技术系统的组成如下要实现技术必须要有多道程序技术的支持系统会建立输入进程和输出进程在磁盘上开辟出两个存储区域一一输入井和输出井输入井模拟脱机输入时的磁带用于收容设备输入的数据输出井模拟脱机输出时的磁带用于收容用户进程输出的数据输入进程模拟脱机输入时的外围控制机输出进程模拟脱机输出时的外围控制机注意输入缓冲区和输出缓冲区是在内存中的缓冲区在输入进程的控制下输入缓冲区用于暂存从输入设备输入的数据之后再转存到输入井中在输出进程的控制下输出缓冲区用于暂存从输出井送来的数据之后再传送到输出设备上共享打印机原理分析独占式设备一一只允许各个进程串行使用的设备一段时间内只能满足一个进程的请求共享设备一一允许多个进程同时使用的设备宏观上同时使用微观上可能是交替使用可以同时满足多个进程的使用请求独占式设备的例子若进程正在使用打印机则进程请求使用打印机时必然阻塞等待使用假脱机技术来让打印机实现共享假脱机文件队列其实就是打印任务队列当多个用户进程提出输出打印的请求时系统会答应它们的请求但是并不是真正把打印机分配给他们而是由假脱机管理进程为每个进程做两件事在磁盘输出井中为进程申请一个空闲缓冲区也就是说这个缓冲区是在磁盘上的并将要打印的数据送入其中为用户进程申请一张空白的打印请求表并将用户的打印请求填入表中其实就是用来说明用户的打印数据存放位置等信息的再将该表挂到假脱机文件队列上当打印机空闲时输出进程会从文件队列的队头取出一张打印请求表并根据表中的要求将要打印的数据从输出井传送到输出缓冲区再输出到打印机进行打印用这种方式可依次处理完全部的打印任务虽然系统中只有一个台打印机但每个进程提出打印请求时系统都会为在输出井中为其分配一个存储区相当于分配了一个逻辑设备使每个用户进程都觉得自己在独占一台打印机从而实现对打印机的共享技术可以把一台物理设备虚拟成逻辑上的多台设备可将独占式设备改造成共享设备设备的分配与回收设备分配时应考虑的因素设备的固有属性设备的固有属性可分为三种独占设备共享设备虚拟设备独占设备一一一个时段只能分配给一个进程如打印机共享设备一一可同时分配给多个进程使用如磁盘各进程往往是宏观上同时共享使用设备而微观上交替使用虚拟设备一一采用技术将独占设备改造成虚拟的共享设备可同时分配给多个进程使用如采用技术实现的共享打印机设备分配算法先来先服务优先级高者优先短任务优先设备分配中的安全性从进程运行的安全性上考虑设备分配有两种方式安全分配方式为进程分配一个设备后就将进程阻塞本次完成后才将进程唤醒考虑进程请求打印机打印输出的例子一个时段内每个进程只能使用一个设备优点破坏了请求和保持条件不会死锁缺点对于一个进程来说和设备只能串行工作不安全分配方式进程发出请求后系统为其分配设备进程可继续执行之后还可以发出新的请求只有某个请求得不到满足时才将进程阻塞一个进程可以同时使用多个设备优点进程的计算任务和任务可以并行处理使进程迅速推进缺点有可能发生死锁死锁避免死锁的检测和解除静态分配与动态分配静态分配进程运行前为其分配全部所需资源运行结束后归还资源动态分配进程运行过程中动态申请设备资源设备分配管理中的数据结构设备控制器通道之间的关系一个通道可控制多个设备控制器每个设备控制器可控制多个设备设备控制表设备控制表系统为每个设备配置一张用于记录设备情况设备类型如打印机扫描仪键盘设备标识符即物理设备名系统中的每个设备的物理设备名唯一设备状态忙碌空闲故障指向控制器表的指针每个设备由一个控制器控制该指针可找到相应控制器的信息重复执行次数或时间当重复执行多次操作后仍不成功才认为此次失败设备队列的队首指针指向正在等待该设备的进程队列由进程组成队列系统会根据阻塞原因不同将进程挂到不同的阻塞队列中控制器控制表通道标识符各个通道的唯一通道状态忙碌空闲故障与通道连接的控制器表首址可通过该指针找到该通道管理的所有控制器相关信息通道队列的队首指针通道队列的队尾指针指向正在等待该通道的进程队列由进程组成队列系统设备表系统设备表记录了系统中全部设备的情况每个设备对应一个表目设备分配的步骤根据进程请求的物理设备名查找注物理设备名是进程请求分配设备时提供的参数根据找到若设备忙碌则将进程挂到设备等待队列中不忙碌则将设备分配给进程根据找到若控制器忙碌则将进程挂到控制器等待队列中不忙碌则将控制器分配给进程根据找到若通道忙碌则将进程挂到通道等待队列中不忙碌则将通道分配给进程缺点用户编程时必须使用物理设备名底层细节对用户不透明不方便编程若换了一个物理设备则程序无法运行若进程请求的物理设备正在忙碌则即使系统中还有同类型的设备进程也必须阻塞等待设备分配步骤的改进方法改进方法建立逻辑设备名与物理设备名的映射机制用户编程时只需提供逻辑设备名根据进程请求的逻辑设备名查找注用户编程时提供的逻辑设备名其实就是设备类型查找找到用户进程指定类型的并且空闲的设备将其分配给该进程操作系统在逻辑设备表中新增一个表项根据找到若控制器忙碌则将进程挂到控制器等待队列中不忙碌则将控制器分配给进程根据找到若通道忙碌则将进程挂到通道等待队列中不忙碌则将通道分配给进程逻辑设备表建立了逻辑设备名与物理设备名之间的映射关系某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求操作系统根据用户进程指定的设备类型逻辑设备名查找系统设备表找到一个空闲设备分配给进程并在中增加相应表项如果之后用户进程再次通过相同的逻辑设备名请求使用设备逻辑设备表的设置问题整个系统只有一张各用户所用的逻辑设备名不允许重复适用于单用户操作系统每个用户一张不同用户的逻辑设备名可重复适用于多用户操作系统缓冲区管理什么是缓冲区有什么作用缓冲区是一个存储区域可以由专门的硬件寄存器组成也可利用内存作为缓冲区使用硬件作为缓冲区的成本较高容量也较小一般仅用在对速度要求非常高的场合如存储器管理中所用的联想寄存器由于对页表的访问频率极高因此使用速度很快的联想寄存器来存放页表项的副本一般情况下更多的是利用内存作为缓冲区设备独立性软件的缓冲区管理就是要组织管理好这些缓冲区缓冲区的作用缓和与设备之间速度不匹配的矛盾减少对的中断频率放宽对中断相应时间的限制解决数据粒度不匹配的问题提高与设备之间的并行性可以把要输出的数据快速地放入缓冲区慢速的设备可以慢慢从缓冲区取走数据解决了和设备之间速度不匹配问题如果不采用缓冲区的话如果是字符型设备则每输出完一个字符就要向发送一次中断信号可以减少的中断频率输出进程每次可以生成一块数据但设备每次只能输出一个字符使用缓冲区的话可以很好的解决证问题等设备向缓冲区中输入的数据满了之后在读取一整块内容解决了数据粒度不匹配问题单缓冲假设某用户进程请求某种块设备读入若干块的数据若采用单缓冲的策略操作系统会在主存中为其分配一个缓冲区若题目中没有特别说明一个缓冲区的大小就是一个块注意当缓冲区数据非空时不能往缓冲区冲入数据只能从缓冲区把数据传出当缓冲区为空时可以往缓冲区冲入数据但必须把缓冲区充满以后才能从缓冲区把数据传出常考题型计算每处理一块数据平均需要多久技巧假定一个初始状态这就是处理一块数据平均所需时间在单缓冲题型中可以假设初始状态为工作区满缓冲区空双缓冲假设某用户进程请求某种块设备读入若干块的数据若采用双缓冲的策略操作系统会在主存中为其分配两个缓冲区若题目中没有特别说明一个缓冲区的大小就是一个块双缓冲题目中假设初始状态为工作区空其中一个缓冲区满另一个缓冲区空假设假设',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-20 22:40:11',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.1.1"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://s1.ax1x.com/2022/11/27/zUFla6.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://262259.xyz/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" href="https://262259.xyz/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">管理</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://qexo.262259.xyz/" title="博客后端"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://unpkg.com/qexo-static@1.4.0/assets/img/brand/qexo.png" alt="博客后端"/><span class="back-menu-item-text">博客后端</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Nuyoah</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://s2.loli.net/2022/08/16/weL31EHsON5ldDU.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/08/16/weL31EHsON5ldDU.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/08/16/2yRjVx9gFKQaidA.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/08/16/2yRjVx9gFKQaidA.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Gitee/" style="font-size: 1.05rem;">Gitee<sup>1</sup></a><a href="/tags/JAVA/" style="font-size: 1.05rem; font-weight: 500; color: var(--anzhiyu-lighttext)">JAVA<sup>5</sup></a><a href="/tags/JS/" style="font-size: 1.05rem;">JS<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>1</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>7</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>2</sup></a><a href="/tags/hexo/" style="font-size: 1.05rem;">hexo<sup>4</sup></a><a href="/tags/win10/" style="font-size: 1.05rem;">win10<sup>1</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/" style="font-size: 1.05rem;">个人日记<sup>1</sup></a><a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 1.05rem;">人工智能<sup>15</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%BA%8E%E9%80%BB%E8%BE%91/" style="font-size: 1.05rem;">数字电路于逻辑<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" style="font-size: 1.05rem;">算法实现<sup>12</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">计算机基础<sup>13</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/01/"><span class="card-archive-list-date">一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/12/"><span class="card-archive-list-date">十二月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url">计算机基础</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>计算机基础</span></a></span></div></div><h1 class="post-title" itemprop="name headline">操作系统教程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-08-22T00:52:14.000Z" title="发表于 2022-08-22 08:52:14">2022-08-22</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-02-20T14:40:11.406Z" title="更新于 2023-02-20 22:40:11">2023-02-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">71.5k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>215分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为石家庄"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>石家庄</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://s2.loli.net/2022/11/21/aDwOWz8tq3yJ1Yb.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://262259.xyz/2022/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><header><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url">计算机基础</a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" tabindex="-1" itemprop="url">计算机基础</a><h1 id="CrawlerTitle" itemprop="name headline">操作系统教程</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Nuyoah</span><time itemprop="dateCreated datePublished" datetime="2022-08-22T00:52:14.000Z" title="发表于 2022-08-22 08:52:14">2022-08-22</time><time itemprop="dateCreated datePublished" datetime="2023-02-20T14:40:11.406Z" title="更新于 2023-02-20 22:40:11">2023-02-20</time></header><h1 id="操作系统第一章初试操作系统"><a class="markdownIt-Anchor" href="#操作系统第一章初试操作系统"></a> 操作系统第一章：初试操作系统</h1>
<h2 id="操作系统的概念功能和目标"><a class="markdownIt-Anchor" href="#操作系统的概念功能和目标"></a> 操作系统的概念，功能和目标</h2>
<div class="tip "><p>操作系统的概念：</p>
</div>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/vdAPN3YofsbWraL.png" alt="image-20220822090300922"  />
<mark class="hl-label red">应用程序如:</mark> QQ，IE浏览器，英雄联盟...
<mark class="hl-label red">操作系统的功能:</mark> 
<ol>
<li>负责管理协调硬件、软件等计算机资源的工作</li>
<li>为上层的应用程序、用户提供简单易用的服务</li>
<li>操作系统是<span class='p green'>系统软件</span>，而不是硬件</li>
</ol>
<mark class="hl-label red">裸机（纯硬件）:</mark> 如CPU，硬盘， 内存
<div class="tip success"><p>操作系统的定义：</p>
</div>
<p>操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p>
<div class="tip "><p>操作系统的功能和目标：</p>
</div>
<p>①操作系统作为系统资源的管理者（这些资源包括软件、硬件、文件等)，需要提供什么功能?</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/FE8UHOjVYKMPSgc.png" alt="image-20220822091924490.png" /></p>
<p>用QQ和朋友视频聊天的过程:<br />
Step 1:在各个文件夹中找到QQ安装的位置（如D:/Tencent/QQ/bin）逐层打开文件夹，找到QQ.exe这个程序（可执行文件）的存<br />
放位置， <mark class="hl-label default">文件管理</mark> </p>
<p>Step 2:双击打开QQ.exe 	需要把改程序相关数据放入内存  <mark class="hl-label default">存储器管理</mark> </p>
<p>Step 3: QQ程序正常运行	对应的进程被处理机（CPU）处理  <mark class="hl-label default">处理机管理</mark> </p>
<p>Step 4:开始和朋友视频聊天	 需要将摄像头设备分配给进程  <mark class="hl-label default">设备管理</mark> </p>
<p>②操作系统作为用户与计算机硬件之间的接口，要为其上层的用户、应用程序提供简单易用的服务，需要实现什么功能?</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/Y6pR7nUC5fhzNou.png" alt="image-20220822092519193.png" /></p>
<p>命令接口:允许用户<span class='p red'>直接使用</span></p>
<ol>
<li>联机命令接口：用户说一句，系统做一句， <mark class="hl-label default">交互式</mark> 命令接口</li>
<li>脱机命令接口：用户说一堆，系统做一堆，<mark class="hl-label default">批处理</mark> 命令接口</li>
</ol>
<p>程序接口:允许用户通过程序<span class='p red'>间接使用</span>	：由一组系统调用组成（程序接口 = 系统调用）只能通过用户程序<span class='p red'>间接</span>使用， 系统调用 = 系统调用命令 = 广义指令</p>
<p>GUI:现代操作系统中最流行的图形用户接口</p>
<p>所有提供给用户的接口可以统称为<mark class="hl-label default">用户接口</mark> </p>
<p>③操作系统作为最接近硬件的层次，需要在纯硬件的基础上实现什么功能?</p>
<p>需要提供的功能和目标:实现对硬件机器的拓展</p>
<p>没有任何软件支持的计算机成为<span class='p red'>裸机</span>。在裸机上安装的操作系统,可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器</p>
<p>通常把覆盖了软件的机器成为<span class='p red'>扩充机器</span>，又称之为<span class='p red'>虚拟机</span></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/sZqTU8eAlmvC9OX.png" alt="image-20220823092909040" /></p>
<h2 id="操作系统的特征"><a class="markdownIt-Anchor" href="#操作系统的特征"></a> 操作系统的特征</h2>
<p>操作系统的特征包括<mark class="hl-label default">并发，共享，虚拟，异步</mark> 这四个特征，其中 <span class='p red'>并发和共享</span>是两个最基本的特征，二者互为存在条件</p>
<div class="tip "><p>并发：</p>
</div>
<p>其中<mark class="hl-label default">并发：</mark> 指两个或多个事件在同一时间间隔内发生。这些事件<mark class="hl-label default">宏观上是同时发生的</mark> ，但<mark class="hl-label orange">微观上是交替发生的</mark>  。常考易混概念一一<span class='p red'>并行</span>:指两个或多个事件在同一时刻同时发生。</p>
<span class='p red'>操作系统的并发性：</span>，指计算机系统中同时存在着多个运行着的程序
<p>一个单核处理器（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但是在宏观上是同时执行的）</p>
<p>事实上，操作系统是伴随着“多道程序技术”而出现的。<mark class="hl-label default">因此操作系统和程序并发是一起出现的</mark> </p>
<p>当今的计算机，一般都是多核CPU，比如Intel的第八代i3处理器就是<span class='p red'>4核</span>CPU这意味着同一时刻可以有4个程序<span class='p red'>并行</span> 执行，但是操作系统的<span class='p red'>并发性依然必不可少</span> 当代人使用计算机绝对有4个以上的程序需要同时工作。</p>
<div class="tip "><p>共享：</p>
</div>
<mark class="hl-label default">共享</mark> 即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用
<p>两种资源共享方式：</p>
<div class="tabs" id="两种资源共享方式"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="两种资源共享方式-1">互斥共享方式</button><button type="button" class="tab " data-href="两种资源共享方式-2">同时共享方式</button></ul><div class="tab-contents"><div class="tab-item-content active" id="两种资源共享方式-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统中的某些资源，虽然可以提供个多个进程使用。但是一个时间段内只允许一个进程访问该资源 </span><br><span class="line"></span><br><span class="line">例子：使用QQ和微信进行视频的时候，同一时间段内摄像头只能分配给其中一个进程</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="两种资源共享方式-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">系统中的某些资源，&#123;%label 允许一个时间段内由多个进程“同时”对他进行访问 red %&#125;</span><br><span class="line"></span><br><span class="line">所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替的对该资源进行访问（即分时共享）</span><br><span class="line"></span><br><span class="line">同时共享方式:使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件,说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<mark class="hl-label red">并发性</mark> 指计算机系统中同时存在着多个运行着的程序。
<mark class="hl-label red">共享性</mark> 是指系统中的资源可供内存中多个并发执行的进程共同使用。
<p>通过上述例子来看并发与共享的关系:</p>
<p>使用QQ发送文件A，同时使用微信发送文件B。</p>
<div class="tabs" id="并发性与共享性"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="并发性与共享性-1">并发性</button><button type="button" class="tab " data-href="并发性与共享性-2">共享性</button></ul><div class="tab-contents"><div class="tab-item-content active" id="并发性与共享性-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两个进程正在并发执行</span><br><span class="line">如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义，共享性就是让多个进程“同时”对它进行访问，但是如果失去并发性的话，又何来多个进程同时存在哪</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="并发性与共享性-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要共享地访问硬盘资源</span><br><span class="line">如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发，既然不能同时访问这个文件，那么同一时间只能有一个进程在运作，所以也就有了并发性</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<div class="tip "><p>虚拟</p>
</div>
<p>这里说明<mark class="hl-label red">虚拟</mark> 是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。例如一个单核CPU可以同时开很多个文件，这给我们的感觉就是看起来是有多个CPU同时在为我进行服务，这时候就用到了虚拟技术虚拟技术中的“时分复用技术”。微观上处理机在各个微小的时间段内交替着为各个进程服务</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/vxDY36nhOAwo7Zg.png" alt="image-20220823110521258" /></p>
<p>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了因此，<mark class="hl-label red">没有并发性，就谈不上虚拟性</mark> 。</p>
<div class="tip "><p>异步</p>
</div>
<p>其中<span class='p red'>异步是指</span>，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的,而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>显然，如果失去了异步性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。<mark class="hl-label red">只有系统拥有并发性，才有可能导以异步性</mark> .</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/qVBnrzXAwSLDjNt.png" alt="image-20220917224826732.png" /></p>
<h2 id="操作系统的发展和分类"><a class="markdownIt-Anchor" href="#操作系统的发展和分类"></a> 操作系统的发展和分类</h2>
<div class="tip "><p>手工操作阶段</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/xmyKAG6Qpti9Hbq.png" alt="image-20220823113156786.png" /></p>
<p>手工操作阶段，每一个程序员都需要把自己写的程序用二进制写在纸带上，然后通过纸带机传递给计算机，等待计算机运算完毕之后，再由纸带机将纸带返回回来，纸带上的二进制就是计算机计算完之后的结果</p>
<p>手工操作阶段：</p>
<mark class="hl-label red">主要缺点</mark> ：用户独占全机（就是每一个机器同时只能为一个人服务），人机速度矛盾导致资源利用率极低
<div class="tip "><p>批处理阶段</p>
</div>
<div class="tabs" id="批处理阶段"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="批处理阶段-1">单道批处理系统</button><button type="button" class="tab " data-href="批处理阶段-2">多道批处理系统</button></ul><div class="tab-contents"><div class="tab-item-content active" id="批处理阶段-1"><p>引入<mark class="hl-label red">脱机输入/输出技术</mark> （用磁带完成）， 并<mark class="hl-label red">监督程序</mark> （操作系统的雏形）负责控制作业的输入和输出</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/e21TDFOswLSgAfm.png" alt="image-20220823115549811" /></p>
<p>单道批处理系统引入了一个外围机，CPU从外围机中读取数据，要比从人工哪读取数据快的多，并且这里可以支持多人共同使用这个机器</p>
<p>单道批处理系统</p>
<p>主要优点:缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p>
<p>主要缺点:<mark class="hl-label red">内存中仅能有一道程序运行</mark>  ，只有该程序运行结束之后才能调入下一道程序。<mark class="hl-label green">CPU有大量的时间是在空闲等待I/O完成。</mark>  资源利用率依然很低.</p></div><div class="tab-item-content" id="批处理阶段-2"><p><mark class="hl-label red">操作系统开始出现</mark></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/wcQBP7fh6rjR2nJ.png" alt="image-20220823120110753" /></p>
<p>多道批处理系统:</p>
<p>主要优点:多道程序<span class='p red'>并发执行</span> ，<span class='p green'>共享</span> 计算机资源。<span class='p red'>资源利用率大幅提升</span>，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</p>
<p>主要缺点:用户响应时间长，<span class='p red'>没有人机交互功能</span>（用户提交自己的作业之后就只能等待计算机处理完成.中间不能控制自己的作业执行)</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<p>为什么多道批处理系统能使资源利用率大幅度提升？</p>
<p>假设计算机需要处理三个作业</p>
<p>作业一:输入1秒，计算1秒，输出1秒</p>
<p>作业二:输入1秒，计算1秒，输出1秒</p>
<p>作业三:输入1秒，计算1秒，输出1秒</p>
<div class="tabs" id="单多道批处理技术"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="单多道批处理技术-1">单道批处理技术</button><button type="button" class="tab " data-href="单多道批处理技术-2">多道批处理系统</button></ul><div class="tab-contents"><div class="tab-item-content active" id="单多道批处理技术-1"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/aNcHdxMposlX4yY.png" alt="image-20220823121512359" /></p></div><div class="tab-item-content" id="单多道批处理技术-2"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/imFzCuK3VYkAGfT.png" alt="image-20221104161521119" /></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<div class="tip "><p>分时操作系统</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/VAf3zvKpL71hrmk.png" alt="image-20220823122116620" /></p>
<p>分时操作系统:计算机以<mark class="hl-label red">时间片</mark>  为单位<mark class="hl-label red">轮流为各个用户/作业服务</mark> ，各个用户可通过终端与计算机进行交互。</p>
<p>主要优点:用户请求可以被即时响应，<mark class="hl-label red">解决了人机交互问题</mark> 。 允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p>
<p>主要缺点:<mark class="hl-label red">不能优先处理一些紧急任务</mark> 。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</p>
<div class="tip "><p>实时操作系统</p>
</div>
<p>实时操作系统:</p>
<p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</p>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<span class='p red'>要在严格的时限内处理完事件</span>。实时操作系统的主要特点是<span class='p red'>及时性和可靠性</span></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/RdLJPltc3IyvME6.png" alt="image-20220823122614279" /></p>
<div class="tip "><p>网络操作系统</p>
</div>
<p>网络操作系统:是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，<span class='p red'>实现数据传送等功能，实现网络中各种资源的共享(如文件共享〉和各台计算机之间的通信</span> 。(如: Windows NT就是一种典型的网络操作系统，网站服务器就可以使用)</p>
<div class="tip "><p>分布式操作系统</p>
</div>
<p>分布式操作系统:主要特点是<span class='p red'>分布性和并行性</span>。系统中的各台计算机地位相同，<span class='p red'>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。</span></p>
<div class="tip "><p>个人计算机操作系统</p>
</div>
<p>个人计算机操作系统:如 Windows XP、MacOs，方便个人使用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/KSrmU39s7lCk5QI.png" alt="image-20220917224756637" /></p>
<h2 id="操作系统的运行机制和体系结构"><a class="markdownIt-Anchor" href="#操作系统的运行机制和体系结构"></a> 操作系统的运行机制和体系结构</h2>
<p>什么是指令？指令和我们平时所接触的代码有什么区别</p>
<p>C语言代码 需要翻译为机器指令 然后CPU才能看懂</p>
<p>简单来说，“指令”就是处理器（CPU)能识别、执行的最基本命令比如:加法指令就是让CPU进行加法运算</p>
<div class="tip "><p>操作系统的两种指令</p>
</div>
<p>指令分为两种：</p>
<div class="tabs" id="操作系统的两种指令"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="操作系统的两种指令-1">特权指令</button><button type="button" class="tab " data-href="操作系统的两种指令-2">非特权指令</button></ul><div class="tab-contents"><div class="tab-item-content active" id="操作系统的两种指令-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不允许用户程序使用例如内存清零指令</span><br><span class="line"></span><br><span class="line">如果用户程序可以使用这个指令，就意味着一个用户可以将其他用户的内存数据随意清零，这样做显然是很危险的。</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="操作系统的两种指令-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如普通的运算指令，能够让用户使用</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<div class="tip "><p>CPU的两种形态</p>
</div>
<p>CPU如何判断当前是否可以执行特权指令</p>
<p>这就引出CPU两种处理状态</p>
<p>用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状<br />
态。如0为用户态，1为核心态</p>
<div class="tabs" id="cpu两种处理状态"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="cpu两种处理状态-1">用户态（目态）</button><button type="button" class="tab " data-href="cpu两种处理状态-2">核心态（管态）</button></ul><div class="tab-contents"><div class="tab-item-content active" id="cpu两种处理状态-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当CPU处于这种形态的时候，表明CPU这时候只能执行非特权指令</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="cpu两种处理状态-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当CPU处于这种形态的时候，表明CPU这时候特权指令和非特权指令都可以执行</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<div class="tip "><p>程序的两种方式</p>
</div>
<p>有些程序需要执行特权指令，有些程序需要执行非特权指令，这时候程序就分为两种形态</p>
<div class="tabs" id="程序的两种方式"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="程序的两种方式-1">内核程序</button><button type="button" class="tab " data-href="程序的两种方式-2">应用程序</button></ul><div class="tab-contents"><div class="tab-item-content active" id="程序的两种方式-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作系统的内核程序是系统的管理者,既可以执行特权指令，也可以执行非特权指令，运行在核心态。</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="程序的两种方式-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<div class="tip "><p>操作系统的内核</p>
</div>
<p>操作系统中那些功能应该由内核程序实现呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/dOA2hrlPUQutzLV.png" alt="image-20220823125320071" /></p>
<ol>
<li>
<mark class="hl-label red">时钟管理：</mark>  实现计算机的计时功能，所有的进程切换和进程调度都需要使用时钟管理来辅助实现
</li>
<li>
<mark class="hl-label red">源语：</mark> 原语是一种特殊的程序。是最接近硬件的部分，这种程序的运行具有原子性。
</li>
<li>
<span class='p red'>内核</span> 是计算机上配置的底层<span class='p red'>软件</span> ，是操作系统最基本、最核心的部分。
</li>
</ol>
<p>实现操作系统内核功能的那些程序就是<span class='p red'>内核程序</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/bBIT34GRsiVD6JK.png" alt="image-20220823125646568" /></p>
<ul>
<li>
<mark class="hl-label red">内核</mark> ： 分为大内核和微内核， 大内核其中包含了对系统资源管理的功能， 而微内核中只有时钟管理，中断管理和原语
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/RYfODFMoEtzKlm7.png" alt="image-20221104161404332" /></p>
<p>操作系统的体系结构问题与企业的管理问题很相似。</p>
<ul>
<li>
<span class='p red'>内核</span>就是企业的<span class='p red'>管理层</span>，负责一些重要的工作。只有管理层才能执行<span class='p red'>特权指令</span>，普通员工只能执行<span class='p red'>非特权指令</span>。<span class='p red'>用户态、核心态</span>之间的切换相当于普通员工和管理层之间的<span class='p red'>工作交接</span>。
</li>
</ul>
<ol>
<li>
<span class='p red'>大内核</span>：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高;缺点是组织结构混乱，难以维护。
</li>
<li>
<span class='p red'>微内核</span> ：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护;缺点是效率低。
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/esofvDQXFBj5PY3.png" alt="image-20220917224721797" /></p>
<h2 id="中断和异常"><a class="markdownIt-Anchor" href="#中断和异常"></a> 中断和异常</h2>
<p>早期的计算机，在接受一堆指令的时候，等待指令处理完之后，必须经过IO处理完成之后才能彻底离开处理器。</p>
<ul>
<li>
<span class='p red'>缺点</span>：各个程序只能串行的执行，系统资源利用率低
</li>
</ul>
<p>为了解决上述问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行</p>
<ul>
<li>
<span class='p red'>本质:发生中断</span>就意味着<span class='p red'>需要操作系统介入</span>，开展管理工作。
</li>
</ul>
<div class="tip "><p>中断的概念和作用</p>
</div>
<ol>
<li>当中断发生时，CPU立即进入核心态。</li>
<li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li>
<li>对于不同的中断信号，会进行不同的处理</li>
</ol>
<p>发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。<span class='p red'>中断</span> 可以使CPU从<span class='p red'>用户态切换为核心态，使操作系统获得计算机的控制权</span>。有了中断，才能实现多道程序并发执行。</p>
<p>问：用户态、核心态之间的切换是怎么实现的?<br />
答:&quot;<span class='p red'>用户态→核心态</span> &quot;是通过<span class='p red'>中断</span>实现的。并且中断是<span class='p red'>唯一</span>途径。“<span class='p red'>核心态→用户态</span> ”的切换是通过<span class='p red'>执行一个特权指令</span>，将程序状态字(PsW)）的标志位设置为“用户态”</p>
<div class="tip "><p>中断的分类</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/fgURNsl2q46zHbA.png" alt="image-20220823154033775" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/qfjwrNngX4zCita.png" alt="image-20220823154142994" /></p>
<div class="tip "><p>外中断处理过程</p>
</div>
<p>Step 1:执行完每个指令之后，CPU都要检查当前是否有外部中断信号</p>
<p>Step 2:如果检测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSw、程序计数器PC、各种通用寄存器)</p>
<p>Step 3:根据中断信号类型转入相应的中断处理程序</p>
<p>Step 4:恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/zR9D4ZKaQSWt6mT.png" alt="image-20220829083423352" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/09/1agS6VuZEboQwAW.png" alt="image-20220917224542361" /></p>
<h2 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h2>
<div class="tip "><p>什么是系统调用，有何作用？</p>
</div>
<p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。</p>
<p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p>
<p>应用程序通过<span class='p red'>系统调用</span>请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样<span class='p red'>可以保证系统的稳定性和安全性</span>，防止用户进行非法操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/JwZ7KryVc3YoC1N.png" alt="image-20220829084914653" /></p>
<p>系统调用相关处理涉及到对系统资源的管理、对进程的控制,这些功能需要执行一些<span class='p red'>特权指令</span> 才能完成，因此<span class='p red'>系统调用</span> 的相关处理需要在<span class='p red'>核心态</span> 下进行</p>
<div class="tip "><p>系统调用与库函数的区别</p>
</div>
<table>
<thead>
<tr>
<th style="text-align:center">普通应用程序</th>
<th style="text-align:center">可以直接使用系统调用也可以使用库函数<br />有的库函数涉及系统调用，有的不涉及</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">编程语言</td>
<td style="text-align:center">向上提供库函数。有时会将系统调用封装成<br />库函数，以隐藏系统调用的一些细节，<br />使上层进行系统调用更加方便。</td>
</tr>
<tr>
<td style="text-align:center">操作系统</td>
<td style="text-align:center">向上提供系统调用</td>
</tr>
<tr>
<td style="text-align:center">裸机</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>不涉及系统调用的库函数:如的“取绝对值”的函数</p>
<p>涉及系统调用的库函数:如“创建一个新文件”的函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/poiCnmc17tJKPZ2.png" alt="image-20220829085653928" /></p>
<div class="tip "><p>系统调用背后的过程</p>
</div>
<p>传递系统调用参数→执行陷入指令（<span class='p red'>用户态</span> ）→执行系统调用相应服务程序（<span class='p red'>核心态</span>）→返回用户程序</p>
<p>注意:</p>
<ol>
<li>
<span class='p red'>陷入指令</span> 是在<span class='p red'>用户态</span>执行的，执行陷入指令之后立即引发一个<span class='p red'>内中断</span>，从而CPU<span class='p red'>进入核心态</span>。
</li>
<li>
<span class='p red'>发出系统调用请求</span>是在<span class='p red'>用户态</span>，而<span class='p red'>对系统调用的相应处理</span>在<span class='p red'>核心态下</span>进行
</li>
<li>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/UaglSIRqsoyAzTd.png" alt="image-20220917224642082" /></p>
<h1 id="操作系统第二章进程管理"><a class="markdownIt-Anchor" href="#操作系统第二章进程管理"></a> 操作系统第二章：进程管理</h1>
<h2 id="进程的定义组成组成方式特征"><a class="markdownIt-Anchor" href="#进程的定义组成组成方式特征"></a> 进程的定义，组成，组成方式，特征</h2>
<div class="tip "><p>程序的定义</p>
</div>
<ul>
<li>
<mark class="hl-label red">程序</mark> :就是一个指令序列
</li>
<li>
<p>早期的计算机（只支持单道程序），就是每一次只能进行一个程序</p>
<p>内存中同一个时间段内只有一个程序在运行，所以程序的程序段和数据段可以放在固定的位置</p>
<span class='p red'>程序的代码放在程序段内，程序运行过程处理的数据放在数据段内（如变量)</span>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/Shv7ob6sWprtRUE.png" alt="image-20220829092433663" /></p>
</li>
<li>
<p>引入多通道技术之后：</p>
<p>内存中同时放入多道程序，各个程序的代码、运算数据存放的位置不同。操作系统要怎么才能找<br />
到各程序的存放位置呢?</p>
<p>为了方便操作系统管理，完成各程序并发执行，引入了<span class='p red'>进程、进程实体</span>的概念</p>
<p>系统为每个运行的程序配置一个数据结构，称为进程控制块（PCB），用来描述进程的各种信息（如程<br />
序代码存放位置)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/JEIjKXGHPiQ49DF.png" alt="image-20220829092744752" /></p>
</li>
</ul>
<div class="tip "><p>进程的定义</p>
</div>
<span class='p red'>程序段、数据段、PCB</span>三部分组成了<span class='p red'>进程实体（进程映像〉</span>。一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB。
<p>注意: <mark class="hl-label red">PCB是进程存在的唯一标志!</mark> </p>
<p>从不同的角度，进程可以有不同的定义，比较传统典型的定义有:(<span class='p red'>强调动态性</span>)</p>
<ol>
<li>
<p>进程是程序的一次执行过程。</p>
</li>
<li>
<p>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</p>
</li>
<li>
<p>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</p>
</li>
</ol>
<p>引入进程实体的概念后，可把进程定义为:</p>
<span class='p red'>进程</span> 是进程实体的 <span class='p red'>运行过程</span> ，是系统进行<span class='p red'>资源分配</span> 和<span class='p red'>调度</span> 的一个独立单位。
<p>注:严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。不过，除非题目专门考察二者区别，否则可以认为进程实体就是进程。因此我们也可以说“进程由程序段、数据段、PCB三部分组成”</p>
<div class="tip "><p>进程的组成</p>
</div>
<p>进程（进程实体）由<span class='p red'>程序段、数据段、PCB</span>三部分组成。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/dCUAtzlSxMBHLPQ.png" alt="image-20220829092744752" /></p>
<ul>
<li>
<mark class="hl-label red">PCD</mark> ： 操作系统通过PCB来管理进程,因此PCB中应该包含操作系统对其进行管理所需的各种信息。
</li>
<li>
<mark class="hl-label red">程序段</mark> ：程序代码即存放在此
</li>
<li>
<mark class="hl-label red">数据段</mark> ：程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量就存放在数据段内
</li>
</ul>
<div class="tip "><p>进程的组织</p>
</div>
<p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p>
<p>注:进程的<span class='p red'>组成</span> 讨论的是一个<span class='p red'>进程内部</span> 由哪些部分构成的问题，而进程的<span class='p red'>组织</span>讨论的是<span class='p red'>多个进程</span>之间的组织方式问题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/T1UCKXcJPWlvMa2.png" alt="image-20220829095153039" /></p>
<div class="tabs" id="进程的组织"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="进程的组织-1">链接方式</button><button type="button" class="tab " data-href="进程的组织-2">索引方式</button></ul><div class="tab-contents"><div class="tab-item-content active" id="进程的组织-1"><ul>
<li>执行指针：指向当前处于运行态（执行态）的进程
<ul>
<li>单核CPU计算机中同一时刻只会有一个进程处于运行态</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/D1jx9i3MP7mWZ6K.png" alt="image-20220830142158333" /></li>
</ul>
</li>
<li>就绪队列指针：指向当前处于就绪态的进程
<ul>
<li>通常会把优先级高的进程放在队头</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/cEHAeOr37ia1lMg.png" alt="image-20220830142211177" /></li>
</ul>
</li>
<li>阻塞队列指针：指向当前处于阻塞态的进程，很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列
<ul>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/1LeCIKg4A6UdHX2.png" alt="image-20220830142218255" /></li>
</ul>
</li>
</ul></div><div class="tab-item-content" id="进程的组织-2"><ul>
<li>
<p>执行指针和链接方式一样</p>
</li>
<li>
<p>就绪表指针：</p>
<ul>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/ekzRfEjB28h43ir.png" alt="image-20220830142349833" /></li>
</ul>
</li>
<li>
<p>阻塞表指针：</p>
<ul>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/8FJ9zrMPNW2eDpt.png" alt="image-20220830142418046" /></li>
</ul>
</li>
</ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<div class="tip "><p>进程的特征</p>
</div>
<p>进程和特征具有两个截然不同的概念，相对于程序，进程有以下特征</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/F1vukGeonrZQyqg.png" alt="image-20220830142622942" /></p>
<h2 id="进程的状态"><a class="markdownIt-Anchor" href="#进程的状态"></a> 进程的状态</h2>
<p>进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p>
<p>进程的三种基本状态：</p>
<div class="tip warning faa-horizontal animated"><p>注意：</p>
</div>
<ul>
<li>
<mark class="hl-label red">运行态（Runing）</mark> :单核处理机环境下,每一时刻最系只有一个进程处于运行态。（双核环境下可以同时有两个进程处于运行态）
</li>
<li>
<mark class="hl-label red">就绪态（Ready）</mark> ：进程已经有了除了处理机外所有需要的资源，一旦获得处理机即可立即进入运行态开始运行，即：万事具备，只欠CPU
</li>
<li>
<mark class="hl-label red">阻塞态</mark> ：如:等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/EsnC3WpP26YygzZ.png" alt="image-20220830143444668" /></p>
<p>另外两种状态：</p>
<ul>
<li>创建态 (New，又称:新建态)进程正在被创建，操作系统为进程分配资源、初始化PCB</li>
<li>终止态（Terminated，又称:结束态)进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</li>
</ul>
<div class="tip "><p>进程状态的转换</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/rjUq9vxVw8znGes.png" alt="image-20220830145116090" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/oY4aRVMOEdXpDmI.png" alt="image-20220830145304994" /></p>
<h2 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h2>
<p>进程控制的主要工能是对系统中所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现进程状态转变等功能。</p>
<p>简化理解：进程控制就是要实现进程状态的转换</p>
<div class="tip "><p>如何实现进程控制？</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/dwbFecN3BtaO5m1.png" alt="image-20220830150111085" /></p>
<p>用<span class='p red'>原语</span> 实现进程控制。原语的<span class='p red'>特点</span> 是执行期间<span class='p red'>不允许中断</span>，只能一气呵成。这种不可被中断的操作即<span class='p red'>原子操作</span>。</p>
<p>原语采用“<span class='p red'>关中断</span> 指令”和“<span class='p red'>开中断</span>指令”实现</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/nzRWCwhtBM6Dab5.png" alt="image-20220830150342047" /></p>
<p>显然，<span class='p red'>关/开中断指令</span>的权限非常大，必然是只允许在<span class='p red'>核心态</span>下执行的<span class='p red'>特权指令</span>。</p>
<div class="tip "><p>进程控制相关原语</p>
</div>
<p>学习技巧:进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情:</p>
<ol>
<li>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)
<ul>
<li>所有的进程控制原语一定都会修改进程状态标志</li>
<li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>
<li>某进程开始运行前必然要恢复期运行环境</li>
</ul>
</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/XgdGEeizva5yRHf.png" alt="image-20220830150953601" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/EWJHO4GC1ZMgPnz.png" alt="image-20220830151039226" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/RrKwqYTJyd9jpMG.png" alt="image-20220830151711582" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/ps53m42XTzUELew.png" alt="image-20220830151810079" /></p>
<h2 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h2>
<div class="tip "><p>什么事进程通信？</p>
</div>
<p>顾名思义：进程通讯就是指进程之间的信息交换。</p>
<p>进程是分配系统资源的单位（包括内存地址空间），因此<span class='p red'>各进程</span>拥有的<span class='p red'>内存地址空间相互独立</span></p>
<p>为了保证进程的安全，<span class='p red'>一个进程不能直接访问另一个进程的地址空间</span>。</p>
<p>但是进程之间的信息交换又是必须要实现的。为了保证进程之间的安全通信，操作系统提供了一些方法</p>
<p>进程通讯分为三种：</p>
<p>共享存储， 消息传递， 管道通信</p>
<div class="tabs" id="进程通讯"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="进程通讯-1">共享存储</button><button type="button" class="tab " data-href="进程通讯-2">消息传递</button><button type="button" class="tab " data-href="进程通讯-3">管道通信</button></ul><div class="tab-contents"><div class="tab-item-content active" id="进程通讯-1"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/rdvJsgypKkOW13e.png" alt="image-20220830153223383" /></p>
<p>两个进程对共享空间的<span class='p red'>访问</span>必须是<span class='p red'>互斥</span>的（互斥访问通过操作系统提供的工具实现）。</p>
<p>操作系统只负责提供共享空间和同步互斥工具（如P、V操作)</p>
<p>共享存储分为两种</p>
<ul>
<li>基于数据结构的共享
<ul>
<li><span class='p red'>基于数据结构</span>的共享:比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<span class='p red'>低级通信</span> 方式</li>
</ul>
</li>
<li>基于存储区的共享
<ul>
<li>基于存储区的共享:在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。</li>
</ul>
</li>
</ul></div><div class="tab-item-content" id="进程通讯-2"><p>进程之间的数据交换以<span class='p red'>格式化的信息</span>（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个“<span class='p red'>原语</span>”进行数据交换</p>
<p>格式化信息分为：</p>
<ul>
<li>消息头
<ul>
<li>消息头包括:发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息)</li>
</ul>
</li>
<li>消息体</li>
</ul>
<p>消息传递分为：</p>
<ul>
<li>直接通讯传递
<ul>
<li>消息直接挂到接收进程的消息缓冲队列上</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/SVe6EMFO1qWlfQm.png" alt="image-20220830160925692" /></li>
</ul>
</li>
<li>间接通讯传递
<ul>
<li>消息要先发送到中间实体（信箱）中，因此也称为”信箱通讯方式“</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/4kJNyrmidtqfXa5.png" alt="image-20220830160942160" /></li>
</ul>
</li>
</ul></div><div class="tab-item-content" id="进程通讯-3"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/pRYCBlqkOanEuJT.png" alt="image-20220830155633613" /></p>
<p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟个大小固定的缓冲区</p>
<ol>
<li>管道只能采用<span class='p red'>半双工通信</span> ，某一时间段内只能实现单向的传输。如果要实现<span class='p red'>双向同时通信</span>，则<span class='p red'>需要设置两个管道</span>。</li>
<li>各进程要<span class='p red'>互斥</span>的访问管道</li>
<li>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li>
<li>如果<span class='p red'>没写满，就不允许读。</span> 如果<span class='p red'>没读空，就不允许写</span>。</li>
<li>数据一旦被读出，就从管道中被抛弃，这就意味着<span class='p red'>读进程最多只能有一个</span>，否则可能会有读错数据的情况。</li>
</ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/housMvIZOHEdCPb.png" alt="image-20220830161045223" /></p>
<h2 id="线程概念多线程模型"><a class="markdownIt-Anchor" href="#线程概念多线程模型"></a> 线程概念多线程模型</h2>
<div class="tip "><p>什么是线程， 为什么要引入线程 ？</p>
</div>
<p>在没有进程之前，CPU一次只能为一个程序进行服务，引入进程之后CPU可以一次性为多个进程进行服务。</p>
<p>例如原先玩QQ和听音乐只能选择其中一个运行，但是引入进程之后，我们就可以边听音乐，边玩QQ。</p>
<p>但是QQ有许多功能，例如视频聊天，文字聊天，如果让一个进程同时进行不同的功能呢，这时候就需要引入线程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/1CqdnorikJMvjNY.png" alt="image-20220830162227903" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/i6r9XVuE5aIFTHK.png" alt="image-20220830162320666" /></p>
<p>可以把线程理解为“轻量级进程”</p>
<ul>
<li>
<span class='p red'>线程</span>是一个<span class='p red'>基本的CPU执行单元</span>，也是<span class='p red'>程序执行流的最小单位</span>。
</li>
<li>引入线程之后，不仅是进程之间可以并发，进程内的<span class='p red'>各线程之间</span>也可以<span class='p red'>并发</span>，从而进一步<span class='p red'>提升了系统的并发度</span>，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件)</li>
<li>引入线程后，<span class='p red'>进程</span>只作为<span class='p red'>除CPU之外的系统资源的分配单元</span>（如打印机、内存地址空间等都是分配给进程的)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/qyXrPmM53Togclu.png" alt="image-20220830162818845" /></p>
<div class="tip "><p>线程的属性</p>
</div>
<ul>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块（TCB)</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销较大</li>
</ul>
<div class="tip "><p>线程的实现方式</p>
</div>
<div class="tabs" id="线程的实现方式"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="线程的实现方式-1">用户级线程</button><button type="button" class="tab " data-href="线程的实现方式-2">内核级线程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="线程的实现方式-1"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/oDHtavJ8mbfSApQ.png" alt="image-20220830163759413" /></p>
<p>用户级线程由应用程序通过线程库实现。</p>
<p>所有的<span class='p red'>线程管理工作</span>都由<span class='p red'>应用程序负责</span>（包括线程切换)</p>
<p>用户级线程中，<span class='p red'>线程切换</span>可以在<span class='p red'>用户态下即可完成</span>，无需操作系统干预。</p>
<p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明)</p>
<p>可以这样理解，<span class='p red'>“用户级线程”</span> 就是<span class='p red'>“从用户视角看能看到的线程”</span> 。</p></div><div class="tab-item-content" id="线程的实现方式-2"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/tkPUGbiRErx6VJD.png" alt="image-20220830164137909" /></p>
<p>内核级<span class='p red'>线程的管理工作</span>由<span class='p red'>操作系统内核</span>完成。线程调度、切换等工作都由内核负责，因此<span class='p red'>内核级线程的切换</span>必然需要在<span class='p red'>核心态</span>下才能完成。</p>
<p>可以这样理解，<span class='p red'>“内核级线程”</span> 就是<span class='p red'>“从操作系统内核视角看能看到的线程”</span></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<p>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式:将n个用户级线程映射到m个内核级线程上( n &gt;= m)</p>
<div class="tip warning faa-horizontal animated"><p>重点：</p>
</div>
<p>操作系统只“看得见”内核级线程，因此只有<span class='p red'>内核级线程才是处理机分配的单位</span>。</p>
<p>例如:下边这个模型中，该进程由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个4核处理机的计算机上运行，也最多只能被分配到两个核，最多只能有两个用户线程并行执行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/5IXmUNqWtAZ1SLv.png" alt="image-20220830164511165" /></p>
<div class="tip "><p>多线程模型</p>
</div>
<div class="tabs" id="多线程模型"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="多线程模型-1">多对一模型</button><button type="button" class="tab " data-href="多线程模型-2">一对一模型</button><button type="button" class="tab " data-href="多线程模型-3">多对多模型</button></ul><div class="tab-contents"><div class="tab-item-content active" id="多线程模型-1"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/OVfEpWLvIt8yucl.png" alt="image-20220830164910647" /></p>
<p>多对一模型:多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p>
<p>优点:用户级线程的切换在用户空间即可完快不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p></div><div class="tab-item-content" id="多线程模型-2"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/OSqghzMkoV9CtHK.png" alt="image-20220830165016897" /></p>
<p>一对一模型:一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<p>优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点:一个用户进程会占用多个内核级线程,线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p></div><div class="tab-item-content" id="多线程模型-3"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/Soa4kWtqUxPpZzM.png" alt="image-20220830165751869" /></p>
<p>多对多模型: n用户级线程映射到m个内核级线程(n &gt;= m) 。每个用户进程对应m个内核级线程。</p>
<p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/PyagXmxMH7zkR9O.png" alt="image-20220830165841674" /></p>
<h2 id="处理机调度的概念层次"><a class="markdownIt-Anchor" href="#处理机调度的概念层次"></a> 处理机调度的概念，层次</h2>
<p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<mark class="hl-label red">某种规则</mark> 来<mark class="hl-label red">决定</mark> 处理这些任务的<mark class="hl-label red">顺序</mark> ，这就是“调度”研究的问题。</p>
<p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。</p>
<ul>
<li>
<mark class="hl-label red">处理机的调度</mark> ：从就绪队列中<mark class="hl-label red">按照一定的算法选择一个进程</mark> 并<mark class="hl-label red">将处理机分配给它</mark> 运行，以实现进程的并发执行。
</li>
</ul>
<div class="tip "><p>调度的三个层次</p>
</div>
<div class="tabs" id="调度的三个层次"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="调度的三个层次-1">高级调度</button><button type="button" class="tab " data-href="调度的三个层次-2">中级调度</button><button type="button" class="tab " data-href="调度的三个层次-3">低级调度</button></ul><div class="tab-contents"><div class="tab-item-content active" id="调度的三个层次-1"><ul>
<li>
<p><span class='p red'>高级调度（作业调度）</span>。按一定的原则从<span class='p red'>外存</span>上处于后备队列的作业中挑选一个(或多个）作业,给他们分配<span class='p red'>内存</span>等必要资源，并<span class='p red'>建立相应的进程（建立PCB)</span>，以使它（们）<span class='p red'>获得竞争处理机的权利</span>。</p>
</li>
<li>
<p>高级调度是<span class='p red'>辅存（外存）</span>与<span class='p red'>内存</span>之间的调度。每个作业只调入一次，调出一次。<span class='p red'>作业调入时会建立相应的PCB，作业调出时才撤销PCB</span>。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p>
</li>
</ul></div><div class="tab-item-content" id="调度的三个层次-2"><ul>
<li>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。</li>
<li>这么做的目的是为了<span class='p red'>提高内存利用率</span>和<span class='p red'>系统吞吐量</span>。</li>
<li>暂时调到外存等待的进程状态为<span class='p red'>挂起状态</span>。值得注意的是，<span class='p red'>PCB</span>并不会一起调到外存，而是<span class='p red'>会常驻内存</span>。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的<span class='p red'>挂起队列</span>中。</li>
<li><mark class="hl-label red">中级调度（内存调度）</mark> ，就是要决定将哪个处于挂起状态的进程重新调入内存。<br />
一个进程可能会被多次调出、调入内存，因此<span class='p red'>中级调度</span>发生的<span class='p red'>频率</span>要比高级调度<span class='p red'>更高</span>。</li>
<li>暂时调到外存等待的进程状态为挂起状态（挂起态，suspend)
<ul>
<li>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</li>
<li>五状态模型→七状态模型</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/DaqGzuKpYA34NQH.png" alt="image-20220905085534328" /></li>
<li>注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</li>
<li>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</li>
</ul>
</li>
</ul></div><div class="tab-item-content" id="调度的三个层次-3"><ul>
<li><mark class="hl-label red">低级调度（进程调度）</mark> ，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</li>
<li>进程调度是操作系统中<span class='p red'>最基本的一种调度</span>，在一般的操作系统中都必须配置进程调度。进程调度的<span class='p red'>频率很高</span>，一般几十毫秒一次。</li>
</ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/9I13vmGwZqXJpTB.png" alt="image-20220905090211738" /></p>
<h2 id="进程调度的时机切换与过程方式"><a class="markdownIt-Anchor" href="#进程调度的时机切换与过程方式"></a> 进程调度的时机，切换与过程，方式</h2>
<div class="tip "><p>进程调度的时机</p>
</div>
<ul>
<li>
<mark class="hl-label red">进程调度</mark> (低级调度)，按照某种算法从就绪队列中选择一个进程为其分配处理机
</li>
</ul>
<p>需要进行进程调度和切换的情况</p>
<ul>
<li>当前运行的进程<span class='p red'>主动放弃</span>处理机
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞（如等待I/O)</li>
</ul>
</li>
<li>当前运行的进程<span class='p red'>被动放弃</span>处理机
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理（如I/O中断)</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
<p>不能进行进程调度和切换的情况</p>
<ul>
<li>在<span class='p red'>处理中断的过程中</span>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li>
<li>进程在<span class='p red'>操作系统内核程序临界区</span>中。</li>
<li>在<span class='p red'>原子操作过程中</span>（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列)</li>
</ul>
<p>临界资源:一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p>
<p>临界区:访问临界资源的那段代码。</p>
<ul>
<li>
<mark class="hl-label red">内核程序临界区</mark> 一般是用来访问<span class='p red'>某种内核数据结构</span>的，比如进程的就绪队列（由各就绪进程的PCB组成)
</li>
<li>当一个程序处于内核程序临界区时：
<ul>
<li>如果还没退出临界区（还没解锁)就进行进程调度,但是进程调度相关的程序也需要访问就绪队列,但此时就绪队列被锁住了，因此又无法顺利进行进程调度</li>
<li>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界<br />
区期间不能进行调度与切换</li>
</ul>
</li>
<li>当一个程序处理普通临界区的时候
<ul>
<li>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲</li>
<li>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</li>
</ul>
</li>
</ul>
<div class="tip "><p>进程调度的方式</p>
</div>
<ul>
<li>
<span class='p red'>非剥夺调度方式</span>，又称<span class='p red'>非抢占方式</span>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
<ul>
<li>实现简单,系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</li>
</ul>
</li>
<li>
<span class='p red'>剥夺调度方式</span>，又称<span class='p red'>抢占方式</span>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。
<ul>
<li>可以优先处理更紧急的进程,也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</li>
</ul>
</li>
</ul>
<div class="tip "><p>进程切换的方式和过程</p>
</div>
<p>“狭义的进程调度”与“进程切换”的区别:</p>
<ul>
<li>
<mark class="hl-label red">狭义的进程调度</mark> 指的是从就绪队列中<span class='p red'>选中一个要运行的进程</span>。(这个进程可以是刚刚被暂停执行的进程，也可能是另<span class='p red'>一个进程</span>，后一种情况就需要<span class='p red'>进程切换</span>）
</li>
<li>
<span class='p red'>进程切换</span>是指一个进程让出处理机，由另一个进程占用处理机的过程。
</li>
<li>
<mark class="hl-label red">广义的进程调度</mark> 包含了选择一个进程和进程切换两个步骤。
</li>
</ul>
<p>进程切换的过程主要完成了:</p>
<ol>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</li>
</ol>
<p>注意:<span class='p red'>进程切换是有代价的</span>，因此如果<span class='p red'>过于频繁的</span>进行进程<span class='p red'>调度、切换</span>，必然会使整个<span class='p red'>系统的效率降低</span>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/R6mkC8pT71t49nP.png" alt="image-20220917224438166" /></p>
<h2 id="调度算法的评价指标"><a class="markdownIt-Anchor" href="#调度算法的评价指标"></a> 调度算法的评价指标</h2>
<div class="tabs" id="调度算法评价指标"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="调度算法评价指标-1">CPU利用率</button><button type="button" class="tab " data-href="调度算法评价指标-2">系统吞吐量</button><button type="button" class="tab " data-href="调度算法评价指标-3">周转时间</button><button type="button" class="tab " data-href="调度算法评价指标-4">等待时间</button><button type="button" class="tab " data-href="调度算法评价指标-5">响应时间</button></ul><div class="tab-contents"><div class="tab-item-content active" id="调度算法评价指标-1"><p>CPU利用率:指CPU“忙碌”的时间占总时间的比例。</p></div><div class="tab-item-content" id="调度算法评价指标-2"><p>系统吞吐量:单位时间内完成作业的数量</p>
<p>系统吞吐量=总共完成了多少道作业 /  总共花了多少时间</p>
<p>Eg:某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为?</p>
<ul>
<li>10/100=0.1道/秒</li>
</ul></div><div class="tab-item-content" id="调度算法评价指标-3"><p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。</p>
<ul>
<li><mark class="hl-label red">周转时间</mark> ，是指从<mark class="hl-label red">作业被提交给系统开始</mark> ，到<span class='p red'>作业完成为止</span>的这段时间间隔。</li>
</ul>
<p>它包括四个部分:作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。</p>
<p>对于用户来说，更关心自己的单个作业的周转时间</p>
<ul>
<li>(作业）周转时间=作业完成时间-作业提交时间</li>
</ul>
<p>对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值</p>
<ul>
<li>平均周转时间= 各作业周转时间之和 / 作业数</li>
</ul>
<p>带权周转时间=作业周转时间 / 作业实际运行的时间 = (作业完成时间-作业提交时间) / 作业实际运行的时间</p>
<ul>
<li>
<p>带权周转时间必然≥1</p>
</li>
<li>
<p>带权周转时间与周转时间都是越小越好</p>
</li>
</ul>
<p>平均带权周转时间= 各作业带权周转时间之和 / 作业数</p></div><div class="tab-item-content" id="调度算法评价指标-4"><p>计算机的用户希望自己的作业尽可能少的等待处理机</p>
<p>等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p>
<p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。<br />
对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p>
<p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。</p></div><div class="tab-item-content" id="调度算法评价指标-5"><p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。</p>
<p>响应时间，指从用户提交请求到首次产生响应所用的时间。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/IdyNluDV4Wr18Lj.png" alt="image-20220905094803977" /></p>
<h2 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h2>
<h3 id="fcfs先来先服务first-come-first-serve"><a class="markdownIt-Anchor" href="#fcfs先来先服务first-come-first-serve"></a> FCFS（先来先服务）（First Come First Serve）</h3>
<div class="tip "><p>FCFS（先来先服务）</p>
</div>
<ul>
<li>算法思想：
<ul>
<li>主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子)</li>
</ul>
</li>
<li>算法规则
<ul>
<li>按照作业/进程到达的先后顺序进行服务</li>
</ul>
</li>
<li>用于作业/进程调度
<ul>
<li>用于作业调度时，考虑的是哪个作业先到达后备队列;用于进程调度时，考虑的是哪个进程先到达就绪队列</li>
</ul>
</li>
<li>是否可抢占?
<ul>
<li>非抢占式的算法</li>
</ul>
</li>
<li>优缺点
<ul>
<li>优点:公平、算法实现简单</li>
<li>缺点:排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利（Eg :排队买奶茶…)</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>
<p>不会</p>
</li>
<li>
<p>某进程/作业长期得不到服务</p>
</li>
</ul>
</li>
</ul>
<h3 id="sjf短作业优先shortest-job-first"><a class="markdownIt-Anchor" href="#sjf短作业优先shortest-job-first"></a> SJF（短作业优先）（Shortest Job First）</h3>
<div class="tip "><p>SJF（短作业优先）</p>
</div>
<ul>
<li>
<p>算法思想</p>
<ul>
<li>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li>
</ul>
</li>
<li>
<p>算法规则</p>
<ul>
<li>最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短)</li>
</ul>
</li>
<li>
<p>用于作业/进程调度</p>
<ul>
<li>即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”</li>
</ul>
</li>
<li>
<p>是否可以抢占</p>
<ul>
<li>SJF和SPF是非抢占式的算法。但是也有抢占式的版本一一最短剩余时间优先算法(SRTN, Shortest Remaining Time Next)</li>
</ul>
</li>
<li>
<p>优缺点</p>
<ul>
<li>优点:
<ul>
<li>“最短的”平均等待时间、平均周转时间</li>
</ul>
</li>
<li>缺点:
<ul>
<li>不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li>
</ul>
</li>
</ul>
</li>
<li>
<p>是否会导致饥饿</p>
<ul>
<li>会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</li>
</ul>
</li>
<li>
<div class="tip warning"><p>注意</p>
</div>
<ol>
<li>如果题目中未特别说明，所提到的“短作业/进程优先算法”默认是非抢占式的</li>
<li>很多书上都会说“SJF调度算法的平均等待时间、平均周转时间最少”
<ul>
<li>严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少</li>
<li>应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”;<br />
或者说“在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少”;</li>
<li>如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先, SRNT算法）的平均等待时间、平均周转时间最少”</li>
</ul>
</li>
<li>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如FCFS),SJF依然可以获得较少的平均等待时间、平均周转时间</li>
<li>如果选择题中遇到“SJF算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</li>
</ol>
</li>
</ul>
<h3 id="hrrn高响应比优先highest-response-ratio-next"><a class="markdownIt-Anchor" href="#hrrn高响应比优先highest-response-ratio-next"></a> HRRN（高响应比优先）（Highest Response RatIO Next）</h3>
<div class="tip "><p>HRRN（高响应比优先）</p>
</div>
<p>算法的来源：</p>
<p>FCFS 算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题</p>
<p>SJF算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题</p>
<p>考虑到上面两个问题的出现，HRRN高响应比优先算法就应运而生</p>
<ul>
<li>
<p>算法思想</p>
<ul>
<li>要综合考虑作业/进程的等待时间和要求服务的时间</li>
</ul>
</li>
<li>
<p>算法规则</p>
<ul>
<li>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</li>
<li>响应比=（等待时间+要求服务时间）/  要求服务时间</li>
<li>响应比≥1</li>
</ul>
</li>
<li>
<p>用于作业/进程调度</p>
<ul>
<li>即可用于作业调度，也可用于进程调度</li>
</ul>
</li>
<li>
<p>是否可以抢占</p>
<ul>
<li>非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</li>
</ul>
</li>
<li>
<p>优缺点</p>
<ul>
<li>综合考虑了等待时间和运行时间（要求服务时间)</li>
<li>等待时间相同时，要求服务时间短的优先（SJF的优点)</li>
<li>要求服务时间相同时，等待时间长的优先（FCFS的优点)</li>
<li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>
</ul>
</li>
<li>
<p>是否会导致饥饿</p>
<ul>
<li>不会</li>
</ul>
</li>
</ul>
<h3 id="rr时间片轮转调度算法round-robin"><a class="markdownIt-Anchor" href="#rr时间片轮转调度算法round-robin"></a> RR（时间片轮转调度算法）（Round-Robin）</h3>
<ul>
<li>
<p>算法思想</p>
<ul>
<li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>
</ul>
</li>
<li>
<p>算法规则</p>
<ul>
<li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li>
</ul>
</li>
<li>
<p>用于作业/进程调度</p>
<ul>
<li>用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</li>
</ul>
</li>
<li>
<p>是否可抢占?</p>
<ul>
<li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</li>
</ul>
</li>
<li>
<p>优缺点</p>
<ul>
<li>优点:公平;响应快，适用于分时操作系统;</li>
<li>缺点:由于高频率的进程切换，因此有一定开销;不区分任务的紧急程度。</li>
</ul>
</li>
<li>
<p>是否会导致饥饿</p>
<ul>
<li>不会</li>
</ul>
</li>
<li>
<p>时间片太大或太小分别有什么影响</p>
<ul>
<li>如果<mark class="hl-label red">时间片太大</mark> ，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为<mark class="hl-label red">先来先服务调度算法</mark> ，并且会<mark class="hl-label red">增大进程响应时间</mark> 。因此<mark class="hl-label red">时间片不能太大</mark> 。</li>
<li>另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境)，因此如果<mark class="hl-label red">时间片太小</mark> ，会导致<mark class="hl-label red">进程切换过于频繁</mark> ，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见<mark class="hl-label red">时间片也不能太小</mark> 。</li>
</ul>
</li>
</ul>
<h3 id="优先级调度算法"><a class="markdownIt-Anchor" href="#优先级调度算法"></a> 优先级调度算法</h3>
<ul>
<li>
<p>算法思想</p>
<ul>
<li>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li>
</ul>
</li>
<li>
<p>算法规则</p>
<ul>
<li>调度时选择优先级最高的作业/进程</li>
</ul>
</li>
<li>
<p>用于作业/进程调度</p>
<ul>
<li>既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中</li>
</ul>
</li>
<li>
<p>是否可抢占?</p>
<ul>
<li>抢占式、非抢占式都有。做题时的区别在于:非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</li>
</ul>
</li>
<li>
<p>优缺点</p>
<ul>
<li>优点:用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</li>
<li>缺点:若源源不断地有高优先级进程到来，则可能导致饥饿</li>
</ul>
</li>
<li>
<p>是否会导致饥饿</p>
<ul>
<li>会</li>
</ul>
</li>
</ul>
<p>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置</p>
<p>根据优先级是否可以动态改变，可将优先级分为<mark class="hl-label red">静态优先级</mark> 和<mark class="hl-label red">动态优先级</mark> 两种。</p>
<p>静态优先级:创建进程时确定，之后一直不变。</p>
<p>动态优先级:创建进程时有一个初始值，之后会根据情况动态地调整优先级。</p>
<p>如何合理的设置各类进程的优先级？</p>
<ul>
<li>系统进程优先级高于用户进程</li>
<li>前台进程优先级高于后台进程</li>
<li>操作系统更偏好I/O型进程（或称I/O繁忙型进程)</li>
<li>与I/O型进程相对的是计算型进程（或称CPU繁忙型进程)</li>
<li>I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</li>
</ul>
<p>如果采用的是动态优先级,什么时候应该调整?</p>
<ul>
<li>可以从追求公平、提升资源利用率等角度考虑，如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li>
</ul>
<h3 id="多级返回队列调度算法"><a class="markdownIt-Anchor" href="#多级返回队列调度算法"></a> 多级返回队列调度算法</h3>
<p>算法来源</p>
<ul>
<li>FCFS算法的优点是公平</li>
<li>SJF算法的优点是能尽快处理完短作业,平均等待/周转时间等参数很优秀</li>
<li>时间片轮转调度算法可以让各个进程得到及时的响应</li>
<li>优先级调度算法可以灵活地调整各种进程被服务的机会</li>
</ul>
<p>能否对上述几个算法做一个折中的权衡，得到一个综合表现优秀的算法呢？</p>
<ul>
<li>
<p>算法思想</p>
<ul>
<li>对其他调度算法的折中权衡</li>
</ul>
</li>
<li>
<p>算法规则</p>
<ol>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第k 级队列为空时，才会为k+1级队头的进程分配时间片</li>
</ol>
</li>
<li>
<p>用于作业/进程调度</p>
<ul>
<li>用于进程调度</li>
</ul>
</li>
<li>
<p>是否可抢占?</p>
<ul>
<li>抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</li>
</ul>
</li>
<li>
<p>优缺点</p>
<ul>
<li>对各类型进程相对公平（FCFS的优点）;</li>
<li>每个新到达的进程都可以很快就得到响应（RR的优点）﹔</li>
<li>短进程只用较少的时间就可完成(SPF的优点）;</li>
<li>不必实现估计进程的运行时间（避免用户作假);</li>
<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程</li>
<li>拓展:可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级)</li>
</ul>
</li>
<li>
<p>是否会导致饥饿</p>
<ul>
<li>会</li>
</ul>
</li>
</ul>
<p>算法运行过程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/f5MN3XjEU42Qiz8.png" alt="image-20220906175225046" /></p>
<h2 id="进程同步和进程互斥"><a class="markdownIt-Anchor" href="#进程同步和进程互斥"></a> 进程同步和进程互斥</h2>
<p>知识点回顾:进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p>
<div class="tip "><p>进程同步</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/evwqZYpHmo2sCtJ.png" alt="image-20220917154036050" /></p>
<ul>
<li>
<p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“<span class='p red'>写数据→读数据</span>”的顺序来执行的。</p>
</li>
<li>
<p>写满才能读， 读完才能写</p>
</li>
<li>
<p>如何解决这种<span class='p red'>异步</span>问题，就是“进程<span class='p red'>同步</span>”所讨论的内容。</p>
</li>
<li>
<span class='p red'>同步</span>亦称<span class='p red'>直接制约关系</span>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<span class='p red'>协调</span>它们的<span class='p red'>工作次序</span>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。
</li>
</ul>
<div class="tip "><p>进程互斥</p>
</div>
<p>我们把<span class='p red'>一个时间段内只允许一个进程使用</span>的资源称为<span class='p red'>临界资源</span>。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p>
<p>对临界资源的访问，必须<span class='p red'>互斥</span>地进行。互斥，亦称<span class='p red'>间接制约关系。进程互斥</span>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p>
<p>上厕所排队，马桶是临界资源，每个人只能互斥地访问，访问的时候把厕所门锁上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    entry sectIOn; <span class="comment">// 进入区</span></span><br><span class="line">    critical sectIOn; <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">exit</span> sectIOn;  <span class="comment">// 退出区</span></span><br><span class="line">    remainder sectIOn; <span class="comment">// 剩余区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="tabs" id="进程互斥"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="进程互斥-1">进入区</button><button type="button" class="tab " data-href="进程互斥-2">临界区</button><button type="button" class="tab " data-href="进程互斥-3">退出区</button><button type="button" class="tab " data-href="进程互斥-4">剩余区</button></ul><div class="tab-contents"><div class="tab-item-content active" id="进程互斥-1"><p>负责检查是否可进入临界区,若可进入，则应没置正在访问临界资源的标志（可理解为“上锁”），以阻止其他进程同时进入临界区</p></div><div class="tab-item-content" id="进程互斥-2"><p>访问临界资源的那段代码</p></div><div class="tab-item-content" id="进程互斥-3"><p>负责解除正在访间临界资源的标志（可理解为“解锁”)</p></div><div class="tab-item-content" id="进程互斥-4"><p>作其他处理</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<p>注意:</p>
<ul>
<li>
<span class='p red'>临界区</span> 是进程中<span class='p red'>访问临界资源</span>的代码段。
</li>
<li>
<span class='p red'>进入区和退出区</span>是<span class='p red'>负责实现互斥</span>的代码段。临界区也可称为“临界段”。
</li>
</ul>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p>
<ol>
<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）;</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/KW3x8NLrpR5mCBJ.png" alt="image-20220917224336993" /></p>
<h2 id="进程互斥的软件实现方法"><a class="markdownIt-Anchor" href="#进程互斥的软件实现方法"></a> 进程互斥的软件实现方法</h2>
<h3 id="单标志法"><a class="markdownIt-Anchor" href="#单标志法"></a> 单标志法</h3>
<p>算法思想:两个进程在<span class='p red'>访问完临界区后</span>会把使用临界区的权限转交给另一个进程。也就是说<span class='p red'>每个进程进入临界区的权限只能被另一个进程赋予</span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p0进程</span></span><br><span class="line"><span class="keyword">while</span>( turn != <span class="number">0</span> )&#123;			<span class="comment">// 进入区</span></span><br><span class="line">    critical sectIOn;		<span class="comment">// 临界区</span></span><br><span class="line">    turn = <span class="number">1</span>;				<span class="comment">// 退出区</span></span><br><span class="line">    remainder sectIOn;		<span class="comment">// 剩余区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1进程</span></span><br><span class="line"><span class="keyword">while</span>( turn != <span class="number">1</span> )&#123;			<span class="comment">// 进入区</span></span><br><span class="line">    critical sectIOn;		<span class="comment">// 临界区</span></span><br><span class="line">    turn = <span class="number">0</span>;				<span class="comment">// 退出区</span></span><br><span class="line">    remainder sectIOn;		<span class="comment">// 剩余区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按PO→P1→PO→P1→…这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是PO，而PO一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</p>
<p>因此，<span class='p red'>单标志法</span> 存在的<span class='p red'>主要问题</span>是: <span class='p red'>违背“空闲让进”原则</span>。</p>
<h3 id="双标志先检查"><a class="markdownIt-Anchor" href="#双标志先检查"></a> 双标志先检查</h3>
<p>算法思想:设置一个布尔型数组flag[]，数组中各个元素用来<span class='p red'>标记各进程想进入临界区的意愿</span>，比如“flag[0] =ture”意味着0号进程PO现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];		<span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>; 	</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>; 	<span class="comment">// 刚开始设置两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p0进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);			<span class="comment">// 1</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;			<span class="comment">// 2</span></span><br><span class="line">critical = sectIOn; 	<span class="comment">// 3</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;		<span class="comment">// 4</span></span><br><span class="line">remainder sectIOn;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);			<span class="comment">// 5 如果此时p0想要进入临界区，p1就一直循环等待</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;			<span class="comment">// 6 标记p1进程想要进入临界区</span></span><br><span class="line">critical = sectIOn; 	<span class="comment">// 7 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;		<span class="comment">// 8 访问完临界区，修改标记为p1不想进入临界区</span></span><br><span class="line">remainder sectIOn;</span><br></pre></td></tr></table></figure>
<p>若按照①⑤②6③⑦…的顺序执行，PO和P1将会同时访问临界因此，双标志先检查法的主要问题是:违反“<span class='p red'>忙则等待</span>”原则。</p>
<p>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生<span class='p red'>进程切换</span>。</p>
<h3 id="双标志后检查"><a class="markdownIt-Anchor" href="#双标志后检查"></a> 双标志后检查</h3>
<p>算法思想:双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];		<span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>; 	</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>; 	<span class="comment">// 刚开始设置两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p0进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;			<span class="comment">// 1</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);			<span class="comment">// 2</span></span><br><span class="line">critical = sectIOn; 	<span class="comment">// 3</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;		<span class="comment">// 4</span></span><br><span class="line">remainder sectIOn;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;			<span class="comment">// 5 如果此时p0想要进入临界区，p1就一直循环等待</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);			<span class="comment">// 6 标记p1进程想要进入临界区</span></span><br><span class="line">critical = sectIOn; 	<span class="comment">// 7 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;		<span class="comment">// 8 访问完临界区，修改标记为p1不想进入临界区</span></span><br><span class="line">remainder sectIOn;</span><br></pre></td></tr></table></figure>
<p>若按照①⑤②⑥…的顺序执行，PO和P1将都无法进入临界区</p>
<p>因此，双标志后检查法虽然<span class='p red'>解决了“忙则等待”</span>的问题，但是又违背了<span class='p red'>“空闲让进”和“有限等待”</span>原则，会因各进程都长期无法访问临界资源而<span class='p red'>产生“饥饿”</span>现象。</p>
<p>两个进程都争着抢着想要进入临界区，但是谁也不让谁，最后谁也无法进入临界区</p>
<h3 id="peterson算法"><a class="markdownIt-Anchor" href="#peterson算法"></a> Peterson算法</h3>
<p>算法思想:双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];		<span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; 		<span class="comment">// turn=0表示优先让那个进程进入临界</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p0进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;				<span class="comment">// 1</span></span><br><span class="line">turn = <span class="number">1</span>;					<span class="comment">// 2</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn=<span class="number">1</span>);	<span class="comment">// 3</span></span><br><span class="line">critical = sectIOn; 		<span class="comment">// 4</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;			<span class="comment">// 5</span></span><br><span class="line">remainder sectIOn;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;				<span class="comment">// 6	表示自己想要进入临界区</span></span><br><span class="line">turn = <span class="number">0</span>;					<span class="comment">// 7	可以让对方优先进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn=<span class="number">0</span>);	<span class="comment">// 8	对方想进，且最后一次是自己让“梨”，那自己就循环等待</span></span><br><span class="line">critical = sectIOn; 		<span class="comment">// 9</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;			<span class="comment">// 10	访问完临界区，表示自己不想访问临界区了</span></span><br><span class="line">remainder sectIOn;</span><br></pre></td></tr></table></figure>
<p>进入区:1.主动争取;2.主动谦让;3.检查对方是否也想使用,且最后一次是不是自己说了“客气话”</p>
<p>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。</p>
<p>Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/Pv9HVzZb2kctKdE.png" alt="image-20220917224256800" /></p>
<h2 id="进程互斥硬件实现方法"><a class="markdownIt-Anchor" href="#进程互斥硬件实现方法"></a> 进程互斥硬件实现方法</h2>
<h3 id="中断屏蔽方法"><a class="markdownIt-Anchor" href="#中断屏蔽方法"></a> 中断屏蔽方法</h3>
<p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关中断: 关中断后即不允许当前进程被中断，也必然不会发生进程切换</span></span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line"><span class="comment">// 开中断:直到当前进程访问完临界区,再执行开中断指令，才有可能有别的进程上处理机并访问临界区</span></span><br></pre></td></tr></table></figure>
<p>优点:简单、高效</p>
<p>缺点:不适用于多处理机;只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险</p>
<h3 id="testandsetts指令tsl指令"><a class="markdownIt-Anchor" href="#testandsetts指令tsl指令"></a> TestAndSet(Ts指令/TSL指令)</h3>
<p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令</p>
<p>TSL指令<span class='p red'>是用硬件实现的</span>，执行的过程不允许被中断，只能一气呵成。以下是用c语言描述的逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔型共享变量lock表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">//true表示已加锁， false表示未加锁</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> ×lock)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> old; </span><br><span class="line">    old = ×lock;	<span class="comment">// 用old来存放lock，原来的值</span></span><br><span class="line">    ×lock = <span class="literal">true</span>;	<span class="comment">// 无论之前是否已经加锁，都将lock设置为true</span></span><br><span class="line">    <span class="keyword">return</span> old;		<span class="comment">// 返回lock原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用TSL指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock));	<span class="comment">// &quot;上锁&quot;并“检查”</span></span><br><span class="line"><span class="comment">// 临界区代码段</span></span><br><span class="line">lock = <span class="literal">false</span>;		<span class="comment">// &quot;解锁&quot;</span></span><br><span class="line"><span class="comment">// 剩余代码段</span></span><br></pre></td></tr></table></figure>
<p>若刚开始lock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。若刚开始lock是true，则执行TLS后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p>
<p>相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p>
<p>优点:实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞;适用于多处理机环境</p>
<p>缺点:不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p>
<h3 id="swap指令xchg指令"><a class="markdownIt-Anchor" href="#swap指令xchg指令"></a> Swap指令(XCHG指令)</h3>
<p>有的地方也叫Exchange指令，或简称XCHG指令。<br />
Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用c语言描述的逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swap 指令作用是交换两个变量的值</span></span><br><span class="line">Swap(<span class="type">bool</span> ×a, <span class="type">bool</span> ×b) &#123;</span><br><span class="line">    <span class="type">bool</span> temp;</span><br><span class="line">    temp = ×a;</span><br><span class="line">    ×a = ×b;</span><br><span class="line">    ×b = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是用Swap指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">// lock表示当前临界区是否被上锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old == <span class="literal">true</span>)</span><br><span class="line">    Swap(&amp;lock, &amp;old);</span><br><span class="line"><span class="comment">// 临界区代码段</span></span><br><span class="line">lock = <span class="literal">false</span>;		<span class="comment">// &quot;解锁&quot;</span></span><br><span class="line"><span class="comment">// 剩余代码段</span></span><br></pre></td></tr></table></figure>
<p>逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old变量上），再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p>
<p>优点:实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞;适用于多处理机环境</p>
<p>缺点:不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/rKpJvE719Aqwy4d.png" alt="image-20220917233129861" /></p>
<h2 id="信号量机制"><a class="markdownIt-Anchor" href="#信号量机制"></a> 信号量机制</h2>
<ul>
<li>
<p>用户进程可以通过使用操作系统提供的<span class='p red'>一对原语</span>来对<span class='p red'>信号量</span>进行操作，从而很方便的实现了进程互斥，进程同步。</p>
</li>
<li>
<span class='p red'>信号量</span>其实就是一个变量(<span class='p blue'>可以是一个整数，也可以是更复杂的记录型变量</span>)，可以用一个信号量来<span class='p red'>表示系统中某种资源的数量</span>，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。
</li>
<li>
<span class='p red'>原语</span>是一种特殊的程序段，其<span class='p red'>执行只能一气呵成，不可被中断</span>。原语是由<span class='p red'>关中断/开中断指令</span>实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。
</li>
<li>
<span class='p red'>一对原语</span>: <span class='p red'>wait(span)</span> 原语和 <span class='p red'>signal(span)</span>原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的<span class='p red'>信号量span</span>其实就是函数调用时传入的一个参数。
</li>
</ul>
<p>wait、signal原语常<span class='p red'>简称为P、V操作</span>（来目荷兰语proberen(测试)  和 Verhogen（增加)。因此做题的时候常常把wait(span)、signal(span)两个操作分别写为<span class='p red'>P(span)、v(span)</span>.</p>
<h3 id="整形信号量"><a class="markdownIt-Anchor" href="#整形信号量"></a> 整形信号量</h3>
<p>用一个<span class='p red'>整数型的变量</span>作为信号量，用来<span class='p red'>表示系统中某种资源的数量</span>。</p>
<p>与普通整数变量的区别:对信号量的操作只有三种，即初始化、P操作、V操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> span = <span class="number">1</span>; 		<span class="comment">//初始化整形信号量span， 表示当前系统中可用的打印机资源数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// “检查”和“上锁”一气呵成,避免了并发、异步导致的问题</span></span><br><span class="line"><span class="comment">// 存在的问题:不满足“让权等待”原则，会发生“忙等”</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> span)</span> &#123;		<span class="comment">// wait 原语，相当于“进入区”</span></span><br><span class="line">    <span class="keyword">while</span>(span &lt;= <span class="number">0</span>);		<span class="comment">// 如果资源数不够，就一直循环等待</span></span><br><span class="line">    span = span<span class="number">-1</span>;			<span class="comment">// 如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> span)</span> &#123; <span class="comment">// signal 原语，相当于退出区</span></span><br><span class="line">    span = span+<span class="number">1</span>;		<span class="comment">// 使用完资源之后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进程P0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">wait(span);			<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...		<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(span);			<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>进程p1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">wait(span);			<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...		<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(span);			<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>…</p>
<p>进程pn</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">wait(span);			<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...		<span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(span);			<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="记录性信号量"><a class="markdownIt-Anchor" href="#记录性信号量"></a> 记录性信号量</h3>
<p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/×记录性信号量的定义×/</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;				<span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> ×<span class="title">L</span>;</span>		<span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/×某进程需要使用资源的时候，通过wait 原语申请 ×/</span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore span)</span>&#123;</span><br><span class="line">    span.value--;</span><br><span class="line">    <span class="keyword">if</span>(span.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果剩余资源数不够,使用block原语使进程从运行态进入阻塞态,并把挂到信号量span的等待队列（即阻塞队列）中</span></span><br><span class="line">        block(span.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/× 进程使用完资源之后，通过signal 原语释放 ×/</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore span)</span> &#123;</span><br><span class="line">    span.value++;</span><br><span class="line">    <span class="keyword">if</span>(span.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程,该进程从阻塞态变为就绪态</span></span><br><span class="line">        wakeup(span.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在考研题目中wait(span)、signal(span)也可以记为P(span)、v(span),这对原语可用于<span class='p red'>实现系统资源的“申请”和“释放”</span>。</p>
<ul>
<li>
<span class='p red'>span.value</span>的初值表示系统中<span class='p red'>某种资源的数目</span>。
</li>
</ul>
<p>对信号量span的<span class='p red'>一次Р操作</span>意味着进程<span class='p red'>请求一个单位的该类资源</span>，因此需要执行span.value–，表示资源数减1，当span.value &lt;0时表示该类资源已分配完毕，因此进程应<span class='p red'>调用block原语进行自我阻塞</span>（当前运行的进程从<span class='p red'>运行态→阻塞态</span>），主动放弃处理机，并插入该类资源的等待队列span.L中。可见，该机制<span class='p red'>遵循了“让权等待”原则</span>  ，不会出现“忙等”现象。</p>
<p>对信号量span的<span class='p red'>一次V操作</span>意味着进程<span class='p red'>释放一个单位的该类资源</span>，因此需要执行span.value++，表示资源数加1，若加1后仍是span.value &lt;=0，表示依然有进程在等待该类资源，因此应<span class='p red'>调用wakeup原语唤醒等待队列中的第一个进程</span>(被唤醒进程从<span class='p red'>阻塞态→就绪态</span>)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/hb43f2aHWPxVBKJ.png" alt="image-20220918104203130" /></p>
<h2 id="用信号量实现进程互斥同步前驱关系"><a class="markdownIt-Anchor" href="#用信号量实现进程互斥同步前驱关系"></a> 用信号量实现进程互斥，同步，前驱关系</h2>
<h3 id="用信号量实现进程互斥"><a class="markdownIt-Anchor" href="#用信号量实现进程互斥"></a> 用信号量实现进程互斥</h3>
<ol>
<li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应该放在临界区）</li>
<li>设置<span class='p red'>互斥信号量</span>mutex，<span class='p red'>初值为1</span>。</li>
<li>在临界区之前执行P(mutex)</li>
<li>在临界区之后执行V(mutex)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/×信号量机制实现互斥×/</span><br><span class="line"><span class="comment">// 要会自己定义记录型信号量，但如果题目中没特别说明,可以把信号量的声明简写成这种形式</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;		<span class="comment">//初始化信号量</span></span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">	...</span><br><span class="line">	P(mutex);		<span class="comment">//使用临界资源前需要加锁</span></span><br><span class="line">	临界区代码段...</span><br><span class="line">	V(mutex);		<span class="comment">//使用临界资源后需要解锁</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">	...</span><br><span class="line">	P(mutex);</span><br><span class="line">    临界区代码段...</span><br><span class="line">    V(mutex);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/QbecB81kEPaAYGC.png" alt="image-20220919090013183" /></p>
<p>注意:对<span class='p red'>不同的临界资源</span>需要<span class='p red'>设置不同的互斥信号量</span>。</p>
<ul>
<li>
<span class='p red'>P、V操作必须成对出现</span>。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。
</li>
</ul>
<h3 id="用信号量实现进程同步"><a class="markdownIt-Anchor" href="#用信号量实现进程同步"></a> 用信号量实现进程同步</h3>
<p>进程同步:要让各并发进程按要求有序地推进。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">P1() &#123;</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，P1、P2并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。</p>
<p>若P2的“代码4”要基于P1的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是在“代码2”之后才会执行。</p>
<p>这就是进程同步问题，让本来异步并发的进程互相配合，有序推进。</p>
<div class="tip "><p>用信号量实现进程同步:</p>
</div>
<p>1.分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码)</p>
<p>2.设置<span class='p red'>同步信号量</span>span,<span class='p red'>初始为0</span>.</p>
<p>3．<span class='p red'>在“前操作”之后执行v(span)</span></p>
<p>4．<span class='p red'>在“后操作”之前执行P(span)</span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/×信号量机制实现同步×/</span><br><span class="line">semaphore span=<span class="number">0</span>;		<span class="comment">//初始化同步信号量，初始值为0</span></span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    V(span);</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    p(span);</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若先执行到v(span)操作，则span++后span=1。之后当执行到P(span)操作时，由于span=1，表示有可用资源，会执行span–，span的值变回0，P2进程不会执行block 原语，而是继续往下执行代码4。</p>
<p>若先执行到P(span)操作，由于span=o，span–后span=-1，表示此时没有可用资源，因此P操作中会执行block原语，主动请求阻塞。之后当执行完代码2，继而执行v(span)操作，span++，使span变回o，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4了</p>
<h3 id="用信号量实现前驱关系"><a class="markdownIt-Anchor" href="#用信号量实现前驱关系"></a> 用信号量实现前驱关系</h3>
<p>进程P1中有句代码span1，P2中有句代码span2 …P3… P6中有句代码span6。这些代码要求按如下前驱图所示的顺序来执行:</p>
<p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作)因此，</p>
<ol>
<li>要为每一对前驱关系各设置一个同步变量</li>
<li>在“前操作”之后对相应的同步变量执行V操作</li>
<li>在“后操作”之前对相应的同步变量执行Р操作</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/8CFe24DmOZjrTGf.png" alt="image-20220919092125479" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/LkapfqP93COxFAl.png" alt="image-20220919092012562" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/xchkXaL2NOoe4Wr.png" alt="image-20220919092333779" /></p>
<h2 id="生产者消费者问题"><a class="markdownIt-Anchor" href="#生产者消费者问题"></a> 生产者消费者问题</h2>
<p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注:这里的“产品”理解为某种数据)</p>
<p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p>
<ul>
<li>
<span class='p red'>只有缓冲区没满时</span>，生产者才能把产品放入缓冲区，否则必须等待。
</li>
<li>
<span class='p red'>只有缓冲区不空时</span>，消费者才能从中取出产品，否则必须等待。
</li>
</ul>
<p>缓冲区是临界资源，各进程必须<span class='p red'>互斥</span>地访问。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/J3uYgdFENSezt5G.png" alt="image-20220919104741067" /></p>
<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>如何用信号量机制(P、V操作）实现生产者、消费者进程的这些功能呢?信号量机制可实现互斥、同步、对一类系统资源的申请和释放。</p>
</div>
<ul>
<li>
<span class='p red'>互斥</span>：设置初值为1的互斥信号量
</li>
<li>
<span class='p red'>同步</span>：设置初值为0的同步信号量（实现“前一后”）
</li>
<li>
<span class='p red'>对一类系统资源的申请和释放</span>:设置一个信号量,初始值即为资源的数量（本质上也属于“同步问题”，若无空闲资源,则申请资源的进程需要等待别的进程释放资源后才能继续往下执行)
</li>
</ul>
<div class="tip "><p>实现方法</p>
</div>
<p>生产者、消费者共享一个<span class='p red'>初始为空、大小为n的缓冲区</span>。</p>
<p>只有<span class='p red'>缓冲区没满</span>时，生产者才能把产品放入缓冲区，否则<span class='p red'>必须等待</span>。</p>
<p>只有<span class='p red'>缓冲区不空</span>时，消费者才能从中取出产品，否则<span class='p red'>必须等待</span>。</p>
<p>缓冲区是临界资源，各进程必须<span class='p red'>互斥地访问</span>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;		<span class="comment">//互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n;		<span class="comment">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;			<span class="comment">//同步信号量,表示产品的数量，也即非空缓冲区的数量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">producer ()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="comment">// 生产一个产品;</span></span><br><span class="line">   		P(empty);   	<span class="comment">//消耗一个空闲缓冲区</span></span><br><span class="line">        P(mutex);</span><br><span class="line">    	<span class="comment">// 把产记放入缓冲区;</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    	V(full);		<span class="comment">// 增加一个产品</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现互斥是在同一进程中进行对PV操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">consumer()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">    P(full);		<span class="comment">// 消耗一个产品（非空缓冲区)</span></span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="comment">//从缓冲区取出一个产品;</span></span><br><span class="line">    V (mutex);</span><br><span class="line">    v(empty);		<span class="comment">// 增加一个空闲缓冲区</span></span><br><span class="line">    <span class="comment">//使用产品;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现两进程的同步关系，是在其中一个进程中执行P，另一进程中执行V</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="tip warning"><p>能否改变相邻的PV操作顺序</p>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">producer ()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="comment">// 生产一个产品;</span></span><br><span class="line">        P(mutex);		<span class="comment">// 1</span></span><br><span class="line">   		P(empty);   	<span class="comment">// 2</span></span><br><span class="line">    	<span class="comment">// 把产记放入缓冲区;</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    	V(full);		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">consumer()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);    <span class="comment">// 3</span></span><br><span class="line">    	P(full);	<span class="comment">// 4	</span></span><br><span class="line">    	<span class="comment">//从缓冲区取出一个产品;</span></span><br><span class="line">    	V (mutex);</span><br><span class="line">    	v(empty);		<span class="comment">// 增加一个空闲缓冲区</span></span><br><span class="line">    	<span class="comment">//使用产品;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若此时缓冲区内已经<span class='p red'>放满产品</span>，则empty=0，full=n。表明这时候只允许消费者来进行访问缓冲区</p>
<p>则生产者进程执行 <span class='p red'>给缓冲区上锁</span></p>
<ul>
<li>使mutex变为0，再执行</li>
<li>由于已没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。消费者进程执行</li>
<li>由于mutex为o，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。</li>
</ul>
<p>这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。</p>
<p>同样的，若缓冲区中没有产品，即full=0，empty=n。按③④①的顺序执行就会发生死锁。因此，<span class='p red'>实现互斥的P操作一定要在实现同步的P操作之后</span>。</p>
<p>V操作不会导致进程阻塞，因此<span class='p red'>两个V操作顺序可以交换</span>。</p>
<div class="tip "><p>总结</p>
</div>
<p>PV操作题目的解题思路:</p>
<ol>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</li>
</ol>
<p>生产者消费者问题是一个互斥、同步的综合问题。</p>
<p>对于初学者来说最难的是发现题目中隐含的<span class='p red'>两对同步关系</span>。</p>
<p>有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。</p>
<p>易错点:实现互斥和实现同步的两个P操作的先后顺序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/vGCZfKM4oVhgEai.png" alt="image-20220927141657032" /></p>
<h2 id="多生产者-多消费者"><a class="markdownIt-Anchor" href="#多生产者-多消费者"></a> 多生产者-多消费者</h2>
<p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/Ak2zW7ygHPnjUx9.png" alt="image-20220927141843887" /></p>
<div class="tip "><p>实现方法</p>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore apple = <span class="number">0</span>;	<span class="comment">//盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;	<span class="comment">//盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;	<span class="comment">//盘子中还可以放多少个水果</span></span><br><span class="line"><span class="comment">// 当缓冲区之后一个的时候可以不是用这个变量 semaphore mutex = 1;	//实现互斥访问盘子（缓冲区）</span></span><br></pre></td></tr></table></figure>
<p>父亲</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dad ()&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">// 准备一个苹果;</span></span><br><span class="line">        P(plate);</span><br><span class="line">		<span class="comment">// 把萃果放入盘子;</span></span><br><span class="line">        V(apple);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>母亲</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mom ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>）&#123;</span><br><span class="line">		<span class="comment">// 准备一个橘子;</span></span><br><span class="line">        P(plate);</span><br><span class="line">        <span class="comment">//把橘子放入盘子;</span></span><br><span class="line">        V(orange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女儿</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">doughter ()&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>）&#123;</span><br><span class="line">		P(apple);</span><br><span class="line">		<span class="comment">// 从盘中取出苹果;</span></span><br><span class="line">        v(plate);</span><br><span class="line">        <span class="comment">// 吃掉苹果;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>儿子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">son()&#123;</span><br><span class="line">	<span class="keyword">while</span>（<span class="number">1</span>）&#123;</span><br><span class="line">		P(orange);</span><br><span class="line">        <span class="comment">// 从盘中取出橘子;</span></span><br><span class="line">        V(plate);</span><br><span class="line">		<span class="comment">// 吃掉橘子;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当缓冲区有两个的时候，<span class='p red'>如果不设置缓冲区互斥访问量</span>的时候，可能会出现，两个生产者同时访问同一块内存，可能发生覆盖的情况，但是需要注意的是：<span class='p red'>实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”</span>.</p>
<h2 id="单生产者多消费者"><a class="markdownIt-Anchor" href="#单生产者多消费者"></a> 单生产者多消费者</h2>
<p>假设一个系统有<span class='p red'>三个抽烟者进程</span>和<span class='p red'>一个供应者进程</span>。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，<span class='p red'>第一个拥有烟草、第二个拥有纸、第三个拥有胶水</span>。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，<span class='p red'>拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了</span>，供应者就会放另外两种材料再桌上，这个过程一直重复（<span class='p red'>让三个抽烟者轮流地抽烟</span>)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/RkMvzZSaKr1WGCA.png" alt="image-20220927144045274" /></p>
<ol>
<li>
<p>关系分析：找出题目中描述的各个进程，分析它们之间的同步，互斥操作：</p>
<ul>
<li>互斥：桌子可以抽象为容量为1的缓冲区，要互斥访问</li>
<li>同步：<span class='p red'>所有操作都做完之后才能让下一个进行，需要按照特定的顺序</span>
<ul>
<li>桌上有组合一→第一个抽烟者取走东西</li>
<li>桌上有组合二→第二个抽烟者取走东西</li>
<li>桌上有组合三→第三个抽烟者取走东西</li>
<li>发出完成信号→供应者将下一个组合放到桌上</li>
</ul>
</li>
</ul>
</li>
<li>
<p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</p>
<ul>
<li>先V后P</li>
</ul>
</li>
<li>
<p>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</p>
</li>
</ol>
<div class="tip "><p>实现方法</p>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;	<span class="comment">//桌上组合一的数量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;	<span class="comment">//桌上组合二的数量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;	<span class="comment">//桌上组合三的数量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;	<span class="comment">//抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;				<span class="comment">//用于实现”三个抽烟者轮流抽烟”</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">provider()&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">// 将组合一放桌上;</span></span><br><span class="line">            V(offer1);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>）&#123;</span><br><span class="line">			<span class="comment">// 将组合二放桌上</span></span><br><span class="line">            V(offer2);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment">// 将组合三放桌上;</span></span><br><span class="line">            V(offer3);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 实现“三个抽象轮流抽象抽象”</span></span><br><span class="line">		i=(i+<span class="number">1</span>)%<span class="number">3</span>;</span><br><span class="line">        P(finish);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">smoker1 ()&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>）&#123;</span><br><span class="line">		P(offer1);</span><br><span class="line">       	<span class="comment">// 从桌上拿走组合一;卷烟;抽掉;</span></span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">smoker2 ()&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>）&#123;</span><br><span class="line">		P(offer2);</span><br><span class="line">       	<span class="comment">// 从桌上拿走组合二;卷烟;抽掉;</span></span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">smoker3 ()&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>）&#123;</span><br><span class="line">		P(offer1);</span><br><span class="line">       	<span class="comment">// 从桌上拿走组合三;卷烟;抽掉;</span></span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读者写者问题"><a class="markdownIt-Anchor" href="#读者写者问题"></a> 读者写者问题</h2>
<p>有读者和写者两组并发进程，共享一个文件，<span class='p red'>当两个或两个以上的读进程同时访问共享数据时不会产生副作用</span>，但若某个<span class='p red'>写进程和其他进程</span>（读进程或写进程）同时访问共享数据时则<span class='p red'>可能导致数据不一致的错误</span>。因此要求:</p>
<ul>
<li>允许多个读者可以同时对文件执行读操作;
<ul>
<li>与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。因此多个读者可同时访问共享数据</li>
</ul>
</li>
<li>只允许一个写者往文件中写信息;</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作;</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
<li>两个写进程同时共享数据，可能导致数据错误覆盖的问题</li>
</ul>
<p>两类进程:写进程、读进程</p>
<ul>
<li>互斥关系:写进程―写进程、写进程―读进程。读进程与读进程不存在互斥问题。</li>
<li>写者进程和任何进程都互斥，设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作。读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对rw执行P、V操作。</li>
<li>如果所有读者进程在访问共享文件之前都执行P(rw)操作，那么会导致各个读进程之间也无法同时访问文件。</li>
</ul>
<p>P(rw)和V(rw)其实就是对共享文件的<span class='p red'>“加锁”和“解锁”</span>。既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，那么我们可以让<span class='p green'>第一个访问文件的读进程“加锁”</span>，<span class='p red'>让最后一个访问完文件的读进程“解锁”</span>。可以设置一个<span class='p red'>整数变量count</span>来记录当前有几个读进程在访问文件。</p>
<div class="tip "><p>如何实现</p>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>;		<span class="comment">//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;		<span class="comment">//记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 用户保证对count变量的互斥访问</span></span><br><span class="line">semaphore w = <span class="number">1</span>; 	<span class="comment">// 用于实现“写优先”</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">writer()&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		P(rw);<span class="comment">//写之前&quot;加锁&quot;</span></span><br><span class="line">		<span class="comment">//写文件...</span></span><br><span class="line">		V(rw);</span><br><span class="line">		<span class="comment">//写之后&quot;解锁”</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">reader ()&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">			P(rw);		<span class="comment">//第一个读进程负责&quot;加锁&quot;</span></span><br><span class="line">		count++;		<span class="comment">//访问文件的读进程数+1</span></span><br><span class="line">		<span class="comment">// 读文件...</span></span><br><span class="line">		count--;		<span class="comment">//访问文件的读进程数-1</span></span><br><span class="line">		<span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">			V(rw);		<span class="comment">//最后一个读进程负责&quot;解锁&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考:若两个读进程并发执行，<span class='p red'>则两个读进程有可能先后执行P(rw)</span>，从而使<span class='p red'>第二个读进程阻塞</span>的情况。</p>
<p>如何解决: 出现上述问题的<span class='p red'>原因在于对count变量的检查和赋值无法一气呵成</span>，因此可以设置另一个互斥信号量来保证<span class='p red'>各读进程对count的访问是互斥的</span>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">reader ()&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex); 		<span class="comment">// 各进程互斥访问count</span></span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">			P(rw);		<span class="comment">//第一个读进程负责&quot;加锁&quot;</span></span><br><span class="line">		count++;		<span class="comment">//访问文件的读进程数+1</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 读文件...</span></span><br><span class="line">        </span><br><span class="line">        P(mutex); 		<span class="comment">// 各进程互斥访问count</span></span><br><span class="line">		count--;		<span class="comment">//访问文件的读进程数-1</span></span><br><span class="line">		<span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">			V(rw);		<span class="comment">//最后一个读进程负责&quot;解锁&quot;</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>潜在的问题:只要有读进程还在读,写进程就要一直阻塞等待,可能“饿死”。因此，这种算法中,读进程是优先的</p>
<ul>
<li>
<span class='p red'>如果第一个读进程加锁之后，后来读进程来之后直接读就行，如果有源源不断的读进程来的话，可能会导致写文件饥饿</span>
</li>
</ul>
<p>解决方法：</p>
<p>我们可以在加锁之前在进行一个读进程和写进程都服从的PV操作，如果一个读进程进入的话 先执行P(W) P(mutex)P(rw)V(mutex);</p>
<p>这时候如果有一个写进程进来的话，我们先执行P(W)，但由于这时候rw还没有释放，所以会被阻塞到P(rw)这里，这时候，如果再有一个读进程进来的话，因为P(w)在写进程哪里使用了，所以下一个读进程需要阻塞到P(w)这里，直到写进程写入完毕之后V(w)之后，下一个读进程才能够读入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">writer()&#123; </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        P(w);</span><br><span class="line">		P(rw);<span class="comment">//写之前&quot;加锁&quot;</span></span><br><span class="line">		<span class="comment">//写文件...</span></span><br><span class="line">		V(rw);</span><br><span class="line">		<span class="comment">//写之后&quot;解锁”</span></span><br><span class="line">        V(w);     </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">reader ()&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(mutex); 		<span class="comment">// 各进程互斥访问count</span></span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">			P(rw);		<span class="comment">//第一个读进程负责&quot;加锁&quot;</span></span><br><span class="line">		count++;		<span class="comment">//访问文件的读进程数+1</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(w);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 读文件...</span></span><br><span class="line">        </span><br><span class="line">        P(mutex); 		<span class="comment">// 各进程互斥访问count</span></span><br><span class="line">		count--;		<span class="comment">//访问文件的读进程数-1</span></span><br><span class="line">		<span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">			V(rw);		<span class="comment">//最后一个读进程负责&quot;解锁&quot;</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="tip "><p>知识回顾</p>
</div>
<p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。</p>
<p>其<span class='p red'>核心思想</span>在于设置了一个<span class='p red'>计数器count</span>用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程,从而做出不同的处理。</p>
<p>另外，对count变量的检查和赋值不能一气呵成导致了一些错误,如果<span class='p red'>需要实现“一气呵成”</span>，<span class='p green'>自然应该想到用互斥信号量</span>。</p>
<h2 id="哲学家进餐"><a class="markdownIt-Anchor" href="#哲学家进餐"></a> 哲学家进餐</h2>
<p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick [<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">Pi ()&#123;		<span class="comment">//i号哲学家的进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>）&#123;</span><br><span class="line">		P(chopstick[i]);	<span class="comment">//拿左</span></span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]）;	<span class="comment">//拿右</span></span><br><span class="line">		<span class="comment">// 吃饭..</span></span><br><span class="line">		v(chopstick[i]);		<span class="comment">//放左</span></span><br><span class="line">		v(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">//放右</span></span><br><span class="line">		<span class="comment">// 思考.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可能会导致死锁问题：<span class='p red'>如果5个哲学家并发地拿起自己左手边的筷子.</span>.</li>
<li>每位哲学家循环等待右达的人放下筷子（阻塞)发生“死锁”</li>
</ul>
<p>解决方法：</p>
<ul>
<li>可以对哲学家进程施加一些限制条件，比如<span class='p red'>最多允许四个哲学家同时进餐</span>。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</li>
<li>要求<span class='p red'>奇数号哲学家先拿左边的筷子</span>，<span class='p red'>然后再拿右边的筷子</span>，<span class='p red'>而偶数号哲学家刚好相反</span>。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。<span class='p red'>这避免了占有一支后再等待另一只的情况</span>。</li>
<li>仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = l;		<span class="comment">//互斥地取筷子</span></span><br><span class="line">Pi ()&#123;		<span class="comment">//i号哲学家的进程</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>）&#123;</span><br><span class="line">		P(mutex);</span><br><span class="line">		P(chopstick [i]);</span><br><span class="line">		<span class="comment">//拿左</span></span><br><span class="line">		P (chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]）;</span><br><span class="line">		<span class="comment">//拿右</span></span><br><span class="line">		V(mutex);</span><br><span class="line">           </span><br><span class="line">		<span class="comment">//吃饭..</span></span><br><span class="line">           </span><br><span class="line">		v(chopstick[i]);</span><br><span class="line">		<span class="comment">//放左</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">		<span class="comment">//放右</span></span><br><span class="line">		<span class="comment">//思考.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>哲学家进餐问题的关键在于解决进程死锁。<br />
这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。<br />
如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，<br />
应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。</p>
</div>
<h2 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h2>
<div class="tip "><p>管程的定义和基本特征</p>
</div>
<p>管程是一种特殊的软件模块，有这些部分组成:</p>
<ol>
<li>局部于管程的<span class='p red'>共享数据结构</span>说明;</li>
<li>对该数据结构进行操作的<span class='p red'>一组过程</span>;</li>
<li>对局部于管程的共享数据设置初始值的语句;</li>
<li>管程有一个名字。</li>
</ol>
<p>管程的基本特征：</p>
<ol>
<li>局部于管程的数据只能被局部于管程的过程所访问;</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据;</li>
<li>
<span class='p red'>每次仅允许一个进程在管程内执行某个内部过程</span>。
</li>
</ol>
<p>管程操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    <span class="comment">// 管程中设置条件变量和等待/唤醒操作，已解决同步问题</span></span><br><span class="line">	conditIOn full,empy;	<span class="comment">// 条件变量用来实现同步(排队)</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;	<span class="comment">// 缓冲区产品的个数</span></span><br><span class="line">	<span class="comment">// 由编译器负责实现各进程互斥地进入管程中的过程</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">insert</span> <span class="params">(Item item)</span>&#123;	<span class="comment">// 把产品item放入缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (count == N)</span><br><span class="line">			wait (full);</span><br><span class="line">        count++;</span><br><span class="line">		insert_item(item);</span><br><span class="line">        <span class="keyword">if</span> ( count == <span class="number">1</span>)</span><br><span class="line">            signal(empty);</span><br><span class="line">    &#125;</span><br><span class="line">	item <span class="title function_">remove</span> <span class="params">()</span>&#123;		<span class="comment">// 从缓冲区中取出一个产品</span></span><br><span class="line">        <span class="keyword">if</span> ( count == <span class="number">0</span>)</span><br><span class="line">            wait (empty);</span><br><span class="line">        count--;</span><br><span class="line">		<span class="keyword">if</span> ( count == N<span class="number">-1</span>)</span><br><span class="line">            signal(full);</span><br><span class="line">		<span class="keyword">return</span> remove_item();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">end monitor;</span><br></pre></td></tr></table></figure>
<p>生产者进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">producer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item=<span class="string">&quot;生产一个产品&quot;</span>;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        item = ProducerConsumer.remove();</span><br><span class="line">        消费产品item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次仅允许一个进程在管程内执行某个内部过程</p>
<p>例1:两个生产者进程并发执行，依次调用了insert过程…</p>
<p>例2:两个消费者进程先执行，生产者进程后执行</p>
<div class="tip "><p>用管程解决生产者和消费者问题</p>
</div>
<p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p>
<ol>
<li>需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</li>
<li>需要在管程中定义用于访问这些共享数据的“入口”一—其实就是一些函数（如生产者消费者<br />
问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)</li>
<li>只有<span class='p red'>通过这些特定的“入口”才能访问共享数据</span>.</li>
<li>管程中有很多“入口”，但是<span class='p red'>每次只能开放其中一个“入口”</span>，并且<span class='p red'>只能让一个进程或线程进入</span>(如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。<span class='p red'>注意:这种互斥特性是由编译器负责实现的，程序员不用关心</span> )</li>
<li>可在管程中设置<span class='p red'>条件变量</span>及 <span class='p red'>等待/唤醒操作</span>以解决同步问题。可以让一个进程或线程在条件变量<br />
上等待（<span class='p red'>此时，该进程应先释放管程的使用权，也就是让出“入口”</span>)﹔可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</li>
</ol>
<p>程序员可以用某种特殊的语法定义一个管程（比如: monitor ProducerConsumer …end monitor;）,之后其他程序员就可以使用这个管程提供的特定“入口”很方便地使用实现进程同步/互斥了。</p>
<p>Java中，如果用关键字synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">monitor</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item buffer[] = <span class="keyword">new</span> <span class="title class_">Item</span>[N];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次只能有一个线程进入insert函数，如果多个线程同时调用insert 函数，则后来者需要排队等待</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">insert</span> <span class="params">(Item item)</span> &#123;</span><br><span class="line">        .....;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/jeFw8A9xDuShamP.png" alt="image-20221001191641818" /></p>
<h2 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2>
<div class="tip "><p>什么是死锁</p>
</div>
<p>在并发环境下，各进程因竞争资源而造成的一种<span class='p red'>互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进</span>的现象，就是“死锁”。发生死锁后若无外力干涉,这些进程都将无法向前推进。</p>
<div class="tip "><p>进程死锁，饥饿，死循环的区别</p>
</div>
<ul>
<li>
<span class='p red'>死锁</span>:各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。
</li>
<li>
<span class='p red'>饥饿</span>:由于长期得不到想要的资源，某进程无法向前推进的现象。比如:在短进程优先(SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。
</li>
<li>
<span class='p red'>死循环</span>:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">区别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">死锁</td>
<td style="text-align:center">死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那<span class='p red'>至少有两个或两个以上的进程同时发生死锁</span>。<br />另外，发生死锁的进程一定处于阻塞态。</td>
</tr>
<tr>
<td style="text-align:center">饥饿</td>
<td style="text-align:center"><span class='p red'>可能只有一个进程发生饥饿</span>。发生饥饿的进程既可能是阻塞态(如长期得不到需要的I/O设备)，<br />也可能是就绪态(长期得不到处理机)</td>
</tr>
<tr>
<td style="text-align:center">死循环</td>
<td style="text-align:center">可能只有一个进程发生死循环。死循环的进程可以上处理机运行（可以是运行态），只不过无法像期待的那样顺利推进。<br />死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<br /><span class='p red'>死锁和饥饿是管理者(操作系统）的问题，死循环是被管理者的问题</span>。</td>
</tr>
</tbody>
</table>
<div class="tip "><p>死锁产生的必要条件</p>
</div>
<p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<ul>
<li>
<span class='p red'>互斥条件</span>:只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。
</li>
<li>
<span class='p red'>不剥夺条件</span>:进程所获得的资源在未使用完之前，<span class='p red'>不能由其他进程强行夺走</span>，只能主动释放。
</li>
<li>
<span class='p red'>请求和保持条件</span>:进程<span class='p red'>已经保持了至少一个资源</span>，但又提出了新的资源<span class='p red'>请求</span>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<span class='p red'>保持</span>不放。
</li>
<li>
<span class='p red'>循环等待条件</span>:存在一种进程<span class='p red'>资源的循环等待链</span>，链中的每一个进程已获得的资源同时被下一个进程所请求。
</li>
</ul>
<p>注意!<span class='p red'>发生死锁时一定有循环等待，但是发生循环等待时未必死锁</span>（循环等待是死锁的必要不充分条件)</p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p>
<div class="tip "><p>什么时候会发生死锁</p>
</div>
<ol>
<li>
<p>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU)）的竞争是不会引起死锁的。</p>
</li>
<li>
<p>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p>
</li>
<li>
<p>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</p>
</li>
</ol>
<p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p>
<div class="tip "><p>死锁的处理策略</p>
</div>
<p>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</p>
<p>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法)</p>
<p>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/FTr6JcIQK2AExWV.png" alt="image-20221001195609338" /></p>
<h2 id="预防死锁"><a class="markdownIt-Anchor" href="#预防死锁"></a> 预防死锁</h2>
<div class="tip "><p>破坏互斥性条件</p>
</div>
<ul>
<li>
<span class='p red'>互斥条件</span>:只有对必须互斥使用的资源的争抢才会导致死锁。
</li>
<li>如果把只能互斥使用的资源改造为<span class='p red'>允许共享使用</span>，则系统不会进入死锁状态。比如: <span class='p red'>SPOOLING技术</span>。操作系统可以采用SPOOLING 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLING技术将打印机改造为共享设备…<br />
入</li>
<li>该策略的<span class='p red'>缺点</span>:并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<span class='p red'>很多时候都无法破坏互斥条件</span>。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/CLstIZJigEPWV9O.png" alt="image-20221001200311790" /></p>
<div class="tip "><p>破会不剥夺条件</p>
</div>
<ul>
<li>
<span class='p red'>不剥夺条件</span>:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
</li>
</ul>
<p>破坏不剥夺条件:</p>
<ul>
<li>方案一:当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。<span class='p red'>得不到的就放手</span>.</li>
<li>方案二:当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如:剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)<span class='p red'>得不到的就把他抢过来</span>.</li>
</ul>
<p>该策略的<span class='p red'>缺点</span>:</p>
<ol>
<li>实现起来比较复杂。</li>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li>
</ol>
<div class="tip "><p>破坏请求和保持条件</p>
</div>
<ul>
<li>
<span class='p red'>请求和保持条件</span>:进程<span class='p red'>已经保持了至少一个资源</span>，但又提出了新的资源<span class='p red'>请求</span>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<span class='p red'>保持</span>不放。
</li>
<li>可以<span class='p red'>采用静态分配方法</span>，即进程在运行前<span class='p red'>一次申请完它所需要的全部资源</span>，在它的资源未满足前，不让它投入运行。一旦投入运行后，<span class='p red'>这些资源就一直归它所有</span>，该进程就不会再请求别的任何资源了。</li>
</ul>
<p>该策略实现起来简单，但也有明显的<span class='p red'>缺点</span>:</p>
<p>有些资源可能只需要用<span class='p red'>很短的时间</span>，因此如果进程的整个运行期间都<span class='p red'>一直保持着所有资源</span>，就会造成严重的资源浪费，<span class='p red'>资源利用率极低</span>。另外，该策略<span class='p red'>也有可能导致某些进程饥饿</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/aD8CElxTPdqc3Jg.png" alt="image-20221001205039864" /></p>
<ul>
<li>例如上面这个程序，如果有源源不断的AB进程涌入过来的话，可能会导致C类进程饥饿</li>
</ul>
<div class="tip "><p>破坏循环等待条件</p>
</div>
<ul>
<li>
<span class='p red'>循环等待条件</span>:存在一种进程<span class='p red'>资源的循环等待链</span>，链中的每一个进程已获得的资源同时被下一个进程所请求。
</li>
<li>可采用<span class='p red'>顺序资源分配法</span>。首先给系统中的资源编号，规定每个进程<span class='p red'>必须按编号递增的顺序请求资源</span>,同类资源（即编号相同的资源）一次申请完。</li>
<li>原理分析:一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/fTrvoO1xN9jSVHa.png" alt="image-20221001205805236" /></p>
<p>该策略的<span class='p red'>缺点</span>:</p>
<ol>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号;</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费;</li>
<li>必须按规定次序申请资源，用户编程麻烦。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/3pvc7DeMT4n6mAK.png" alt="image-20221001195839622" /></p>
<h2 id="避免死锁"><a class="markdownIt-Anchor" href="#避免死锁"></a> 避免死锁</h2>
<div class="tip "><p>安全序列</p>
</div>
<p>所谓<span class='p red'>安全序列</span>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<span class='p red'>安全状态</span>。当然，<span class='p red'>安全序列可能有多个</span>。</p>
<p>如果分配了资源之后，系统中<span class='p red'>找不出任何一个安全序列</span>，系统就进入了<span class='p red'>不安全状态</span>。这就意味着之后<span class='p red'>可能</span>所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那<span class='p red'>系统也有可能重新回到安全状态</span>，不过我们在分配资源之前总是要考虑到最坏的情况。</p>
<p>如果系统处于<span class='p red'>安全状态</span>，就<span class='p red'>一定不会</span>发生<span class='p red'>死锁</span>。如果系统进入<span class='p red'>不安全状态</span>，就<span class='p red'>可能发生死锁</span>（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</p>
<p>因此可以<span class='p red'>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态</span>，以此决定是否答应资源分配请求。这也是“<span class='p red'>银行家算法</span>”的核心思想。</p>
<div class="tip "><p>银行家算法</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/GHpzjAgvEWfaU2F.png" alt="image-20221001211640526" /></p>
<ul>
<li>
<span class='p red'>资源总数10</span>.
</li>
</ul>
<p>此时系统是否处于安全状态?</p>
<p>思路:尝试找出一个安全序列… <span class='p red'>P1，P3，PO，P2，P4</span></p>
<p>依次检查剩余可用资源(3,3,2)是否能满足各进程的需求</p>
<p>可满足P1需求，将P1加入安全序列，并更新剩余可用资源值为(5，3，2)</p>
<p>依次检查剩余可用资源(5,3,2)是否能满足剩余进程（<span class='p red'>不包括已加入安全序列的进程</span>）的需求</p>
<p>可满足P3需求，将P3加入安全序列，并更新剩余可用资源值为(7,4,3)</p>
<p>依次检查剩余可用资源(7,4,3)是否能满足剩余进程（<span class='p red'>不包括已加入安全序列的进程</span>）的需求………</p>
<p>以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列。该算法称为<span class='p red'>安全性算法</span>。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。实际做题时可以更快速的得到安全序列。</p>
<ul>
<li>
<mark class="hl-label red">手算算法</mark> 
</li>
</ul>
<p>实际做题（手算）时可用更快速的方法找到一个安全序列:</p>
<p>经对比发现，(3,3,2）可满足P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3一定可以顺利的执行完，并归还资源。可把P1、P3先加入安全序列。</p>
<p>(2,0,0)+(2,1,1)+(3,3,2)= (7,4,3)</p>
<p>剩下的PO、P2、P4都可被满足。同理，这些进程都可以加入安全序列。</p>
<p>于是，5个进程全部加入安全序列，说明此时系统<span class='p red'>处于安全状态</span>,暂<span class='p red'>不可能发生死锁</span>。</p>
<ul>
<li>在看一个找不到安全序列的例子：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/5VZNOE2LRsBcdmT.png" alt="image-20221001211950766" /></p>
<ul>
<li>
<span class='p red'>资源总数10</span>.
</li>
</ul>
<p>经对比发现，(3,3,2）可满足P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3一定可以顺利的执行完，并归还资源。可把P1、P3先加入安全序列。</p>
<p>(2,0,0)+(2,1,1)+(3,3,2)= (7,4,3)</p>
<p>剩下的P0需要(8,4,3)，P2需要(6,5,0)，P4需要(4,3,4),</p>
<p>任何一个进程都不能被完全满足</p>
<p>于是，无法找到任何一个安全序列，说明此时系统处于<span class='p red'>不安全状态，有可能发生死锁</span>。</p>
<ul>
<li>
<mark class="hl-label red">具体流程</mark> 
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/fkJ1EUvTzrmB5SN.png" alt="image-20221001212935409" /></p>
<p>假设系统中有<span class='p red'>n个进程，m种资源</span>.</p>
<p>每个进程在运行前先声明对各种资源的最大需求数，则可用一个n×m 的矩阵（可用二维数组实现）表示所有进程对各种资源的最大需求数。不妨称为<span class='p red'>最大需求矩阵Max</span>，Max[i, j]=K表示进程Pi最多需要K个资源Rj。同理，系统可以用一个n×m的<span class='p red'>分配矩阵AllocatIOn</span>表示对所有进程的资源分配情况。Max 一 AllocatIOn = <span class='p red'>Need矩阵</span>，表示各进程最多还需要多少各类资源。另外，还要用一个长度为m的一维数组Available表示当前系统中还有多少可用资源。</p>
<p>某进程Pi向系统申请资源，可用一个<span class='p red'>长度为m的一维数组 Request</span>,表示本次申请的各种资源量。</p>
<p>可用银行家算法预判本次分配是否会导致系统进入不安全状态:</p>
<ol>
<li>
<p>如果Request[i]≤Need[ i,  i ] (O≤j≤m)便转向 2 ;否则认为出错。因为它所需要的资源数已超过它所宣布的最大值。</p>
</li>
<li>
<p>如果Request[i]&lt;Available[i,j] (0≤j&lt;m)，便转向③;否则表示尚无足够资源，Pi必须等待。</p>
</li>
<li>
<p>系统<span class='p red'>试探着</span>把资源分配给进程Pi，并修改相应的数据（<span class='p red'>并非真的分配，修改数值只是为了做预判</span>):</p>
<p>Available = Available - Request,;</p>
<p>AllocatIOn[i, j] = AllocatIOn[i, j] + Request;[j]</p>
<p>Need[i, j] = Need[i, j]- Request[j]</p>
</li>
<li>
<p>操作系统执行<span class='p red'>安全性算法</span>，检查此次资源分配后，系统<span class='p red'>是否处于安全状态</span>。若安全，才正式分配;否则，恢复相应数据，让进程阻塞等待。</p>
</li>
</ol>
<div class="tip "><p>回顾</p>
</div>
<p>数据结构:</p>
<p>长度为m的一维数组Available表示还有多少可用资源</p>
<p>n×m矩阵Max表示各进程对资源的最大需求数</p>
<p>n×m矩阵AllocatIOn表示已经给各进程分配了多少资源</p>
<p>Max - AllocatIOn = Need矩阵表示各进程最多还需要多少资源用长度为m的一位数组Request表示进程此次申请的各种资源数</p>
<p>银行家算法步骤:</p>
<ol>
<li>检查此次申请是否超过了之前声明的最大需求数</li>
<li>检查此时系统剩余的可用资源是否还能满足这次请求</li>
<li>试探着分配，更改各数据结构</li>
<li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li>
</ol>
<p>安全性算法步骤:</p>
<ul>
<li>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列并把该进程持有的资源全部回收。</li>
<li>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li>
<li>
<span class='p red'>系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁</span>。
</li>
</ul>
<h2 id="死锁的检测和解除"><a class="markdownIt-Anchor" href="#死锁的检测和解除"></a> 死锁的检测和解除</h2>
<div class="tip "><p>死锁的检测</p>
</div>
<p>为了能对系统是否已发生了死锁进行检测，必须:</p>
<ol>
<li>用<span class='p red'>某种数据结构</span>来保存资源的请求和分配信息;</li>
<li>提供<span class='p red'>一种算法</span>，利用上述信息来检测系统是否已进入死锁状态。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/3L1xm4uTHXIbQtY.png" alt="image-20221001214521421" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/aCvtqWmrRsn8KfH.png" alt="image-20221001214556529" /></p>
<p>一般用矩形表示资源结点，矩形中的小圆代表该类资源的数量</p>
<p>为了能对系统是否已发生了死锁进行检测，必须:</p>
<ol>
<li>用<span class='p red'>某种数据结构</span>来保存资源的请求和分配信息;</li>
<li>提供<span class='p red'>一种算法</span>，利用上述信息来检测系统是否已进入死锁状态。</li>
</ol>
<p>如果系统中剩余的可用资源数足够<span class='p red'>满足进程的需求</span>，那么这个进程<span class='p red'>暂时是不会阻塞的</span>，可以顺利地执行下去。如果这个进程执行<span class='p red'>结束了把资源归还系统</span>，就可能使某些正在等待资源的进程<span class='p red'>被激活</span>，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…</p>
<p>如果按上述过程分析，最终<span class='p red'>能消除所有边</span>，就称这个图是<span class='p red'>可完全简化的</span>。此时一定<span class='p red'>没有发生死锁</span>（相当于能找到一个安全序列)</p>
<p>如果最终<span class='p red'>不能消除所有边</span>，那么此时就是<span class='p red'>发生了死锁</span>。</p>
<ul>
<li>
<span class='p red'>最终还连着边的那些进程就是处于死锁状态的进程</span>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/tUzAYpjOwNuVahS.png" alt="image-20221001215037638" /></p>
<ul>
<li>像上面这个图可以按照p1 p2 这个方式进行的话就可以消除所有的边</li>
</ul>
<p>检测死锁的算法:</p>
<ol>
<li>在资源分配图中，找出<span class='p red'>既不阻塞又不是孤点的</span>进程Pi(即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。<span class='p red'>消去它所有的请求边和分配边</span>，使之称为孤立的结点。在下图中P1是满足这一条件的进程结点，于是将P1的所有边消去。</li>
<li>进程Pi所释放的资源，可以<span class='p red'>唤醒某些因等待这些资源而阻塞的进程</span>，原来的阻塞进程可能变为非阻塞进程。在下图中，P2就满足这样的条件。根据1）中的方法进行一系列简化后，若能消去途中所有的边，则称该图是<span class='p red'>可完全简化</span>的,那么此时系统<span class='p red'>死锁</span>.</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/mWlvwrOZoN6EetS.png" alt="image-20221001215856857" /></p>
<ul>
<li>
<span class='p red'>死锁定理</span>:如果某时刻系统的资源分配图是<span class='p red'>不可完全简化的</span>，那么此时系统<span class='p red'>死锁</span>.
</li>
</ul>
<div class="tip "><p>死锁的解除</p>
</div>
<p>一旦检测出死锁的发生，就应该立即解除死锁。<br />
补充:并不是系统中所有的进程都是死锁状态，用死锁检测算法<span class='p red'>化简资源分配图后，还连着边的那些进程就是死锁进程</span>.</p>
<p>解除死锁的主要方法有:</p>
<ol>
<li>
<span class='p red'>资源剥夺法</span>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。
</li>
<li>
<span class='p red'>撤销进程法</span>（或称<span class='p red'>终止进程法</span>）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。
</li>
<li>
<span class='p red'>进程回退法</span>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/PcNt1bOhsqBQLSW.png" alt="image-20221001220633161" /></p>
<ul>
<li>如何决定“对那个进程执行操作”</li>
</ul>
<ol>
<li>进程优先级</li>
<li>已执行多长时间还要多久能完成</li>
<li>进程已经使用了多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/dEDiebmBapVzw6Y.png" alt="image-20221001213545200" /></p>
<h1 id="操作系统第三章内存管理"><a class="markdownIt-Anchor" href="#操作系统第三章内存管理"></a> 操作系统第三章：内存管理</h1>
<h2 id="内存的基础知识"><a class="markdownIt-Anchor" href="#内存的基础知识"></a> 内存的基础知识</h2>
<div class="tip "><p>什么是内存，有何作用？</p>
</div>
<p>内存是用于存放数据的硬件。程序执行前需要<span class='p red'>先放到内存中才能被CPU处理</span>。</p>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>思考:在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢?</p>
<p>方案:给内存的存储单元编地址</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/klc78iyZrJGt9dM.png" alt="image-20221003083025408" /></p>
<p>内存中也有一个一个的“小房间”，每个小房间就是一个“<span class='p red'>存储单元</span>”</p>
<p>如果计算机“<span class='p red'>按字节编址</span>’则<span class='p red'>每个存储单元大小为1字节</span>，即1B，即8个二进制位</p>
<p>如果<span class='p red'>字长为16位</span>的计算机“<span class='p red'>按字编址</span>”，则每个<span class='p red'>存储单元大小为1个字</span>;每字的大小为16个二进制位</p>
<div class="tip "><p>逻辑地址和物理地址</p>
</div>
<p>我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址存/取数据,这个数据应该做什么样的处理。在这个例子中，指令中直接给出了变量x的实际存放地址（<span class='p red'>物理地址</span>）。但实际在生成机器指令的时候并不知道该进程的数据会被放到什么位置。所以编译生成的指令中一般是使用逻辑地址（<span class='p red'>相对地址</span>)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/EYx674mOldJHVuS.png" alt="image-20221003083800093" /></p>
<p>宿舍四个人一起出去旅行，四个人的学号尾号分别是0、1、2、3。</p>
<p>住酒店时酒店给你们安排了4个房号相连的房间。四个人按学号递增次序入住房间。<span class='p red'>比如0、1、2、3号同学分别入住了5、6、7、8号</span>房间。</p>
<p>四个人的编号0、1、2、3其实是一个“相对位置”，而各自入住的房间号是一个“绝对位置”。只要知道0号同学住的是房号为N的房间，那么M号同学的房号一定是N+M。</p>
<p>也就是说，只要知道各个同学的<span class='p red'>“相对位置”和“起始房号”</span>，就一定可以算出所有同学的“<span class='p red'>绝对位置</span>”</p>
<p>指令中的地址也可以采用这种思想。编译时产生的<span class='p red'>指令只关心“相对地址”</span>，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</p>
<p>Eg:编译时只需确定变量X存放的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU想要找到X在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p>
<ul>
<li>
<span class='p red'>相对地址又称逻辑地址，绝对地址又称物理地址</span>。
</li>
</ul>
<div class="tip "><p>逻辑地址和物理地址的互相转换</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/z61oEnDFLcNtIsS.png" alt="image-20221003084631937" /></p>
<ul>
<li>
<span class='p red'>编译</span>:由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言<span class='p red'>翻译为机器语言</span>，注意<span class='p green'>这里面的地址是逻辑地址</span>)
</li>
<li>
<span class='p red'>链接</span>:由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块装入（装载）:由装入程序将装入,<span class='p red'>这时候的地址是完整的逻辑地址</span>.
</li>
<li>
<p>模块装入内存运行，<span class='p red'>这时候的地址是物理地址</span>.</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/RLDfso2JbvadUgY.png" alt="image-20221003085055401" /></p>
<ul>
<li>如上面图片中所表达的，如果从内存地址为100的地址开始依此执行装入模块中的指令的话，如果<span class='p red'>不进行逻辑地址的转换</span>,那么这时候会向地址为80的地址写入数据，会导致程序出错</li>
<li>装入的三种方式（用三种不同的方法完成<span class='p red'>逻辑地址到物理地址的转换</span>）:
<ol>
<li>绝对装入</li>
<li>静态重定位</li>
<li>动态重定位</li>
</ol>
</li>
</ul>
<h3 id="装入的三种方式"><a class="markdownIt-Anchor" href="#装入的三种方式"></a> 装入的三种方式</h3>
<div class="tip "><p>绝对装入</p>
</div>
<ul>
<li>
<span class='p red'>绝对装入</span>:在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码.装入程序按照装入模块中的地址，将程序和数据装入内存。
</li>
<li>Eg:如果知道装入模块要从地址为100的地方开始存放…</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/1FQOkIzYsMd9rVt.png" alt="image-20221003090305334" /></p>
<ul>
<li>绝对装入<span class='p red'>只适用于单道程序环境</span>因为单道程序环境在同一时刻只会有一个程序在运行，我们可以规定每个程序的起始位置。</li>
<li>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</li>
</ul>
<div class="tip "><p>静态重定位</p>
</div>
<ul>
<li>
<span class='p red'>静态重定位</span>:又称<span class='p red'>可重定位装入</span>。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。<span class='p red'>装入时对地址进行“重定位”</span>，将<span class='p red'>逻辑地址</span>变换为<span class='p red'>物理地址</span>（地址变换是在装入时一次完成的）。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/lyZrP4cxgwmvkCt.png" alt="image-20221003090640751" /></p>
<ul>
<li>静态重定位的特点是在一个作业装入内存时，<span class='p red'>必须分配其要求的全部内存空间</span>，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，<span class='p red'>在运行期间就不能再移动</span>，也不能再申请内存空间。</li>
</ul>
<div class="tip "><p>动态重定位</p>
</div>
<ul>
<li>
<span class='p red'>动态重定位</span>:又称<span class='p red'>动态运行时装入</span>。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<span class='p red'>把地址转换推迟到程序真正要执行时才进行</span>。因此<span class='p red'>装入内存后</span>所有的地址<span class='p red'>依然是逻辑地址</span>。这种方式需要一个<span class='p red'>重定位寄存器</span>的支持。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/efrQWPuN7L6YlAx.png" alt="image-20221003091050374" /></p>
<p>采用动态重定位时<span class='p red'>允许程序在内存中发生移动</span>。</p>
<p>优点：</p>
<ul>
<li>可将程序分配到不连续的存储区中;在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存;</li>
<li>便于程序段的共享,可以向用户提供一个比存储空间大得多的地址空间。</li>
</ul>
<h3 id="链接的三种方式"><a class="markdownIt-Anchor" href="#链接的三种方式"></a> 链接的三种方式</h3>
<div class="tip "><p>静态链接</p>
</div>
<ul>
<li>
<span class='p red'>静态链接</span>:在程序运行之前先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）,<span class='p red'>之后不再拆开</span>。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/Ll46wnuvpO23xes.png" alt="image-20221003091356872" /></p>
<div class="tip "><p>装入时动态链接</p>
</div>
<ul>
<li>
<span class='p red'>装入时动态链接</span>:将各目标模块装入内存时，<span class='p red'>边装入边链接的链接方式</span>。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/8WFDUyHpZsizCLY.png" alt="image-20221003091523174" /></p>
<div class="tip "><p>运行时动态链接</p>
</div>
<ul>
<li>
<span class='p red'>运行时动态链接</span>:在程序执行中<span class='p red'>需要该目标模块时</span>。其优点是<span class='p red'>便于修改和更新，便于实现对目标模块的共享</span>。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/ztOiYwkfbge1dIH.png" alt="image-20221003091711144" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/1AJLbGcV3R5pIOa.png" alt="image-20221003091927836" /></p>
<h2 id="内存管理的概念"><a class="markdownIt-Anchor" href="#内存管理的概念"></a> 内存管理的概念</h2>
<div class="tip "><p>内存空间的分配与回收</p>
</div>
<ol>
<li>操作系统要怎么记录哪些内存区域已经被分配出去了，哪些又还空闲?</li>
<li>如果一个进程过来之后，内存中有许多位置都是空闲的要怎么确定放的位置？</li>
<li>当进程结束之后，如何将进程占用的内存进行回收？</li>
</ol>
<div class="tip "><p>内存空间的扩展</p>
</div>
<ul>
<li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</li>
<li>操作系统的虚拟性</li>
</ul>
<div class="tip "><p>地址的转换</p>
</div>
<p>操作系统需要提供地址转换功能，负责程序的<span class='p red'>逻辑地址与物理地址</span>的转换.</p>
<p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<span class='p red'>逻辑地址到物理地址的转换</span>（这个过程称为<span class='p red'>地址重定位</span>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/eihgCv82PToHzyq.png" alt="image-20221003094149029" /></p>
<div class="tip "><p>内存保护</p>
</div>
<p>操作系统需要提供<span class='p red'>内存保护</span>功能。保证各进程在<span class='p red'>各自存储空间内运行，互不干扰</span>.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/GJgfbvpK5TekOqj.png" alt="image-20221003094544770" /></p>
<p>每个进程都只能访问自己的内存空间，不能够访问其他进程的，或者是操作系统的</p>
<p>内存保护可采取两种方法:<br />
方法一:在CPU中<span class='p red'>设置一对上、下限寄存器</span>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p>
<p>方法二:采用<span class='p red'>重定位寄存器</span>（又称<span class='p red'>基址寄存器</span>）和<span class='p green'>界地址寄存器</span>（又称<span class='p green'>限长寄存器</span>）进行越界检查。重定位寄存器中存放的是进程的<span class='p red'>起始物理地址</span>。界地址寄存器中存放的是进程的<span class='p green'>最大逻辑地址</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/IFopmPtNuVDJQ1C.png" alt="image-20221003095052600" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/7KHOCvpYdezPVMl.png" alt="image-20221003095114946" /></p>
<h2 id="覆盖与交换"><a class="markdownIt-Anchor" href="#覆盖与交换"></a> 覆盖与交换</h2>
<h3 id="覆盖技术"><a class="markdownIt-Anchor" href="#覆盖技术"></a> 覆盖技术</h3>
<p>早期的计算机内存很小，比如 IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。</p>
<p>后来人们引入了<span class='p red'>覆盖技术</span>,用来<span class='p red'>解决“程序大小超过物理内存总和”的问题</span>.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/ThIGjimO3vya1lE.png" alt="image-20221003105827945" /></p>
<p>覆盖技术的思想:将<span class='p red'>程序分为多个段</span>（多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。</p>
<p>内存中分为<span class='p red'>一个“固定区”</span>和<span class='p red'>若干个“覆盖区”</span>。</p>
<p>需要常驻内存的段放在“<span class='p red'>固定区</span>”中，<span class='p red'>调入后就不再调出</span>(除非运行结束)</p>
<p>不常用的段放在“<span class='p red'>覆盖区</span>”，<span class='p red'>需要用到时调入内存，用不到时调出内存</span>.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/wzyq5n2D1QR4YCo.png" alt="image-20221003150640307" /></p>
<p>B和C只能由A调用，BC在同一时间段只能有一个进程使用，同理，DEF在同一时间段只能由一个程序唤醒</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/1GrjAitwe5WxBFk.png" alt="image-20221003150920495" /></p>
<ul>
<li>按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区</li>
<li>
<span class='p red'>必须由程序员声明覆盖结构</span>，操作系统完成自动覆盖。
</li>
<li>
<span class='p red'>缺点:对用户不透明</span>，增加了用户编程负担。
</li>
<li>覆盖技术只用与早期操作系统，现在已经成为历史</li>
</ul>
<h3 id="交换技术"><a class="markdownIt-Anchor" href="#交换技术"></a> 交换技术</h3>
<p>交换（对换）技术的设计思想:内存空间紧张时，系统将内存中某些进程暂时<span class='p red'>换出</span>外存，把外存中某些已具备运行条件的进程<span class='p red'>换入</span>内存（进程在内存与磁盘间动态调度)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/vR9b2nwifNGZjCD.png" alt="image-20221003152045524" /></p>
<ul>
<li>
<span class='p red'>中级调度（内存调度）</span>，就是要决定将哪个处于挂起状态的进程重新调入内存。
</li>
<li>在进程调出内存的时候，PCB不会跟着一起调出，因为PCB还需要在内存中控制程序的调入。</li>
</ul>
<p>暂时换出外存等待的进程状态为<span class='p red'>挂起状态（挂起态，suspend）</span></p>
<p>挂起态又可以进一步细分为<span class='p red'>就绪挂起、阻塞挂起</span>两种状态</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/O3lvU1EgeuxVJrM.png" alt="image-20221003152454576" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/OCctLJoXnr5IhRs.png" alt="image-20221003153331681" /></p>
<ol>
<li>
<p>应该在外存（磁盘）的什么位置保存被换出的进程?</p>
<p>具有对换功能的操作系统中，通常把磁盘空间分为<span class='p red'>文件区</span>和<span class='p red'>对换区</span>两部分。<span class='p red'>文件区</span>主要用于存放文件，<span class='p red'>主要追求存储空间的利用率</span>，因此对文件区空间的管理<span class='p red'>采用离散分配方式;对换区</span>空间只占磁盘空间的小部分，<span class='p red'>被换出的进程数据就存放在对换区</span>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<span class='p red'>主要追求换入换出速度</span>，因此通常对换区<span class='p red'>采用连续分配方式</span>（学过文件管理章节后即可理解）。总之，<span class='p red'>对换区的I/O速度比文件区的更快</span>。</p>
</li>
<li>
<p>什么时候应该交换?</p>
<p>交换通常在许多进程运行且<span class='p red'>内存吃紧</span>时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生<span class='p red'>缺页</span>，就说明内存紧张，此时可以换出一些进程;如果<span class='p red'>缺页率明显下降</span>，就可以暂停换出。</p>
</li>
<li>
<p>应该换出哪些进程?</p>
<p>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</p>
</li>
</ol>
<p>注意:<span class='p red'>PCB会驻内存</span>，不会被换出外存)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/gw8Eye59ukF7bRv.png" alt="image-20221003154305908" /></p>
<h2 id="连续分配管理方式"><a class="markdownIt-Anchor" href="#连续分配管理方式"></a> 连续分配管理方式</h2>
<h3 id="单一连续分配"><a class="markdownIt-Anchor" href="#单一连续分配"></a> 单一连续分配</h3>
<p>在单一连续分配方式中，内存被分为<span class='p red'>系统区</span>和<span class='p red'>用户区</span>。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。</p>
<p>内存中<span class='p red'>只能有一道用户程序</span>，用户程序独占整个用户区空间。</p>
<ul>
<li>
<span class='p red'>优点</span>:实现简单;<span class='p red'>无外部碎片</span>;可以采用覆盖技术扩充内存;不一定需要采取内存保护(eg:早期的PC操作系统MS-DOS)。
</li>
<li>
<span class='p red'>缺点</span>:只能用于单用户、单任务的操作系统中;<span class='p red'>有内部碎片</span>;存储器利用率极低。
</li>
<li>内部碎片：内存已经给这个用户分配了，但是用户没有使用，内存利用率低</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/OkwBVWiJ7Z3NCj4.png" alt="image-20221003164842581" /></p>
<h3 id="固定分区分配"><a class="markdownIt-Anchor" href="#固定分区分配"></a> 固定分区分配</h3>
<p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将<span class='p red'>整个用户空间</span>划分为<span class='p red'>若干个固定大小的分区</span>，在<span class='p red'>每个分区中只装入一道作业</span>，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p>
<p>分区方式：</p>
<ul>
<li>分区大小相等
<ul>
<li>缺乏灵活性，但是很<span class='p red'>适合用于用一台计算机控制多个相同对象的场合</span>（比如:钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序)</li>
</ul>
</li>
<li>分区大小不等
<ul>
<li>增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如:划分多个小分区、适量中等分区少量大分区)</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/G4kX9wbYmOPWxRn.png" alt="image-20221003165818574" /></p>
<p>操作系统需要建立一个数据结构—<span class='p red'>分区说明表</span>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<span class='p red'>大小、起始地址、状态</span>（是否已分配）。</p>
<p>用数据结构的数组(或链表)即可表示这表</p>
<p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个<span class='p red'>能满足大小的、未分配的分区</span>，将之分配给该程序,然后修改状态为“已分配”。</p>
<p>优点:实现简单，<span class='p red'>无外部碎片</span>。</p>
<p>缺点:</p>
<ul>
<li>当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能;</li>
<li>会产生内部碎片，内存利用率低。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/EqzNhR2oiMmsKly.png" alt="image-20221003202510614" /></p>
<h3 id="动态分区分配"><a class="markdownIt-Anchor" href="#动态分区分配"></a> 动态分区分配</h3>
<ul>
<li>
<span class='p red'>动态分区分配</span>又称为<span class='p red'>可变分区分配</span>。这种分配方式<span class='p red'>不会预先划分内存分区</span>，而是在进程装入内存时<span class='p red'>根据进程的大小动态地建立分区</span>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。(eg:假设某计算机内存大小为64MB，系统区8MB
用户区共56 MB…)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/3giWLNq7DjSFCr9.png" alt="image-20221003203004766" /></p>
<div class="tip "><p>系统要用什么样的数据结构记录内存的使用情况?</p>
</div>
<ul>
<li>空闲分区表</li>
</ul>
<p>空闲分区表:每个空闲分区对应一个表项。</p>
<p>表项中包含分区号、分区大小、分区起始地址等信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/Awj6nbPm9WB7FhK.png" alt="image-20221003203227786" /></p>
<ul>
<li>空闲分区链：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/gVHT5fJ4BDYd1R2.png" alt="image-20221003203318982" /></p>
<p>空闲分区链:每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</p>
<div class="tip "><p>当很多个空闲分区都能满足需求时,应该选择哪个分区进行分配?</p>
</div>
<ul>
<li>当一个新进程过来之后，如果多个空闲地方都满足这个进程的话，我们应该选择使用最大的分区进行分配，还是用最小的分区进行分配，又或者用地址最低的部分进行分配</li>
<li>把一个新作业装入内存时，须按照一定的<span class='p red'>动态分区分配算法</span>，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。</li>
</ul>
<div class="tip "><p>如何进行分区的分配与回收操作?</p>
</div>
<ol>
<li>
<p>情况一：回收区的后面有一个相邻的空闲分区</p>
<p>两个空闲分区合并为一个</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/wDdfG9JBYVCK4P1.png" alt="image-20221003204424081" /></p>
<ol start="2">
<li>
<p>情况二：回收区的前面有一个相邻的空闲分区，两个空闲分区合并为一个</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/23evPGWXFUhmkZr.png" alt="image-20221003204513309" /></p>
<ol start="3">
<li>
<p>情况三：回收区前后都有一个空闲分区，三个相邻的分区合并为一个</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/gqBCDhfLHZ2k7s5.png" alt="image-20221003204557564" /></p>
</li>
<li>
<p>情况四：回收区前后都没有空闲分区</p>
<p>新增一个表项</p>
<p>注:各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/whoGr6Y8dztmZCH.png" alt="image-20221003204732357" /></p>
</li>
</ol>
<ul>
<li>
<span class='p red'>动态分区分配</span>又称为<span class='p red'>可变分区分配</span>。这种分配方式<span class='p red'>不会预先划分内存分区</span>，而是在进程装入内存时，<span class='p red'>根据进程的大小动态地建立分区</span>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。
</li>
<li>动态分区分配<span class='p red'>没有内部碎片</span>，但是<span class='p red'>有外部碎片</span>。
<ul>
<li>
<mark class="hl-label red">内部碎片</mark> ，分配给某进程的内存区域中，如果有些部分没有用上。
</li>
<li>
<mark class="hl-label red">外部碎片</mark> ，是指内存中的某些空闲分区由于太小而难以利用。
</li>
</ul>
</li>
</ul>
<p>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。</p>
<p>可以通过<span class='p red'>紧凑（拼凑</span>技术来解决外部碎片</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/zStVqAfOwYohZFP.png" alt="image-20221003205450402" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/bSTsdErcoj5LvOX.png" alt="image-20221003205642871" /></p>
<h2 id="动态分配算法"><a class="markdownIt-Anchor" href="#动态分配算法"></a> 动态分配算法</h2>
<h3 id="首次适应算法first-fit"><a class="markdownIt-Anchor" href="#首次适应算法first-fit"></a> 首次适应算法(First Fit)</h3>
<ul>
<li>
<span class='p red'>算法思想</span>:每次都从低地址开始查找，找到第一个能满足大小的空闲分区。
</li>
<li>
<span class='p red'>如何实现:空闲分区以地址递增的次序排列</span>。每次分配内存时顺序查找<span class='p red'>空闲分区链</span>（或<span class='p red'>空闲分区表</span>)，找到大小能满足要求的第一个空闲分区。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/xHD8FBuwUlbKype.png" alt="image-20221003210432119" /></p>
<h3 id="最佳适应算法best-fit"><a class="markdownIt-Anchor" href="#最佳适应算法best-fit"></a> 最佳适应算法(Best Fit)</h3>
<ul>
<li>
<span class='p red'>算法思想</span>:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。
</li>
<li>
<span class='p red'>如何实现</span>:空闲分区<span class='p red'>按容量递增次序链接</span>。每次分配内存时顺序查找<span class='p red'>空闲分区链</span>（或<span class='p red'>空闲分区表</span>），找到大小能满足要求的第一个空闲分区。
</li>
<li>
<mark class="hl-label red">缺点:每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</mark> .
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/QGdyL3aRDVSK7rF.png" alt="image-20221003211517737" /></p>
<h3 id="最坏适应算法worst-fit"><a class="markdownIt-Anchor" href="#最坏适应算法worst-fit"></a> 最坏适应算法(Worst Fit)</h3>
<p>又称<span class='p red'>最大适应算法</span>（Largest Fit)</p>
<ul>
<li>
<span class='p red'>算法思想</span>:为了解决最佳适应算法的问题一一即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。
</li>
<li>
<span class='p red'>如何实现</span>:空闲分区<span class='p red'>按容量递减次序链接</span>。每次分配内存时顺序查找<span class='p red'>空闲分区链</span>（或<span class='p red'>空闲分区表</span>)，找到大小能满足要求的第一个空闲分区。
</li>
</ul>
<p>缺点：</p>
<ul>
<li>每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会<span class='p red'>导致较大的连续空闲区被迅速用完</span>。如果之后<span class='p red'>有“大进程”到达，就没有内存分区可用了</span>。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/ouH8D5wmBLW4Ix9.png" alt="image-20221003211951431" /></p>
<h3 id="邻近适应算法next-fit"><a class="markdownIt-Anchor" href="#邻近适应算法next-fit"></a> 邻近适应算法(Next Fit)</h3>
<ul>
<li>
<span class='p red'>算法思想</span>:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也<span class='p red'>增加了查找的开销</span>。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
</li>
<li>
<span class='p red'>如何实现</span>:空闲分区以地址递增的顺序排列(可排成一个<span class='p red'>循环链表</span>）。每次分配内存时<span class='p red'>从上次查找结束的位置开始</span>查找<span class='p red'>空闲分区链</span>（或空闲分区表)，找到大小能满足要求的第一个空闲分区。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/Sg3F5bHTAIM4xmJ.png" alt="image-20221003212433892" /></p>
<p>首次适应算法每次都<span class='p red'>要从头查找</span>，每次都需要检索低地址的小分区但是这种规则也决定了当低地址部分有更小的分区可以满足需求时会更有可能用到低地址部分的小分区，也会<span class='p red'>更有可能把高地址部分的大分区保留下来</span>（最佳适应算法的优点）</p>
<p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有<span class='p red'>相同的概率被使用</span>，也就导致了<span class='p red'>高地址部分的大分区更可能被使用</span>，划分为小分区，<span class='p red'>最后导致无大分区可用</span>（最大适应算法的缺点)</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">算法思想</th>
<th style="text-align:center">分区排列顺序</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">首次适应</td>
<td style="text-align:center">从头到尾找到合适的分区</td>
<td style="text-align:center">空闲分区以地址<br />递增次序排列</td>
<td style="text-align:center">综合看性能最好。算<br/>法开销小，回收分区后一般<br />不需要对空闲分区队列重新排序</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">最佳适应</td>
<td style="text-align:center">优先使用更小的分区，<br />以保留更多大的分区</td>
<td style="text-align:center">空闲分区以容量<br />递增次序排列</td>
<td style="text-align:center">会有更多的大分区被保留下来，<br />更能满足大进程需求</td>
<td style="text-align:center">会产生很多太小的、<br />难以利用的碎片;<br />算法开销大回收分区后可能需要对空闲分区队列重新排序</td>
</tr>
<tr>
<td style="text-align:center">最坏适应</td>
<td style="text-align:center">优先使用更大的分区<br />以防止生产太小不可使用的碎片</td>
<td style="text-align:center">空闲分区以容量<br />递减次序排列</td>
<td style="text-align:center">可以减少难以利用<br />的小碎片</td>
<td style="text-align:center">大分区容易被用完，<br />不利于大进程;算法开销大(原因同上)</td>
</tr>
<tr>
<td style="text-align:center">临近适应</td>
<td style="text-align:center">由首次适应演变而来<br />每次从上次查完之后<br />的位置开始查找</td>
<td style="text-align:center">空闲分区以地址<br />递增次序排列<br />(可排列成循环链表)</td>
<td style="text-align:center">不用每次都从<br />低地址的<br />小分区开始检索。<br />算法开销小<br />（原因同首次适应算法)</td>
<td style="text-align:center">会使高地址的大分区也被用完</td>
</tr>
</tbody>
</table>
<h2 id="基本分页存储管理的基本概念"><a class="markdownIt-Anchor" href="#基本分页存储管理的基本概念"></a> 基本分页存储管理的基本概念</h2>
<div class="tip "><p>思考：连续分配的缺点</p>
</div>
<p>考虑支持多道程序的两种连续分配方式:</p>
<ol>
<li>固定分区分配:缺乏灵活性，会产生大量的内部碎片，内存的利用率很低。</li>
<li>动态分区分配:会产生很多外部碎片，虽然可以用“紧凑”技术来处理,但是“紧凑”的时间代价很高</li>
</ol>
<p>如果允许将一个进程<span class='p red'>分散地装入到许多不相邻的分区中</span>，便可充分地利用内存，而无需再进行“紧凑”</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/kW7Bo8ciTKAgUZY.png" alt="image-20221003214915271" /></p>
<ul>
<li>
<span class='p red'>连续分配</span>:为用户进程分配的必须是一个<span class='p red'>连续的内存空间</span>。
</li>
<li>
<span class='p red'>非连续分配</span>:为用户进程分配的可以是一些<span class='p red'>分散的内存空间</span>。
</li>
</ul>
<h3 id="分页存储管理的基本概念"><a class="markdownIt-Anchor" href="#分页存储管理的基本概念"></a> 分页存储管理的基本概念</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/pYeOmjRrPvhbXIw.png" alt="image-20221003215516823" style="zoom: 80%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/BcTG3xQaZ4tWi2U.png" alt="image-20221003215532449" style="zoom:67%;" /></p>
<p>将内存空间分为一个个<span class='p red'>大小相等的分区</span>（比如:每个分区4KB），每个分区就是一个“<span class='p red'>页框</span>”，或称“<span class='p red'>页帧</span>”、“<span class='p red'>内存块</span>”、“<span class='p red'>物理块</span>”。每个页框有一个编号，即“<span class='p red'>页框号</span>”(或者“<span class='p red'>内存块号</span>”、“<span class='p red'>页帧号</span>”、“<span class='p red'>物理块号</span>”)页框号<span class='p red'>从0开始</span>。</p>
<p>将用户进程的地址空间也分为<span class='p red'>与页框大小相等</span>的一个个区域，称为“<span class='p red'>页</span>”或“<span class='p red'>页面</span>”。每个页面也有一个编号，即“页号”页号也是从0开始。（注:进程的最后一个页面可能没有一个页框那么大。因此，<span class='p red'>页框不能太大，否则可能产生过大的内部碎片</span>)</p>
<p>操作系统<span class='p red'>以页框为单位为各个进程分配</span>内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的<span class='p red'>页面</span>与内存的页框有<span class='p red'>一一对应</span>的关系。</p>
<p>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p>
<h3 id="如何实现地址的转换"><a class="markdownIt-Anchor" href="#如何实现地址的转换"></a> 如何实现地址的转换</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/ZMUJgfn3bQ5WSAo.png" alt="image-20221003223024132" /></p>
<ul>
<li>如果这时候CPU正在执行指令1，我们需要去寻找地址为80的页面，我们如何将80这个逻辑地址，改变成物理地址</li>
<li>逻辑地址为80的内存单元: 应该在<span class='p red'>1号页</span>，该页在内存中的<span class='p red'>起始位置为450</span>，逻辑地址为80的内存单元相对于该页的起始地址而言,<span class='p red'>“偏移量”应该是30</span>。</li>
</ul>
<p>逻辑地址转换成物理地址</p>
<ol>
<li>要算出逻辑地址对应的页号</li>
<li>要知道该页号对应页面在内存中的起始地址</li>
<li>要算出逻辑地址在页面内的“偏移量”</li>
<li>物理地址 = 页面地址 + 页内偏移量</li>
</ol>
<div class="tip "><p>页号，页内偏移量的计算</p>
</div>
<ul>
<li>
<span class='p red'>页号</span>=逻辑地址/页面长度(取除法的<span class='p red'>整数</span>部分)
</li>
<li>
<span class='p red'>页内偏移量</span>=逻辑地址%页面长度（取除法的<span class='p red'>余数</span>部分)
</li>
<li>
<span class='p red'>页面在内存中的起始位置</span>:操作系统需要用某种数据结构记录进程各个页面的起始位置。
</li>
</ul>
<p>在计算机中为了方便计算页号，页内偏移量，页面大小一般使用2的整数幂</p>
<p>假设用32个二进制位表示逻辑地址，页面大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{12}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>= 4096B= 4KB</p>
<p>0号页的逻辑地址空间应该是0~4095，用二进制表示应该是:</p>
<p>00000000000000000000  000000000000~00000000000000000000   111111111111</p>
<p>1号页的逻辑地址空间应该是4096~8191，用二进制表示应该是:</p>
<p>00000000000000000001  000000000000 ~ 00000000000000000001   111111111111</p>
<p>2号页的逻辑地址空间应该是8192~12287，用二进制表示应该是:</p>
<p>00000000000000000010  000000000000~000000000000000000101   111111111111</p>
<ul>
<li>
<span class='p red'>前面是页号，后面是页内偏移量</span>
</li>
</ul>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>Eg:逻辑地址2，用二进制表示应该是00000000000000000000  000000000010</p>
<p>若0号页在内存中的起始地址为x，则逻辑地址⒉对应的物理地址应该是X+000000000010</p>
</div>
<p>结论:如果每个页面大小为2×B，用二进制数表示逻辑地址，则末尾K位即为<span class='p red'>页内偏移量</span>，其余部分就是<span class='p red'>页号</span>.</p>
<p>因此，如果让<span class='p red'>每个页面的大小为2的整数幂</span>，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量.</p>
<h3 id="逻辑地址结构"><a class="markdownIt-Anchor" href="#逻辑地址结构"></a> 逻辑地址结构</h3>
<table>
<thead>
<tr>
<th style="text-align:center">31   …    12</th>
<th style="text-align:center">11  …  0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">页号</td>
<td style="text-align:center">页内偏移量</td>
</tr>
</tbody>
</table>
<p>地址结构包含两个部分:前一部分为页号，后一部分为页内偏移量w。在上图所示的例子中，地址长度为32位，其中0 ~ 11位为“<span class='p red'>页内偏移量</span>”，或称“<span class='p red'>页内地址</span>”;12 - 31位为“<span class='p red'>页号</span>”。</p>
<ul>
<li>
<span class='p red'>如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是$2^k$个内存单元</span>.
</li>
<li>
<span class='p red'>如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有$2^M$个页面</span>.
</li>
</ul>
<h3 id="页表"><a class="markdownIt-Anchor" href="#页表"></a> 页表</h3>
<p>为了能知道进程的每个页面在内存中存放的位置，操作系统要<span class='p red'>为每个进程建立一张页表</span></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/3VaTJcDs4iZBYCp.png" alt="image-20221004102027722" /></p>
<ol>
<li>一个进程对应一张页表</li>
<li>进程的每一页对应一个页表项</li>
<li>每个页表项由“页号”和“块号”组成</li>
<li>页表记录<span class='p red'>进程页面和实际存放的内存块之间的对应关系</span>.</li>
<li>每个页表项的长度是相同的，<span class='p red'>页号是“隐含”的</span>.</li>
</ol>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>为什么页号是隐藏的？</p>
<p>各页表项会<span class='p red'>按顺序连续地</span>存放在内存中如果该页表在内存中存放的起始地址为x，则M号页对应的页表项一定是存放在内存地址为X＋3×M</p>
<p>因此，页表中的“页号”可以是“隐含”的。只需要知道<span class='p red'>页表存放的起始地址和页表项长度</span>，即可找到各个页号对应的页表项存放的位置</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/sFdtUw8CH94DIek.png" alt="image-20221004095838876" /></p>
<h2 id="基本地址变换结构"><a class="markdownIt-Anchor" href="#基本地址变换结构"></a> 基本地址变换结构</h2>
<ul>
<li>
<mark class="hl-label default">重点理解、记忆基本地址变换机构（用于实现逻辑地址到物理地址转换的一组硬件机构）的原理和流程</mark> .
</li>
</ul>
<p>基本地址变换机构可以<span class='p red'>借助进程的页表</span>将<span class='p red'>逻辑地址转换为物理地址</span>.</p>
<p>通常会在系统中设置一个<span class='p red'>页表寄存器</span>（PTR)，存放<span class='p red'>页表在内存中的起始地址F</span>和<span class='p red'>页表长度M</span>。进程未执行时，页表的始址和页表长度<span class='p red'>放在进程控制块（PCB）中</span>，当进程被调度时，	作系统内核会把它们放到<span class='p red'>页表寄存器</span>中。</p>
<p>注意:<span class='p red'>页面大小是2的整数幂</span>.</p>
<p>设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/QVkifh2o6atDwUR.png" alt="image-20221004144334236" /></p>
<ol>
<li>计算页号Р和页内偏移量w（如果用十进制数手算，则P=A/L，W=A%L;但是在计算机实际运行时，<span class='p red'>逻辑地址结构是固定不变的</span>，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量)</li>
<li>比较页号P和页表长度M，若P<span class='p red'>≥</span>M，则产生越界中断，否则继续执行。（注意:页号是从0开始的，而页表长度至少是1，因此<span class='p red'>P=M时也会越界</span>)</li>
<li>页表中页号p对应的<span class='p red'>页表项地址=页表起始地址F+页号P×页表项长度</span>，取出该页表项内容b,即为内存块号。（注意区分<span class='p red'>页表项长度、页表长度、页面大小的区别</span>。</li>
<li>
<span class='p red'>页表长度</span>指的是这个页表中总共有<span class='p red'>几个页表项</span>，即总共有几个页;
</li>
<li>
<span class='p red'>页表项长度</span>指的是每个页表项P<span class='p red'>占多大的存储空间</span>;
</li>
<li>
<span class='p red'>页面大小</span>:是一个页面占多大的存储空间
</li>
<li>计算E= b×L+W(物理块号×页面长度 + 页内偏移量)，用得到的物理地址E去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了)</li>
</ol>
<p>EG: 若<span class='p red'>页面大小</span></p>
<p>L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。</p>
<p>等价描述:某系统<span class='p red'>按字节寻址</span>，逻辑地址结构中，<span class='p red'>页内偏移量占10位</span>，页号2对应的内存块号b=8,将逻辑地址A=2500转换为物理地址E。</p>
<ul>
<li>
<span class='p red'>页内偏移量占用位数</span>: 就是偏移量占用的位数，偏移量一共有几位，偏移量的位数决定了页面的大小
</li>
</ul>
<ol>
<li>
<p>计算页号、页内偏移量</p>
<p>页号P=A/L = 2500/1024= 2; 页内偏移量W=A%L = 2500%1024=452</p>
</li>
<li>
<p>根据题中条件可知，页号没有越界，其存放的内存块号b=8</p>
</li>
<li>
<p>物理地址E= b×L+W=8×1024+ 425=8644</p>
</li>
</ol>
<p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，<span class='p red'>页式管理中地址是一维的</span>。即，只要给出一个逻辑地址，系统就可以<span class='p red'>自动地算出页号、页内偏移量两个部分</span>，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>
<h3 id="对页表项的进一步讨论"><a class="markdownIt-Anchor" href="#对页表项的进一步讨论"></a> 对页表项的进一步讨论</h3>
<ul>
<li>
<span class='p red'>每个页表项的长度是相同的，页号是“隐含”的</span>
</li>
</ul>
<p>Eg:假设某系统物理内存大小为4GB，页面大小为4KB，的内存总共会被分为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}/2^{12}=2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>个内存块，因此内存块号的范围应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>−</mo><msup><mn>2</mn><mn>20</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0-2^{20}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span><br />
因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3个字节才够(每个字节8个二进制位，3个字节共24个二进制位)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/vhu2DPj46XS9nzw.png" alt="image-20221005090721368" /></p>
<p>各页表项会<span class='p red'>按顺序连续地</span>存放在内存中<br />
如果该页表在内存中存放的起始地址为X，则M号页对应的页表项是存放在内存地址为<span class='p red'>X＋3×M</span></p>
<p>一个页面为4KB，则每个页框可以存放4096/3= 1365个页表项，但是这个页框会剩余4096% 3=1B页内碎片。因此，1365号页表项存放的地址为X+3×1365＋1</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/vEUC9dJjrt3OaRh.png" alt="image-20221005091012304" /></p>
<p>如果<span class='p red'>每个页表项占4字节</span>，则每个页框刚好可存放1024个而表项</p>
<p>1024号页表项虽然是存放在下一个页框中的，但是它的地址依然可以用X＋4×1024得出</p>
<ul>
<li>
<span class='p red'>结论</span>:理论上，页表项长度为3B即可表示内存块号的范围，但是，为了方便页表的查询常常会让一个页表项占更多的字节，使得<span class='p red'>每个页面恰好可以装得下整数个页表项</span>。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/vdCSJfaDbIO19FK.png" alt="image-20221004164135024" /></p>
<h2 id="具有快表的地址变换机构"><a class="markdownIt-Anchor" href="#具有快表的地址变换机构"></a> 具有快表的地址变换机构</h2>
<h3 id="局部性原理"><a class="markdownIt-Anchor" href="#局部性原理"></a> 局部性原理</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序执行时,会很频繁地访问10号、23号内存块</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/p1jGwZaXmuHr84o.png" alt="image-20221005092546411" /></p>
<ul>
<li>
<span class='p red'>时间局部性</span>:如果执行了程序中的某条指令，那么不久后这<span class='p red'>条指令很有可能再次执行</span>;如果某个数据被访问过，不久之后<span class='p red'>该数据很可能再次被访问</span>。(因为程序中存在大量的循环)
</li>
<li>
<span class='p red'>空间局部性</span>:一旦程序访问了某个存储单元，在不久之后，<span class='p red'>其附近的存储单元也很有可能被访问</span>。(因为很多数据在内存中都是连续存放的)
</li>
<li>
<p>上小节介绍的<span class='p red'>基本地址变换机构</span>中，每次要访问一个逻辑地址，都需要<span class='p red'>查询内存中的页表</span>。由于局部性原理，<span class='p red'>可能连续很多次查到的都是同一个页表项</span>。既然如此，能否利用这个特性减少访问页表的次数呢?</p>
</li>
</ul>
<h3 id="快表机制tlb-translation-lookaside-buffer"><a class="markdownIt-Anchor" href="#快表机制tlb-translation-lookaside-buffer"></a> 快表机制(TLB, TranslatIOn Lookaside Buffer)</h3>
<ul>
<li>
<span class='p red'>快表</span>，又称<span class='p red'>联想寄存器（TLB）</span>，是一种<span class='p red'>访问速度比内存快很多</span>的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为<span class='p red'>慢表</span>。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/LuzdyhEZkr7Q4aV.png" alt="image-20221005142304797" /></p>
<h3 id="引入快表之后地址的变化过程"><a class="markdownIt-Anchor" href="#引入快表之后地址的变化过程"></a> 引入快表之后，地址的变化过程</h3>
<ol>
<li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，<span class='p red'>将页号与快表中的所有页号进行比较</span>。</li>
<li>如果<span class='p red'>找到匹配的页号</span>，说明要访问的页表项在快表中有副本，则<span class='p red'>直接从中取出该页对应的内存块号</span>，再将内存块号与页内偏移量拼接形成物理地址，最后，<span class='p red'>访问该物理地址对应的内存单元</span>。因此.若<span class='p red'>快表命中</span>，则访问某个逻辑地址仅需<span class='p red'>一次访存</span>即可。</li>
<li>如果没有找到匹配的页号，则需要<span class='p red'>访问内存中的页表</span>，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，<span class='p red'>访问该物理地址对应的内存单元</span>。因此,若<span class='p red'>快表未命中</span>，则访问某个逻辑地址需要<span class='p red'>两次访存</span>（注意:在找到页表项后，应<span class='p red'>同时将其存入快表</span>。但若快表已满，则必须按照<span class='p red'>一定的算法对旧的页表项进行替换</span>)</li>
</ol>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理．一船来说快表的合中率可以达到90%以上</p>
<p>例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us，访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?</p>
<p>(1+100)× 0.9+ (1+100+100)× 0.1= 111 us</p>
<p>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是(1+100)×0.9+(100+100)× 0.1=110.9 us</p>
<p>若未采用快表机制，则访问一个逻辑地址需要100+100 = 200us显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">地址变换过程</th>
<th style="text-align:center">访问一个逻辑地址<br />的访问速度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基本地址<br />变化机构</td>
<td style="text-align:center">1. 算页号、页内偏移量<br />2.检查页号合法性<br />3.查页表，找到页面存放的内存块号<br/>4.根据内存块号与页内偏移量得到物理地址<br />5.访问目标内存单元</td>
<td style="text-align:center">两次访问</td>
</tr>
<tr>
<td style="text-align:center">具有快表的<br />地址变换机构</td>
<td style="text-align:center">1.算页号、页内偏移量<br />2.检查页号合法性<br/>3.查快表。若命中，即可知道页面存放的内存块号，可直接进行;<br />若未命中则进行<br/>4. 查页表，找到页面存放的内存块号，并且将页表项复制到快表中<br />5.根据内存块号与页内偏移量得到物理地址<br/>6. 访问目标内存单元</td>
<td style="text-align:center">快表命中，只需一次访存<br/>快表未命中，需要两次访存</td>
</tr>
</tbody>
</table>
<h2 id="两级页表"><a class="markdownIt-Anchor" href="#两级页表"></a> 两级页表</h2>
<h3 id="单级页表存在什么问题如何解决"><a class="markdownIt-Anchor" href="#单级页表存在什么问题如何解决"></a> 单级页表存在什么问题?如何解决?</h3>
<p>某计算机系统按字节寻址，支持32位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为4B。</p>
<p>4KB= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>B，因此页内<span class='p red'>地址要用12位表示</span>，<span class='p red'>剩余20位表示页号</span>。</p>
<p>因此，该系统中用户进程最多有220页。相应的，一个进程的页表中，最多会有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>=</mo><mn>1</mn><mi>M</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>048</mn><mo separator="true">,</mo><mn>576</mn></mrow><annotation encoding="application/x-tex">2^{20}= 1M = 1,048,576</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">4</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mord">6</span></span></span></span>个页表项，所以一个页表最大需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>×</mo><mn>4</mn><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>22</mn></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{20}× 4B= 2^{22}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，共需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}/2^{12}=2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>个页框存储该页表。</p>
<p>根据局部性原理可知，很多时候，<span class='p red'>进程在一段时间内只需要访问某几个页面就可以正常运行了</span>。因此<span class='p red'>没有必要让整个页表都常驻内存</span>。</p>
<div class="tip "><p>如何解决单级页表的问题</p>
</div>
<ul>
<li>
<span class='p red'>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框</span>。
</li>
</ul>
<p>没有必要让整个页表常驻内存，因为进程在一段时间内<span class='p red'>可能只需要访问某几个特定的页面</span>。</p>
<ul>
<li>解决方法：虚拟内存:是计算机系统内存管理的一种技术。使得应用程序以为它拥有连续可用的内存空间，而实际上，它通常是被分割成多个物理内存块，还有部分暂时存储在外存上，这种技术使得大型程序编写更加方便，对真正的物理内存使用也更有效率</li>
</ul>
<p>可将长长的页表进行分组，使每个内存块刚好可以放入一个分组（比如上个例子中，页面大小4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再讲各组离散地放到各个内存块中)</p>
<p>另外，要为离散分配的页表再建立一张页表，称为<span class='p red'>页目录表</span>，或称<span class='p red'>外层页表</span>，或称<span class='p red'>顶层页表</span>.</p>
<h3 id="两级页表的原理-逻辑地址结构"><a class="markdownIt-Anchor" href="#两级页表的原理-逻辑地址结构"></a> 两级页表的原理、逻辑地址结构</h3>
<p>32位逻辑地址空间，页表项大小为4B，页面大小为4KB，则页内地址占12位</p>
<ul>
<li>
<mark class="hl-label red">单级页表结构的逻辑地址结构</mark> 
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">31…12</th>
<th style="text-align:center">11…0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">页号</td>
<td style="text-align:center">页内偏移量</td>
</tr>
</tbody>
</table>
<ul>
<li>
<mark class="hl-label red">多级页表的逻辑地址结构</mark> 
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">31…22</th>
<th style="text-align:center">21…12</th>
<th style="text-align:center">11…0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">一级页号</td>
<td style="text-align:center">二级页号</td>
<td style="text-align:center">页内偏移量</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/IhNGMT8wnVaxWHJ.png" alt="image-20221005162941721" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/qEYQTAxXk9trNeW.png" alt="image-20221005163027405" /></p>
<h3 id="如何实现地址变换"><a class="markdownIt-Anchor" href="#如何实现地址变换"></a> 如何实现地址变换?</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/p1Iqvn5b4g9zUuC.png" alt="image-20221005163551930" /></p>
<ol>
<li>按照地址结构将逻辑地址拆分成三部分</li>
<li>从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</li>
<li>根据二级页号查表，找到最终想访问的内存块号</li>
<li>结合页内偏移量得到物理地址</li>
</ol>
<p>最终要访问的内存块号为4</p>
<p>该内存块的<span class='p red'>起始地址</span>为4×4096= 16384</p>
<p>页内偏移量为4095</p>
<p>最终的物理地址为16384 +4095=20479,</p>
<h3 id="两级页表问题需要注意的几个细节"><a class="markdownIt-Anchor" href="#两级页表问题需要注意的几个细节"></a> 两级页表问题需要注意的几个细节</h3>
<ol>
<li>若采用多级页表机制，则<span class='p red'>各级页表的大小不能超过一个页面</span>.</li>
</ol>
<p>例:某系统按字节编址，采用40位逻辑地址，页面大小为4KB，页表项大小为4B，假设采用纯页式存储，则要采用（)级页表，页内偏移量为（）位?</p>
<p>页面大小=4KB =<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>B，按字节编址，因此页内偏移量为12位</p>
<p>页号=40- 12= 28位</p>
<p>页面大小=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>B，页表项大小=4B，则每个页面可存放<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}/4 = 2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>个页表项<br />
因此各级页表最多包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>个页表项，需要10位二进制位才能映射到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>个页表项，因此每一级的页表对应页号应为10位。总共28位的页号至少要分为三级</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/xpAfsP7NVDF96hU.png" alt="image-20221005165120920" /></p>
<p>两级贝表的<span class='p red'>访存次数分析</span>（假设没有快表机构)</p>
<p>第一次访存:访问内存中的页目录表</p>
<p>第二次访存:访问内存中的二级页表</p>
<p>第三次访存:访问目标内存单元</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/9AVpD8TB45dHgbx.png" alt="image-20221005171016683" /></p>
<h2 id="基本分段存储方式"><a class="markdownIt-Anchor" href="#基本分段存储方式"></a> 基本分段存储方式</h2>
<h3 id="分段"><a class="markdownIt-Anchor" href="#分段"></a> 分段</h3>
<p>进程的地址空间:按照程序<span class='p red'>自身的逻辑</span>关系<span class='p red'>划分为若干个段</span>，每个段都有一个段名（在低级语言中，程序员使用段名来编程)，<span class='p red'>每段从o开始编址</span>.<br />
内存分配规则:以段为单位进行分配，<span class='p red'>每个段在内存中占据连续空间</span>，但<span class='p red'>各段之间可以不相邻</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/OwSvDPac6Hlu8hC.png" alt="image-20221007150323052" /></p>
<p>由于是按逻辑功能模块划分，用户<span class='p red'>编程更方便，程序的可读性更高</span>.</p>
<p>LOAD 1,[D] |&lt; A &gt;;		//将分段D中A单元内的值读入寄存器1</p>
<ul>
<li>写程序时使用的段名[D]、[A]会被编译程序翻译成对应段号</li>
</ul>
<p>STORE 1,[X]|&lt; B &gt;;		//将寄存器1的内容存入X分段的B单元中</p>
<ul>
<li>&lt; A &gt;单元、&lt; B &gt;单元会被编译程序翻译成段内地址</li>
</ul>
<p>分段系统的逻辑地址由段号（段名）和段内地址（段内偏移量）所组成。如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">31 … 16</th>
<th style="text-align:center">15 … 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">段号</td>
<td style="text-align:center">段内地址</td>
</tr>
</tbody>
</table>
<ul>
<li>
<span class='p red'>段号的位数决定了每个进程最多可以分几个段</span>.
</li>
<li>
<span class='p red'>段内地址位数决定了每个段的最大长度是多少</span>.
</li>
</ul>
<p>在上述例子中，若系统是按字节寻址的，则段号占16位，因此在该系统中，每个进程最多有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>64</mn><mi>K</mi></mrow><annotation encoding="application/x-tex">2^{16}=64K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>个段段内地址占16位，因此每个段的最大长度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>64</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{16} =64KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/Sz13pTPgWkKhUoQ.png" alt="image-20221007151248173" /></p>
<h3 id="段表"><a class="markdownIt-Anchor" href="#段表"></a> 段表</h3>
<p>问题:程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张<span class='p red'>段映射表</span>，简称“<span class='p red'>段表</span>”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/EZOG6mz1TesKtWl.png" alt="image-20221007151403638" /></p>
<ol>
<li>每个段对应一个段表项，其中记录了该段在内存中的<span class='p red'>起始位置</span>(又称“<span class='p red'>基址</span>”）和<span class='p red'>段的长度</span>。</li>
<li>
<span class='p red'>各个段表项的长度是相同的</span>。例如:某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位,段内地址16位），因此用16位即可表示最大段长。物理内存大小为4GB(可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占16+32=48位，即6B。由于段表项长度相同，<span class='p red'>因此段号可以是隐含的，不占存储空间</span>。若段表存放的起始地址为M，则K号段对应的段表项存放的地址为M＋K×6
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/5fFLeH4BNSZAQtl.png" alt="image-20221007152144721" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/4XILKOdSGiZoMvq.png" alt="image-20221007152551152" /></p>
<h3 id="分段和分页管理的对比"><a class="markdownIt-Anchor" href="#分段和分页管理的对比"></a> 分段和分页管理的对比</h3>
<ul>
<li>
<span class='p red'>页</span>是<span class='p red'>信息的物理单位</span>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，<span class='p green'>完全是系统行为</span>，<span class='p red'>对用户是不可见的</span>。
</li>
<li>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li>
<li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</li>
<li>
<span class='p red'>分页</span>的用户进程<span class='p red'>地址空间是一维的</span>，程序员只需给出一个记忆符即可表示一个地址。
</li>
<li>
<span class='p red'>分段</span>的用户进程<span class='p red'>地址空间是二维的</span>，程序员在标识一个地址时，既要给出段名，也要给出段内地址。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/TUINs25ZCDbpAey.png" alt="image-20221008140954639" /></p>
<div class="tip "><p>分段比分页更容易实现信息的共享和保护</p>
</div>
<ul>
<li>
<span class='p red'>不能被修改的代码</span>称为<span class='p greed'>纯代码</span>或<span class='p red'>可重入代码</span>（不属于临界资源)，这样的代码<span class='p red'>是可以共享的</span>。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致)
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/ZG83njJXqLwz7Sl.png" alt="image-20221008141343980" /></p>
<p>只需让各进程的段表项指向同一个段即可实现共享</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/dA1OfagrhxoJ9IQ.png" alt="image-20221008141356003" /></p>
<ul>
<li>
<mark class="hl-label red">分页式共享操作</mark> 
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/4PUg2VDY1d7hCnm.png" alt="image-20221008141646623" /></p>
<p>其中<span class='p red'>绿色的代码段表示可共享数据</span>.</p>
<p>如果让消费者进程的某个页表项指向这个页面，显然不合理，因为这个页面中的<span class='p red'>橙色部分是不允许共享的</span>,只有绿色部分可以</p>
<p>页面不是按逻辑模块划分的。这就很难实现共享。</p>
<div class="tip "><p>访问一个逻辑地址需要的访问内存的次数</p>
</div>
<ul>
<li>
<span class='p red'>分页（单级页表)</span>∶第一次访存一一查内存中的页表，第二次访存一一访问目标内存单元。<span class='p red'>总共两次访存</span>.
</li>
<li>
<span class='p red'>分段</span>:第一次访存一一查内存中的段表，第二次访存一一访问目标内存单元。<span class='p red'>总共两次访存</span>.
</li>
<li>与分页系统类似，<span class='p red'>分段系统中也可以引入快表机构</span>，将近期访问过的段表项放到快表中，这样<span class='p red'>可以少一次访问</span>，加快地址变换速度。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/j92LeFGoNlWnr1b.png" alt="image-20221008142143688" /></p>
<h2 id="段页式管理方式"><a class="markdownIt-Anchor" href="#段页式管理方式"></a> 段页式管理方式</h2>
<div class="tip "><p>分页和分段的优缺点分析</p>
</div>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">分页管理</td>
<td style="text-align:center">内存空间利用率高，<span class='p red'>不会产生外部碎片</span>,<br />只会产生少量的页内碎片</td>
<td style="text-align:center">不方便按照逻辑模块实现信息的共享和保护</td>
</tr>
<tr>
<td style="text-align:center">分段管理</td>
<td style="text-align:center">很方便按照逻辑模块实现信息的共享和保护</td>
<td style="text-align:center">如果段长过大，为其分配很大的连续空间<br />会很不方便，另外，段式管理<span class='p red'>会产生外部碎片</span><br />虽然可以使用“紧凑”来解决，但是会花费大量的时间</td>
</tr>
</tbody>
</table>
<ul>
<li>
<mark class="hl-label red">段页式管理集合了分页管理和分段管理的优点</mark> 
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/rbzcdHjm8MswUle.png" alt="image-20221008143150932" /></p>
<div class="tip "><p>段页式管理的逻辑地址结构</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/AKykHE4RpV36UeL.png" alt="image-20221008144341818" /></p>
<ul>
<li>
<mark class="hl-label red">段号的位数决定了每个进程最多可以分几个段</mark> .
</li>
<li>
<mark class="hl-label default">页号位数决定了每个段最大有多少页</mark> .
</li>
<li>
<mark class="hl-label default">页内偏移量决定了页面大小、内存块大小是多少</mark> .
</li>
</ul>
<p>在上述例子中，若系统是按字节寻址的，则段号占16位，因此在该系统中，每个进程最多有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>64</mn><mi>K</mi></mrow><annotation encoding="application/x-tex">2^{16}=64K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>个段</p>
<p>页号占4位，因此每个段最多有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">2^4= 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span>页</p>
<p>页内偏移量占12位，因此每个页面\每个内存块大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>= 4096= 4KB</p>
<p>“<span class='p red'>分段</span>”对用户<span class='p green'>是可见的</span>,程序员编程时需要显式地给出段号、段内地址。而将各段“<span class='p green'>分页</span>”对用户是<span class='p red'>不可见的</span>。系统会根据段内地址自动划分页号和页内偏移量。</p>
<p>因此<span class='p red'>段页式管理的地址结构是二维的</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/lQk98ofaNSTzcmn.png" alt="image-20221008145040977" /></p>
<p>每个段对应一个段表项，每个段表项由<span class='p red'>段号</span>、<span class='p green'>页表长度</span>、<span class='p red'>页表存放块号</span>(页表起始地址）组成。每个<span class='p red'>段表项长度相等，段号是隐含的</span>。</p>
<p>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，<span class='p red'>页号是隐含的</span>。</p>
<ul>
<li>
<mark class="hl-label default">一个程序对应一个段表项，一个段表对应着多个页表，那么在段页式管理的时候，一个程序对应着多个页表</mark> 
</li>
</ul>
<p>​	<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/agzKHrpJoyZBE3U.png" alt="image-20221008145650792" /></p>
<p>其中重要的是第四步，检查页号是否越界，因为每一个段可能对应着多个页面，所以这里需要检查一下页号是否越界了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/6buEalRxCmY8r92.png" alt="image-20221008145825775" /></p>
<h2 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h2>
<span class='p red'>传统储存管理的缺点</span>
<ul>
<li>
<mark class="hl-label red">一次性</mark> :<span class='p red'>作业必须一次性全部装入内存后才能开始运行</span>。这会造成两个问题:①作业很大时，不能全部装入内存，导致<span class='p red'>大作业无法运行</span>;②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，<span class='p red'>导致多道程序并发度下降</span>。
</li>
<li>
<mark class="hl-label red">驻留性</mark> :一旦作业被装入内存，就<span class='p red'>会一直驻留在内存</span>中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。
</li>
</ul>
<div class="tip "><p>局部性原理</p>
</div>
<ul>
<li>
<span class='p red'>时间局部性</span>:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）
</li>
<li>
<span class='p red'>空间局部性</span>:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/qWjg6ahudBzpPk4.png" alt="image-20221008151724681" /></p>
<ul>
<li>
<mark class="hl-label red">高速缓冲技术</mark> 的思想: 将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。
</li>
</ul>
<h3 id="虚拟内存的定义和特征"><a class="markdownIt-Anchor" href="#虚拟内存的定义和特征"></a> 虚拟内存的定义和特征</h3>
<p>基于局部性原理，在程序装入时，可以将程序中<span class='p red'>很快会用到的部分装入内存，暂时用不到的部分留在外存</span>，就可以让程序开始执行。</p>
<p>在程序执行过程中，当所访问的<span class='p red'>信息不在内存时</span>，由<span class='p red'>操作系统负责将所需信息从外存调入内存</span>，然后继续执行程序。</p>
<p>若内存空间不够，由<span class='p red'>操作系统</span>负责将内存中<span class='p red'>暂时用不到的信息换出到外存</span>。</p>
<p>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<span class='p red'>虚拟内存</span></p>
<p>操作系统虚拟性的一个体现，实际的物理内存大小没有变, 只是在逻辑上进行了扩充</p>
<div class="tip warning"><p>易混知识点:</p>
</div>
<p>虚拟内存的<span class='p red'>最大容量</span>是由计算机的地址结构（CPU寻址范围）确定的</p>
<p>虚拟内存的<span class='p red'>实际容量</span>= min（内存和外存容量之和，CPU寻址范围)</p>
<p>EG:如:某计算机地址结构为32位，按字节编址，内存大小为512MB,外存大小为2GB</p>
<p>则虚拟内存的<span class='p red'>最大容量</span>:为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mi>B</mi><mo>=</mo><mn>4</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{32}B= 4GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></p>
<p>虚拟内存的<span class='p red'>实际容量</span>=min (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mi>B</mi><mo separator="true">,</mo><mn>512</mn><mi>M</mi><mi>B</mi><mo>+</mo><mn>2</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{32}B,512MB+2GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>)= 2GB+512MB</p>
<p>虚拟内存有一下三个主要<mark class="hl-label red">特征</mark> :</p>
<ul>
<li>
<span class='p red'>多次性</span>:无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
</li>
<li>
<span class='p red'>对换性</span>:在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换
入、换出。</li>
<li>
<span class='p red'>虚拟性</span>:从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。
</li>
</ul>
<h3 id="如何实现虚拟内存技术"><a class="markdownIt-Anchor" href="#如何实现虚拟内存技术"></a> 如何实现虚拟内存技术</h3>
<p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在<span class='p red'>离散分配</span>的内存管理方式基础上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/J3n2YorVyDXaIwW.png" alt="image-20221008153419370" /></p>
<ul>
<li>
<p>请求分页和基本分页的主要区别：</p>
<p>在程序执行过程中，当所<span class='p red'>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</span>，然后继续执行程序。操作系统要提供请求调页(或请求调段）功能</p>
<p>若内存空间不够，由操作系统负责<span class='p red'>将内存中暂时用不到的信息换出到外存</span>。操作系统要提供页面置换（或段置换）的功能</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/EjptzvkfLNhrg1q.png" alt="image-20221008153917445" /></p>
<h2 id="请求分页管理方式"><a class="markdownIt-Anchor" href="#请求分页管理方式"></a> 请求分页管理方式</h2>
<ul>
<li>
<span class='p red'>请求分页</span>存储管理与<span class='p red'>基本分页</span>存储管理的主要区别:
</li>
<li>在程序执行过程中，当所<span class='p red'>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存(操作系统需要提供请求调页功能，将缺失的页面从外存调入内存)</span>，然后继续执行程序。</li>
<li>若内存空间不够，由操作系统负责<span class='p red'>将内存中暂时用不到的信息换出到外存</span>。</li>
</ul>
<p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统<span class='p red'>需要知道每个页面是否已经调入内存</span>；如果还没调入，那么也<span class='p red'>需要知道该页面在外存中存放的位置</span>。</p>
<p>当内存空间不够时，要实现“<span class='p red'>页面置换</span>”，操作系统需要<span class='p red'>通过某些指标来决定</span>到底换出哪个页面；有的页面没有被修改过，<span class='p red'>就不用再浪费时间写回外存</span>。有的页面<span class='p red'>修改过</span>，就需要<span class='p red'>将外存中的旧数据覆盖</span>，因此，操作系统也需要<span class='p red'>记录各个页面是否被修改的信息</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/eivRFMDTwOfEbcu.png" alt="image-20221008155106313" /></p>
<h3 id="缺页中断机构"><a class="markdownIt-Anchor" href="#缺页中断机构"></a> 缺页中断机构</h3>
<p>假设此时要访问逻辑地址=(页号，页内偏移量〉= (0,1024)</p>
<p>在请求分页系统中，每当要访问的<span class='p red'>页面不在内存时</span>，便产生一个<span class='p red'>缺页中断</span>，然后由操作系统的缺页<span class='p red'>中断处理程序处理中断</span>。</p>
<p>此时<span class='p red'>缺页的进程阻塞</span>，放入阻塞队列，调页<span class='p red'>完成后再将其唤醒</span>，放回就绪队列。</p>
<p>如果内存中<span class='p red'>有空闲块</span>，则为进程<span class='p red'>分配一个空闲块</span>，将所缺页面装入该块，并修改页表中相应的页表项。</p>
<p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p>
<h2 id="页面置换算法"><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h2>
<ul>
<li>
<span class='p red'>请求分页</span>存储管理与<span class='p red'>基本分页</span>存储管理的<span class='p green'>主要区别</span>:
</li>
<li>在程序执行过程中，当所<span class='p red'>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</span>，然后继续执行程序。</li>
<li>若内存空间不够，由操作系统负责<span class='p red'>将内存中暂时用不到的信息换出到外存</span>。</li>
<li>用页面置换算法决定应该先换出那个页面</li>
</ul>
<h3 id="最佳置换算法opt"><a class="markdownIt-Anchor" href="#最佳置换算法opt"></a> 最佳置换算法(OPT)</h3>
<p>最佳置换算法（OPT，Optimal):每次选择<span class='p red'>淘汰的页面</span>将是<span class='p red'>以后永不使用</span>，或者<span class='p red'>在最长时间内不再被访问的页面</span>，这样可以保证最低的缺页率。</p>
<p>例:假设系统为某进程分配了三个内存块，并考虑到有一下页面号引用串（会依次访问这些页面):7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/wAzaKloNZh7Cb4v.png" alt="image-20221010090957395" /></p>
<ul>
<li>
<mark class="hl-label red">当执行到第四步访问页面二的时候</mark> ：选择从0，1，7中淘汰一页。按最佳置换的规则,往后寻找，<span class='p red'>最后一个出现的页号就是要淘汰的页面</span>.
</li>
<li>整个过程<span class='p red'>缺页中断</span>发生了<span class='p red'>9次</span>，<span class='p red'>页面置换</span>发生了<span class='p red'>6次</span>。</li>
<li>注意:<span class='p red'>缺页时未必发生页面置换</span>。若还有可用的空闲内存块,就不用进行页面置换。</li>
<li>
<span class='p red'>缺页率</span>=9/20= 45%
</li>
</ul>
<p>最佳置换算法可以保证最低的缺页率，但实际上，只有在<span class='p red'>进程执行的过程中才能知道接下来会访问到的是哪个页面</span>。操作系统无法提前预判页面访问序列。因此，<span class='p red'>最佳置换算法是无法实现的</span>。</p>
<h3 id="先进先出算法fifo"><a class="markdownIt-Anchor" href="#先进先出算法fifo"></a> 先进先出算法(FIFO)</h3>
<p>先进先出置换算法（FIFO):每次选择<span class='p red'>淘汰的页面</span>是<span class='p red'>最早进入内存的页面</span>.</p>
<p>实现方法:把调入内存的页面根据调入的先后顺序排成一个队列,需要换出页面时选择队头页面即可。</p>
<p>队列的最大长度取决于系统为进程分配了多少个内存块。</p>
<p>例:假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串:</p>
<p>3，2, 1，0, 3，2，4，3，2，1，0，4</p>
<table>
<thead>
<tr>
<th style="text-align:center">访问页面</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">4</th>
<th style="text-align:center">3</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内存块1</td>
<td style="text-align:center"><span class='p red'>3</span></td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><span class='p red'>4</span></td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center"><span class='p red'>0</span></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">内存块2</td>
<td style="text-align:center"></td>
<td style="text-align:center"><span class='p red'>2</span></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center"><span class='p red'>3</span></td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center"><span class='p red'>4</span></td>
</tr>
<tr>
<td style="text-align:center">内存块3</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><span class='p red'>1</span></td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><span class='p red'>2</span></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">内存块4</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><span class='p red'>0</span></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><span class='p red'>1</span></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">是否缺页</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<p>分配<span class='p red'>四个</span>内存块时:缺页次数:<span class='p red'>10次</span>.</p>
<p>分配<span class='p red'>三个</span>内存块时:缺页次数:<span class='p red'>9次</span>.</p>
<ul>
<li>
<span class='p red'>Belady异常</span>―当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。
</li>
<li>
<span class='p red'>只有FIFO算法会产生Belady异常</span>。另外，FIFO算法虽然<span class='p red'>实现简单</span>，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，<span class='p red'>算法性能差</span>,
</li>
</ul>
<h3 id="最近最久未使用置换算法lru"><a class="markdownIt-Anchor" href="#最近最久未使用置换算法lru"></a> 最近最久未使用置换算法(LRU)</h3>
<p>最近最久未使用置换算法（LRU，least recently used):每次<span class='p red'>淘汰的页面</span>是<span class='p green'>最近最久未使用的页面</span>.</p>
<p>实现方法:赋予每个页面对应的页表项中，用<span class='p red'>访问字段记录该页面自上次被访问以来所经历的时间t</span>。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/aVtCxTd7FJEPgon.png" alt="image-20221013093727904" /></p>
<p>例:假设系统为某进程分配了<span class='p red'>四个内存块</span>，并考虑到有以下页面号引用串:1,8,1,7,8,2,7,2,1,8,3,8,2,1,3,1,7,1,3,7</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/IbTfoM2eL385hDF.png" alt="image-20221013094036096" /></p>
<p>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在<span class='p red'>逆向扫描过程中最后一个出现的页号就是要淘汰的页面</span>。</p>
<p>该算法的实现需要专门的硬件支持,虽然算法<span class='p red'>性能好</span>，但是<span class='p red'>实现困难</span>.</p>
<h3 id="时钟置换算法clock"><a class="markdownIt-Anchor" href="#时钟置换算法clock"></a> 时钟置换算法(Clock)</h3>
<p>最佳置换算法性能最好，但无法实现;先进先出置换算法实现简单，但算法性能差﹔最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p>
<ul>
<li>
<span class='p red'>时钟置换算法</span>是一种性能和开销较均衡的算法，乂称<span class='p red'>CLOCK算法</span>，或最近未使用算法（NRU，Not 	 Recently Used）
</li>
<li>
<span class='p red'>简单的CLOCK算法</span>实现方法:为每个页面设置一个<span class='p red'>访问位</span>，再将内存中的页面都通过链接指针<span class='p red'>链接成一个循环队列</span>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2023/02/18/mF78drDcOEWXQ5S.png" alt="image-20221013094657763" /></p>
<p>例:假设系统为某进程分配了五个内存块，并考虑到有以下页面号引用串:1,3,4,2,5,6,3,4,7</p>
<p>当经过1,3,4,2,5之后所有内存块的访问位都被置为1，所以在放入第六个元素的时候，需要循环找出访问位为0的，经过一轮寻找之后，<span class='p red'>发现没有访问位为0的，但是在我们寻找的过程中，会将访问位为1的转换为0</span>.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/D1t4zmQNLYZ5oUs.png" alt="image-20221013094738083" /></p>
<h3 id="改进型的时钟置换算法"><a class="markdownIt-Anchor" href="#改进型的时钟置换算法"></a> 改进型的时钟置换算法</h3>
<ul>
<li>
<span class='p red'>简单的时钟置换算法</span>仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。<span class='p red'>只有被淘汰的页面被修改过时，才需要写回外存</span>。
</li>
<li>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。<span class='p red'>在其他条件都相同时，应优先淘汰没有修改过的页面</span>，避免I/O操作。这就是改进型的时钟置换算法的思想。</li>
<li>
<span class='p red'>修改位=0</span>，表示页面没有被修改过;<span class='p red'>修改位=1</span>，表示页面被修改过。
</li>
</ul>
<p>为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1, 1）表示一个页面近期被访问过，且被修改过。</p>
<ul>
<li>
<span class='p red'>算法规则</span>:将所有可能被置换的页面排成一个循环队列
<ul>
<li>
<p>第一轮:从当前位置开始扫描到第一个（0,0）的帧用于替换。<span class='p red'>本轮扫描不修改任何标志位</span>. 第一优先级:最近没访问,且没修改的页面</p>
</li>
<li>
<p>第二轮:若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。<span class='p red'>本轮将所有扫描过的帧访问位设为0</span>.第二优先级:最近没访问，但修改过的页面</p>
</li>
<li>
<p>第三轮:若第二轮扫描失败，则重新扫描，查找第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位,第三优先级:最近访问过,但没修改的页面</p>
</li>
<li>
<p>第四轮:若第三轮扫描失败，则重新扫描，查找第一个(0, 1）的帧用于替换。第四优先级:最近访问过,且修改过的页面</p>
</li>
</ul>
</li>
<li>
<p>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此<span class='p red'>改进型CLOCK置换算法</span>选择一个淘汰页面<span class='p red'>最多会进行四轮扫描</span>.</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/8aXjNLkHG2wmbFT.png" alt="image-20221013095905098" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/02/nSiQLxXzZ2vO8VU.png" alt="image-20221013100249336" /></p>
<h2 id="页面分配策略"><a class="markdownIt-Anchor" href="#页面分配策略"></a> 页面分配策略</h2>
<div class="tip "><p>驻留集</p>
</div>
<p>驻留集:指请求分页存储管理中<span class='p red'>给进程分配的物理块的集合</span>。</p>
<p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p>
<p>考虑一个极端情况，若某进程共有100个页面,则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页</p>
<ul>
<li>
<mark class="hl-label red">若驻留集太小</mark> ，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少;
</li>
<li>
<mark class="hl-label red">驻留集太大</mark> ，又会导致多道程序<span class='p red'>并发度下降</span>，资源利用率降低。所以应该选择一个合适的驻留集大小。
</li>
</ul>
<h3 id="页面分配置换策略"><a class="markdownIt-Anchor" href="#页面分配置换策略"></a> 页面分配置换策略</h3>
<ul>
<li>
<span class='p red'>固定分配</span>:操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变
</li>
<li>
<span class='p red'>可变分配</span>:先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，<span class='p red'>驻留集大小可变</span>.
</li>
<li>
<span class='p red'>局部置换</span>:发生缺页时只能选进程自己的物理块进行置换。
</li>
<li>
<span class='p red'>全局置换</span>:可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/SrCt9l8dUI5DuY2.png" alt="image-20221013101109759" /></p>
<p>全局置换意味着<span class='p red'>一个进程拥有的物理块数量必然会改变</span>，因此不可能是固定分配</p>
<ul>
<li>
<span class='p red'>固定分配局部置换</span>:系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的<span class='p red'>缺点</span>是:<mark class="hl-label default">很难在刚开始就确定应为每个进程分配多少个物理块才算合理</mark> 。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)
</li>
<li>
<mark class="hl-label red">可变分配全局置换</mark> :刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程;若已无空闲物理块，则可选择一个<span class='p red'>未锁定</span>的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，<mark class="hl-label red">只要某进程发生缺页,都将获得新的物理块</mark> ，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个<span class='p red'>被选中的进程拥有的物理块会减少，缺页率会增加</span>。
</li>
<li>
<mark class="hl-label red">可变分配局部置换</mark> :刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度;反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。
</li>
</ul>
<p>可变分配<span class='p red'>全局</span>置换:只要缺页就络分配新物理块</p>
<p>可变分配<span class='p red'>局部</span>置换:要根据发生<span class='p red'>缺页的频率</span>来动态地增加或减少进程的物理块</p>
<h3 id="调入页面的时机"><a class="markdownIt-Anchor" href="#调入页面的时机"></a> 调入页面的时机</h3>
<ul>
<li>
<mark class="hl-label red">预调页策略</mark> :根据局部性原理(主要指<mark class="hl-label red">空间局部性</mark> ，即:如果当前访问了某个内存单元，在之后很有可能会接着访问与其相邻的那些内存单元)，<span class='p red'>一次调入若干个相邻的页面可能比一次调入一个页面更高效</span>。但如果<span class='p red'>提前调入的页面中大多数都没被访问过，则又是低效的</span>。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前<mark class="hl-label red">预测成功率只有50%</mark> 左右。故这种策略<mark class="hl-label re">主要用于进程的首次调入(运行前调入)</mark> ，由程序员指出应该先调入哪些部分。
</li>
<li>请求调页策略:进程<span class='p red'>在运行期间发现缺页时才将所缺页面调入内存(运行时调入)</span>。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘lI/O操作，因此I/O开销较大。</li>
</ul>
<p>系统<span class='p red'>拥有足够的对换区空间</span>:页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前,<span class='p red'>需将进程相关的数据从文件区复制到对换区</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/M6zgkZxVniQwB2F.png" alt="image-20221013102534682" /></p>
<p>系统<span class='p red'>缺少足够的对换区空间</span>:凡是<span class='p red'>不会被修改的数据都直接从文件区调入</span>，由于这些页面<span class='p red'>不会被修改</span>，因此<span class='p red'>换出时不必写回磁盘</span>，下次需要时再从文件区调入即可。对于<span class='p red'>可能被修改的部分</span>，换出时需<span class='p red'>写回磁盘对换区</span>，下次需要时<span class='p red'>再从对换区调入</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/Gb5Azd2V7sLvUjR.png" alt="image-20221013102914671" /></p>
<ul>
<li>
<mark class="hl-label default">UNIX方式</mark> :运行之前进程有关的数据<span class='p red'>全部放在文件区</span>，故<span class='p red'>未使用过的页面</span>，<span class='p red'>都可从文件区调入</span>。若<span class='p red'>被使用过的页面需要换出，则写回对换区</span>，下次需要时从对换区调入。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/DCmktHo1RW7n5Tl.png" alt="image-20221013103135110" /></p>
<h3 id="抖动颠簸现象"><a class="markdownIt-Anchor" href="#抖动颠簸现象"></a> 抖动(颠簸)现象</h3>
<p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种<span class='p red'>频繁的页面调度行为称为抖动</span>，或<mark class="hl-label red">颠簸</mark> 。产生抖动的<span class='p red'>主要原因</span>是进程频繁访问的页面数目高于可用的物理块数（<span class='p red'>分配给进程的物理块不够</span>)</p>
<ul>
<li>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</li>
<li>为了研究为应该为每个进程分配多少个物理块，Denning提出了进程“工作集”的概念</li>
</ul>
<h3 id="工作机"><a class="markdownIt-Anchor" href="#工作机"></a> 工作机</h3>
<ul>
<li>
<span class='p red'>驻留集</span>:指请求分页存储管理中给进程分配的内存块的集合
</li>
<li>
<span class='p red'>工作集</span>:指在某段时间间隔里，进程实际访问页面的集合。
</li>
</ul>
<p>操作系统会根据“窗口尺寸”来算出工作集。例:某进程的页面访问序列如下，<span class='p red'>窗口尺寸为4</span>，各时刻的工作集为?</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/cRr9i1EmtjvZTCI.png" alt="image-20221013103715424" /></p>
<ul>
<li>
<span class='p red'>工作集大小</span>,可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。如:窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。
</li>
<li>一般来说，<span class='p red'>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</span>。</li>
<li>拓展:基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法一一选择一个不在工作集中的页面进行淘汰。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/U3p9ziguwohma1y.png" alt="image-20221013104235555" /></p>
<h1 id="操作系统第四章文件管理"><a class="markdownIt-Anchor" href="#操作系统第四章文件管理"></a> 操作系统第四章：文件管理</h1>
<h2 id="初识文件管理"><a class="markdownIt-Anchor" href="#初识文件管理"></a> 初识文件管理</h2>
<div class="tip "><p>文件的属性</p>
</div>
<p>一个文件有哪些属性?</p>
<ul>
<li>
<span class='p red'>文件名</span>:由创建文件的用户决定文件名，主要是为了方便用户找到文件，<span class='p red'>同一目录下不允许有重名文件</span>。
</li>
<li>
<span class='p red'>标识符</span>:一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。
</li>
<li>
<span class='p red'>类型</span>:指明文件的类型
</li>
<li>
<span class='p red'>位置</span>:文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见)
</li>
<li>大小:指明文件大小</li>
<li>
<span class='p red'>创建时间、上次修改时间</span>.
</li>
<li>
<span class='p red'>文件所有者信息</span>.
</li>
<li>
<span class='p red'>保护信息</span>:对文件进行保护的访问控制信息
</li>
</ul>
<div class="tip "><p>文件内部数据组织方式</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/HFixC7U9Vq1kWZs.png" alt="image-20221017144329740" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/RHj3p7G9AcQKeCz.png" alt="image-20221017144359856" /></p>
<div class="tip "><p>操作系统向上提供的功能</p>
</div>
<ol>
<li>可以“<span class='p red'>创建文件</span>”(点击新建后，图形化交互进程在背后调用了“<span class='p red'>create系统调用</span>”)</li>
<li>可以“<span class='p red'>读文件</span>”,将文件数据读入内存，才能让CPU处理(双击后,“记事本”应用程序通过操作系统提供的“<span class='p red'>读文件</span>”功能，即<span class='p red'>read系统调用</span>,将文件数据从外存读入内存，并显示在屏幕上）</li>
<li>可以“写文件”,，将更改过的文件数据写回外存（我们在“记事本”应用程序中编辑文件内容，点击“保存”后，“记事本”应用程序通过操作系统提供的“<span class='p red'>写文件</span>”功能，即<span class='p red'>write系统调用</span>，将文件数据从内存写回外存)</li>
<li>可以“<span class='p red'>删除文件</span>”（点了“删除”之后,图形化交互进程通过操作系统提供的“<span class='p red'>删除文件</span>”功能，即<span class='p red'>delete系统调用</span>，将文件数据从外存中删除)</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/mHD1YZW4FVBG6yh.png" alt="image-20221017145006373" /></p>
<div class="tip "><p>文件应该如何存放到外存</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/IrlwACGe8QbJ6dY.png" alt="image-20221017145411392" /></p>
<p>与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据（如1B）。每个存储单元对应一个物理地址</p>
<p>类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址（如本例中，一块包含210个地址，即1KB）。同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取决于磁盘块的大小</p>
<p>操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用1KB的磁盘块。外存中的数据读入内存时同样以块为单位</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/hNwSoJj734Ocqf5.png" alt="image-20221017145558575" /></p>
<h2 id="文件的逻辑结构"><a class="markdownIt-Anchor" href="#文件的逻辑结构"></a> 文件的逻辑结构</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/tJwmguSYsc7FNbi.png" alt="image-20221017151553151" /></p>
<p>所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件<br />
的数据是如何存放在外存中的。</p>
<p>类似于数据结构的“逻辑结构”和“物理结构”。</p>
<p>如“线性表”就是一种逻辑结构，在用户角度看来，线性表就是一组有先后关系的元素序列，如: a,b, c, d, e …</p>
<p>“线性表”这种逻辑结构可以用不同的物理结构实现，如:顺序表/链表。顺序表的各个元素在逻辑上相邻，在物理上也相邻;而链表的各个元素在物理上可以是不相邻的。因此，<span class='p red'>顺序表可以实现“随机访问”，而“链表”无法实现随机访问</span>。</p>
<p>可见，<span class='p red'>算法的具体实现与逻辑结构、物理结构都有关</span>（文件也一样，文件操作的具体实现与文件的逻辑结构、物理结构都有关)</p>
<h3 id="有结构文件"><a class="markdownIt-Anchor" href="#有结构文件"></a> 有结构文件</h3>
<p>按文件是否有结构分类，可以分为无结构文件、有结构文件两种</p>
<ul>
<li>
<span class='p red'>无结构文件</span>:文件内部的数据就是一系列二进制流或字符流组成。又称“<span class='p red'>流式文件</span>”。如:Windows操作系统中的.txt文件。
</li>
<li>
<span class='p red'>有结构文件</span>:由一组相似的记录组成，又称“<span class='p red'>记录式文件</span>”。每条记录又若干个数据项组成。如:数据库表文件。一般来说，每条记录有一个数据项可作为<span class='p red'>关键字</span>。根据各条记录的长度（占用的存储空间）是否相等，又可分为<span class='p red'>定长记录</span>和<span class='p red'>可变长记录</span>两种。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/z1SW35lVHXJN4q2.png" alt="image-20221017152740406" /></p>
<p>这个有结构文件由<span class='p red'>可变长记录</span>组成，由于各个学生的特长存在很大区别，因此“特长”这个数据项的长度不确定，这就导致了各条记录的长度也不确定。当然,没有特长的学生甚至可以去掉“特长”数据项。</p>
<h3 id="顺序文件"><a class="markdownIt-Anchor" href="#顺序文件"></a> 顺序文件</h3>
<ul>
<li>
<span class='p red'>顺序文件</span>:文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以<span class='p red'>顺序存储</span> 或<span class='p red'>链式存储</span>。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/HifJeIy6Zo5FbCE.png" alt="image-20221019083830860" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/vVHGbdK7uTwn5zU.png" alt="image-20221019083913618" /></p>
<div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>假设:已经知道了文件的起始地址（也就是第一个记录存放的位</p>
<p>思考1:能否快速找到第i个记录对应的地址?（即能否实现随机存取)</p>
<p>思考2:能否快速找到某个关键字对应的记录存放的位置?</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/L5d3ShpUsYIwNEi.png" alt="image-20221019084137961" /></p>
<ul>
<li>
<mark class="hl-label red">顺序可边长结构</mark> 
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/WtZ6DqsnjuYQXkS.png" alt="image-20221019084334534" /></p>
<p>虽然我们可以得出每一条记录是顺序存储的，但是这条记录的长度<span class='p red'>却不是固定的</span>， 这时候我们需要使用一个可边长记录表，来记录每条记录的长度，因为每条记录的长度都不是固定的，所以不能够直接找到第i条记录的位置。</p>
<p>结论:定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取;若能再保证记录的顺序结构,则可实现快速检索(即根据关键字快速找到对应记录)</p>
<p>注:一般来说，考试题目中所说的“顺序文件”指的是<span class='p red'>物理上顺序存储的顺序文件</span>。之后的讲解中提到的顺序文件也默认如此。可见，顺序文件的<span class='p red'>缺点</span>是<span class='p red'>增加/删除一个记录比较难</span>（如果是串结构则相对简单)</p>
<h3 id="索引文件"><a class="markdownIt-Anchor" href="#索引文件"></a> 索引文件</h3>
<p>对于可变长记录文件，要找到第i个记录，必须先顺序第查找前i-1个记录但是很多应用场景中又必须使用可变长记录。如何解决这个问题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/hgkU37OMdm15KGi.png" alt="image-20221019085036427" /></p>
<ul>
<li>
<span class='p red'>索引表</span>本身是<span class='p red'>定长记录的顺序文件</span>。因此可以快速找到第i个记录对应的索引项。
</li>
</ul>
<p>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。</p>
<p>每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此<span class='p red'>主要用于对信息处理的及时性要求比较高的场合</span>。<br />
另外，<span class='p red'>可以用不同的数据项建立多个索引表</span>。如:学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就可以根据“姓名”快速地检索文件了。</p>
<p>(Eg: SQL就支持根据某个数据项建立索引的功能)</p>
<h3 id="顺序索引文件"><a class="markdownIt-Anchor" href="#顺序索引文件"></a> 顺序索引文件</h3>
<p>思考索引文件的缺点:<span class='p red'>每个记录对应一个索引表项</span>，因此索引表可能会很大。比如:文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对<span class='p red'>存储空间的利用率就太低了</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/rSqRigeJdVsDhBL.png" alt="image-20221019085553039" /></p>
<p>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是:<span class='p red'>并不是每个记录对应一个索引表项</span>,而是<span class='p red'>一组记录对应一个索引表项</span>。</p>
<div class="tip "><p>检索效率</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/NqOifgU5rwXTGFh.png" alt="image-20221019085717249" /></p>
<p>若一个<span class='p red'>顺序文件</span>有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构的顺序文件），平均须查找<span class='p red'>5000个记录</span>。</p>
<p>若采用<span class='p red'>索引顺序文件</span>结构，可把10000个记录分为v10000 =100组，每组100个记录。则需要先顺序查找索引表找到分组（共100个分组，因此索引表长度为100，平均需要查50次〉，找到分组后，再在分组中顺序查找记录（每个分组100个记录，因此平均需要查50次）。可见，采用索引顺序文件结构后，<span class='p red'>平均查找次数减少为50+50 = 100次</span>。</p>
<h3 id="多级索引顺序文件"><a class="markdownIt-Anchor" href="#多级索引顺序文件"></a> 多级索引顺序文件</h3>
<p>为了进一步提高检索效率，可以为顺序文件<span class='p red'>建立多级索引表</span>。例如，对于一个含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>个记录的文件，可先为该文件建立一张低级索引表，每100个记录为一组，故低级索引表中共有10000个表项(即10000个定长记录），再把这10000个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有100个表项。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/1iycvJB7jrXePf3.png" alt="image-20221019090001026" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/aUBhoemkDzPVc8Z.png" alt="image-20221019090051745" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/fmE5F129SzgndYV.png" alt="image-20221019090128485" /></p>
<h2 id="文件目录"><a class="markdownIt-Anchor" href="#文件目录"></a> 文件目录</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/UWE3OhMpLRITwXo.png" alt="image-20221019090214002" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/09/jgxSJwFy5BsbD4Q.png" alt="image-20221019090357906" /></p>
<ul>
<li>
<mark class="hl-label red">目录文件中的一条记录就是文件控制块（FCB)</mark> 
</li>
<li>FCB的有序集合称为“文件目录”，一个FCB就是一个<span class='p red'>文件目录项</span>。</li>
<li>FCB中包含了文件的<span class='p red'>基本信息（文件名、物理地址</span>、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。</li>
<li>
<span class='p red'>最重要，最基本的还是文件名、文件存放的物理地址</span>。
</li>
<li>FCB 实现了文件名和文件之间的映射。使用户（用户程序)可以实现“按名存取”</li>
</ul>
<h3 id="文件控制块"><a class="markdownIt-Anchor" href="#文件控制块"></a> 文件控制块</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/F6V4BKgfshb2Wez.png" alt="image-20221019090824748" /></p>
<ul>
<li>
<mark class="hl-label red">文件控制块就是FCB的集合</mark> 
</li>
</ul>
<p>需要对目录进行哪些操作?</p>
<p>搜索:当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</p>
<p>创建文件:创建一个新文件时，需要在其所属的目录中增加一个目录项</p>
<p>删除文件:当删除一个文件时，需要在目录中删除相应的目录项</p>
<p>显示目录:用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</p>
<p>修改目录:某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项(如:文件重命名)</p>
<h3 id="单级目录结构"><a class="markdownIt-Anchor" href="#单级目录结构"></a> 单级目录结构</h3>
<p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。每个文件占一个目录项.</p>
<p>单级目录实现了“按名存取”，但是<span class='p red'>不允许文件重名</span>.</p>
<p>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。</p>
<p>显然，单级目录结构不适用于多用户操作系统。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/f1oSxEW7KqTYIek.png" alt="image-20221019091144814" /></p>
<h3 id="两极目录结构"><a class="markdownIt-Anchor" href="#两极目录结构"></a> 两极目录结构</h3>
<p>早期的多用户操作系统，采用两级目录结构。分为<span class='p red'>主文件目录</span>(MFD，Master File Directory)和<span class='p red'>用户文件目录</span>（UFD，User Flie Directory）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/9FmKXMi6HCpxwEQ.png" alt="image-20221019091453122" /></p>
<p>允许<span class='p red'>不同用户的文件重名</span>。文件名虽然相同,但是对应的其实是不同的文件</p>
<p>两级目录结构允许不同用户的文件重名,也可以在目录上实现实现访问限制（检查此时登录的用户名是否匹配）。但是两级目录结构依然缺乏灵活性,用户不能对自己的文件进行分类</p>
<h3 id="多级目录结构-树形目录结构"><a class="markdownIt-Anchor" href="#多级目录结构-树形目录结构"></a> 多级目录结构-树形目录结构</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/kIxSqhrQtfE69ip.png" alt="image-20221019091657741" /></p>
<p>用户(或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用“/”隔开。从<span class='p red'>根目录出发</span>的路径称为<span class='p red'>绝对路径</span>。</p>
<p>例如:<span class='p red'>自拍.jpg的绝对路径是“/照片/2015-08/自拍.jpg”</span>.</p>
<p>系统根据绝对路径一层一层地找到下一级目录。刚开始<span class='p red'>从外存读入根目录的目录表</span>;找到“照片”目录的存放位置后，从<span class='p red'>外存读入对应的目录表</span>;再找到“2015-08”目录的存放位置，<span class='p red'>再从外存读入对应目录表</span>;最后才找到文件“自拍.jpg”的存放位置。整个过程需要<span class='p red'>3次读磁盘I/O操作</span>。</p>
<p>例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某个文件时，可以使用<span class='p red'>从当前目录出发</span>的“<mark class="hl-label red">相对路径</mark> ”。</p>
<p>在Linux中，“.”表示当前目录，因此如果“照片”是当前目录，则&quot;自拍.jpg&quot;的<span class='p red'>相对路径为</span>:</p>
<p>“<span class='p red'>./2015-08/自拍.jpg</span>”。从当前路径出发，只需要查询内存中的“照片”目录表，即可知道”2015-08”目录表的存放位置，从外存调入该目录，即可知道“自拍.jpg”存放的位置了。</p>
<p>可见，引入“<span class='p red'>当前目录</span>”和“<span class='p red'>相对路径</span>”后，磁盘I/O的次数减少了。这就提升了访问文件的效率。</p>
<h3 id="无环图目录结构"><a class="markdownIt-Anchor" href="#无环图目录结构"></a> 无环图目录结构</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/clSGoXmOEtDIh2p.png" alt="image-20221019092315491" /></p>
<p>在树形目录结构的基础上,增加一些指向同一节点的有向边，使整个目录成为一个<span class='p red'>有向无环图</span>。可以更方便地<span class='p red'>实现多个用户间的文件共享</span>。</p>
<ul>
<li>
<span class='p red'>可以用不同的文件名指向同一个文件</span>，甚至可以指向同一个目录（共享同一目录下的所有内容）。
</li>
<li>
<p>需要为<span class='p red'>每个共享结点设置一个共享计数器</span>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使<span class='p red'>共享计数器减1</span>，并不会直接删除共享结点。</p>
</li>
<li>
<span class='p red'>只有共享计数器减为0时，才删除结点</span>。
</li>
<li>
<p>注意:共享文件不同于复制文件。在<span class='p red'>共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化</span>。</p>
</li>
</ul>
<h3 id="索引节点fcb的改进"><a class="markdownIt-Anchor" href="#索引节点fcb的改进"></a> 索引节点(FCB的改进)</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/7SfXkhJ6nzvTUjH.png" alt="image-20221019092904907" /></p>
<p>其实在查找各级目录的过程中只需要用到“文件名”这个信息,有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录表“瘦身”来提升效率。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/81sWwjgFlrUGv6Q.png" alt="image-20221019093004427" /></p>
<p>思考有何好处?</p>
<p>假设一个FCB是64B，磁盘块的大小为1KB，则每个盘块中只能存放16个FCB。若一个文件目录中共有640个目录项，则共需要占用640/16= 40个盘块。因此按照某文件名检索该目录，<span class='p red'>平均需要查询320个目录项</span>。</p>
<p>若<span class='p red'>使用索引结点机制</span>，文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那么按文件名检索目录<span class='p red'>平均只需耍读入320/64=5个磁盘块</span>。显然，这<span class='p red'>将大大提升文件检索速度</span>。</p>
<p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p>
<p>存放<span class='p red'>在外存中</span>的索引结点称为“<span class='p red'>磁盘索引结点</span>”，当索引结点<span class='p red'>放入内存</span>后称为“<span class='p red'>内存索引结点</span>”。</p>
<p>相比之下<span class='p red'>内存索引结点中需要增加一些信息</span>，比如:文件是否被修改、此时有几个进程正在访问该文件等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/skCOq789ahz3ovd.png" alt="image-20221019093503522" /></p>
<h2 id="文件的物理结构"><a class="markdownIt-Anchor" href="#文件的物理结构"></a> 文件的物理结构</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/LQZSPNm91MDzfjI.png" alt="image-20221019093644952" /></p>
<div class="tip "><p>文件块，磁盘块</p>
</div>
<p>类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”。很多操作系统中，<span class='p red'>磁盘块的大小与内存块、页面的大小相同</span>.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/gbS6cA1jM7OaoLI.png" alt="image-20221019093915877" style="zoom:50%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/DWvw5mgeK386XfI.png" alt="image-20221019093952882" style="zoom:50%;" /></p>
<p>在内存管理中，进程的逻辑地址空间被分为一个一个页面</p>
<p>同样的，在外存管理中，为了方便对文件数据的管理，<span class='p red'>文件的逻辑地址空间也被分为了一个一个的文件“块”</span>。</p>
<p>于是文件的逻辑地址也可以表示为（<span class='p red'>逻辑块号，块内地址</span>）的形式。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/LiaVoC2QMqI875f.png" alt="image-20221019094201123" style="zoom: 50%;" />
<h3 id="文件的分配方式连续分配"><a class="markdownIt-Anchor" href="#文件的分配方式连续分配"></a> 文件的分配方式：连续分配</h3>
<ul>
<li>
<span class='p red'>连续分配</span>方式要求<span class='p red'>每个文件在磁盘上占有一组连续的块</span>。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/xfjzDrUu4Xktm9d.png" alt="image-20221019095019085" /></p>
<p>用户通过逻辑地址来操作自己的文件，操作系统如何实现从逻辑地址到物理地址的映射?</p>
<p>(逻辑块号，块内地址)→(物理块号，块内地址）。<span class='p red'>只需转换块号就行，块内地址保持不变</span>.</p>
<p>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB)</p>
<ul>
<li>
<mark class="hl-label red">物理块号=起始块号＋逻辑块号</mark> 
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/jtl9mLDKSFnOukB.png" alt="image-20221019095452126" /></p>
<p>例如我想要找到文件aaa中逻辑块号为2的地址，我们先要找到aaa对应的FCB中的起始块号4，然后4+2 = 6，最后得出逻辑地址为6</p>
<p>可以直接算出逻辑块号对应的物理块号,因此<span class='p red'>连续分配支持顺序访问和直接访间（即随机访问)</span>.</p>
<p>读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。</p>
<p>结论:<span class='p red'>连续分配的文件在顺序读/写时速度最快</span>.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/5OM69pZBLcHbNrq.png" alt="image-20221019095914647" style="zoom:50%;" />
<ul>
<li>物理上连续分配的文件A占用了连续的三个块，</li>
<li>橙色区域为其他文件已经占用的磁盘块</li>
<li>绿色区域为空闲磁盘块</li>
<li>若此时文件A要拓展，需要再增加一个磁盘块（总共需要连续的4个磁盘块)。由于采用连续结构，因此文件A占用的磁盘块必须是连续的。</li>
<li>因此只能将文件A全部“迁移”到绿色区域。</li>
<li>结论:物理上采用<span class='p red'>连续分配的文件不方便拓展</span>。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/OZuRiXEnjfgk7oB.png" alt="image-20221019100150022" style="zoom:50%;" />
<p>橙色区域为非空闲块,绿色区域为空闲磁盘块</p>
<p>若此时创建的新文件大小为3个块,那么无法为其分配足够的存储空间</p>
<p>结论:物理上采用<span class='p red'>连续分配</span>.</p>
<p>可以用<span class='p red'>紧凑</span>来处理碎片，但是需要耗费很大的时间代价。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/2cdxOePvC36lSKj.png" alt="image-20221019100547379" style="zoom:50%;" />
<ul>
<li>
<span class='p red'>优点</span>:支持顺序访问和直接访问（即随机访问)﹔连续分配的文件在顺序访问时速度最快
</li>
<li>
<span class='p red'>缺点</span>:不方便文件拓展;存储空间利用率低，会产生磁盘碎片
</li>
</ul>
<h3 id="文件的分配方式链接分配"><a class="markdownIt-Anchor" href="#文件的分配方式链接分配"></a> 文件的分配方式：链接分配</h3>
<ul>
<li>
<span class='p red'>链接分配</span>采取离散分配的方式，可以为文件分配离散的磁盘块。分为<span class='p red'>隐式链接和显式链接</span>两种。
</li>
</ul>
<div class="tip "><p>隐式链接</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/kgTKYcxFoi34Evn.png" alt="image-20221019101553757" /></p>
<p>目录中记录了文件存放的起始块号和结束块号。当然,也可以增加一个字段来表示文件的长度</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/y52LsovpdCkMTwn.png" alt="image-20221019101537235" style="zoom:50%;" />
<p>除了文件的最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针,这些指针用户是透明的</p>
<p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项(FCB)…</p>
<p>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块,再找到2号逻辑块的存放位置…以此类推。</p>
<p>因此，读入i号逻辑块，总共需要i+1次磁盘I/O。</p>
<p>结论:采用<span class='p red'>链式分配（隐式链接)</span>方式的文件，<span class='p red'>只支持顺序访问，不支持随机访问</span>，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</p>
<p>结论:采用隐式链接的<span class='p red'>链接分配方式，很方便文件拓展</span>。</p>
<p>另外,所有的空闲磁盘块都可以被利用，<span class='p red'>不会有碎片问题外存利用率高</span>。</p>
<div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>隐式链接―—除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p>
<p>优点:很方便文件拓展，不会有碎片问题，外存利用率高。</p>
<p>缺点:只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</p>
</div>
<div class="tip "><p>显示链接</p>
</div>
<p>把用于链接文件各物理块的指针<span class='p red'>显式地存放在一张表中</span>。即文件分配表（FAT,File AllocatIOn Table)</p>
<p>目录中只需记录文件的起始块号</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/lO8zd9XBIhQ1K2U.png" alt="image-20221019103038259" /></p>
<p>假设某个新创建的文件“aaa”依次存放在磁盘块2→5→0→1</p>
<p>假设某个新创建的文件“bbb”依次存放在磁盘块4→2→3→3</p>
<ul>
<li>
<span class='p red'>注意:一个磁盘仅设置一张FAT。开机时</span>，并常驻内存。FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。
</li>
</ul>
<p>如何<span class='p red'>实现文件的逻辑块号到物理块号的转变</span>:</p>
<p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项(FCB） …</p>
<p>从目录项中找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT往后找到i号逻辑块对应的物理块号。<span class='p red'>逻辑块号转换成物理块号的过程不需要读磁盘操作</span>。</p>
<p>结论:采用<span class='p red'>链式分配（显式链接)</span>方式的文件，支持顺序访问，也<span class='p red'>支持随机访问（想访问i号逻辑块时，并不需要依次访问之前的0~i-1号逻辑块）</span>，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</p>
<p>显然，显式链接也<span class='p red'>不会产生外部碎片，也可以很方便地对文件进行拓展</span>。</p>
<div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>显式链接一一把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表（FAT，FileAllocatIOn Table)。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，<span class='p red'>并常驻内存</span>。</p>
<p>优点:很方便文件拓展，不会有碎片问题，外存利用率高，并且<span class='p red'>支持随机访问</span>。相比于隐式链接来说，<span class='p red'>地址转换时不需要访问磁盘，因此文件的访问效率更高</span>。</p>
<p>缺点:文件分配表的需要占用一定的存储空间。</p>
</div>
<h3 id="文件的分配方式索引的分配"><a class="markdownIt-Anchor" href="#文件的分配方式索引的分配"></a> 文件的分配方式：索引的分配</h3>
<ul>
<li>
<span class='p red'>索引分配</span>允许文件离散地分配在各个磁盘块中，系统会<span class='p red'>为每个文件建立一张索引表</span>，索引表中<span class='p red'>记录了文件的各个逻辑块对应的物理块</span>（索引表的功能类似于内存管理中的页表一一建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为<span class='p red'>数据块</span>。
</li>
</ul>
<p>假设某个新创建的文件“aaa”的数据依次存放在磁盘块2→5 → 13 →9。7号磁盘块作为“aaa”的索引块,索引块中保存了索引表的内容。</p>
<p>注:在显式链接的链式分配方式中，文件分配表FAT是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张。</p>
<p>可以用固定的长度表示物理块号（如:假设磁盘总容量为1TB=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>40</mn></msup></mrow><annotation encoding="application/x-tex">2^{40}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>B，磁盘块大小为1KB，则共有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>个磁盘块，则可用4B表示磁盘块号），因此，索引表中的“逻辑块号”可以是隐含的。</p>
<p>从目录项中可知索引表存放位置,将索引表从外存读入内存，并查找索引表即可知i号逻辑块在外存中的存放位置。</p>
<p>可见，<span class='p red'>索引分配方式可以支持随机访问。文件拓展也很容易实现</span>（只需要给文件分配一个空闲块，并增加一个索引表项即可)但是<span class='p red'>索引表需要占用一定的存储空间</span>.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/mIq6NhDeloLQvKA.png" alt="image-20221019105228841" style="zoom:50%;" />
<p>若每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放256个索引项。</p>
<p>如果一个文件的大小超过了256块,那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题?</p>
<ul>
<li>链接方案</li>
<li>多层索引</li>
<li>混合索引</li>
</ul>
<div class="tip "><p>链接方案</p>
</div>
<p>链接方案: 如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p>
<p>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。</p>
<p>若一个文件大小为256× 256KB =65,536 KB = 64MB</p>
<p>该文件共有256×256个块，也就对应256×256个索引项，也就需要256个索引块来存储，这些索引块用链接方案连起来。</p>
<p>若<span class='p red'>想要访问文件的最后一个逻辑块</span>,就必须找到最后一个索引块（第256个索引块），而各个索引块之间是用指针链接起来的,因此必须<span class='p red'>先顺序地读入前255个索引块</span>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/WNdYf6h5XVBv7Zm.png" alt="image-20221019110435399" style="zoom:50%;" />
<div class="tip "><p>索引分配</p>
</div>
<ul>
<li>
<span class='p red'>多层索引</span>:建立多层索引(<span class='p red'>原理类似于多级页表</span>）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/Ldu1CcITsSo4p7Q.png" alt="image-20221019110959249" /></p>
<p>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。</p>
<p>若某文件采用<span class='p red'>两层索引</span>，则该<span class='p red'>文件的最大长度</span>可以到256×256×1KB= 65,536 KB = 64MB</p>
<p>可根据逻辑块号算出应该查找索引表中的哪个表项。如:要访问1026号逻辑块，则1026/256=4，1026%256=2</p>
<p>因此可以先将一级索引表调入内存，查询4号表项，将其对应的二级索引表调入内存，再查询二级索引表的2号表项即可知道1026号逻辑块存放的磁盘块号了。访问目标数据块，<span class='p red'>需要3次磁盘I/O</span>。</p>
<p>若采用<span class='p red'>三层索引</span>，则<span class='p red'>文件的最大长度为</span>256×256×256×1KB = 16GB</p>
<p>类似的，<span class='p red'>访问目标数据块</span>.</p>
<ul>
<li>采用K层索引结构,且<span class='p red'>顶级索引表未调内存</span>，则访问一个数据块只需要K+1读磁盘操作</li>
</ul>
<div class="tip "><p>混合索引</p>
</div>
<p>混合索引:多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引(直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引（指向两层索引表)）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/roHBAiCRpklfhPa.png" alt="image-20221019123117710" /></p>
<ul>
<li>
<span class='p red'>索引分配</span>允许文件离散地分配在各个磁盘块中，系统会<span class='p red'>为每个文件建立一张索引表</span>，索引表中<span class='p red'>记录了文件的各个逻辑块对应的物理块</span>（索引表的功能类似于内存管理中的页表―-建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为<span class='p red'>索引块</span>。文件数据存放的磁盘块称为<span class='p red'>数据块</span>。
<p>若文件太大，索引表项太多，可以采取以下三种方法解决:</p>
<ol>
<li>
<span class='p red'>链接方案</span>:如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。<span class='p red'>缺点</span>:若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到i号索引块，必须先依次读入0~i-1号索引块,这就导致磁盘I/O次数过多，查找效率低下。
</li>
<li>
<span class='p red'>多层索引</span>:建立多层索引（<span class='p red'>原理类似于多级页表</span>)。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块
<p>采用K层索引结构，且<span class='p red'>顶级索引表未调入内存</span>，则访问一个数据块只需要K +1次读磁盘操作。<span class='p red'>缺点</span>:即使是小文件，访问一个数据块依然需要K+1次读磁盘操作。</p>
</li>
<li>
<span class='p red'>混合索引</span>:多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<span class='p red'>直接地址索引</span>（直接指向数据块），又包含<span class='p red'>一级间接索引</span>（指向单层索引表)、还包含<span class='p red'>两级间接索引</span>（指向两层索引表）。优点:对于小文件来说，访问一个数据块所需的读磁盘次数更少。
</li>
</ol>
</li>
<li>
<mark class="hl-label red">超级超级超级重要考点</mark> :
<ul>
<li>要会根据多层索引、混合索引的结构计算出文件的最大长度(Key:各级索引表最大不能超过一个块)﹔</li>
<li>要能自己分析访问某个数据块所需要的读磁盘次数（Key:FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入.顶级索引块。每次读入下一级的索引块都需要一次读他盘操作。另外，要注意题目条件一一<span class='p red'>顶级索引块是否已调入内存</span>)</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/27Z68I4TYOxwfgV.png" alt="image-20221019123655813" /></p>
<h2 id="文件存储空间管理"><a class="markdownIt-Anchor" href="#文件存储空间管理"></a> 文件存储空间管理</h2>
<p>文件存储空间管理：<span class='p red'>就是对空闲磁盘块的管理</span>.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/acRjxmMINELzh4F.png" alt="image-20221019123800263" /></p>
<h3 id="存储空间的划分和初始化"><a class="markdownIt-Anchor" href="#存储空间的划分和初始化"></a> 存储空间的划分和初始化</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/i7IOrsv9SU1Aoxf.png" alt="image-20221019123939377" /></p>
<h3 id="存储空间管理-空闲表法"><a class="markdownIt-Anchor" href="#存储空间管理-空闲表法"></a> 存储空间管理-空闲表法</h3>
<p>适用于<span class='p red'>连续分配的方式</span>.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/eGBhzwK1uJWRrx9.png" alt="image-20221019124047343" /></p>
<p>如何分配磁盘块:与内存管理中的动态分区分配很类似，为一个文件<span class='p red'>分配连续的存储空间</span>。同样<span class='p red'>可采用首次适应、最佳适应、最坏适应等算法</span>来决定要为文件分配哪个区间。</p>
<p>如何回收磁盘块:与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况</p>
<ol>
<li>回收区的前后都没有相邻空闲区;</li>
<li>回收区的前后都是空闲区;</li>
<li>回收区前面是空闲区;</li>
<li>回收区后面是空闲区。</li>
</ol>
<ul>
<li>
<span class='p red'>总之，回收时需要注意表项的合并问题</span>。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/NRHbZMkAaEr4yuK.png" alt="image-20221019124907191" /></p>
<div class="tip "><p>空闲盘块链</p>
</div>
<p>操作系统保存着<span class='p red'>链头、链尾指针</span>。</p>
<p>如何分配:若某文件申请K个盘块，则从链头开始依次<span class='p red'>摘下K个盘块分配</span>，并修改空闲链的链头指针。</p>
<p>如何回收:<span class='p red'>回收的盘块依次挂到链尾</span>，并修改空闲链的链尾指针。</p>
<p>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作</p>
<div class="tip "><p>空闲盘区链</p>
</div>
<p>如何分配：若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区分配给文件。<span class='p red'>若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件</span>，注意分配后可能要修改相应的链指针、盘区大小等数据</p>
<p>如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p>
<p>离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高</p>
<h3 id="存储空间管理-位示图法"><a class="markdownIt-Anchor" href="#存储空间管理-位示图法"></a> 存储空间管理-位示图法</h3>
<ul>
<li>
<span class='p red'>位示图</span>:每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中一个字的字长是16位，字中的每一位对应一个盘块。因此<span class='p red'>可以用(字号，位号）对应一个盘块号</span>。当然有的题目中也描述为（<span class='p red'>行号，列号</span>)
</li>
<li>
<mark class="hl-label red">重要重要重要:要能自己推出盘块号与(字号位号）相互转换的公式。</mark> 
</li>
<li>
<span class='p red'>注意题目条件:盘块号、字号、位号</span>到底是从0开始还是从1开始
</li>
</ul>
<p>如本例中<span class='p red'>盘块号、字号、位号从0开始</span>，若n表示字长，则…</p>
<p>(字号,位号)=(i,j)的二进制位对应的盘块号b=ni+ j</p>
<p>b号盘块对应的字号i= b/n，位号j= b%n</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/2D9tJX1VHnQ5ZLs.png" alt="image-20221019130345302" /></p>
<p>如何分配:若文件需要k个块，</p>
<ol>
<li>顺序扫描位示图，找到k个相邻或不相邻的“0”;</li>
<li>根据字号、位号算出对应的盘块号，将相应盘块分配给文件;</li>
<li>将相应位设置为“1”。</li>
</ol>
<p>如何回收:</p>
<ol>
<li>根据回收的盘块号计算出对应的字号、位号;</li>
<li>将相应二进制位设为“0”</li>
</ol>
<h3 id="存储空间管理成组链接法"><a class="markdownIt-Anchor" href="#存储空间管理成组链接法"></a> 存储空间管理–成组链接法</h3>
<p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了<span class='p red'>成组链接法</span>对磁盘空闲块进行管理。</p>
<p>文件卷的目录区中专门用一个磁盘块作为“<span class='p red'>超级块</span>”，当系统启动时需要将<span class='p red'>超级块读入内存</span>。并且要保证内存与外存中的“超级块”数据一致。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/WMZApHCkfBmSeu6.png" alt="image-20221019130723485" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/9JuvimN5BpnhSRH.png" alt="image-20221019130812827" /></p>
<ul>
<li>
<mark class="hl-label red">如何分配</mark> 
</li>
<li>需要1个空闲块
<ol>
<li>检查第一个分组的块数是否足够。1&lt;100，因此是足够的。</li>
<li>分配第一个分组中的1个空闲块，并修改相应数据</li>
</ol>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/1uiCDKmToMcGAw5.png" alt="image-20221019131324664" /></p>
<ul>
<li>需要100个空闲块
<ol>
<li>检查第一个分组的块数是否足够。100=100，是足够的。</li>
<li>分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中。</li>
</ol>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/ILbj1NUFdQCMy8c.png" alt="image-20221019131158146" /></p>
<mark class="hl-label red">如何回收</mark> 
<ul>
<li>假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块。</li>
<li>假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。<mark class="hl-label red">需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组</mark> 。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/7c98QBFDPvIwegS.png" alt="image-20221019131726123" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/WuyPg5UmxfkKSMD.png" alt="image-20221019131741671" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/YSf7TMmFsgUE4IG.png" alt="image-20221019131758305" /></p>
<h2 id="文件的基本操作"><a class="markdownIt-Anchor" href="#文件的基本操作"></a> 文件的基本操作</h2>
<h3 id="创建文件create系统调用"><a class="markdownIt-Anchor" href="#创建文件create系统调用"></a> 创建文件(create系统调用)</h3>
<p>进行Create系统调用时，需要提供的几个主要参数:</p>
<ol>
<li>所需的外存空间大小（如:一个盘块，即1KB)</li>
<li>文件存放路径（“D:/Demo”)</li>
<li>文件名(这个地方默认为“新建文本文档.txt”)</li>
</ol>
<p>操作系统在处理Create系统调用时，主要做了两件事:</p>
<ol>
<li>
<span class='p red'>在外存中找到文件所需的空间</span>（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间)
</li>
<li>根据文件存放路径的信息找到该目录对应的目录文件（此处就是D:/Demo目录），在目录中<span class='p red'>创建该文件对应的目录项</span>。目录项中包含了文件名、文件在外存中的存放位置等信息。</li>
</ol>
<h3 id="删除文件delete系统调用"><a class="markdownIt-Anchor" href="#删除文件delete系统调用"></a> 删除文件(delete系统调用)</h3>
<p>进行Delete系统调用时，需要提供的几个主要参数:</p>
<ol>
<li>文件存放路径（“D:/Demo”)</li>
<li>文件名（“test.txt”)</li>
</ol>
<p>操作系统在处理Delete系统调用时，主要做了几件事:</p>
<ol>
<li>根据文件存放路径找到相应的目录文件，从目录中<span class='p red'>找到文件名对应的目录项</span>。</li>
<li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，<span class='p red'>回收文件占用的磁盘块</span>。(回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理)</li>
<li>从目录表中<span class='p red'>删除文件对应的目录项</span>。</li>
</ol>
<h3 id="读文件read系统调用"><a class="markdownIt-Anchor" href="#读文件read系统调用"></a> 读文件(read系统调用)</h3>
<p>进程使用read系统调用完成写操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可)，还需要指明要读入多少数据（如:读入1KB）、指明读入的数据要放在内存中的什么位置。</p>
<p>操作系统在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p>
<h3 id="写文件write系统调用"><a class="markdownIt-Anchor" href="#写文件write系统调用"></a> 写文件(write系统调用)</h3>
<p>进程使用write系统调用完成写操作，需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可)，还需要指明要写出多少数据（如:写出1KB）、写回外存的数据放在内存中的什么位置</p>
<p>操作系统在处理write 系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</p>
<h3 id="打开文件open系统调用"><a class="markdownIt-Anchor" href="#打开文件open系统调用"></a> 打开文件(open系统调用)</h3>
<p>在很多操作系统中，在对文件进行操作之前，要求用户先使用open 系统调用“打开文件”，需要提供的几个主要参数:</p>
<ol>
<li>文件存放路径（“D:/Demo”)</li>
<li>文件名( “test.txt”)</li>
<li>要对文件的操作类型（如: r只读;rw读写等)</li>
</ol>
<p>操作系统在处理open系统调用时，主要做了几件事:</p>
<ol>
<li>根据文件存放路径找到相应的目录文件，从目录中找到<span class='p red'>文件名对应的的目录项</span>，并检查该用户是否有指定的操作权限。</li>
<li>
<span class='p red'>将目录项复制到内存中的“打开文件表”中</span>。并将对应表目的编号返回给用户。之后<span class='p red'>用户使用打开文件表的编号来指明要操作的文件</span>。
</li>
</ol>
<p>将<mark class="hl-label red">目录表从外存中复制到内存中，以后用户在访问文件的时候，就不需要从新从外存中读取了</mark> </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/QqLcfEXM6n1HFhk.png" alt="image-20221019145801031" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/e5qH21AjhWrpJm4.png" alt="image-20221019150228371" /></p>
<h3 id="关闭文件close系统调用"><a class="markdownIt-Anchor" href="#关闭文件close系统调用"></a> 关闭文件(close系统调用)</h3>
<p>进程使用完文件后，要“关闭文件”操作系统在处理Close系统调用时，主要做了几件事:</p>
<ol>
<li>将进程的打开文件表相应表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的打开计数器count减1，若count =0，则删除对应表项。</li>
</ol>
<h2 id="文件共享"><a class="markdownIt-Anchor" href="#文件共享"></a> 文件共享</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/DCN1uJeT2rixKht.png" alt="image-20221019152131063" /></p>
<p>注意:<span class='p red'>多个用户共享同一个文件</span>，意味着系统中只有“一份”文件数据。并且只要某个用户<span class='p red'>修改了该文件的数据</span>，其他用户<span class='p red'>也可以看到文件数据的变化</span>。</p>
<p>如果是多个用户都“<span class='p red'>复制</span>”了同一个文件，那么系统中会有“<span class='p red'>好几份</span>”文件数据。<span class='p red'>其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响</span>。</p>
<h3 id="基于索引节点的共享方式硬链接"><a class="markdownIt-Anchor" href="#基于索引节点的共享方式硬链接"></a> 基于索引节点的共享方式(硬链接)</h3>
<p>知识回顾:索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/KGtcm47hWVZaLwX.png" alt="image-20221019152610117" /></p>
<p>索引结点中设置一个链接计数变量count，用于表示链接到本索引结点上的用户目录项数。</p>
<p>若count =2，说明<span class='p red'>此时有两个用户目录项链接到该索引结点上</span>，或者说是有两个用户在共享此文件。若<span class='p red'>某个用户决定“删除”该文件</span>，则只是要<span class='p red'>把用户目录中与该文件对应的目录项删除</span>，且索引结点的count值减1。</p>
<p>若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</p>
<p>当count=0的时候，系统负责删除文件</p>
<h3 id="基于符号链的共享方式软连接"><a class="markdownIt-Anchor" href="#基于符号链的共享方式软连接"></a> 基于符号链的共享方式(软连接)</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/Puc5dJXNUjIGYqD.png" alt="image-20221019152949308" /></p>
<p>当User3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/w7rT1tB8hRLUFjQ.png" alt="image-20221019153208151" /></p>
<h2 id="文件保护"><a class="markdownIt-Anchor" href="#文件保护"></a> 文件保护</h2>
<h3 id="口令保护"><a class="markdownIt-Anchor" href="#口令保护"></a> 口令保护</h3>
<p>为文件设置一个“口令”(如: abc112233），用户请求访问该文件时必须提供“口令”。</p>
<p>口令<mark class="hl-label red">一般存放在文件对应的FCB或索引结点中</mark> 。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比,如果正确，则允许该用户访问文件</p>
<p>优点:保存口令的空间开销不多，验证口令的时间开销也很小。</p>
<p>缺点:正确的“口令”存放在系统内部，不够安全。</p>
<h3 id="加密保护"><a class="markdownIt-Anchor" href="#加密保护"></a> 加密保护</h3>
<p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。</p>
<p>Eg:一个最简单的加密算法―—异或加密，<span class='p red'>假设用于加密/解密的“密码”为“01001”</span>.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/r5gFVZeHDyKbQ7w.png" alt="image-20221019155417628" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/09/BaRL2AsWmfVruti.png" alt="image-20221019155456287" /></p>
<p>优点:保密性强，不需要在系统中存储“密码”</p>
<p>缺点:编码/译码，或者说加密/解密要花费一定时间。</p>
<h3 id="访问控制"><a class="markdownIt-Anchor" href="#访问控制"></a> 访问控制</h3>
<p>在每个文件的FCB（或索引结点）中增加一个访问控制列表（Access-Control List,ACL)，该表中记录了各个用户可以对该文件执行哪些操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/tyIHejrWSfs7pxm.png" alt="image-20221019160435992" /></p>
<p>有的计算机可能会有很多个用户,因此访问控制列表可能会很大，可以用精简的访问列表解决这个问题</p>
<p>精简的访问列表:以“组”为单位，标记各“组”用户可以对文件执行哪些操作。</p>
<p>如:分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。</p>
<p>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/RpCyDWsV8BmUYaN.png" alt="image-20221019160542290" /></p>
<p>若想要让某个用户能够读取文件，只需要把该用户放入“文件主的伙伴”这个分组即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/l523Oy4v1e6CQai.png" alt="image-20221019160857948" /></p>
<h2 id="文件系统的层次结构"><a class="markdownIt-Anchor" href="#文件系统的层次结构"></a> 文件系统的层次结构</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/SqoUlzvLfu8i45e.png" alt="image-20221019161724461" /></p>
<p>用一个例子来辅助记忆文件系统的层次结构:</p>
<p>假设某用户请求删除文件“D:/工作目录/学生信息.xlsx”的最后100条记录。</p>
<ol>
<li>用户需要通过操作系统提供的接口发出上述请求一一<span class='p red'>用户接口</span>.</li>
<li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项一一<span class='p red'>文件目录系统</span>.</li>
<li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限-----<span class='p red'>存取控制模块（存取控制验证层)</span>.</li>
<li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址一一<span class='p red'>逻辑文件系统与文件信息缓冲区</span>.</li>
<li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址一一<span class='p red'>物理文件系统</span>.</li>
<li>要删除这条记录，必定要对磁盘设备发出请求一一<span class='p red'>设备管理程序模块</span>.</li>
<li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收一一<span class='p red'>辅助分配模块</span>.</li>
</ol>
<h2 id="磁盘的结构"><a class="markdownIt-Anchor" href="#磁盘的结构"></a> 磁盘的结构</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/sJpqnx3Sk4MXdhi.png" alt="image-20221019162240240" /></p>
<h3 id="磁盘磁道扇区"><a class="markdownIt-Anchor" href="#磁盘磁道扇区"></a> 磁盘，磁道，扇区</h3>
<p>磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/jJmDohIcAtIONkT.png" alt="image-20221019163031932" /></p>
<h3 id="磁盘的读写操作"><a class="markdownIt-Anchor" href="#磁盘的读写操作"></a> 磁盘的读写操作</h3>
<p>需要把“磁头”移动到想要读/写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/joL14lQWFqKpacU.png" alt="image-20221019163135597" /></p>
<h3 id="盘面柱面"><a class="markdownIt-Anchor" href="#盘面柱面"></a> 盘面，柱面</h3>
<p>一个盘片可能对应着两个面，上面和下面</p>
<p>每个盘面对应一个磁头</p>
<p>所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退”</p>
<p>所有盘面中<span class='p red'>相对位置相同的磁道</span>组成<span class='p red'>柱面</span>,</p>
<p>可用（<span class='p red'>柱面号，盘面号，扇区号</span>）来定位任意一个“磁盘块”。在“文件的物理结构”小节中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号)的地址形式。</p>
<p>可根据该地址读取一个“块”</p>
<ol>
<li>根据“柱面号”移动磁臂，让磁头指向指定柱面;</li>
<li>激活指定盘面对应的磁头;</li>
<li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/5lEFfzKZshLeRCQ.png" alt="image-20221019163226119" /></p>
<h3 id="磁盘的分类"><a class="markdownIt-Anchor" href="#磁盘的分类"></a> 磁盘的分类</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/vxuYLN7XldyBD8M.png" alt="image-20221019163623561" /></p>
<p>磁头<span class='p green'>可以移动的</span>称为<span class='p red'>活动头磁盘</span>。磁臂可以来回伸缩来带动磁头定位磁道</p>
<p>磁头<span class='p green'>不可移动的</span>称为<span class='p red'>固定头磁盘</span>。这种磁盘中每个磁道有一个磁头</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/Ric89TUzVWbj4k6.png" alt="image-20221019163804326" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/BreFogc7tM9STvf.png" alt="image-20221019162841626" /></p>
<h2 id="磁盘调度算法"><a class="markdownIt-Anchor" href="#磁盘调度算法"></a> 磁盘调度算法</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/AZdM6UsqwfQOocy.png" alt="image-20221019163907799" /></p>
<h3 id="一次磁盘读写操作所需要的时间"><a class="markdownIt-Anchor" href="#一次磁盘读写操作所需要的时间"></a> 一次磁盘读/写操作所需要的时间</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/UadXytN6Iq9wD2v.png" alt="image-20221019171206374" /></p>
<ul>
<li>
<span class='p red'>寻找时间</span>（寻道时间）Ts:在读/写数据前，将磁头移动到指定磁道所花的时间。
<ol>
<li>
<p>启动磁头臂是需要时间的。假设耗时为s;</p>
</li>
<li>
<p>移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则:寻道时间Ts = s+ m×n</p>
</li>
<li>
<span class='p red'>延迟时间$T_R$</span>:通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r(单位:转/秒，或转/分），则
<span class='p red'>平均所需的延迟时间TR=(1/2)×(1/r)= 1/(2r)</span>
</li>
<li>
<p>传输时间Tt:从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N。</p>
<p>则:<span class='p red'>传输时间Tt =(1/r)×(b/N)= b/(rN)</span>.</p>
<p>总的平均存取时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub><mo>=</mo><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mi>r</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>r</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_t=T_s+ 1/2r + b/(rN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>.</p>
</li>
</ol>
</li>
<li>
<span class='p red'>延迟时间</span>和<span class='p red'>传输时间</span>都<span class='p red'>与磁盘转速相关</span>，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间,<span class='p red'>只能够通过优化寻找时间来进行优化</span>
</li>
</ul>
<h3 id="先来先服务算法"><a class="markdownIt-Anchor" href="#先来先服务算法"></a> 先来先服务算法</h3>
<p>根据进程请求访问磁盘的先后顺序进行调度。</p>
<p>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道</p>
<p>按照FCFS的规则，按照请求到达的顺序，磁头需要依次移动到55，58、39、18、90、160、150、38、184号磁道</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/ehdQ4D2uw8INS6C.png" alt="image-20221019182647885" /></p>
<p>磁头总共移动了45+3+19+21+72+70+10+112+146=498 个磁道</p>
<p>响应一个请求平均需要移动498/9=55.3个磁道(平均寻找长度)</p>
<ul>
<li>
<mark class="hl-label red">优点</mark> : 公平;如果请求访问的磁道比较集中的话，算法性能还算过的去
</li>
<li>
<mark class="hl-label red">缺点</mark> :如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能 上很差，寻道时间长。
</li>
</ul>
<p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。( 其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)</p>
<p>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、 90、160、150、38、 184号磁道</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/KaIEjFe69NTQcGH.png" alt="image-20221019183341715" /></p>
<p>磁头总共移动了(100-18) + (184-18) = 248个磁道</p>
<p>响应一个请求平均需要移动248/9=27.5个磁道(平均寻找长度)</p>
<p>优点:<span class='p red'>性能较好，平均寻道时间短</span>.</p>
<p>缺点:<span class='p red'>可能产生“饥饿”现象</span>.</p>
<p>本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、 184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。</p>
<p>产生饥饿的原因：	磁头在一个小区域内来回跳动</p>
<h3 id="扫描算法"><a class="markdownIt-Anchor" href="#扫描算法"></a> 扫描算法</h3>
<p>SSTF算法会产生饥饿的原因在于:磁头有可能在一个小区域内来回来去地移动。为了防止这个问题,可以规定，<span class='p red'>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</span>。这就是<span class='p red'>扫描算法(SCAN)的思想</span>。由于磁头移动的方式很像电梯，因此也叫<span class='p red'>电梯算法</span>。</p>
<p>假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且<span class='p red'>此时磁头正在往磁道号增大的方向移动</span>，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/NB63YtmQhlsRpZu.png" alt="image-20221019184214138" /></p>
<p>磁头总共移动了(200-100) + (200-18) = 282个磁道响应一个请求平均需要移动282/9=31.3个磁道(平均寻找长度)</p>
<p>优点:性能较好，平均寻道时间较短，<span class='p red'>不会产生饥饿现象</span>.</p>
<p>缺点:</p>
<ol>
<li>只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。</li>
<li>SCAN算法对于各个位置磁道的响应频率不平均(如:假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一 段距离;而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了)</li>
</ol>
<h3 id="look算法"><a class="markdownIt-Anchor" href="#look算法"></a> Look算法</h3>
<p>在<span class='p red'>扫描算法(SCAN)</span> 中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。<span class='p red'>LOOK调度算法</span>就是为了解决这个问题，<span class='p red'>如果在磁头移动方向.上已经没有别的请求，就可以立即改变磁头移动方向</span>。(边移动边观察， 因此叫LOOK)</p>
<p>假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且<span class='p red'>此时磁头正在往磁道号增大的方向移动</span>，有多个进程先后陆续地请求访问55、58、39、18、90、160、 150、 38、184 号磁道</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/jpZ2vinfAK1LTgY.png" alt="image-20221019184931995" /></p>
<p>磁头总共移动了(184- 100) + (184-18)= 250个磁道响应一个请求平均需要移动250/9=27.5个磁道(平均寻找长度)</p>
<p>优点:比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</p>
<h3 id="循环扫描算法c-scan"><a class="markdownIt-Anchor" href="#循环扫描算法c-scan"></a> 循环扫描算法(C-Scan)</h3>
<p>SCAN算法对于各个位置磁道的响应频率不平均，而<span class='p red'>C-SCAN算法</span>就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而<span class='p red'>返回时直接快速移动至起始端而不处理任何请求</span>。</p>
<p>假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，<span class='p red'>且此时磁头正在往磁道号增大的方向移动</span>，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/9gBsnNjme6UwGEZ.png" alt="image-20221019185120159" /></p>
<p>磁头总共移动了(200-100) + (200-0) + (90-0)= 390个磁道响应一个请求平均需要移动390/9=43.3个磁道(平均寻找长度)</p>
<p>优点:比起SCAN来，对于各个位置磁道的响应频率很平均。</p>
<p>缺点:只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了;并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。</p>
<h3 id="c-look调度算法"><a class="markdownIt-Anchor" href="#c-look调度算法"></a> C-LOOK调度算法</h3>
<p>C-SCAN算法的<span class='p red'>主要缺点是只有到达最边上的磁道时才能改变磁头移动方向</span>，并且磁头返回时不- -定需要返回到最边缘的磁道上。C-LOOK 算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p>
<p>假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，<span class='p red'>且此时磁头正在往磁道号增大的方向移动</span>，有多个进程先后陆续地请求访问55、58、39、18、 90、160、 150、38、184 号磁道</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/5S8YQgrdlyKp2us.png" alt="image-20221019185747318" /></p>
<p>磁头总共移动了(184-100) + (184-18) + (90-18)= 322个磁道</p>
<p>响应-一个请求平均需要移动322/9=35.8个磁道(平均寻找长度)</p>
<p>优点:比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/K9TWmuhRgIjfq1A.png" alt="image-20221019185901759" /></p>
<h2 id="减少磁盘延迟时间的方法"><a class="markdownIt-Anchor" href="#减少磁盘延迟时间的方法"></a> 减少磁盘延迟时间的方法</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/y3xA7zF2vgsTUhc.png" alt="image-20221019190224978" /></p>
<p>假设要连续读取橙色区域的2、3、4扇区:<span class='p red'>磁头读取一块的内容(也就是一个扇区的内容)后需要一小段时间处理</span>，而盘片又在<span class='p red'>不停地旋转</span>,</p>
<p>因此，<span class='p red'>如果2、3号扇区相邻着排列</span>，则读完2号扇区后<span class='p red'>无法连续不断地读入3号扇区</span>必须等盘片继续旋转，<span class='p red'>3号扇区再次划过磁头</span>，才能完成扇区读入</p>
<p>结论:磁头读入一个扇区数据后<span class='p red'>需要一小段时间处理</span>，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/vD6Eo9AVY5PXJ14.png" alt="image-20221019190259152" /></p>
<h3 id="减少延迟时间的方法交替编号"><a class="markdownIt-Anchor" href="#减少延迟时间的方法交替编号"></a> 减少延迟时间的方法:交替编号</h3>
<p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理.上有一-定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/HrYO9GUuTQPoZA5.png" alt="image-20221019191245748" /></p>
<h3 id="磁盘地址结构的设计"><a class="markdownIt-Anchor" href="#磁盘地址结构的设计"></a> 磁盘地址结构的设计</h3>
<p>思考:为什么?磁盘的物理地址是(柱面号，盘面号，扇区号)而不是(盘面号，柱面号，扇区号)</p>
<ul>
<li>答:读取地址连续的磁盘块时，采用(柱面号，盘:面号，扇区号)的地址结构可以减少磁头移动消耗的时间</li>
</ul>
<p>假设某磁盘有8个柱面/磁道(假设最内侧柱面/磁道号为0)4个盘面，8个扇区。则可用3个二进制位表示柱面，2个二进制位表示盘面，3个二进制位表示扇区。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/DKyMIVrvRJHAXL9.png" alt="image-20221019192346627" /></p>
<p>若<span class='p red'>物理地址结构是( 盘面号.柱面号.扇区号)</span>，且需要连，续读取物理地址( 00.000.000) ~ (00.001.111)的扇区:(00, 000, 000) ~ ( 00, 000, 111 )转两圈可读完</p>
<p>之后再读取物理地址相邻的区域，即(00.001.000) ~ ( 00.001.111 )，<span class='p red'>需要启动磁头臂，将磁头移动到下一个磁道</span>.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/G3fOPcWuQJszaX1.png" alt="image-20221019192638453" /></p>
<p>若<span class='p red'>物理地址结构是(柱面号，盘面号，扇区号)</span>，且需要连续读取物理地址(000, 00, 000) ~ (000, 01, 111)的扇区:(000.00.000) ~ ( 000.00.111 )由盘面0的磁头读入数据之后再读取物理地址相邻的区域，即(000.01.000) ~ ( 000.01.111 )，<span class='p red'>由于柱面号/磁道号相同，只是盘面号不同</span></p>
<ul>
<li>
<mark class="hl-label red">两者的区别就是：如果是连续存储的话，第一种编址方式是存满一个盘面之后再存放下一个盘面，第二种编址方式是：存完这个盘面的这个柱面之后，在存放下一个盘面相同位置的柱面</mark> 
</li>
</ul>
<h3 id="减少延迟时间的方法错位命名"><a class="markdownIt-Anchor" href="#减少延迟时间的方法错位命名"></a> 减少延迟时间的方法：错位命名</h3>
<div class="tip "><p>方案一:若相邻的盘面相对位置相同处扇区编号相同</p>
</div>
<p>如果不采用错位命名的话：就会呈现下面这种情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/scd9AzXfMSbUm6V.png" alt="image-20221019194408752" /></p>
<p>0号盘面的0号扇区，对应着一号盘面的0号扇区，<span class='p red'>如果我们读取的是（000.00.000）--（000.01.111）</span>，这时候我们经过了0号页面的两圈旋转，这时候应该访问（000.01.000），但是这时候一号的盘面的指针需要休息，这时候我们不能够读取该位置的数据，需要从新转一圈之后才能读取。这样会大大延长读取时间。</p>
<p>注意，<span class='p red'>所有盘面都是一起连轴转的</span></p>
<p>读取完磁盘块( 000.00.111)之后，需要短暂的时间处理，而盘面又在不停地转动，因此<span class='p red'>当(000.01.000)第一次划过1号盘面的磁头下方时，并不能读取数据</span>，只能再等该扇区再次划过磁头。</p>
<div class="tip "><p>方案二：错位命名</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/E4zUCofOQ3YFLDx.png" alt="image-20221019195428028" /></p>
<p>由于采用错位命名法，因此读取完磁盘块(000.00.111)之后，还有一段时间处理，当(000.01.000)第一次划过1号盘面的磁头下方时，就可以直接读取数据。从而减少了延迟时间</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/jZqo7lJytN64bdr.png" alt="image-20221019195537952" /></p>
<h2 id="磁盘的管理"><a class="markdownIt-Anchor" href="#磁盘的管理"></a> 磁盘的管理</h2>
<h3 id="磁盘初始化"><a class="markdownIt-Anchor" href="#磁盘初始化"></a> 磁盘初始化</h3>
<p>磁盘初始化:</p>
<p>Step 1:进行<span class='p red'>低级格式化(物理格式化)</span>，将磁盘的各个磁道<span class='p red'>划分为扇区</span>。一个扇区通常可分为头、数据区域(如512B大小)、尾三个部分组成。管理扇区所需要的各种数据结构- -般存放在头、尾两个部分，包括扇区校验码(如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误)</p>
<p>Step2:将磁盘分区，每个分区由若干柱面组成(即分为我们熟悉的C盘、D盘、E盘)</p>
<p>Step3:进行<span class='p red'>逻辑格式化</span>，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构( 如位示图、空闲分区表)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/UrzLSKpZaHciTO7.png" alt="image-20221019200632084" style="zoom:50%;" />
<h3 id="引导块"><a class="markdownIt-Anchor" href="#引导块"></a> 引导块</h3>
<p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行<span class='p red'>初始化程序</span>(<span class='p red'>自举程序</span>)完成的</p>
<p>初始化程序可以放在ROM ( 只读存储器）中。ROM中的数据在出厂时就写入了，<span class='p red'>并且以后不能再修改</span>.</p>
<p>注: ROM-般是出厂时就集成在主板上的</p>
<p>初始化程序程序( 自举程序）放在ROM中存在什么问题?</p>
<p>万一需要更新自举程序，将会很不方便，因为ROM中的数据无法更改。如何解决呢?</p>
<ul>
<li>采用自举装入程序</li>
<li>ROM中只存放很小的“自举装入程序”开机时计算机先<span class='p red'>运行“自举装入程序”</span>，通过执行该程序就<span class='p red'>可找到引导块</span>，并<span class='p red'>将完整的“自举程序”读入内存</span>，完成初始化</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/jhWo4GX6EqYiAdv.png" alt="image-20221019201501986" /></p>
<ul>
<li>完整的自举程序放在磁盘的启动块(即引导块/启动分区). 上，启动块位于磁盘的固定位置。</li>
<li>拥有启动分区的磁盘称为<span class='p red'>启动磁盘或系统磁盘(C:盘)</span>.</li>
</ul>
<h3 id="坏块的管理"><a class="markdownIt-Anchor" href="#坏块的管理"></a> 坏块的管理</h3>
<p>坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它</p>
<p>对于简单的磁盘，可以在逻辑格式化时(建立文件系统时)对整个磁盘进行坏块检查,标明哪些扇区是坏扇区，比如:在FAT表上标明。(在这种方式中， <span class='p red'>坏块对操作系统不透明</span>)</p>
<p>对于复杂的磁盘，磁盘控制器(磁盘设备内部的一个硬件部件)会维护-一个坏块链表。</p>
<p>在磁盘出厂前进行低级格式化(物理格式化)时就将坏块链进行初始化。</p>
<p>会保留一些“备用扇区”，用于替换坏块。这种方案称<span class='p red'>为扇区备用</span>。且这种处理方式中，<span class='p red'>坏块对操作系统透明</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/nyaUu4tVZIKQRTq.png" alt="image-20221019202048760" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/YbtXi24mgPeLOH6.png" alt="image-20221019202122901" /></p>
<h1 id="操作系统第五章io设备"><a class="markdownIt-Anchor" href="#操作系统第五章io设备"></a> 操作系统第五章：I/O设备</h1>
<h2 id="io的概念和分类"><a class="markdownIt-Anchor" href="#io的概念和分类"></a> IO的概念和分类</h2>
<h3 id="io的概念"><a class="markdownIt-Anchor" href="#io的概念"></a> IO的概念</h3>
<p>“I/O”就是“输入/输出”(Input/Output)</p>
<p>I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p>
<p>Write操作:向外部设备写出数据</p>
<p>Read操作:从外部设备读入数据</p>
<h3 id="io设备分类按使用特性分类"><a class="markdownIt-Anchor" href="#io设备分类按使用特性分类"></a> IO设备分类—按使用特性分类</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/xX2GwjtvPK6nYT7.png" alt="image-20221020103452929" style="zoom:50%;" />
<ul>
<li>人机交互类外部设备：<span class='p red'>数据速度传输慢</span>，鼠标、键盘、打印机等一一用于人机交互</li>
<li>存储设备：<span class='p red'>数据传输块</span>，移动硬盘、光盘等一一用于数据存储</li>
<li>网络设备通讯：<span class='p red'>数据传输速度介于上述两者之间</span>. 调制解调器等一一用于网络通信</li>
</ul>
<h3 id="io设备分类按传输速率分配"><a class="markdownIt-Anchor" href="#io设备分类按传输速率分配"></a> IO设备分类—按传输速率分配</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/C1YrITQL8y395mM.png" alt="image-20221020104020392" style="zoom:50%;" />
<ul>
<li>低速设备：鼠标、键盘一一传输速率为每秒几个到几百字节</li>
<li>中速设备: 如激光打印机等一一传输速率为每秒数千至上万个字节</li>
<li>高速设备: 如磁盘等一一传输速率为每秒数千字节至千兆字节的设备</li>
</ul>
<h3 id="io设备分类按信息交换的单位分类"><a class="markdownIt-Anchor" href="#io设备分类按信息交换的单位分类"></a> IO设备分类—按信息交换的单位分类</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/XDLzcTMKo8yqGmC.png" alt="image-20221020104222386" style="zoom:50%;" />
<ul>
<li>块设备：如磁盘等一一数据传输的基本单位是“块”，<span class='p red'>传输速率较高，可寻址，即对它可随机地读/写任一块</span>.</li>
<li>字符设备:鼠标、键盘等一一数据传输的基本单位是字符。<span class='p red'>传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式</span>.</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/LMskU39ijWD7ePz.png" alt="image-20221020104508628" style="zoom:50%;" />
<h2 id="io控制器"><a class="markdownIt-Anchor" href="#io控制器"></a> IO控制器</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/GhXeTS3VmELlrRM.png" alt="image-20221020104736218" style="zoom:50%;" />
<h3 id="机械部件"><a class="markdownIt-Anchor" href="#机械部件"></a> 机械部件</h3>
<p>IO设备的<span class='p red'>机械部件</span>主要用来执行具体IO操作。</p>
<p>如我们看得见摸得着的鼠标/键盘的按钮;显示器的LED屏;移动硬盘的磁臂、磁盘盘面。</p>
<p>IO设备的<span class='p red'>电子部件</span>通常是一块插入主板扩充槽的印刷电路板。</p>
<h3 id="电子部件"><a class="markdownIt-Anchor" href="#电子部件"></a> 电子部件</h3>
<p>CPU<span class='p red'>无法直接控制I/O设备的机械部件</span>，因此I/O设备还要有<span class='p red'>一个电子部件作为CPU和I/O设备机械部件之间的“中介”</span>，用于实现CPU对设备的控制。</p>
<p>这个电子部件就是<span class='p red'>I/O控制器</span>，又称<span class='p red'>设备控制器</span>。CPU可控制I/O控制器，又由I/O控制器来控制设备的机械部件。</p>
<ul>
<li>
<mark class="hl-label red">IO控制器的功能</mark> 
<ul>
<li>
<p>接受和识别CPU发出的命令</p>
<p>如CPU发来的read/write命令，I/O控制器中会有相应的<span class='p red'>控制寄存器</span>来存放命令和参数</p>
</li>
<li>
<p>向CPU报告设备的状态</p>
<p>IO控制器中会有相应的<span class='p red'>状态寄存器</span>用于记录IO设备的当前状态。如:1表示空闲，0表示忙碌</p>
</li>
<li>
<p>数据交换</p>
<p>IO控制器中会设置相应的<span class='p red'>数据寄存器</span>。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时,数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。</p>
</li>
<li>
<p>地址识别</p>
<p>类似于内存的地址,为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器</p>
</li>
</ul>
</li>
</ul>
<h3 id="io控制器的组成"><a class="markdownIt-Anchor" href="#io控制器的组成"></a> IO控制器的组成</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/pKWkzUdRGIFl2ji.png" alt="image-20221020143005870" /></p>
<ul>
<li>
<p>CPU与控制器的接口：</p>
<p>用于实现CPU与控制器之间的通信。CPU通过控制线发出命令;通过地址线指明要操作的设备;通过数据线来取出（输<br />
入）数据，或放入(输出）数据</p>
</li>
<li>
<p>IO逻辑</p>
<p>负责接收和识别CPL的各种命令（如地址译码)，并负责对设备发出命令</p>
</li>
<li>
<p>控制器与设备的接口</p>
<p>用于实现控制器与设备之间的通信</p>
</li>
</ul>
<p>值得注意的小细节:</p>
<ol>
<li>一个IO控制器可能<span class='p red'>会对应多个设备</span>;</li>
<li>数据寄存器、控制寄存器、状态寄存器可能有多个(如:每个控制/状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为<span class='p red'>内存映像I/O</span>;另一些计算机则采用I/O专用地址，即<span class='p red'>寄存器独立编址</span>。</li>
</ol>
<h3 id="内存映像io和寄存器独立编址"><a class="markdownIt-Anchor" href="#内存映像io和寄存器独立编址"></a> 内存映像IO和寄存器独立编址</h3>
<p>内存映射I/O。控制器中的寄存器与内存地址统一编址</p>
<p>优点:简化了指令。可以采用对内存进行操作的指令来对控制器进行操作</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/rKIfW9Byzp7agcl.png" alt="image-20221020143450983" style="zoom:67%;" />
<p>寄存器独立编制。控制器中的寄存器使用单独的地址</p>
<p>缺点:需要<span class='p red'>设置专门的指令</span>来实现对控制器的操作，<span class='p red'>不仅要指明寄存器的地址，还要指明控制器的编号</span>.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/3HFLvz5PuYjmOkE.png" alt="image-20221020143601505" style="zoom:50%;" />
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/MAgpmwVxaLzGkZs.png" alt="image-20221020143737717" /></p>
<h2 id="io控制方式"><a class="markdownIt-Anchor" href="#io控制方式"></a> IO控制方式</h2>
<p>分为四种：<span class='p red'>程序直接控制方式，中断驱动方式，DMA方式，通道控制方式</span></p>
<p>需要注意的问题：</p>
<ol>
<li>完成一次读/写操作的流程</li>
<li>CPU干预的频率;</li>
<li>数据传送的单位</li>
<li>数据的流向;</li>
<li>主要缺点和主要优点。</li>
</ol>
<h3 id="程序直接控制方式"><a class="markdownIt-Anchor" href="#程序直接控制方式"></a> 程序直接控制方式</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/4VGu9YRKzQPtokM.png" alt="image-20221020144952819" style="zoom:50%;" />
<ol>
<li>CPU向控制器发出读指令于是设备启动，并且状态寄存器设为1（未就绪)</li>
<li>轮询检查控制器的状态(<span class='p red'>其实就是在不断地执行程序的循环</span>，<mark class="hl-label green">若状态位一直是1，说明设备还没准备好要输入的数据，于是CPU会不断地轮询)</mark> .</li>
<li>输入设备准备好数据后<span class='p red'>将数据传给控制器，并报告自身状态</span>.</li>
<li>控制器<span class='p red'>将输入的数据放到数据寄存器中</span>,并将状态改为0（已就绪)</li>
<li>CPU发现设备已就绪，即可<span class='p red'>将数据寄存器中的内容读入CPU的寄存器中</span>,再把CPU寄存器中的内容放入内存.</li>
<li>若还要继续读入数据，则CPU继续发出读指令</li>
</ol>
<div class="tip "><p>详细信息</p>
</div>
<ol>
<li>完成一次读/写操作的流程（见右图，Key word:轮询)</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/qiFk1rubSg5jGwn.png" alt="image-20221020145835329" style="zoom:50%;" />
<ol start="2">
<li>
<p>CPU干预的频率</p>
<p>很频繁，IO操作开始之前、完成之后需要CPU介入，并且<span class='p red'>在等待I/O完成的过程中CPU需要不断地轮询检查</span>。</p>
</li>
<li>
<p>数据传送的单位每次读/写一个字</p>
</li>
<li>
<p>数据的流向</p>
<p>读操作（数据输入）:I/O设备→CPU(CPU寄存器)→内存</p>
<p>写操作（数据输出）:内存→CPU→&gt;IO设备</p>
<p>每个字的读/写都需要CPU的帮助</p>
</li>
<li>
<p>主要缺点和主要优点</p>
<p>优点:实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可(因此才称为“程序直接控制方式”)</p>
<p>缺点:<span class='p red'>CPU和I/O设备只能串行工作，CPU需要一直轮询检查长期处于“忙等”状态</span>，CPU利用率低。</p>
</li>
</ol>
<h3 id="中断驱动方式"><a class="markdownIt-Anchor" href="#中断驱动方式"></a> 中断驱动方式</h3>
<p>引入<span class='p red'>中断机制</span>。</p>
<p>由于I/O设备速度很慢，因此在CPU发出读/写命令后，可<span class='p red'>将等待I/O的进程阻塞</span>，先切换到别的进程执行。</p>
<p>当I/O<span class='p red'>完成后</span>，<mark class="hl-label red">控制器会向CPU发出一个中断信号</mark> ，</p>
<p>CPU<span class='p red'>检测到中断信号后</span>，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。</p>
<p>处理中断的过程中，CPU从I/O控制器<mark class="hl-label red">读一个字的数据传送到CPU寄存器</mark> ，再写入主存。</p>
<p>接着，<span class='p red'>CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行</span>。</p>
<p>注意:</p>
<ol>
<li>CPU会在<span class='p red'>每个指令周期的末尾检查中断</span>;</li>
<li>中断处理过程中<span class='p red'>需要保存、恢复进程的运行环境</span>，这个过程是需要一定时间开销的。可见，<span class='p red'>如果中断发生的频率太高，也会降低系统性能</span>。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/9bMQfP47EqOK3Da.png" alt="image-20221020150620847" style="zoom:50%;" />
<ol>
<li>
<p>完成一次读/写操作的流程（见s上图，Key word:中断)</p>
</li>
<li>
<p>CPU干预的频率</p>
<p>每次I/O操作开始之前、完成之后需要CPU介入。</p>
<p>在<span class='p red'>等待I/O完成的过程中CPU可以切换到别的进程执行</span>。</p>
</li>
<li>
<p>数据传送的单位</p>
<p>每次读/写一个字</p>
</li>
<li>
<p>数据的流向</p>
<p>读操作（数据输入）: I/O设备→&gt;CPU→内存</p>
<p>写操作（数据输出）:内存→&gt;CPU→&gt;I/O设备</p>
</li>
<li>
<p>主要缺点和主要优点</p>
<p>优点:与“程序直接控制方式”相比，在“中断驱动方式”中，I/O控制器会通过中断信号主动报告I/O已完成，CPU<span class='p red'>不再需要不停地轮询</span>。<span class='p red'>CPU和I/O设备可并行工作</span>，CPU利用率得到明显提升。</p>
<p>缺点:每个字在IO设备与内存之间的传输，<span class='p red'>都需要经过CPU</span>。而<span class='p red'>频繁的中断处理会消耗较多的CPU时间</span>。</p>
</li>
</ol>
<h3 id="dma方式"><a class="markdownIt-Anchor" href="#dma方式"></a> DMA方式</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/j9gnkoVP5DKOSA8.png" alt="image-20221020152700365" /></p>
<p>DR (Data Register，数据寄存器）:暂存从设备到内存，或从内存到设备的数据。</p>
<p>MAR (Memory Address Register，内存地址寄存器)∶</p>
<p>​	在输入时，MAR表示数据应放到内存中的什么位置;</p>
<p>​	输出时MAR表示要输出的数据放在内存中的什么位置。</p>
<p>DC ( Data Counter，数据计数器）:表示剩余要读/写的字节数。</p>
<p>CR(Command Register，命令/状态寄存器)︰用于存放CPU发来的I/O命令，或设备的状态信息。</p>
<ul>
<li>
<mark class="hl-label red">虽然宏观上是一块一块的读入，但是在微观上，还是一个字节一个字节的进行读入的，读入的字节现在放在DR中，然后通过MAR放到内存中</mark> 
</li>
</ul>
<ol>
<li>完成一次读/写操作的流程（见右图)</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/G9LYfSIWput57OQ.png" alt="image-20221020152619068" /></p>
<ol>
<li>
<p>CPU干预的频率</p>
<p>仅在传送一个或多个数据块的开始和结束时，才需要CPU千预。</p>
</li>
<li>
<p>数据传送的单位</p>
<p>每次读/写<span class='p red'>一个或多个块（注意:每次读写的只能是连续的多个块</span>.</p>
<p>如果不是连续的话我们需要CPU给出多条指令</p>
</li>
<li>
<p>数据的流向（<span class='p red'>不再需要经过CPU</span>)</p>
<p>读操作（数据输入） : I/O设备→内存</p>
<p>写操作（数据输出）:内存→I/O设备</p>
</li>
<li>
<p>主要缺点和主要优点</p>
<p>优点:数据传输以“块”为单位，<span class='p red'>CPU介入频率进一步降低</span>。数据的传输<span class='p red'>不再需要先经过CPU再写入内存</span>，数据传输效率进一步增加。CPU和I/O设备的并行性得到提升。</p>
<p>缺点:<span class='p red'>CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块</span>。</p>
</li>
</ol>
<h3 id="通道控制方式"><a class="markdownIt-Anchor" href="#通道控制方式"></a> 通道控制方式</h3>
<p>通道:一种<span class='p red'>硬件</span>，可以理解为是“<span class='p red'>弱鸡版的CPU</span>”。通道可以识别并执行一系列<span class='p red'>通道指令</span>.</p>
<p>与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的,也就是说通道与CPU共享内存</p>
<ol>
<li>CPU向通道发出I/O指令。指明通道程序在内存中的位置，并指明要操作的是哪个I/O设备。之后CPU就切换到其他进程执行了</li>
<li>通道执行内存中的通道程序（其中指明了要读入/写出多少数据,读/写的数据应放在内存的什么位置等信息）</li>
<li>通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断进行处理</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/Rl5Oa9VbYmjDyLF.png" alt="image-20221020154238432" /></p>
<ol>
<li>完成一次读/写操作的流程(见右图)</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/gMAyKfDceNt8FLP.png" alt="image-20221020153752899" style="zoom:50%;" />
<ol>
<li>
<p>CPU干预的频率</p>
<p>极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。</p>
</li>
<li>
<p>数据传送的单位</p>
<p>每次读/写<span class='p red'>一组数据块</span>.</p>
</li>
<li>
<p>数据的流向（<span class='p red'>在通道的控制下进行</span>)</p>
<p>读操作（数据输入）: I/O设备→内存</p>
<p>写操作（数据输出）:内存→IO设备</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/MHvqA5dS7JYpU9C.png" alt="image-20221020154416071" /></p>
<h2 id="io软件层次结构"><a class="markdownIt-Anchor" href="#io软件层次结构"></a> IO软件层次结构</h2>
<p>IO软件层次结构：用户层软件，设备独立性软件，设备驱动程序，中断处理程序，硬件</p>
<p>越上面的层次越接近用户</p>
<p>越下面的层次越接近硬件</p>
<p>每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节,向高层提供服务（“封装思想”)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/eGVLIPmvBSyzNXF.png" alt="image-20221020154912766" /></p>
<h3 id="用户层软件"><a class="markdownIt-Anchor" href="#用户层软件"></a> 用户层软件</h3>
<p>用户层软件<span class='p red'>实现了与用户交互的接口</span>，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作</p>
<p>用户层软件将用户请求翻译成格式化的I/O请求,并通过“系统调用”请求操作系统内核的服务</p>
<p>Eg: printf(hello, world!&quot;);会被<span class='p red'>翻译成等价的write系统调用</span>，当然，用户层软件也会在系统调用时填入相应参数。</p>
<p>Windows操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用(Windows API)</p>
<h3 id="设备独立性软件"><a class="markdownIt-Anchor" href="#设备独立性软件"></a> 设备独立性软件</h3>
<ul>
<li>
<span class='p red'>设备独立性软件</span>，又称<span class='p red'>设备无关性软件</span>。与设备的硬件特性无关的功能几乎都在这一层实现。
</li>
</ul>
<p>主要实现功能：</p>
<ol>
<li>
<p>向上层提供统一的调用接口（如read/write系统调用)</p>
</li>
<li>
<p>设备的保护</p>
<p>原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。</p>
</li>
<li>
<p>差错处理</p>
<p>设备独立性软件需要对一些设备的错误进行处理</p>
</li>
<li>
<p>设备的分配与回收</p>
</li>
<li>
<p>数据的缓冲与管理</p>
<p>可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</p>
</li>
<li>
<p>建立逻辑设备名到物理设备名的映射关系;根据设备类型选择<span class='p red'>调用相应的驱动程序</span>.</p>
<p>用户或用户层软件发出I/O操作相关系统调用的系统调用时，需要指明此次要操作的I/O设备的逻辑设备名(eg:去学校打印店打印时，需要选择打印机1/打印机2/打印机3，其实这些都是<span class='p red'>逻辑设备名</span>)</p>
<p>其中<span class='p red'>设备独立性软件</span>需要通过“<span class='p red'>逻辑设备表（LUT，Logical UnitTable）</span>”来确定逻辑设备对应的<span class='p red'>物理设备</span>，并找到该设备对应的<span class='p red'>设备驱动程序</span>.</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/E3kupFYCfVgsiXT.png" alt="image-20221020160717031" /></p>
<p>I/O设备被当做一种特殊的文件</p>
<p>不同类型的I/O设备需要有<span class='p red'>不同的驱动程序处理</span>.</p>
<p>操作系统系统可以采用两种方式管理<span class='p red'>逻辑设备表（LUT)</span>:</p>
<p>第一种方式，<span class='p red'>整个系统只设置一张LUT</span>，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</p>
<p>第二种方式，<span class='p red'>为每个用户设置一张LUT</span>，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</p>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>为什么不同的设备需要不同的设备驱动程序？</p>
<p>答：不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的揩令序列，来完成设置设备寄存器，检查设备状态等工作</p>
</div>
<h3 id="设备驱动程序"><a class="markdownIt-Anchor" href="#设备驱动程序"></a> 设备驱动程序</h3>
<p>主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read/write）转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器;检查设备状态等</p>
<p>不同的I/O设备<span class='p red'>有不同的硬件特性</span>，具体细节只有设备的厂家才知道。因此厂家<span class='p red'>需要根据设备的硬件特性设计并提供相应的驱动程序</span>。</p>
<p>驱动程序一般会以一个独立进程的方式存在</p>
<ul>
<li>
<mark class="hl-label red">设备驱动程序会直接和硬件打交道</mark> .
</li>
</ul>
<h3 id="中断处理程序"><a class="markdownIt-Anchor" href="#中断处理程序"></a> 中断处理程序</h3>
<p>当IO任务完成时，lIO控制器会发送一个<span class='p red'>中断信号</span>，系统会<span class='p red'>根据中断信号类型</span>找到相应的<span class='p red'>中断处理程序</span>并执行。中断处理程序的处理流程如下:</p>
<ul>
<li>
<mark class="hl-label red">中断处理程序也会直接的和硬件打交道</mark> .
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/pl6ZVUQRb8cTgdq.png" alt="image-20221020161907413" /></p>
<p>理解并记住I/O软件<span class='p red'>各个层次之间的顺序</span>，要能够推理判断某个处理应该是在哪个层次完成的（最常考的是设备独立性软件、设备驱动程序这两层。</p>
<p>只需理解一个特点即可:<mark class="hl-label red">直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的;没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的)</mark> .</p>
<h2 id="io核心子系统"><a class="markdownIt-Anchor" href="#io核心子系统"></a> IO核心子系统</h2>
<p>IO核心子系统实现的功能：主要是上面讲的<span class='p red'>设备独立性软件，设备驱动软件，中断处理程序</span>这三层实现的功能</p>
<h3 id="io调度"><a class="markdownIt-Anchor" href="#io调度"></a> IO调度</h3>
<ul>
<li>
<span class='p red'>I/O调度:用某种算法确定一个好的顺序来处理各个I/O请求</span>。
</li>
</ul>
<p>如:磁盘调度（先来先服务算法、最短寻道优先算法、SCAN算法, C-SCAN算法、LOOK算法、C-LOOK算法）。当多个磁盘IO请求到来时，用某种调度算法确定满足IO请求的顺序。</p>
<p>同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定I/O 调度顺序。</p>
<h3 id="设备保护"><a class="markdownIt-Anchor" href="#设备保护"></a> 设备保护</h3>
<p>操作系统需要实现<span class='p red'>文件保护功能</span>，不同的用户对各个文件有不同的访问权限（如:只读、读和写等）。</p>
<p>在UNIx系统中，<span class='p red'>设备被看做是一种特殊的文件</span>，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。(参考“文件保护”小节)</p>
<h2 id="假脱机技术spooling技术"><a class="markdownIt-Anchor" href="#假脱机技术spooling技术"></a> 假脱机技术(SPOOLING技术)</h2>
<h3 id="什么是脱机技术"><a class="markdownIt-Anchor" href="#什么是脱机技术"></a> 什么是脱机技术</h3>
<p>手工操作阶段:主机直接从IO设备获得数据，<span class='p red'>由于设备速度慢，主机速度很快</span>。人机速度矛盾明显，主机要浪费很多时间来等待设备</p>
<p>批处理阶段引入了<span class='p red'>脱机输入/输出技术</span>（用磁带完成）</p>
<p>引入脱机技术后，缓解了CPU与慢速IO设备的速度矛盾。另一方面，<span class='p red'>即使CPU在忙碌，也可以提前将数据输入到磁带</span>;即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。</p>
<p>在外围控制机的控制下,<span class='p red'>慢速输入设备的数据先被输入到更快速的磁带上</span>。之后主机<span class='p red'>可以从快速的磁带上读入数据</span>，从而缓解了速度矛盾</p>
<p>Tips:<mark class="hl-label red">为什么称为“脱机”</mark> —―脱离主机的控制进行的输入/输出操作。</p>
<h3 id="假脱机技术输入输出缓冲区"><a class="markdownIt-Anchor" href="#假脱机技术输入输出缓冲区"></a> 假脱机技术–输入/输出缓冲区</h3>
<p>“假脱机技术”，又称“SPOQLing 技术”是用软件的方式模拟脱机技术。SPOOLING系统的组成如下:</p>
<p>要实现SPOOLING 技术，<span class='p red'>必须要有多道程序技术的支持</span>。系统会建立“输入进程”和“输出进程”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/kpWuxgRvEPowBOC.png" alt="image-20221020180019193" /></p>
<p>在磁盘上开辟出两个存储区域一一“输入井”和“输出井”</p>
<p>“输入井”<mark class="hl-label red">模拟脱机输入时的磁带</mark> ，用于收容I/O设备输入的数据</p>
<p>“输出井”<mark class="hl-label red">模拟脱机输出时的磁带</mark> ，用于收容用户进程输出的数据</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/8ecC3PYiBVjKOol.png" alt="image-20221020180142716" /></p>
<p>“输入进程”<mark class="hl-label red">模拟脱机输入时的外围控制机</mark> .</p>
<p>输出进程<mark class="hl-label red">模拟脱机输出时的外围控制机</mark> </p>
<p>注意：<span class='p red'>输入缓冲区和输出缓冲区是在内存中的缓冲区</span>.</p>
<p>在输入进程的控制下，“<span class='p red'>输入缓冲区”用于暂存从输入设备输入的数据</span>，之后再转存到输入井中</p>
<p>在输出进程的控制下，<span class='p red'>“输出缓冲区”用于暂存从输出井送来的数据</span>，之后再传送到输出设备上</p>
<h3 id="共享打印机原理分析"><a class="markdownIt-Anchor" href="#共享打印机原理分析"></a> 共享打印机原理分析</h3>
<p>独占式设备一一<span class='p red'>只允许各个进程串行使用的设备</span>。一段时间内只能满足一个进程的请求。</p>
<p>共享设备一一<span class='p red'>允许多个进程“同时”使用的设备</span>（宏观上同时使用，微观上可能是交替使用）。可以同时满足多个进程的使用请求。</p>
<p>独占式设备的例子:</p>
<p>若进程1正在使用打印机,则进程2请求使用打印机时必然阻塞等待</p>
<ul>
<li>
<mark class="hl-label red">使用假脱机技术来让打印机实现共享</mark> ，假脱机文件队列（其实就是打印任务队列)
</li>
</ul>
<p>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们,而是由假脱机管理进程为每个进程做两件事:</p>
<ol>
<li>在磁盘输出井中<span class='p red'>为进程申请一个空闲缓冲区</span>（也就是说，这个缓冲区是在磁盘上的)，并将要打印的数据送入其中;</li>
<li>
<span class='p red'>为用户进程申请一张空白的打印请求表</span>，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。
</li>
</ol>
<p>当打印机空闲时，<span class='p red'>输出进程会从文件队列的队头取出一张打印请求表</span>，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务</p>
<p>虽然系统中<span class='p red'>只有一个台打印机</span>，但每个进程提出打印请求时，系统<span class='p red'>都会为在输出井中为其分配一个存储区</span>（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p>
<p>SPOOLING技术可以把一台物理设备<span class='p red'>虚拟</span>成逻辑上的多台设备，<span class='p red'>可将独占式设备改造成共享设备</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/DfnPCuxTrymFSHE.png" alt="image-20221020202056965" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/l6iuQR9BcmTxyWU.png" alt="image-20221020202213076" /></p>
<h2 id="设备的分配与回收"><a class="markdownIt-Anchor" href="#设备的分配与回收"></a> 设备的分配与回收</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/yer35fUCMBLVWzb.png" alt="image-20221020202333247" /></p>
<h3 id="设备分配时应考虑的因素"><a class="markdownIt-Anchor" href="#设备分配时应考虑的因素"></a> 设备分配时应考虑的因素</h3>
<div class="tip "><p>设备的固有属性</p>
</div>
<p>设备的固有属性可分为三种:独占设备、共享设备、虚拟设备。</p>
<ul>
<li>
<span class='p red'>独占设备</span>一一一个时段只能分配给一个进程（如打印机）
</li>
<li>
<span class='p red'>共享设备</span>一一可同时分配给多个进程使用（如磁盘)，各进程往往是宏观上同时共享使用设备，而微观上交替使用。
</li>
<li>
<span class='p red'>虚拟设备</span>一一采用SPOOLING 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLING技术实现的共享打印机)
</li>
</ul>
<div class="tip "><p>设备分配算法</p>
</div>
<p>先来先服务</p>
<p>优先级高者优先</p>
<p>短任务优先</p>
<div class="tip "><p>设备分配中的安全性</p>
</div>
<p>从进程运行的安全性上考虑，设备分配有两种方式:</p>
<ul>
<li>
<span class='p red'>安全分配方式</span>:为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。(eg:考虑进程请求打印机打印输出的例子)
<p>一个时段内每个进程只能使用一个设备</p>
<p>优点:破坏了“请求和保持”条件，不会死锁</p>
<p>缺点:对于一个进程来说，CPU和I/O设备只能串行工作</p>
</li>
<li>
<p>不安全分配方式:进程发出IO请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。</p>
<p>一个进程可以同时使用多个设备</p>
<p>优点:进程的计算任务和IO任务可以并行处理，使进程迅速推进</p>
<p>缺点:有可能发生死锁（死锁避免、死锁的检测和解除）</p>
</li>
</ul>
<h3 id="静态分配与动态分配"><a class="markdownIt-Anchor" href="#静态分配与动态分配"></a> 静态分配与动态分配</h3>
<p>静态分配:<span class='p red'>进程运行前为其分配全部所需资源，运行结束后归还资源</span>.</p>
<p>动态分配:<span class='p red'>进程运行过程中动态申请设备资源</span>.</p>
<h3 id="设备分配管理中的数据结构"><a class="markdownIt-Anchor" href="#设备分配管理中的数据结构"></a> 设备分配管理中的数据结构</h3>
<p>设备，控制器，通道之间的关系：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/stTKvp6L4CGYo1h.png" alt="image-20221020203659467" /></p>
<p>一个通道可控制多个设备控制器，每个设备控制器可控制多个设备。</p>
<div class="tip "><p>设备控制表(DCT)</p>
</div>
<ul>
<li>
<span class='p red'>设备控制表(DCT）</span>:系统为每个设备配置一张DCT，用于记录设备情况
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/n972qXoLI8jsPFK.png" alt="image-20221020204301522" /></p>
<p>设备类型：如:打印机/扫描仪/键盘</p>
<p>设备标识符：即物理设备名，系统中的每个设备的物理设备名唯一</p>
<p>设备状态：忙碌/空闲/故障…</p>
<p>指向控制器表的指针：每个设备由一个控制器控制，该指针可找到相应控制器的信息</p>
<p>重复执行次数或时间：当重复执行多次I/O操作后仍不成功，才认为此次I/O失败</p>
<p>设备队列的队首指针：指向正在等待该设备的进程队列（由进程PCB组成队列)<span class='p red'>“系统会根据阻塞原因不同，将进程PCB挂到不同的阻塞队列中”</span>.</p>
<div class="tip "><p>控制器控制表(COCT)</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/EJapAYr5wWhGn3N.png" alt="image-20221020204800864" /></p>
<p>通道标识符：各个通道的唯一ID</p>
<p>通道状态：忙碌/空闲/故障…</p>
<p>与通道连接的控制器表首址：可通过该指针找到该通道管理的所有控制器相关信息（COCT)</p>
<p>通道队列的队首指针：</p>
<p>通道队列的队尾指针：指向正在等待该通道的进程队列（由进程PCB组成队列)</p>
<div class="tip "><p>系统设备表(SDT)</p>
</div>
<ul>
<li>
<span class='p red'>系统设备表（SDT)</span>:记录了<span class='p red'>系统中全部设备</span>的情况，每个设备对应一个表目。
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/03/QidI785pHnS3hLM.png" alt="image-20221020205257697" /></p>
<h3 id="设备分配的步骤"><a class="markdownIt-Anchor" href="#设备分配的步骤"></a> 设备分配的步骤</h3>
<ol>
<li>根据进程请求的<span class='p red'>物理设备名</span>查找SDT（注:物理设备名是进程请求分配设备时提供的参数)</li>
<li>根据SDT找到DCT，若<span class='p red'>设备</span>忙碌则将进程PCB挂到<span class='p red'>设备等待队列</span>中，不忙碌则将<span class='p red'>设备</span>分配给进程。</li>
<li>根据DCT找到COCT，若<span class='p red'>控制器</span>忙碌则将进程PCB挂到<span class='p red'>控制器等待队列</span>中，不忙碌则将<span class='p red'>控制器</span>分配给进程。</li>
<li>根据cOCT找到CHCT，若<span class='p red'>通道</span>忙碌则将进程PCB挂到<span class='p red'>通道等待队列</span>中，不忙碌则将<span class='p red'>通道</span>分配给进程。</li>
</ol>
<p>缺点:</p>
<ol>
<li>用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li>
<li>若换了一个物理设备，则程序无法运行</li>
<li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li>
</ol>
<h3 id="设备分配步骤的改进方法"><a class="markdownIt-Anchor" href="#设备分配步骤的改进方法"></a> 设备分配步骤的改进方法</h3>
<p>改进方法:建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</p>
<ol>
<li>根据进程请求的<span class='p red'>逻辑设备名</span>查找SDT(<span class='p red'>注:用户编程时提供的逻辑设备名其实就是“设备类型”</span>)</li>
<li>查找SDT，找到用户进程<span class='p red'>指定类型的、并且空闲</span>的设备，将其分配给该进程。操作系统<span class='p red'>在逻辑设备表(LUT)中新增一个表项</span>。</li>
<li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>
<li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/RhkxMp65jqm2vrY.png" alt="image-20221020210539396" /></p>
<ul>
<li>
<span class='p red'>逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系</span>。
</li>
</ul>
<p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。</p>
<p>如果<span class='p red'>之后用户进程再次通过相同的逻辑设备名请求使用设备</span>。</p>
<p>逻辑设备表的设置问题:</p>
<p>整个系统只有一张LUT:各用户所用的<span class='p red'>逻辑设备名不允许重复</span>，适用于单用户操作系统</p>
<p>每个用户一张LUT:<span class='p red'>不同用户的逻辑设备名可重复</span>，适用于多用户操作系统</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/HjEcaJ7IZerKF6b.png" alt="image-20221020210757951" /></p>
<h2 id="缓冲区管理"><a class="markdownIt-Anchor" href="#缓冲区管理"></a> 缓冲区管理</h2>
<h3 id="什么是缓冲区有什么作用"><a class="markdownIt-Anchor" href="#什么是缓冲区有什么作用"></a> 什么是缓冲区？有什么作用？</h3>
<p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。使用<span class='p red'>硬件作为缓冲区</span>的<span class='p red'>成本较高，容量也较小</span>，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p>
<p>一般情况下，更多的是利用<span class='p red'>内存作为缓冲区</span>，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</p>
<div class="tip "><p>缓冲区的作用</p>
</div>
<ol>
<li>缓和CPU与I/O设备之间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li>
<li>解决数据粒度不匹配的问题</li>
<li>提高CPU与I/O设备之间的并行性</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/2KvBhozrgdUnlup.png" alt="image-20221020212638675" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/Worg7hCfytxeld6.png" alt="image-20221021083502277" /></p>
<p>CPU可以把要输出的数据<span class='p red'>快速地放入缓冲区</span>.</p>
<p>慢速的I/O设备<span class='p red'>可以慢慢从缓冲区取走数据</span>. <mark class="hl-label red">解决了CPU和IO设备之间速度不匹配问题</mark> .</p>
<p>如果不采用缓冲区的话：</p>
<p>如果是字符型设备，则每输出完一个字符就要向CPU发送一次中断信号，<mark class="hl-label red">可以减少CPU的中断频率</mark> .</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/OIh7CSKxHB9wrPf.png" alt="image-20221021083832834" /></p>
<p>输出进程每次可以生成一块数据,但I/O设备每次只能输出一个字符,使用缓冲区的话可以很好的解决证问题，等IO设备向缓冲区中输入的数据满了之后CPU在读取一整块内容，<mark class="hl-label default">解决了数据粒度不匹配问题</mark> </p>
<h3 id="单缓冲"><a class="markdownIt-Anchor" href="#单缓冲"></a> 单缓冲</h3>
<p>假设某用户进程请求某种块设备读入若干块的数据。<span class='p red'>若采用单缓冲的策略</span>，操作系统会<span class='p red'>在主存中为其分配一个缓冲区</span>（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p>
<p>注意:<span class='p red'>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出;当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/aeh3AHNUiBOGC9m.png" alt="image-20221021085142087" /></p>
<p>常考题型:<mark class="hl-label red">计算每处理一块数据平均需要多久</mark> ?</p>
<p>技巧:<span class='p red'>假定一个初始状态</span>，这就是处理一块数据平均所需时间。</p>
<p>在“<mark class="hl-label red">单缓冲</mark> ”题型中，可以<span class='p red'>假设初始状态为工作区满，缓冲区空</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/UJZ7SeqdrDCNzp2.png" alt="image-20221021085614023" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/rixXjRuJWV5Fyoq.png" alt="image-20221021085650194" /></p>
<h3 id="双缓冲"><a class="markdownIt-Anchor" href="#双缓冲"></a> 双缓冲</h3>
<p>假设某用户进程请求某种块设备读入若干块的数据。若采用<mark class="hl-label red">双缓冲</mark> 的策略，操作系统会<span class='p red'>在主存中为其分配两个缓冲区</span>（若题目中没有特别说明，一个缓冲区的大小就是一个块)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/Ao8R1ySOhs9ET6C.png" alt="image-20221021090330754" /></p>
<p>双缓冲题目中，假设初始状态为:<span class='p red'>工作区空，其中一个缓冲区满，另一个缓冲区空</span>.</p>
<ul>
<li>
<mark class="hl-label red">假设T>C+M</mark> 
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/Eya6FRip4vkqVPQ.png" alt="image-20221021090306260" /></p>
<ul>
<li>
<mark class="hl-label red">假设T<CM</mark> 
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/RaWjBXP8c23oFuG.png" alt="image-20221021090504602" /></p>
<p>结论:<mark class="hl-label (T,">采用双缓冲策略，处理一个数据块的平均耗时为Max</mark> .</p>
<h3 id="使用单双缓冲在通信时的区别"><a class="markdownIt-Anchor" href="#使用单双缓冲在通信时的区别"></a> 使用单双缓冲在通信时的区别</h3>
<p>两台机器之间通信时，可以配置缓冲区用于数据的发送和接受。</p>
<ul>
<li>
<mark class="hl-label red">单缓冲</mark> 
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/6uFUMvN4jfSQEJV.png" alt="image-20221021091308480" /></p>
<p>显然，若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。<mark class="hl-label red">因为只有在缓冲区为空的时候才能向里面写入数据，只有缓冲区满了之后才能从里面读出数据</mark> .</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/vHWiz13rZykQAut.png" alt="image-20221021091440533" /></p>
<p>若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。</p>
<p>注:<span class='p red'>管道通信中的“管道”其实就是缓冲区。要实现数据的双向传输，必须设置两个管道</span>.</p>
<h3 id="循环缓冲区"><a class="markdownIt-Anchor" href="#循环缓冲区"></a> 循环缓冲区</h3>
<p>将多个大小相等的缓冲区链接成一个循环队列。</p>
<p>注:以下图示中，<span class='p red'>橙色表示已充满数据的缓冲区，绿色表示空缓冲区</span>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/hMzw6JtVxmZYaCH.png" alt="image-20221021091700787" /></p>
<h3 id="缓冲池"><a class="markdownIt-Anchor" href="#缓冲池"></a> 缓冲池</h3>
<p>缓冲池<span class='p red'>由系统中共用的缓冲区组成</span>。这些缓冲区按使用状况可以分为:空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p>
<p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区:<mark class="hl-label red">用于收容输入数据的工作缓冲区（hin)</mark> 、<mark class="hl-label green">用于提取输入数据的工作缓冲区(sin)</mark> 、<mark class="hl-label hout)">用于收容输出数据的工作缓冲区(</mark> 、<mark class="hl-label orange">用于提取输出数据的工作缓冲区(sout)</mark> .</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/so8mpfePlNhDTvy.png" alt="image-20221021092205125" /></p>
<ul>
<li>
<p>输入进程请求输入数据</p>
<p>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区(hin）。冲满数据后将缓冲区挂到输入队列队尾</p>
</li>
<li>
<p>计算进程想要取得一块输入数据</p>
<p>从输入队列中取得一块冲满输入数据的缓冲区作为“提取输入数据的工作缓冲区sin）”。缓冲区读空后挂到空缓冲区队列</p>
</li>
<li>
<p>计算进程想要将准备好的数据冲入缓冲区</p>
<p>从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”。数据冲满后将缓冲区挂到输出队列队尾</p>
</li>
<li>
<p>输出进程请求输出数据</p>
<p>从输出队列中取得一块冲满输出数据的缓冲区作为“提取输出数据的工作缓冲区（sout） ”。缓冲区读空后挂到空缓冲区队列</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/OMjpHuVD2lmSX1x.png" alt="image-20221021091928152" /></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">Nuyoah</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://262259.xyz/2022/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://262259.xyz/2022/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/')">操作系统教程</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://s2.loli.net/2022/08/16/weL31EHsON5ldDU.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/08/16/weL31EHsON5ldDU.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/08/16/2yRjVx9gFKQaidA.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/08/16/2yRjVx9gFKQaidA.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://262259.xyz/2022/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=操作系统教程&amp;url=http://262259.xyz/2022/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&amp;pic=https://s2.loli.net/2022/11/21/aDwOWz8tq3yJ1Yb.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://262259.xyz" target="_blank">Nuyoah</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>计算机基础<span class="tagsPageCount">13</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://s3.bmp.ovh/imgs/2022/11/08/d8916c8dd7e09280.png?_r_=83605935-c04f-a0ba-c19b-8ce2ff7cf6fd" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/16/%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85%E5%B0%8F%E8%AE%B0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/21/9DvfsAuchF7NpBz.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">电脑组装小记</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/16/Java%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/21/Sm8lFrjtzUkihVy.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java邮件发送</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2022/05/05/HuffmanTree/" title="哈夫曼编译码器（实现中英文）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/21/jO1zT7NyZMcHpwr.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-05-05</div><div class="title">哈夫曼编译码器（实现中英文）</div></div></a></div><div><a href="/2021/05/05/KMP/" title="KMP"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/21/MAjwIXl1mVgNF4J.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-05-05</div><div class="title">KMP</div></div></a></div><div><a href="/2022/09/27/Vmtools%E5%AE%89%E8%BD%AC%E8%BF%87%E7%A8%8B%E5%92%8C%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/" title="Vmtools无法在虚拟机和物理机之间复制粘贴"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/19/vJMKhVAUYNXRQuE.jpg?_r_=dc7c96b7-3315-4239-6d64-451d6ed7e2d0" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-09-27</div><div class="title">Vmtools无法在虚拟机和物理机之间复制粘贴</div></div></a></div><div><a href="/2021/05/05/%E4%B8%B2%E6%95%B0%E7%BB%84%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="串数组广义表"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/21/jO1zT7NyZMcHpwr.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-05-05</div><div class="title">串数组广义表</div></div></a></div><div><a href="/2021/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="数据结构基本原理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/21/jO1zT7NyZMcHpwr.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-03-25</div><div class="title">数据结构基本原理</div></div></a></div><div><a href="/2021/06/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" title="栈和队列代码实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/21/jO1zT7NyZMcHpwr.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-06-25</div><div class="title">栈和队列代码实现</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display: none">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Nuyoah</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/zjhinsist" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2152889763@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%88%9D%E8%AF%95%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text"> 操作系统第一章：初试操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.</span> <span class="toc-text"> 操作系统的概念，功能和目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.</span> <span class="toc-text"> 操作系统的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text"> 操作系统的发展和分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text"> 操作系统的运行机制和体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">1.5.</span> <span class="toc-text"> 中断和异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text"> 系统调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text"> 操作系统第二章：进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E7%BB%84%E6%88%90%E7%BB%84%E6%88%90%E6%96%B9%E5%BC%8F%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.</span> <span class="toc-text"> 进程的定义，组成，组成方式，特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.</span> <span class="toc-text"> 进程的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text"> 进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.</span> <span class="toc-text"> 进程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text"> 线程概念多线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%B1%82%E6%AC%A1"><span class="toc-number">2.6.</span> <span class="toc-text"> 处理机调度的概念，层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B%E6%96%B9%E5%BC%8F"><span class="toc-number">2.7.</span> <span class="toc-text"> 进程调度的时机，切换与过程，方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-number">2.8.</span> <span class="toc-text"> 调度算法的评价指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text"> 调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fcfs%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1first-come-first-serve"><span class="toc-number">2.9.1.</span> <span class="toc-text"> FCFS（先来先服务）（First Come First Serve）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sjf%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88shortest-job-first"><span class="toc-number">2.9.2.</span> <span class="toc-text"> SJF（短作业优先）（Shortest Job First）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hrrn%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88highest-response-ratio-next"><span class="toc-number">2.9.3.</span> <span class="toc-text"> HRRN（高响应比优先）（Highest Response RatIO Next）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rr%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95round-robin"><span class="toc-number">2.9.4.</span> <span class="toc-text"> RR（时间片轮转调度算法）（Round-Robin）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.5.</span> <span class="toc-text"> 优先级调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E8%BF%94%E5%9B%9E%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.6.</span> <span class="toc-text"> 多级返回队列调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">2.10.</span> <span class="toc-text"> 进程同步和进程互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.11.</span> <span class="toc-text"> 进程互斥的软件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="toc-number">2.11.1.</span> <span class="toc-text"> 单标志法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5"><span class="toc-number">2.11.2.</span> <span class="toc-text"> 双标志先检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5"><span class="toc-number">2.11.3.</span> <span class="toc-text"> 双标志后检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#peterson%E7%AE%97%E6%B3%95"><span class="toc-number">2.11.4.</span> <span class="toc-text"> Peterson算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.12.</span> <span class="toc-text"> 进程互斥硬件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95"><span class="toc-number">2.12.1.</span> <span class="toc-text"> 中断屏蔽方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#testandsetts%E6%8C%87%E4%BB%A4tsl%E6%8C%87%E4%BB%A4"><span class="toc-number">2.12.2.</span> <span class="toc-text"> TestAndSet(Ts指令&#x2F;TSL指令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swap%E6%8C%87%E4%BB%A4xchg%E6%8C%87%E4%BB%A4"><span class="toc-number">2.12.3.</span> <span class="toc-text"> Swap指令(XCHG指令)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">2.13.</span> <span class="toc-text"> 信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%BD%A2%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.13.1.</span> <span class="toc-text"> 整形信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%80%A7%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.13.2.</span> <span class="toc-text"> 记录性信号量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-number">2.14.</span> <span class="toc-text"> 用信号量实现进程互斥，同步，前驱关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">2.14.1.</span> <span class="toc-text"> 用信号量实现进程互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.14.2.</span> <span class="toc-text"> 用信号量实现进程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-number">2.14.3.</span> <span class="toc-text"> 用信号量实现前驱关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.15.</span> <span class="toc-text"> 生产者消费者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.16.</span> <span class="toc-text"> 多生产者-多消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.17.</span> <span class="toc-text"> 单生产者多消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.18.</span> <span class="toc-text"> 读者写者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90"><span class="toc-number">2.19.</span> <span class="toc-text"> 哲学家进餐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">2.20.</span> <span class="toc-text"> 管程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">2.21.</span> <span class="toc-text"> 死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">2.22.</span> <span class="toc-text"> 预防死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">2.23.</span> <span class="toc-text"> 避免死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-number">2.24.</span> <span class="toc-text"> 死锁的检测和解除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text"> 操作系统第三章：内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text"> 内存的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 装入的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 链接的三种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.</span> <span class="toc-text"> 内存管理的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.3.</span> <span class="toc-text"> 覆盖与交换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 覆盖技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 交换技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text"> 连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 单一连续分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.4.2.</span> <span class="toc-text"> 固定分区分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.4.3.</span> <span class="toc-text"> 动态分区分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text"> 动态分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95first-fit"><span class="toc-number">3.5.1.</span> <span class="toc-text"> 首次适应算法(First Fit)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95best-fit"><span class="toc-number">3.5.2.</span> <span class="toc-text"> 最佳适应算法(Best Fit)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95worst-fit"><span class="toc-number">3.5.3.</span> <span class="toc-text"> 最坏适应算法(Worst Fit)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95next-fit"><span class="toc-number">3.5.4.</span> <span class="toc-text"> 邻近适应算法(Next Fit)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.6.</span> <span class="toc-text"> 基本分页存储管理的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.6.1.</span> <span class="toc-text"> 分页存储管理的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.6.2.</span> <span class="toc-text"> 如何实现地址的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.3.</span> <span class="toc-text"> 逻辑地址结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.6.4.</span> <span class="toc-text"> 页表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="toc-number">3.7.</span> <span class="toc-text"> 基本地址变换结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA"><span class="toc-number">3.7.1.</span> <span class="toc-text"> 对页表项的进一步讨论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">3.8.</span> <span class="toc-text"> 具有快表的地址变换机构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">3.8.1.</span> <span class="toc-text"> 局部性原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8%E6%9C%BA%E5%88%B6tlb-translation-lookaside-buffer"><span class="toc-number">3.8.2.</span> <span class="toc-text"> 快表机制(TLB, TranslatIOn Lookaside Buffer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%BF%AB%E8%A1%A8%E4%B9%8B%E5%90%8E%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">3.8.3.</span> <span class="toc-text"> 引入快表之后，地址的变化过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.9.</span> <span class="toc-text"> 两级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">3.9.1.</span> <span class="toc-text"> 单级页表存在什么问题?如何解决?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">3.9.2.</span> <span class="toc-text"> 两级页表的原理、逻辑地址结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">3.9.3.</span> <span class="toc-text"> 如何实现地址变换?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E9%97%AE%E9%A2%98%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%86%E8%8A%82"><span class="toc-number">3.9.4.</span> <span class="toc-text"> 两级页表问题需要注意的几个细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.10.</span> <span class="toc-text"> 基本分段存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-number">3.10.1.</span> <span class="toc-text"> 分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-number">3.10.2.</span> <span class="toc-text"> 段表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.10.3.</span> <span class="toc-text"> 分段和分页管理的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.11.</span> <span class="toc-text"> 段页式管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">3.12.</span> <span class="toc-text"> 虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">3.12.1.</span> <span class="toc-text"> 虚拟内存的定义和特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-number">3.12.2.</span> <span class="toc-text"> 如何实现虚拟内存技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.13.</span> <span class="toc-text"> 请求分页管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="toc-number">3.13.1.</span> <span class="toc-text"> 缺页中断机构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.14.</span> <span class="toc-text"> 页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95opt"><span class="toc-number">3.14.1.</span> <span class="toc-text"> 最佳置换算法(OPT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95fifo"><span class="toc-number">3.14.2.</span> <span class="toc-text"> 先进先出算法(FIFO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95lru"><span class="toc-number">3.14.3.</span> <span class="toc-text"> 最近最久未使用置换算法(LRU)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95clock"><span class="toc-number">3.14.4.</span> <span class="toc-text"> 时钟置换算法(Clock)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%9E%8B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.14.5.</span> <span class="toc-text"> 改进型的时钟置换算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.15.</span> <span class="toc-text"> 页面分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">3.15.1.</span> <span class="toc-text"> 页面分配置换策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">3.15.2.</span> <span class="toc-text"> 调入页面的时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E9%A2%A0%E7%B0%B8%E7%8E%B0%E8%B1%A1"><span class="toc-number">3.15.3.</span> <span class="toc-text"> 抖动(颠簸)现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA"><span class="toc-number">3.15.4.</span> <span class="toc-text"> 工作机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text"> 操作系统第四章：文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text"> 初识文件管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text"> 文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 有结构文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 顺序文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 索引文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.4.</span> <span class="toc-text"> 顺序索引文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.5.</span> <span class="toc-text"> 多级索引顺序文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">4.3.</span> <span class="toc-text"> 文件目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 文件控制块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 单级目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%9E%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.3.</span> <span class="toc-text"> 两极目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.4.</span> <span class="toc-text"> 多级目录结构-树形目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.5.</span> <span class="toc-text"> 无环图目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9fcb%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">4.3.6.</span> <span class="toc-text"> 索引节点(FCB的改进)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.</span> <span class="toc-text"> 文件的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">4.4.1.</span> <span class="toc-text"> 文件的分配方式：连续分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D"><span class="toc-number">4.4.2.</span> <span class="toc-text"> 文件的分配方式：链接分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-number">4.4.3.</span> <span class="toc-text"> 文件的分配方式：索引的分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text"> 文件存储空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.5.1.</span> <span class="toc-text"> 存储空间的划分和初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86-%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95"><span class="toc-number">4.5.2.</span> <span class="toc-text"> 存储空间管理-空闲表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86-%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95"><span class="toc-number">4.5.3.</span> <span class="toc-text"> 存储空间管理-位示图法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">4.5.4.</span> <span class="toc-text"> 存储空间管理–成组链接法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.6.</span> <span class="toc-text"> 文件的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6create%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.6.1.</span> <span class="toc-text"> 创建文件(create系统调用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6delete%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.6.2.</span> <span class="toc-text"> 删除文件(delete系统调用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6read%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.6.3.</span> <span class="toc-text"> 读文件(read系统调用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6write%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.6.4.</span> <span class="toc-text"> 写文件(write系统调用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6open%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.6.5.</span> <span class="toc-text"> 打开文件(open系统调用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6close%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.6.6.</span> <span class="toc-text"> 关闭文件(close系统调用)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">4.7.</span> <span class="toc-text"> 文件共享</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">4.7.1.</span> <span class="toc-text"> 基于索引节点的共享方式(硬链接)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AC%A6%E5%8F%B7%E9%93%BE%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%E8%BD%AF%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.7.2.</span> <span class="toc-text"> 基于符号链的共享方式(软连接)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">4.8.</span> <span class="toc-text"> 文件保护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A3%E4%BB%A4%E4%BF%9D%E6%8A%A4"><span class="toc-number">4.8.1.</span> <span class="toc-text"> 口令保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4"><span class="toc-number">4.8.2.</span> <span class="toc-text"> 加密保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">4.8.3.</span> <span class="toc-text"> 访问控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">4.9.</span> <span class="toc-text"> 文件系统的层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">4.10.</span> <span class="toc-text"> 磁盘的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%A3%81%E9%81%93%E6%89%87%E5%8C%BA"><span class="toc-number">4.10.1.</span> <span class="toc-text"> 磁盘，磁道，扇区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">4.10.2.</span> <span class="toc-text"> 磁盘的读写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%98%E9%9D%A2%E6%9F%B1%E9%9D%A2"><span class="toc-number">4.10.3.</span> <span class="toc-text"> 盘面，柱面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.10.4.</span> <span class="toc-text"> 磁盘的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.11.</span> <span class="toc-text"> 磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">4.11.1.</span> <span class="toc-text"> 一次磁盘读&#x2F;写操作所需要的时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95"><span class="toc-number">4.11.2.</span> <span class="toc-text"> 先来先服务算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95"><span class="toc-number">4.11.3.</span> <span class="toc-text"> 扫描算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#look%E7%AE%97%E6%B3%95"><span class="toc-number">4.11.4.</span> <span class="toc-text"> Look算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95c-scan"><span class="toc-number">4.11.5.</span> <span class="toc-text"> 循环扫描算法(C-Scan)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-look%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.11.6.</span> <span class="toc-text"> C-LOOK调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E7%A3%81%E7%9B%98%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.12.</span> <span class="toc-text"> 减少磁盘延迟时间的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%A4%E6%9B%BF%E7%BC%96%E5%8F%B7"><span class="toc-number">4.12.1.</span> <span class="toc-text"> 减少延迟时间的方法:交替编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.12.2.</span> <span class="toc-text"> 磁盘地址结构的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%E9%94%99%E4%BD%8D%E5%91%BD%E5%90%8D"><span class="toc-number">4.12.3.</span> <span class="toc-text"> 减少延迟时间的方法：错位命名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">4.13.</span> <span class="toc-text"> 磁盘的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.13.1.</span> <span class="toc-text"> 磁盘初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E5%9D%97"><span class="toc-number">4.13.2.</span> <span class="toc-text"> 引导块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%8F%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">4.13.3.</span> <span class="toc-text"> 坏块的管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%94%E7%AB%A0io%E8%AE%BE%E5%A4%87"><span class="toc-number">5.</span> <span class="toc-text"> 操作系统第五章：I&#x2F;O设备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text"> IO的概念和分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.1.</span> <span class="toc-text"> IO的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB%E6%8C%89%E4%BD%BF%E7%94%A8%E7%89%B9%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.2.</span> <span class="toc-text"> IO设备分类—按使用特性分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB%E6%8C%89%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E5%88%86%E9%85%8D"><span class="toc-number">5.1.3.</span> <span class="toc-text"> IO设备分类—按传输速率分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB%E6%8C%89%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%8D%95%E4%BD%8D%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.4.</span> <span class="toc-text"> IO设备分类—按信息交换的单位分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text"> IO控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E6%A2%B0%E9%83%A8%E4%BB%B6"><span class="toc-number">5.2.1.</span> <span class="toc-text"> 机械部件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%83%A8%E4%BB%B6"><span class="toc-number">5.2.2.</span> <span class="toc-text"> 电子部件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">5.2.3.</span> <span class="toc-text"> IO控制器的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8Fio%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E7%8B%AC%E7%AB%8B%E7%BC%96%E5%9D%80"><span class="toc-number">5.2.4.</span> <span class="toc-text"> 内存映像IO和寄存器独立编址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text"> IO控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 程序直接控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text"> 中断驱动方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dma%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.3.</span> <span class="toc-text"> DMA方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.4.</span> <span class="toc-text"> 通道控制方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.</span> <span class="toc-text"> IO软件层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82%E8%BD%AF%E4%BB%B6"><span class="toc-number">5.4.1.</span> <span class="toc-text"> 用户层软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6"><span class="toc-number">5.4.2.</span> <span class="toc-text"> 设备独立性软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.4.3.</span> <span class="toc-text"> 设备驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.4.4.</span> <span class="toc-text"> 中断处理程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.5.</span> <span class="toc-text"> IO核心子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E8%B0%83%E5%BA%A6"><span class="toc-number">5.5.1.</span> <span class="toc-text"> IO调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%BF%9D%E6%8A%A4"><span class="toc-number">5.5.2.</span> <span class="toc-text"> 设备保护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AFspooling%E6%8A%80%E6%9C%AF"><span class="toc-number">5.6.</span> <span class="toc-text"> 假脱机技术(SPOOLING技术)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">5.6.1.</span> <span class="toc-text"> 什么是脱机技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.6.2.</span> <span class="toc-text"> 假脱机技术–输入&#x2F;输出缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%89%93%E5%8D%B0%E6%9C%BA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">5.6.3.</span> <span class="toc-text"> 共享打印机原理分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">5.7.</span> <span class="toc-text"> 设备的分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%97%B6%E5%BA%94%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">5.7.1.</span> <span class="toc-text"> 设备分配时应考虑的因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">5.7.2.</span> <span class="toc-text"> 静态分配与动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.7.3.</span> <span class="toc-text"> 设备分配管理中的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.7.4.</span> <span class="toc-text"> 设备分配的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%AD%A5%E9%AA%A4%E7%9A%84%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.5.</span> <span class="toc-text"> 设备分配步骤的改进方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">5.8.</span> <span class="toc-text"> 缓冲区管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E5%8C%BA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">5.8.1.</span> <span class="toc-text"> 什么是缓冲区？有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="toc-number">5.8.2.</span> <span class="toc-text"> 单缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-number">5.8.3.</span> <span class="toc-text"> 双缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8D%95%E5%8F%8C%E7%BC%93%E5%86%B2%E5%9C%A8%E9%80%9A%E4%BF%A1%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.8.4.</span> <span class="toc-text"> 使用单双缓冲在通信时的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.8.5.</span> <span class="toc-text"> 循环缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">5.8.6.</span> <span class="toc-text"> 缓冲池</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/20/Redis7/" title="Redis7"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s3.bmp.ovh/imgs/2022/11/08/d8916c8dd7e09280.png?_r_=83605935-c04f-a0ba-c19b-8ce2ff7cf6fd" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis7"/></a><div class="content"><a class="title" href="/2024/04/20/Redis7/" title="Redis7">Redis7</a><time datetime="2024-04-20T02:31:27.000Z" title="发表于 2024-04-20 10:31:27">2024-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/16/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/10/CpDf8cx6TQdS49b.jpg?_r_=23f60ad1-9d22-de99-b995-62faf83a860f" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题"/></a><div class="content"><a class="title" href="/2024/04/16/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题">面试题</a><time datetime="2024-04-16T10:01:14.000Z" title="发表于 2024-04-16 18:01:14">2024-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/29/SpringCloud/" title="SpringCloud"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s3.bmp.ovh/imgs/2022/11/08/b5885d06cbc7f57b.png?_r_=9f970938-899c-edd3-865a-3d3c894fb2fd" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloud"/></a><div class="content"><a class="title" href="/2024/03/29/SpringCloud/" title="SpringCloud">SpringCloud</a><time datetime="2024-03-29T01:37:06.000Z" title="发表于 2024-03-29 09:37:06">2024-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/17/%E9%AB%98%E7%89%88%E6%9C%ACJDK%E5%BA%94%E7%94%A8JWT%E9%97%AE%E9%A2%98/" title="mybatis-plus"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/19/MkDHwvYu5p8XLBy.jpg?_r_=a78b4e4c-5ae9-b951-8018-5c645f04c6e8" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mybatis-plus"/></a><div class="content"><a class="title" href="/2024/03/17/%E9%AB%98%E7%89%88%E6%9C%ACJDK%E5%BA%94%E7%94%A8JWT%E9%97%AE%E9%A2%98/" title="mybatis-plus">mybatis-plus</a><time datetime="2024-03-17T00:49:28.000Z" title="发表于 2024-03-17 08:49:28">2024-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/12/SpringSecurity/" title="mybatis-plus"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/19/B89gcloHOqx2z1E.png?_r_=3e0568ab-5d7d-16a9-c765-bbd811bbc92a" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mybatis-plus"/></a><div class="content"><a class="title" href="/2024/03/12/SpringSecurity/" title="mybatis-plus">mybatis-plus</a><time datetime="2024-03-12T00:49:28.000Z" title="发表于 2024-03-12 08:49:28">2024-03-12</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" href="/docs/">文档</a><a class="footer-item" title="源码" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu">源码</a><a class="footer-item" title="更新日志" href="/update/">更新日志</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="Nuyoah" target="_blank">Nuyoah</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">9</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://262259.xyz/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" href="https://262259.xyz/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">管理</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://qexo.262259.xyz/" title="博客后端"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://unpkg.com/qexo-static@1.4.0/assets/img/brand/qexo.png" alt="博客后端"/><span class="back-menu-item-text">博客后端</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Gitee/" style="font-size: 0.88rem;">Gitee<sup>1</sup></a><a href="/tags/JAVA/" style="font-size: 0.88rem; font-weight: 500; color: var(--anzhiyu-lighttext)">JAVA<sup>5</sup></a><a href="/tags/JS/" style="font-size: 0.88rem;">JS<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>1</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>7</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>2</sup></a><a href="/tags/hexo/" style="font-size: 0.88rem;">hexo<sup>4</sup></a><a href="/tags/win10/" style="font-size: 0.88rem;">win10<sup>1</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/" style="font-size: 0.88rem;">个人日记<sup>1</sup></a><a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 0.88rem;">人工智能<sup>15</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%BA%8E%E9%80%BB%E8%BE%91/" style="font-size: 0.88rem;">数字电路于逻辑<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" style="font-size: 0.88rem;">算法实现<sup>12</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">计算机基础<sup>13</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>1</sup></a></div></div><hr/></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开/关闭中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版/本站右键菜单</div></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Nuyoah 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.262259.xyz/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.262259.xyz/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.262259.xyz/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>