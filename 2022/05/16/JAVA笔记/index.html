<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JAVA教程 | Nuyoah</title><meta name="keywords" content="JAVA"><meta name="author" content="Nuyoah"><meta name="copyright" content="Nuyoah"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JAVA教程"><meta name="application-name" content="JAVA教程"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JAVA教程"><meta property="og:url" content="http://262259.xyz/2022/05/16/JAVA%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="Nuyoah"><meta property="og:description" content="学习笔记，记录一下"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://s2.loli.net/2022/11/21/Sm8lFrjtzUkihVy.webp"><meta property="article:author" content="Nuyoah"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2022/11/21/Sm8lFrjtzUkihVy.webp"><meta name="description" content="学习笔记，记录一下"><link rel="shortcut icon" href="https://s1.ax1x.com/2022/11/27/zUFla6.png"><link rel="canonical" href="http://262259.xyz/2022/05/16/JAVA%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"404！加载失败！","backTitle":"加载成功！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.262259.xyz/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":"a665f8c80fd739329dd0d3f3fe7d90fc"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Nuyoah","link":"链接: ","source":"来源: Nuyoah","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: {"enable":true,"delay":100,"shiftDelay":200},
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Nuyoah',
  title: 'JAVA教程',
  postAI: '',
  pageFillDescription: ' JAVA笔记,  注释需要注意的地方：,  编译需要注意的,  命名规范,  变量分类,  基本数据类型之间的运算规则：,  String类型,  进制转换,  源码 反码 补码,  逻辑运算符：（操作对象都是boolean类型的）,  从键盘获取数据,  Math类中的方法,  数组的使用,  面向对象,  Java类及类的成员（属性方法构造器；代码块内部类）,  方法的重写,  重载和重写的区别,  子类对象实例化的过程,  代码块,  内部类：,  Object类的使用,  Vector可扩展数组,  面向对象的三大特称（封装性继承性多态性（抽象性））,  面向对象的特征一：封装和隐藏,  继承性,  多态性,  其他关键字thissuper static finalabstractinterface,  this关键字的使用：,  package关键字的使用,  import关键字的使用,  super关键字的使用,  instanceof关键字的使用,  static关键字的使用：,  final关键字的使用：,  抽象类与抽象方法（abstract关键字）,  匿名类：,  多态的应用,  接口（interface）,  设计模式：,  main函数的使用方发,  赋值的先后顺序,  每天一考,  异常处理,  异常体系结构：,  异常处理机制,  方式一：try - catch - finally,  方式二：throws + 异常类型,  方法重写规则之一：,  自定义异常类,  异常的测试,  面试题,  多线程,  Thread类的有关方法,  线程的调度,  线程的生命周期,  线程的同步（线程安全）,  线程的通信,  JDK5.0新增线程方式,  常用类,  字符串相关的类,  String对象的特性,  String对象的创建：,  String常用方法：,  String与基本数据类型的转换,  String与字符数组转换,  String与字节数组进行转换,  StringBuffer 和 StringBuilder的使用,  日期和事件API,  JDK8 以前,  JDK8以后,  瞬时：instant类,  格式化与解析日期或时间,  其他API,  与传统的日期处理相互转换,  JAVA比较器,  System类Math类BigInteger与BigDecimal,  System类,  Math类,  BigInteger类,  BigDecimal类,  枚举与注解,  枚举类的使用,  注解（Annotation）,  集合,  出现的背景,  Collection,  Iterator的使用,  foreach,  List接口,  set接口,  Map,  集合掌握要求,  泛型,  概念,  泛型的使用,  泛型类泛型接口泛型方法,  泛型类泛型接口,  泛型方法,  IO流原理及流的分类,  File类的使用,  常用构造器,  常用方法,  IO流,  字符流的读入,  字符流的输出,  字节流的读入和输出,  缓冲流的使用,  转换流,  标准输入输出流,  打印流,  数据流,  对象流,  随机存取文件流,  NIO.2中Path PathsFiles类的使用,  网络编程,  网络通讯中的两个要素,  IP和端口号,  网络通讯协议,  TCP网络编程,  UDP网络编程,  URL编程,  反射机制,  概述,  类的加载,  创建运行时类对象,  获取运行时类的完整结构,  调用运行时类的指定结构,  动态代理,  静态代理功能,  动态代理,  Java8新特性,  Lambda表达式,  函数式接口,  方法引用与构造器引用,  方法引用：,  构造器引用：,  StreamAPI,  StreamAPI实例化的四种方法,  Stream的中间操作,  终止操作,  Optional类,  Java91011新特性笔记注释需要注意的地方这是文档注释会生成一个文件来对这个文档进行说明多行注释中注释不能嵌套编译需要注意的一个文件中可以生命多个但是最多只能有一个被修饰而且要求声明为的类的类名必须与源文件相同程序入口是方法格式是固定的输出语句输出完之后有换行输出完之后不换行编译之后会生成一个或多个字节码文件字节码文件的文件名与文件中类名相同的开发工具核心类库配置环境变量目的是为了在运行框中任何盘之下都可以进行语法的调用命名规范包名多单词组成时所有字母都小写类名接口名多单词组成时所有单词的首字母大写变量名方法名多单词组成时第一个单词首字母小写第二个单词开始每个单词首字母大写常量名所有字母都大写多单词时每个单词用下划线链接变量分类基本数据类型引用数据类型类接口数组一个字节字节个字节个字节这样会导致编译不通过声明型变量的时候必须以或结尾声明型变量的时候必须以或结尾使用小数的时候我们通常使用类型的变量因为空间更大而且不用再最后写一个或者更基本数据类型之间的运算规则前提不包含自动类型提升当容量小的数据类型的变量与容量打的数据类型的变量做运算的时候和类型相加的话为当使用命名变量的时候如果后面不加的话就相当于使用型赋值给型当让如果你后面赋值的数字超过类型的大小的话那么会报错这样就会报错如果定义类型的变量的时候后面不加的话而且后面数字还为小数那么会报错因为小数默认为型型赋值给型明显是错误的类型是一个字符串使用双引号可以和八种数据类型变量做运算且运算只能是链接运算运算完结果是类型的方法用来比较两个字符串所包含的内容是否相同这种方法相同为不同为进制转换二级制开头八进制以开头十六进制以开头源码反码补码正数的三个码都和其本身相同负数源码该负数的本身反码处符号位剩下的都取反补码反码加一计算机的底层都已补码的方式来存储数据逻辑运算符操作对象都是类型的逻辑是从左到右全部判断完之后结束短路是能判断结果之后就停止逻辑与短路与逻辑或短路或逻辑非逻辑异或当和相同的时候为当不同的时候为位运算符需要为型左移运算符单目运算符左移一位相当于整体乘被移除的高位丢弃空缺位补右移运算符单目运算符右移一位相当于整体除以最小为右移之后最高位为空缺补最高位为空缺位补零被移位二进制最高位无论是或者空缺位都用补使用二进制一对一都为的时候生成数对应的位置才为其余为零使用二进制一对一都为的时候生成数对应位置才为其余为使用二进制一对一对应位置相同的时候才为否则为三元运算符条件表达式表达式表达式其中表达式和表达式数据类型必须相同如果条件表达式为真的话运行表达式为假的话运行表达式从键盘获取数据这里涉及到导包操作使用类步骤导包的实例化调用类的相关方法来获取指定类型的变量除了获取字符串的方法是剩下的全部都是来获取数据类型中没有获取单个字符的方法如果想要获取单个字符串的话可以先使用获取完字符串之后在使用来获取单个字符方法的参数是字符串的第几个位置的索引如果用户输入的数据类型和源文件中要求输入的数据类型不同的话那就要做比较如果用户输入的数据类型所占字节数比源文件中要求的数据类型多则会报错类中的方法将的次方运算完之后的数字赋值给将开方之后的值赋值给的范围是左开右闭取该范围里面的随机数返回值是所以如果你想要得到整数的话你可以使用类型强制转换成类型获取的是之间的随机数获取的是之间的随机数用法逻辑代码块一处理代码块一如果逻辑代码块一出现问题的时候则执行中处理代码块一如果没有出现问题的话则执行完逻辑代码块一之后跳过中的代码块执行下一条语句数组的使用一维数组的声明和初始化静态初始化动态初始化数组一旦初始化完成其长度就已经确定了数组元素默认初始化值整形的统统为浮点型的统统为类型的统统为码中的类型的统统为二维数组二维数组在动态初始化的时候列数必须填行数不一定要填写二维数组求长度的时候用上面的例子只要是数组就有方法二维数组初始值对于这样都分配好空间的数组来说代表是地址的初始值和一维数组类型初始值一样对于只给出列没有给出行的数组来说代表的是内层元素不能调用否则报错数组的方法引用判断两个数组是否相同输出数组信息将指定值填充到数组之中对数组进行排序对排序后的数组进行二分查找指定的值数组异常数组角标越界异常空指针异常声明了但是没有复制这样就会报错面向对象面向过程强调的是功能行为以函数为最小单位考虑怎么做面向对象将功能封装进对象强调具备了功能的对象以类对象为最小单位考虑谁来做类及类的成员属性方法构造器代码块内部类两个要素类是对一类事物的描述是抽象的概念上的定义对象是实际存在的该类事物的每个个体因而也称为实例面向对象的重点就是类的设计设计类就是设计类的成员类含有属性和方法属性成员变量域字段方法成员方法函数创建类的对象类的实例化实例化类创建类属性方法我会吃饭我会睡觉人可以说话使用的是创建类的对象这里就是创建类的对象调用对象的结构属性方法调用对象的属性调用对象的方法类和对象的使用面向对象思想落地创建类设计类的成员创建类的对象通过对象属性或对象方法调用对象的结构属性成员变量局部变量相同点定义变量的格式数据类型变量名变量值先声明后使用变量都有其对应的作用域不同点在类中声明的位置不同属性直接定义在类的一对内局部变量声明在方法内方法形参代码块之内构造器形参构造器内部的变量权限修饰符的不同属性可以在声明属性的时候指明其权限使用权限修饰符常用的权限修饰符有缺省不加声明就是默认缺省封装性局部变量不可以使用权限修饰符默认初始化值的情况属性类的属性根据其类型都有默认初始化值整形浮点型字符型或布尔型局部变量没有初始化值意味着我们再调用局部变量之前一定要先是赋值特别地在形参调用时我们赋值即可在加载位置不同属性加载到堆空间中非局部变量加载到栈空间中成员变量这里就是局部变量这里也是局部变量我是中国人我说方法的使用举例方法的声明权限修饰符返回值类型方法名形参列表方法体说明关于权限修饰符默认方法的权限是先使用规定的种权限修饰符缺省封装性返回值类型有返回值没有返回值如果方法有返回值则必须在方法声明时指定返回的类型同时方法中必须需要使用关键字来返回指定类型的常量或变量如果方法没有返回值则方法声明时使用来表示通常没有返回值的方法中就不使用但是如果使用的话只能用表示结束此方法的意思方法名需要符合方法名的规则和规范形参列表可以有一个两个或多个数据类型形参数据类型形参关键字的使用适用范围使用在方法体中作用结束方法针对有返回值类型的方法使用返回数据关键字后面不可以使用语句方法的使用中可以调用当前类的属性或方法编译完源程序之后生成一个或多个字节码文件编译器使用中的类的加载器和解释器对生成的字节码文件进行解释运行意味着需要将字节对应的类加载到内存中涉及到内存解析所以说编译的时候不会讲字节加载到内存中只有在运行的时候才会设计到内存理解万事万物皆对象在语言范畴中我们都将功能结构等封装到类中通过类的实例化来调用功能结构等文件网络资源涉及到语言与前端后端数据库交互时前后端的结构在层面都体现为类对象内存解析的说明引用类型的变量只可能存储两类值或地址值含变量的类型匿名对象的使用理解我们创建对象没有显示的赋给一个变量名即为匿名对象特征匿名对象只能调用一次使用这里就是匿名对象调用完之后就无法再调用这个对象了方法方法的重载定义在同一个类中允许存在一个以上的同名的方法只要他们的参数个数或者参数类型不同即可两同一不同相同类相同方法名参数列表不同参数个数不同参数类型不同举例我的名字是我的名字是这样的话当你传入的参数不同的时候调用的方法也不同可变个数的形参定义可变形参格式数据类型变量名运行结果为当使用可变个数形参的时候传入多个参数的的时候形参就会变成对应的数组具体使用可变个数形参的格式数据类型变量名当调用可变个数形参方法时传入的参数个数可以是个个个可变个数形参的方法与本类中方法名相同形参不同的方法之间构成重载可变个数的形参变量必须声明在方法的最后一个可变个数的形参在同一个方法中最多声明一个关于变量的赋值如果变量是基本数据类型此时赋值的时变量所保存的数据值如果变量是引用数据类型此时赋值的是变量所保存的数据的地址值关于程序的退出使用会直接结束程序方法的重写定义子类可以根据需要对父类中继承来的方法进行改造也称为方法的重置或者覆盖在执行程序的时候子类的方法将覆盖父类的方法要求子类重写的方法必须和父类被重写的方法具有相同的方法名称参数列表子列重写的方法的返回值类型不能大于父类被重写的方法的返回值类型父类中返回值类型时的时候则子类重写方法的返回值类型只能是父类被重写的方法的返回值类型时类型则子类重写的方法的返回值类型可以是类或者的子类父类中被重写的方法的返回值类型是基本数据类型则子类重写方法的返回值类型必须是相同的基本数据类型子类重写的方法使用权限不能小于父类中被重写的方法的访问权限子列不能重写父类中声明为权限的方法方法的声明权限修饰符返回值类型方法名形参列表异常类型子类方法抛出的异常不能大于父类中被重写方法的异常权限修饰符在子类中可以用但是在不同包下不可以用如果想要在不同包下调用权限的变量我们可以使用来继承相应的类注意子类与父类中同名同参数的方法必须同时声明为即为重写或者同时声明为的不是重写因为方法是属于类的子类无法覆盖父类的方法应用重写之后当创建子类对象以后通过子类对象调用父类中同名的方法时实际执行的时子类重写父类的方法重载和重写的区别概念重载在同一个类中可以声明多个方法名相同形参列表不同的方法重写子类继承父类之后可以对父类中同名同参数的方法进行覆盖操作编译和运行对于重载而言在方法调用的之前编译器已经确定了索要调用的方法这称为早绑定或静态绑定对于多态只有等到方法调用的时候编译器才会确定索要调用的具体方法这成为完绑定或动态绑定子类对象实例化的过程从结果上看子类继承父类之后就获取了父类中声明的属性或方法创建子类对象在对空间中就会加载所有父类中声明的属性从过程上来看当我们通过子类的构造器创建子类对象上来看我们一定会直接或间接的调用其父类的构造器进而调用父类的父类的构造器直到调用了类中空参构造器为止正因为加载过所有的父类的结构所以才可以看到内存中有父类中的结构子类对象才可以考虑进行调用明确虽然创建子类对象时调用了父类的构造器但自始至终就创建过一个对象即为的子类对象代码块代码块的作用用来初始化类和对象代码块如果有修饰的话只能使用分类静态代码块非静态代码块静态代码块内部可以有输出语句随着类的加载而运行而且只执行一次作用初始化类的信息如果一个类中定义了多个静态代码块则按照声明的先后顺序执行静态代码块的执行要优先于非静态代码块静态代码块内只能调用静态的属性静态的方法不能调用非静态的结构非静态代码块内部可以有输出语句随着对象的创建而运行创建几个对象执行几次作用初始化类的信息如果一个类中定义了多个非静态代码块则按照声明的先后顺序执行非静态代码块内可以调用静态的属性静态的方法或非静态的属性非静态的方法使用方法我们想要给一个属性的赋值的之前需要做一下其他的工作这时候不能够进行如下方法赋值这样的赋值是错误的我们想要在这个赋值之前需要做一下别的工作这时候我们需要代码块作别的工作执行的先后顺序由父即子静态线性静态初始化模块普通初始化模块无参构造器静态初始化模块普通初始化模块无参构造器静态初始化模块普通初始化模块无参构造器最后结果为静态初始化模块静态初始化模块静态初始化模块普通初始化模块无参构造器普通初始化模块无参构造器普通初始化模块无参构造器如果我们在一个子类的对象中调用模块的话由父即子静态线性静态初始化模块普通初始化模块无参构造器静态初始化模块普通初始化模块无参构造器静态初始化模块普通初始化模块无参构造器这是初始化函数的部分最后结果为静态初始化模块静态初始化模块静态初始化模块这是初始化函数的部分普通初始化模块无参构造器普通初始化模块无参构造器普通初始化模块无参构造器内部类使用方法一般在定义的他的类或语句块之间在外部引用他的时候必须给出完整名称类名不能和外部类相同在中我们允许一个类定义于另一个类的内部前者成为内部类后者称为外部类分类成员内部类成员内部类和非成员内部类局部内部类不谈修饰符匿名内部类成员内部类一方面可以作为外部类的成员调用外部类的结构可以被修饰可以被四种不同的权限修饰符另一方面作为一个类类可以定义属性方法构造器等可以被修饰表示此类不能够别继承言外之意不适用就可以被继承可以使用修饰静态成员内部类卡拉是一条狗非静态成员内部类我是一只小小鸟局部内部类代码块局部内部类局部内部类关注问题如何实现内部类的对象如何在成员内部类中区分调用外部类的结构方法的形参内部类的属性外部类的属性开发中局部内部类的使用创建实例静态成员内部类创建实例非静态的成员内部类这样是错误的因为内部类不是不能通过直接调用需要实例化的对象然后通过实例化的的对象来调用这个内部类总结成员内部类和局部内部类在编译之后都会出现字节码文件格式成员内部类外部类内部类名局部内部类外部类数字内部类名注意在局部内部类的方法中比如说如果调用局部内部类所声明的方法比如中的局部变量比如说要求此局部变量声明为及以前的版本要求此局部变量声明为的及以后的版本可以省略的声明局部变量这样是错误的这样是正确的类的使用类是所有类的根父类如果在类的声明中未使用关键字指明其父类则默认父类为类类中的功能属性方法就具有通用性属性无方法方法的使用回顾运算符可以使用在基本数据类型变量和引用数据类型变量中如果可以比较的是基本数据类型变量比较两个变量保存是数据是否相等不一定要类型相同如果比较的是引用数据类型变量则比较的是两个数据地址值是否相等即两个引用是否指向一个对象实体方法的使用是一个方法而并非一个运算符只能适用于引用数据类型类中的定义这就说明类中定义的方法和是相同的比较两个对象的地址值是否相等即两个引用是否指向同一个数据对象像包装类都重写的中的的方法重写后比较的不是两个引用的地址值是否相同而是比较两个对象的实体内容是否相同通常情况下我们自定义类如果使用的话也通常是比较两个对象的实体内容是否相同那么我们就需要对类中进行重写类中有两个属性重写中的方法比较两个对象的属性是否相同类中的使用当我们输出一个对象的引用的时候默认调用的是他的的方法中方法计算该类在堆空间的值使用类的转换成进制像包装类等都重写了类中方法使得在调用对象的时返回实体内容信息自定义类也可以重写方法当调用此方法的时候返回对象的实体内容中的单元测试步骤选中当前工程右键选择下一步创建类进行单元测试此时类要求此类时的此类提供公共的无参构造器此类中声明单元测试方法此时的单元测试方法防范权限是没有返回值没有形参此时单元测试方法以后就可以在方法体内测试相关的代码此单元测试方法上需要声明注解在单元测试类中导入写完代码以后就可以对单元格进行测试了颜色是否相等包装类的使用针对八种基本类型定义相应的引用类型包装类封装类有了类的特点就可以调用类中的方法才是真正的面向对象提供了中基本数据类型对应的包装类使得基本数据类型的变量具有类的特征前六个是数值型的由共同的父类基本数据类型包装类包装类中核心部分基本数据类型包装类与类之间的转换基本数据类型的转换包装类调用包装类的对象下面这种方法就会报错因为基本数据类型没有方法可言转换成引用数据类型这样就会报错是基础类型是一个类包装类基本数据类型调用包装类的调用包装类就可以将包装类转换成对应的数据类型新特性不强制要求上述转换方法了有自动转换的新特性自动装箱与拆箱理论上说的参数是对象但是你直接填入基本数据类型也不会报错基本数据类型包装类的对象自动装箱基本数据类型包装类自动拆箱包装类基本数据类型基本数据类型包装类类型基本数据类型包装类类型调用重载的方式一连接运算方式二调用的方法类型基本数据类型包装类调用可以将对应的转换为对应的属性调用包装类的常用方法创建并复制该对象比较两个对象是否相等垃圾回收当该对象没有变量指向它的时候就会自动调用这个方法注意自动类型提升这里面就存在着自动类型提升的一部分因为是要给赋值的所以编译器需要事先确定好赋值的类型一个是一个是所以需要自动类型提升内部的结构内部定义了结构中定义了保存了范围内整数如果我们使用自动装箱的方式给赋值的范围在内时可以直接使用数组中的元素不用再去了提高效率相当于了一个对象可扩展数组在使用的时候可以给定数组长度达到预期长度减少扩展次数添加数据面向对象的三大特称封装性继承性多态性抽象性面向对象的特征一封装和隐藏高内聚低耦合高内聚类的内部数据操作细节自己完成不允许外部干涉低耦合仅对外暴露少量的方法用于自己使用隐藏对象内部的复杂性之对外公开简单的接口便于外界调用从而提高系统的可扩展性可维护性通俗的说把该隐藏的隐藏该暴露的暴露出来这就是封装性的设计思想问题的引入当我们创建一个类的对象之后我们可以通过对象属性的方式对对象属性进行赋值这里赋值操作要受到属性的数据类型和存储范围的制约但是除此之外没有其他制约条件但是在实际问题中我们往往需要给属性赋值加入额外的限制条件这个条件就不能再属性声明时体现我们只能通过方法来进行限制条件的添加同时我们需要避免用户在使用对象属性的方式对属性进行赋值则需要将属性声明为私有的此时针对属性就体现了封装封装性的体现我们将类的属性私有化同时提供公共的方法来获取和设置该变量的值拓展封装性的体现如上不对外暴露私有的方法单例模式封装性的体现需要权限修饰符来配合规定的种权限修饰符从小到大缺省修饰符类内部同一个包不同包的子类同一个工程缺省四种权限可以用来修饰类及类的内部结构属性方法构造器内部类具体的四种权限都可以用来修饰类的内部结构属性方法构造器内部类修饰类的话只能使用缺省总结提供了中权限修饰符来修饰类的内部结构体现类及类的内部结构在被调用时的可见性大小类的结构三构造器或构造方法的使用建设建造构造器的作用创建对象初始化对象信息说明如果没有显式的定义类的构造器的话则系统默认提供一个空参的构造器定义构造器的格式权限修饰符类名形参列表一个类中定义的多个构造器彼此构成重载一旦我们显示的定义类的构造器后系统不再提供默认的空参构造器一个类中至少有一个构造器总结属性赋值的先后顺序默认初始化显式初始化构造器中赋值通过对象方法或对象属性赋值以上操作先后顺序继承性继承性的好处减少了代码的冗余提高了代码的复用性便于功能的扩展为了以后多态性的使用提供了前提继承性的格式子类派生类父类超类基类体现一旦子类继承父类以后子类中就获取了父类中声明的所有的属性和方法特别的父类中声明为的属性和方法子类继承父类之后仍然认为获取了父类中私有的结构只是应为封装性的影响使得子类不能调用父类中的结构而已子类继承父类之后还可以声明自己特有的属性和方法实现功能的扩展子类和父类的关系不同于子集和集合的关系扩展延展中关于继承性的规定一个类中可以背多个子类继承中类的单继承性一个类只能有一个父类子父类是相对的概念子类解释继承的父类称为直接父类间接继承的父类称为间接父类子类继承父类之后就获取了直接父类以及所有间接父类中声明的属性和方法如果我们没有显式的声明一个类的父类的话则此继承于类所有的类除类之外都直接或间接的继承于类意味着所有的类具有类中所有声明的功能多态性理解多态性如果想要调用子类种的方法的话你需要在父类中也有这个方法在子类重写之后你调用的这个方法在父类种也可以使用如果和是的子类这就是多态性何为多态性对象的多态性父类的引用指向子类的对象或子类的对象赋给父类引用多态性的使用虚拟方法调用有了对象的多态性以后我们在编译期只能调用父类中声明的方法但在运行期我们执行的是子类重写父类的方法总结编译看左边运行看右边多态性使用前提类的继承关系方法的重写对象的多态性只适用于方法不适用与属性虚拟方法的调用正常方法调用虚拟方法调用多态情况下子类中定义了与父类同名同参数的方法在多态情况下此时父类方法称为虚拟方法父类根据赋给它不同子类的对象动态调用属于子类的该方法这样方法的调用在编译期是无法确定的是运行时行为调用类的方法多态性使用的时候不能调用子类特有的方法和属性有了对象的多态性之后内存中实际上是加载了子类特有的属性和方法的但是由于变量声明为父类类型导致编译时只能调用父类中声明的属性和方法子类特有的属性和方法不能够调用如何才能调用子类特有的属性和方法向下转型使用强制类型转换符但是在使用强制类型转换的时候可能会出现的异常这时候我们可以使用关键字来规避这个错误其他关键字关键字的使用可以用来修饰属性方法构造器修饰属性和方法理解为当前对象在类方法中我们可以使用属性或者方法的方式调用当前对象属性或方法但是通常情况下我们选择省略特殊情况下如果方法的形参和类的属性同名这时候我们就需要使用关键字表明此变量是属性而非形参前面使用来表示前面的是属性后面的是形参调用构造器我们在类的构造器中可以显式的使用形参列表方式调用本类中其他的构造器构造器中不能通过形参列表方式调用自己如果一个类中有个构造器则最多有个构造器啊使用形参列表规定形参列表必须声明在当前构造器的首行构造器内部最多只能声明一个形参列表用来调用其他的构造器关键字的使用为了更好的实现项目中类的管理提供包的概念使用声明类或接口所属的包声明在源文件首行包属于标识符遵循标识符的命名规则规范见名知意每一次就代表一层文件目录补充同一个包下不能命名同名的接口类不同包下可以命名同命的接口类包含一些语言常用的核心类如和提供常用功能包含执行与网络相关的操作的类和接口提供多种输入输出功能的类包含一些实用的工具类如定义系统特征接口集合框架类使用与日期日历相关的函数包含了一些格式化相关的类包含了进行数据库编程的相关类接口包含了构成了抽象窗口工具集的多个类这些类用来构建和管理应用程序的图像化界面关键字的使用导入在源文件中显示的使用结构导入指定包下面的类接口声明在包的声明和类的声明之间如果需要导入多个结构则并列写出即可可使用的方法表示可以导入包下的所有结构如果使用的类或接口是包下定义的则可以省略结构如果使用的类或接口是本包下定义的则可以省略结构如果在源文件中使用了不同包下的同名的类则必须至少有一个类需要以全类名的方式显示其中是关键字是包名后面的是包中的类名全类名的显示方式使用方式表明可以调用包下面的所有结构但如果使用的是包下面的子结构则仍需要显示导入导入的指定类或接口中的静态结构不是类属性或方法关键字的使用关键字理解为父类的可以用来调用属性方法构造器的使用调用属性或方法我们可以在子类的方法或构造器中通过使用属性或方法的方式显示调用父类中声明的属性或方法但是通常情况下我们习惯省略特殊情况当子类和父类中定义了同名的属性的时候我们想要在子类中调用父类声明的属性的时候则必须显式的使用属性的方式表明调用的是父类中声明的属性特殊情况当子类重写了父类中的方法之后我们想要在子类的方法中调用父类的中被重写的方法的时候则必须显式的使用方式的方法表明调用的是父类中被重写的方法调用构造器我们可以在子类的构造器中显示的使用形参列表的方式调用父类中声明的指定的构造器形参列表的使用必须声明在子类构造器的首行我们在类的构造器中针对与形参列表或形参列表只能二选一不能同时出现在构造器的首行没有显式的声明形参列表或形参列表则默认调用的是父类中空参的构造器在类的多个构造器中至少有一个类的构造器中使用了形参列表调用父类中的构造器关键字的使用用法判断对象是否是类的实例如果是返回如果不是返回要求所属类与必须是子类或者父类的关系否则编译会出现错误目的为了在多态的时候使用类型强制转换的时候不出现错误这样的话我们就不会出现多态中类型转换出现的错误了如果类是类的父类返回则返回练习问题一编译时通过运行时不通过举例一同子类不能互相转换举例二要想使用类的强制类型转换必须是多态之间的问题二编译时通过运行时也通过问题三编译不通过逻辑语法都不符合直接报错关键字的使用目的为了减少统一变量的空间例如所有中国人的国籍都是中国这时候我们建立一个中国人的类这个国籍变量就可以设置为就是所有的中国人的实例都共用这一个变量静态变量在这时候就可以使用了中国阿里百度这行代码输出的是这行代码输出的是静态的随着类的加载而加载用来修饰属性方法代码块内部类使用修饰属性静态变量属性按是否使用修饰分为静态属性非静态属性实例变量实例变量我们创建了类的多个对象每个对象都有一套属于自己的非静态属性修改其中一个的非静态属性不会影响其它对象里面的属性静态变量我们创建了类的多个对象多个对象共享一套非静态属性当通过某一个对象修改非静态属性会导致其他对象调用此静态对象的时候是修改过的修饰属性的其他说明静态变量随着类的加载而加载可以通过类静态变量的方式进行调用静态变量的加载要早于对象的创建由于类只会加载一次则静态变量在内存中也只会存在一份使用修饰方法静态方法随着类的加载而加载可以通过类静态方法的方式调用静态方法种只能调用静态的方法或属性非静态方法种既可以调用静态方法也可以调用非静态方法或属性注意点在静态方法种不能使用关键字关键字关于静态属性和静态方法的使用可以从生命周期的角度去理解开发中如何确定一个属性是否要声明为的属性可以被多个方法共享不会随着对象的的不同而不同操作静态属性的方法通常设置为工具类种的方法习惯上声明为这样就可以直接通过类名来调用不需要在实例化了关键字的使用最终的可以用来修饰的结构类方法变量用来修饰一个类此类不能被其他的类所继承不想在扩充功能了比如说类类类用来修饰方法表明此方法不能够被重写比如类中的用来修饰变量此时的变量就称为常量抽象类与抽象方法关键字随着继承层次中一个个新子类的定义类变得越来越具体而父类则更一般更通用类的设计应该保证父类和子类能够共享特征有时将一个父类设计得非常抽象以至于它没有具体的实例这样的类叫做抽象类关键字的使用可以用来修饰的结构类方法修饰类使用修饰的类不能够创建实例但是抽象类中有构造器虽然不能够实例化但是实例化子类的时候还是可以调用的在开发中都会提供抽象类的子类让子类对象实例化完成相关操作如果没有子类的话修饰类就没有意义了修饰方法抽象方法只有声明没有方法体包含抽象方法的类一定是一个抽象类因为抽象方法没有方法体如果包含抽象方法的类不是抽象类的话那么就可以通过类的实例化来调用抽象方法了这样做显然是不合适的所以包含抽象方法的类一定是抽象类反之抽象类中不一定包含抽象方法如果子类重写了父类中所有的抽象方法后此类方法可以实例化如果子类没有重写父类的所有抽象方法那么此子类也是一个抽象类需要使用修饰如果一个类是抽象类的话直接这样实例化是会报错的人吃饭人走路定义抽象方法如果父类中有抽象方法的话并且子类中没有重写父类中的抽象方法的话那么子类必须使用修饰否则会报错虽然父类使用修饰之后不能够直接使用构造器调用但是子类可以调用父类的构造器如果子类重写了父类中所有的抽象方法的话那么子类就可以不适用修饰了学生说话使用上的注意点不能用来修饰属性构造器等结构不能用来修饰私有方法和静态方法和的方法因为使用修饰的方法必定会被子类重写但是私有化方法子类又不能重写这样会导致矛盾静态方法在子类中虽然能够构造同名同参数的方法但是不认为这两个方法是同一个修饰的方法不能够被重写匿名类这是匿名对象实名类但是实例化对象的时候没有对象名字称为匿名对象非匿名的类非匿名的对象非匿名类匿名对象创建了一个匿名子类对象因为子类是匿名的所以我们只用父类对象即可我是抽象类创建匿名子类匿名对象我是匿名子类匿名对象工人想要发表声明最后运行结果为工人想要发表声明工人想要发表声明我是抽象类我是匿名子类匿名对象多态的应用模版方法设计模式应用场景当我们在构造一些功能的时候功能内部一部分是确定的一部分是不确定的这时候我们可以把不确定的哪一部分暴露出去让子类去实现换句话说我们在设计一个算法的时候整体步骤很固定通用这些步骤已经在父类中写好了但是某些部分易变易变的部分可以抽象出来供不同的子类实现这就是一种模板形式这里就是不确定的部分易变的部分花费的时间为接口再生产模式中我们通常需要从几个类中派生出一个子类继承他们所有的属性和方法但是不支持多重继承有了接口就可以得到多重继承的效果另一方面有时必须从几个类中抽取出一些共同的行为特征而它们之间又没有的关系仅仅是具有相同的行为特征而已例如鼠标键盘打印机扫描仪摄像头充电器机手机数码相机移动硬盘等都支持连接接口就是规范定义的是一组规则体现了现实世界中如果你是要则必须能的思想继承是一个是不是的关系而接口实现则是能不能的关系接口的本质是契约标准规范就像我们的法律一样制定好后大家都要遵守接口的使用接口使用来定义中接口和类是并行的两个结构如何定义接口定义接口中的成员及以前只能定义全局常量和抽象方法全局常量的但是可以省略不写抽象方法的除了可以定义全局常量和抽象方法之外还可以定义静态方法方法名默认方法方法名接口中定义的静态方法只能接口自己调用实现类中可以调用接口中的默认方法如果实现类重写了接口中的方法的话调用的时候仍会调用重写的方法如果子类或实现类继承父类和实现的接口中同名同参数的默认方法那么子类在没有重写此方法的时候默认调用的是父类中的同名同参数的方法类优先原则如果实现类实现了多个接口而这多个接口中定义了同名同参数的默认方法那么在类没有重写这个方法的时候报错接口冲突解决方法我们需要在类中重写此方法调用接口中的默认方法如果要调用接口中的静态方法直接通过接口静态方法这种方式来进行调用如果想要调用接口中的默认方法的话需要通过接口默认方法这种方法来进行调用接口中不能定义构造器意味着接口不能够实例化在中接口通过让类实现的方式来使用如果实现类覆盖了接口中的所有抽象方法则此实现类可以实例化如果实现类没有覆盖接口中的所有抽象方法则次实现类仍未一个抽象类类可以实现多个接口弥补了单继承的局限性格式接口和接口之间可以继承也可以多继承接口的具体使用体现多态性接口实际上可以看做一种规范接口的使用接口的使用上也满足多态性全局常量省略前面的修饰词也可以抽象方法通过引擎起飞驾驶员减速停止实现多个接口子弹飞子弹停子弹攻击接口应用的代理模式代理模式是开发中使用较多的一种设计模式代理设计就是为了其他对象提供一种代理以控制这个对象的访问接口报错这时候会报错因为不明确不知道是调用父类的还是接口中的下面这种方法不会报错接口排错这里重写的是将两个接口中的方法都重写了这里就有问题了因为这个字符在接口中定义过是一个型的变量不能够从新赋值设计模式设计模式设计模式是在大量的实践中总结和理论化之后优选的代码结构编程风格以及解决问题的思考方式设计模免去我们自己再思考和摸索式就像是经典的棋谱不同的棋局我们用不同的棋谱套路单例模式所谓类的单例设计模式就是采取一定的方法保证在整个的软件系统中对某个类只能存在一个对象实例并且该类只提供一个取得其对象实例的方法如果我们要让类在一个虚拟机中只能产生一个对象我们首先必须将类的构造器的访问权限设置为这样就不能用操作符在类的外部产生类的对象了但在类内部仍可以产生该类的对象因为在类的外部开始还无法得到类的对象只能调用该类的某个静态方法以返回类内部创建的对象静态方法只能访问类中的静态成员变量所以指向类内部产生的该类对象的变量也必须定义成静态的单例设计模式单例设计模式就是采用一定的方法保证在整个软件系统中该类只有一个实例对象实现方法饿汉式懒汉式饿汉式私有化类的构造器目的就是为了防止在该类外面创建这个类的实例在该类内部创建类的对象静态提供公共的方法静态来调用这个类中创建的对象懒汉式私有化类的构造器目的就是为了防止在该类外面创建这个类的实例声明当前类的对象没有初始化设置为声明的返回当前类的方法在该方法中进行类的声明在声明前需要判断一下该对象是否为如果是的话在进行实例化如果不是的话直接返回饿汉式坏处对象一开始就存在存在时间过长懒汉式好处什么时候使用是么时候在开始创建饿汉式私有化类的构造器在该类内部创建类的对象提供公共的方法返回类的对象私有化类的构造器声明当前类的对象没有初始化此对象需要声明为声明的返回当前类的方法单例模式的应用场景网站的计数器一般也是单例模式实现否则难以同步应用程序的日志应用一般都使用单例模式实现这一般是由于共享的日志文件一直处于打开状态因为只能有一个实例去操作否则内容不好追加数据库连接池的设计一般也是采用单例模式因为数据库连接是一种数据库资源项目中读取配置文件的类一般也只有一个对象没有必要每次使用配置文件数据都生成一个对象去读取也是单例的典型应用的任务管理器就是很典型的单例模式的回收站也是典型的单例应用在整个系统运行过程中回收站一直维护着仅有的一个实例创建型模式共种工厂方法模式抽象工厂模式单例模式建造者模式原型模式结构型模式共种适配器模式装饰器模式代理模式外观模式桥接模式组合模式享元模式行为型模式共种策略模式模板方法模式观察者模式迭代子模式责任链模式命令模式备忘录模式状态模式访问者模式中介者模式解释器模式函数的使用方发方法的使用说明方法作为程序入口方法也是一个普通的静态方法方法也可以作为我们与控制台的交互方法传入参数为数组中的元素操作方法运行时这样的操作就是把后面这四个元素放到类型的数组中赋值的先后顺序对象赋值可使用的位置默认初始化显示初始化在代码中赋值在构造器中初始化有对象之后可以通过对象属性或对象方法的方式进行赋值执行先后顺序为不分先后谁在前谁先赋值默认初始化在你创建变量的时候就会初始化赋值例如在创建变量的时候会默认赋值例如型默认值为浮点型默认型为型默认为显示初始化我们手动的给他赋值例如在代码块中赋值字面意思每天一考如何实现向下转型需要注意什么如何解决此问题向下转型的目的就是使父类对象能够调用子类的方法使用强转符如果转换失败的话会报异常为了避免这个错误我们在进行强制类型转换之前先进行判断一下被转换目标和可用于基础数据类型也可用于引用数据类型用于基础数据类型的时候比较的是两个数据的值相等就返回如果是引用数据类型的话就是要比较这两个引用数据类型地址是否相等是一个方法只能比较引用数据类型在没有重写的时候和的用法是相同的都是比较地址如果重写之后就能够比较引用数据变量内的具体的值种数据类型及其对应的包装类基本数据类型包装类三者之间如何转换基本数据类型和包装类使用自动装箱和拆箱前两者和之间的基本数据类型包装类使用中的方法基本数据类型包装类使用包装类种的方法对多态性的理解实现代码的通用性抽象类和接口肯定体现了多态性抽象类和接口不能实例化多态性是运行时行为修饰的属性相较于实例变量有哪些特别之处随着类的加载而加载早于对象的创建只要权限允许可以通过对象属性的方式进行调用存在于方法区的静态域中可以用来修饰那些结构分别表示什么意思可以用来修饰的结构类方法变量用来修饰一个类此类不能被其他的类所继承不想在扩充功能了比如说类类类用来修饰方法表明此方法不能够被重写比如类中的用来修饰变量此时的变量就称为常量类的属性赋值位置有哪些先后顺序为什么默认初始化显示赋值代码块赋值构造器赋值对象属性或者对象方法赋值小结一叶知秋方法体权限修饰符缺省封装性修饰符可以用来修饰方法返回值类型无返回值有返回值方法名需要满足标识符命名的规则规范见名知意形参列表重载重写参数的值传递机制体现对象的多态性方法体来体现方法的功能方法体来体现方法的功能异常处理异常体系结构重大错误异常一般不编写针对性的代码进行处理可以进行异常处理编译时异常运行时异常异常实例空指针异常数据越界类型转换失败数据转化失败输入的类型和我们想要的类型不相同算数异常异常处理机制处理异常的情况是将异常处理的程序代码集中在一起与正常的程序代码分开是程序简洁优雅并易于维护异常的处理抓抛模型过程一抛程序在正常执行的时候一旦出现异常就会在异常代码处生成一个对应的异常类的对象并将这个对象抛出一旦抛出对象之后其后代吗就不再执行关于异常对象的产生系统自动生成的异常对象手动生成一个异常对象并抛出这里的作用是当输入有误的时候停止程序运行使用这种方式只能让用户知道输入错误但是后面的程序依旧会执行输入不合法使用这种方法当输入不合法的时候会自动抛出一个异常让该语句之后的语句都不再执行输入不合法过称二抓可以理解为异常的处理方式方式一可能出现异常的代码异常类型变量名处理方法异常类型变量名处理方法异常类型变量名处理方法一定会执行的代码说明是可选的使用将可能的出现错误的代码包装起来在执行过程中一旦出现异常就会生成一个对应的异常类根据此对象的类型去中匹配一旦中异常对象匹配到某一个时就进入中进行异常处理一旦处理完成就跳出当前的结构在没有写的情况下继续执行其后面的代码中异常类型如果没有子父类关系则谁声明在上谁声明在下无所谓如果有子父类的关系则要求子类一定要声明在父类上面否则报错中常用的异常处理方式在结构中声明的变量再出了结构以后就不能够再调用了结构可以相互嵌套体会使用处理编译时异常的时候使得在编译时不报错但是运行的时候可能会报错相当于我们使用将一个编译时可能出现的异常延迟到运行时出现体会开发中由于运行时异常比较常见所以我们通常不针对运行时异常编写了针对编译时异常我们一定要考虑异常的处理空指针异常索引超范围异常的使用是可选的中声明的是一定会执行的代码即使中又出现异常了中有语句中有语句的情况如果出现以上几种情况的话结构后面的语句就不会运行了如果有语句的话即使出现上面的情况的话里面的语句也会被执行像数据库输入输出流网络编程等资源中是不能够自动回收的我们需要自己手动的进行资源的释放此时资源的释放就需要声明在中方式二异常类型异常类型写在方法的声明处指明此方法执行时可能会抛出的异常类型一旦方法体执行的时出现异常仍会在异常代码处生成一个异常的对象此对象满足后异常类型时就会被抛出异常后面的代码不会再执行体会真正的将异常给处理掉了的方式只是将异常抛给了方法的调用者并没有真正的将异常处理掉开发中如何选择还是方式来处理异常如果父类中的方法没有进行方式来进行处理异常那么子类重写该方法的时候也不能使用方式来处理异常但是如果子类中重写的方法真的有异常的话只能使用的方式来进行处理在执行方法的时候又先后调用了另外几个方法这几个方法是递进关系执行的我们建议这几个方法使用方式来进行处理而执行方法可以使用来进行处理当函数调用的时候这个异常就必须在这个函数这处理了因为这是最后一个函数了必须要在这个函数中解决这个问题调用者的时候有两种情况情况一使用来处理这个异常情况二使用方法将这个问题在抛出不解决谁调用谁解决这个问题最上面后面的异常是这个方法中可能出现的异常情况但是只是抛出异常不处理谁调用这个函数谁处理方法重写规则之一子类重写的方法抛出的异常类型不能大于父类被重写的方法抛出的异常类型自定义异常类继承与现有的异常结构提供全局常量提供重载的构造器异常的测试结果为数据类型不一致缺少命令行参数除零不能输入负数和的区别是生成一个异常的方式是异常处理的一个方式世界上最遥远的距离是我在里你在里似乎一直相伴又永远分离世界上最痴心的等待是我当你是或许永远都选不上自己世界上最真情的相依是你在我在无论你发神马脾气我都默默承受静静处理到那时再来期待我们的面试题三者的区别类似和和重写重载结构不相似的抽象类接口多线程程序进程线程程序是为了完成特定的任务用某种语言编写的一组指令的集合即一段静态的代码静态对象进程是进程的一次执行过程或是正在运行的一个程序是一个动态的过程有它自身产生存在和消亡的过程生命周期进程作为资源分配的单位系统在运行时会为每个进程分配不同的内存区域线程进程可以进一步细化为线程是一个程序内部的一条执行路径如果一个进程同一时间并行执行多个线程就是支持多线程的并行和并发并行多个同时执行多个任务多个人做不同的事情并发一个同时执行多个任务多个人做同一件事情使用多线程的优点背景以单核为例只使用单个线程先后完成多个任务调用多个方法肯定比用多个线程来完成用的时间更短为何仍需多线程呢多线程程序的优点提高应用程序的响应对图形化界面更有意义可增强用户体验提高计算机系统的利用率改善程序结构将既长又复杂的进程分为多个线程独立运行利于理解和修改创建多线程的方法通过实现的子类来进行创建啊创建一个线程创建一个继承与类的子类重写中的方法将此线程中需要执行的操作放在方法中创建类的子类对象通过此对象调用方法来创建新线程启动当前线程调用当前线程中的方法问题我们不能够直接通过对象的方法来启用多线程问题如果我们想要在启用一个线程的话不能够通过已经后的线程来开启会报错我们需要从新创建一个线程对象来进行下一个线程的调用如果一个线程中的东西我们只想执行一次的话我们可以创建一个匿名对象需要执行的代码通过实现这个接口来实现创建一个实现了接口的类实现类去实现中的抽象方法创建实现类的对象将此对象作为参数传递到类的构造器中创建类的对象通过类的对象的调用比较创建线程的两种方式开发中优先选择实现接口的方式原因实现方式没有类的单继承性的局限性实现的方式更适合来处理多个线程有共享数据的情况联系类实现了方法相同点两种方式都需要重写将线程执行的逻辑声明在中以上两种方式要想启动线程都是要调用类中的方法来进行调用的类的有关方法启动线程线程在被调度的实行的操作返回线程的名称设置该线程的方法返回当前线程在子类中就是通常使用与主线程和实现类线程让步暂停当前线程把执行机会让给优先级相同或者更高的线程若队列中没有同优先级的线程则忽略此方法当某个执行流中调用其他线程的方法调用线程将会被堵塞知道方法加入的线程执行完毕之后自己在开始执行让当前的线程在指定时间段之内放弃对的控制使得其他的线程有机会被执行时间到后从新排队抛出异常强制结束线程生命进程不推荐使用返回值判断线程是否还活着线程的调度时间片抢占式高优先级的线程抢占的调度方法同优先线程组成先进先出队列先到先服务使用时间片策略对高优先级使用优先调度的抢占式策略优先级的方法返回线程优先级改变线程的优先级一般的时候线程的优先级都为这个我们可以自己设置说明线程创建的时候继承父线程的优先级低优先级只是获得调度的概率低并非一定是在高优先级线程之后才被调用线程的生命周期一个完整的生命周期有以下几种状态新建当一个类或者其子类的对象被声明创建的时候新生的状态处于新建状态就绪处于新建状态的线程被后将进入线程队列等待时间片此时他已经具备了运行条件只是还没有被分配到资源运行当就绪的线程被调度并获得资源的时候便进入了运行状态方法定义了线程的操作和功能阻塞在某种特殊情况下被人为挂起或执行输入输出操作时让出并临时终止自己的执行进入阻塞状态死亡线程完成了它的全部工作或线程被提前强制性终止或出现异常导致结束线程的同步线程安全问题多个线程的不确定性引起执行结果的不稳定多个线程对账本的共享会造成操作的不完整性会破坏数据原因某个线程在操作共享数据的时候在还没有操作完的时候其他线程也参与进来这就会导致线程的安全问题解决方案当一个线程在操作公共数据的时候其他线程不能够参与进来直到这个线程完成了对公共数据的操作之后其他线程才能进来这种情况即使这个线程发生了阻塞别的线程也不能进来操作在中我们通过同步机制来解决线程安全问题方式同步代码块同步监视器需要被同步的代码说明操纵共享数据的代码就是要被同步的代码不能够包多也不能包少共享数据多个线程共同操作的数据同步监视器俗称锁任何一个类的对象都可以充当锁要求多个线程必须公用同一把锁补充在实现接口中创建多线程的方法中我们可以考虑使用充当同步监视器在继承类中创建多线程方法中我们可以考虑使用类来充当同步监视器方式同步方法使用同步方法来解决实现接口的线程安全问题同步方法仍然涉及到同步监视器只是不需要我们显示的声明非静态方法实现接口的方法同步监视器是静态方法继承类的方法同步监视器是当前类本身实现方法直接使用修饰监视器即可方式锁新增方法实例化对象调用锁定方法票数调用解锁方法面试题与的异同相同两者都可以解决线程安全问题不同需要手动的启用同步同时结束同步也需要手动实现机制在执行完全相同的代码以后自动释放同步监视器优先使用方式同步代码块已经进入方法体分配了相应的资源同步方法在方法体之外同步操作的方式解决了线程的安全问题好处弊端操作同步代码的时候只能有一个线程参与其他线程等待这相当于一个单线程的问题效率比较低解决懒汉式的线程安全问题懒汉式单例化类私有化类的构造器不能够从外面新建类线程的死锁问题不同的线程分别占用对方需要的同步资源不放弃都在等待对方放弃自己需要的同步资源就形成了线程的死锁出现死锁后不会出现异常不会出现提示只是所有的线程都处于阻塞状态无法继续解决方法专门的算法原则尽量减少同步资源的定义尽量避免嵌套同步线程的通信使线程交替运行让每一个线程都有机会抢到运行的代码线程通信的三个方法一旦执行此方法当前线程就被进入阻塞状态并释放同步监视器一旦执行此方法就会唤醒的一个线程如果有多个线程被就唤醒优先级高的那个一旦执行此方法就会唤醒所有被的线程这三个方法只能够出现在同步代码块中这三个方法调用者必须是同步代码块或同步方法中的同步监视器这三个方法是定义在类中释放前几个线程防止线程的阻塞调用方法的线程进入阻塞状态这时候下一个线程就可以进入实现线程的交替和的异同相同点一旦执行方法都可以使得当前的线程进入阻塞状态不同点两个方法声明位置不同类中声明类中声明调用的位置不同可以在任何需要的场景下调用必须在同步代码快中使用关于是否释放同步监视器如果两个方法都是用在同步代码块或同步方法中经典例题生产者和消费者问题线程通信的应用生产者消费者问题生产者将产品交给店员而消费者从店员处取走产品店员一次只能持有固定数量的产品比如如果生产者试图生产更多的产品店员会叫生产者停一下如果店中有空位放产品了再通知生产者继续生产如果店中没有产品了店员会告诉消费者等一下如果店中有产品了再通知消费者来取走产品分析是否有多线程问题是生产者线程消费者线程有可能在生产者生产第个产品的时候消费者抢到的线程消费了第个产品最后生产者生产完第个产品之后计数却为是否有共享数据是店员产品如何解决线程安全问题同步机制三种方法是否涉及线程的通信是开始生产个产品当我们生产一个产品之后就可以通知消费者来消费产品了可以使用开始消费个产品当我们消费了一个产品的时候就可以通知生产者来进行生产了有我们就要考虑使用开始生产产品开始消费产品生产者消费者新增线程方式新增方式一实现接口实现方法相比于方法可以有返回值方法可以抛出异常支持泛型的返回值需要借助类比如说获取返回结果接口可以对具体的任务的执行结果进行取消查询是否完成获取结果等是接口的唯一实现类同时实现了接口它既可以作为被线程执行又可以作为得到的返回值创建一个实现接口的类实现方法将此线程需要执行的操作声明在中创建接口实现类的对象将此接口实现类的对象作为参数传递到构造器中创建的对象将的对象作为参数传递到类的构造器中创建对象并调用方法启用线程获取中方法的返回值返回值为构造器参数实现类重写的的返回值为什么接口方式创建多线程比实现接口创建多线程的方式强大可以有返回值可以抛出异常被外面的操作捕获获取异常信息是支持泛型的新增方式二使用线程池背景经常创建和销毁使用量特别大的资源比如并发下的线程对性能影响很大思路提前创建好多个线程放入线程池中使用时直接获取使用完放回池中可以避免频繁创造销毁实现重复利用类似生活中的公共交通问题好处提高反应速度减少了创建新线程的时间降低资源消耗重复线程池中的线程不需要每次都创建便于线程的管理核心池的大小最大线程数线程没有任务时最多保持多长时间后会终止方法真正的线程池接口常见的子类执行命令没有返回值一般用来执行执行任务有返回值一般又来执行关闭连接池工具类线程池的工厂类用于创建并返回不同类型的线程池创建一个可根据需要创建新线程的线程创建一个可重用固定线程数的线程池创建一个只有一个线程的线程池创建一个线程池它可安排在给定延迟后运行命令或者定期地执行提供指定数量的线程池返回值是一个接口对象可以将这个接口强制转换为类对象通过这个类的对象来调用各个属性执行指定的线程操作需要提供实现接口或者接口的对象适用于适用于关闭线程池常用类字符串相关的类对象的特性字符串使用一对括起来表示声明为的表示不可以被继承实现了接口表示该类型是可序列化的实现了接口表示该类型是可以比较大小的内部定义了用于存储字符串的数据代表了不可变的字符序列简称不可变性体现当对字符串进行从新赋值的时候需要重新指定区域赋值不能够对原有的进行赋值当进行字符串的拼接操作的时候也需要重新指定区域赋值不能够对原有的进行赋值当调用的方法修改指定字符串的时候也需要重新指定区域赋值不能够对原有的进行赋值通过字面量方式区别于给一个字符串赋值此时字符串值声明在字符串常量池中字符串常量池中是不会出现相同内容的字符串的字面量的定义方式比较和的地址值返回值是对象的创建面试题方式创建对象在内存中创建了几个对象两个一个是堆空间中结构另一个是对应的常量池中的数据本质上通过字面量定义的的方式此时的和的数据生命在方法取中的字符串常量池中通过构造器的方式此时和保存的地址值是数据在堆空间中开辟空间以后对应的值常量和常量的拼接结果在常量池并且常量池中不会出现相同内容的常量在字符串拼接的时候只要其中有一个是变量结果就在堆中如果拼接的结果是调用方法返回值就在常量池中常用方法返回字符串的长度返回某索引处的字符判断是否是空字符串使用默认语言环境将中的所有字符转换为小写使用默认语言环境将中的所有字符转换为大写返回字符串的副本忽略前导空白和尾部空白比较字符串的内容是否相同与方法类似忽略大小写将指定字符串连接到此字符串的结尾等价于用比较两个字符串的大小返回值是返回一个新的字符串它是此字符串的从开始截取返回一个新字符串它是此字符串从开始截取到结束不包括如果返回值是表明两个字符串相同如果是负数的话表明前一个字符串小正数的话表明前一个字符串大测试此字符串是否以指定的后缀结束测试此字符串是否以指定的前缀开始测试此字符串从指定索引开始的子字符串是否以指定前缀开始返回值是类型当且仅当此字符串包含指定的值序列时返回返回指定子字符串在此字符串中第一次出现处的索引返回指定子字符串在此字符串中第一次出现处的索引从指定的索引开始返回指定子字符串在此字符串中最右边出现处的索引和方法如果未找到都是返回返回指定子字符串在此字符串中最后次出现处的索引从指定的索引开始反向搜索返回第一个字符的位置从第个位置开始找从字符串的后面开始进行寻找返回第一个字符出现的位置从索引为的位置开始向前寻找返回一个新的字符串它是通过用替换此字符串中出现的所有得到的使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串使用给定的替换此字符串所有匹配给定的正则表达式的子字符串使用给定的替换此字符串匹配给定的正则表达式的第一个子字符串河北地质大学真大大小河北地质大学真大河北地质小学真小河北中国中国地质大学真大告知此字符串是否匹配给定的正则表达式根据给定正则表达式的匹配拆分此字符串根据匹配给定的正则表达式来拆分此字符串最多不超过个如果超过了剩下的全部都放到最后一个元素中与基本数据类型的转换与基本数据类型包装类之间的转换基本数据类型包装类调用包装类中的基本数据类型包装类调用中的方法或者与字符数组转换与之间的转化调用了中的调用了类型的构造器与字节数组进行转换与之间的转换编码调用的解码调用的构造器编码字符串字节看得懂看不懂的二进制数据解码编码的逆过程字节字符串看不懂的二进制数据看得懂说明解码时要求解码使用的字符集必须与编码时使用的字符集一致否则会出现乱码中国使用默认是字符集进行转换一个汉子占三个字节使用进行编码一个汉字占两个字节使用默认的字符集进行解码出现乱码原因编码集和解码集不一致和的使用三者的异同不可变的字符序列底层使用存储可变的字符序列线程安全的效率低底层使用存储可变的字符序列新增的线程不安全的效率高底层使用存储源码分析底层创建了一个长度为的字符数组问题问题扩容问题如果要添加的数据底层数组盛不下了那就需要扩容底层的数组默认情况下扩容为原来容量的倍同时将原有数组中的元素复制到新的数组中指导意义开发中建议使用或者常用方法的常用方法提供了很多的方法用于进行字符串拼接删除指定位置的内容把位置替换为在指定位置插入把当前字符序列逆转总结增删改查插长度遍历日期和事件以前类提供的用来返回当前时间与年月日时分秒之间以毫秒为单位的时间差此方法适用于计算时间差计算世界时间的主要标准有类中的返回当前时间与年月日时分秒之间以毫秒为单位的时间差这个被称为时间戳类表示特定的时间精确到毫秒构造器使用无参构造器创建的对象可以获取本地当前时间常用方法返回自年月日以来此对象表示的毫秒数把此对象转换为以下形式的其中是一周中的某一天是时间标准其它很多方法都过时了类类两个构造器的使用构造器一创建一个对应当前时间的对象构造器二创建指定毫秒数的对象两个方法的使用显示当前的年月日时分秒获取当前对象对应的毫秒数时间戳对应着数据库中的日期类型的变量如何实例化如何将对象转换成对象构造器一构造器二创建指定毫秒数的对象创建对象如何将对象转换成对象情况一父类强转化成子类这种方法只限于父类时候子类的构造器创建的时候父类才能强转成子类情况二类类的不易于国际化大部分被废弃了类是一个不与语言环境有关的方式来格式化和解析日期的具体类它允许进行格式化日期文本解析文本日期格式化默认的模式和语言环境创建对象该构造方法可以用参数指定的格式创建一个对象该对象调用方法格式化时间对象解析从给定字符串的开始解析文本以生成一个日期的使用对日期类的格式化和解析两个操作格式化日期字符串解析字符串日期格式化日期字符串下午解析字符串日期下午这里面的参数的格式一定要符合中的参数的格式如果我们想要自定义日期的格式的话我们可以使用另外一种的构造函数格式化解析日历类是一个抽象基类主要完成日期字段之间相互操作的功能获取实例的方法使用方法调用了它的子类的构造器一个的实例是系统时间的抽象表示通过方法来取得想要的时间信息比如注意获取月份时一月是二月是以此类推月是获取星期时周日是周二是周六是让天下没有难学的技以后新方法出现的背景和的缺陷可变性像日期和时间这样的类应该是不可变的偏移性中的年份是从开始的而月份都从开始格式化格式化只对有用则不行此外它们也不是线程安全的不能处理闰秒等新方法的优势吸收了的精华以一个新的开始为创建优秀的新的中包含了所有关于本地日期本地时间本地日期时间时区持续时间的类历史悠久的类新增了方法用于把转换成新的表示形式这些新增的本地化时间期大大简化了日期时间和本地化的管理方法描述静态方法根据当前时间创建对象指定时区的对象静态方法根据指定日期时间创建对象获得月份天数获得年份天数获得星期几返回一个枚举值获得月份返回一个枚举值获得月份获得年份获得当前对象对应的小时分钟秒将月份天数年份天数月份年份修改为指定的值并返回新的对象向当前对象添加几天几周几个月几年几小时从当前对象减去几月几周几天几年几小时的使用获取当前的日期时间日期时间设置指定的年月日时分秒是没有偏移量的不可变性修改操作修改后的数据返回不会再当前数据上进行修改不可变性在原先的基础上加上了三个月不可变性在原先的基础上减去了天瞬时类时间线上的一个瞬时点这个可能被用来记录应用程序中的事件时间戳在处理时间和日期的时候我们通常会想到年月日时分秒这种记录时间的方法这只是时间的一个模型是面向人类的第二种通用模式是面向机器的或者说是连续处理的在此模型中时间线中的一个点表示为一个很大的数这也有利于计算机的处理在中这个数从年开始以秒为单位同样的在中也是从年开始但是以毫秒为单位包通过值类型提供机器视图不提供处理人类意义上的时间单位表示时间线上的一点而不需要任何上下文信息例如时区概念上讲它只是简单的表示自年月日时分秒开始的秒数因为包是基于纳秒计算的所以的精度可以达到纳秒级秒毫秒微妙纳秒方法描述静态方法返回默认时区的类的对象静态方法返回在基础上加上指定毫秒数之后的类的对象结合即时的偏移来创建一个返回到当前时间的毫秒数即为时间戳的实现获取本初子午线对应的标准时间添加时间的偏移量获取当前时间到年月日时分秒开始的毫秒数通过给定的毫秒数获取指定时间格式化与解析日期或时间类该类提供了三种格式化方法方式一预定义的标准格式方式二本地化相关格式适用于适用于自定义格式如方法方法描述静态方法返回一个指定字符串格式的格式化一个日期时间返回字符串将指定格式的字符串序列解析为一个日期时间格式化或解析日期时间类似于创建类的三种方法方法一预定义的标准格式格式化日期字符串由于是标准形式结果差不多解析字符串日期方法二适用于格式化年月日上午上午适用于年月日方法三自定义格式如格式化解析其他该类中包含了所有的时区信息一个时区的如一个在日历系统时区的目期时间如其中每个时区都对应着地区都为区域城市的格式例如等使用时区提供对当前即时日期和时间的访问的时钟持续时间用于计算两个时间间隔日期间隔用于计算两个日期间隔时间校正器有时我们可能需要获取例如将日期调整到下一个工作日等操作该类通过静态方法提供了大量的常用的实现与传统的日期处理相互转换类遗留类遗留类与与与与与与与无比较器一说明中的对象正常情况下只能比较或者不能够使用或的但是在开发场景中我们需要对多个对象进行排序言外之意就需要比较对象的大小如何实现使用两个接口中的任意一个或接口的使用举例自然排序像包装类实现了接口重写了方法给出比较两个对象的方法像包装类重写方法以后进行了从小到大的排列重写的规则如果当前对象大于形参对象则返回正整数如果当前对象小于形参对象则返回负整数如果当前对象等于形参对象则返回零对于自定义类来说如果你想要进行排序的话则需要实现接口重写方法在中指明应该如何排序如果方法返回正整数则表示大于如果返回表示相等返回负整数表示小于接口的使用定制排序接口的使用定制排序背景当元素的类型没有实现接口而又不方便修改代码或者实现了接口的排序规则不适合当前的操作那么可以考虑使用的对象来排序重写方法比较和的大小如果方法返回正整数则表示大于如果返回表示相等返回负整数表示小于二接口和的使用比较接口的方式一旦确定保证接口实现类的对象在任何位置都可以比较大小接口属于临时性的比较类类与类类代表系统系统级的很多属性和控制方法都放置在该类的内部该类位于包由于该类的构造器是的所以无法创建该类的对象也就是无法实例化该类其内部的成员变量和成员方法都是的所以也可以很方便的进行调用成员变量类内部包含和三个成员变量分别代表标准输入流键盘输入标准输出流显示器和标准错误输出流显示器成员方法该方法的作用是返回当前的计算机时间时间的表达格式为当前计算机时间和时间格林威治时间年月号时分秒所差的毫秒数该方法的作用是退出程序其中的值为代表正常退出非零代表异常退出使用该方法可以在图形界面编程中实现程序的退出功能等该方法的作用是请求系统进行垃圾回收至于系统是否立刻回收则取决于系统中垃圾回收算法的实现以及系统执行时的情况该方法的作用是获得系统中属性名为的属性对应的值系统中常见的属性名以及属性的作用如下表所示属性名属性说明运行时环境版本的安装目录操作系统的名称操作系统的版本用户账户的名称用户主目录用户当前的工作目录的的的的的的的的的的的的的的类提供了一系列静态方法用于科学计算其方法的参数和返回值类型一般为型绝对值三角函数平方根的次幂自然对数为底指数返回到的随机数型数据转换为型四舍五入弧度角度角度弧度类类作为的包装类能存储的最大整型值为类也是有限的最大为如果要表示再大的整数不管是基本数据类型还是他们的包装类都无能为力更不用说进行运算了包的可以表示不可变的任意精度的整数提供所有的基本整数操作符的对应物并提供的所有相关方法另外还提供以下运算模算术计算质数测试素数生成位操作以及一些其他操作构造器根据字符串构建对象常用方法返回此的绝对值的返回其值为的返回其值为的返回其值为的返回其值为的整数相除只保留整数部分返回其值为的返回包含后跟的两个的数组返回其值为的类一般的类和类可以用来做科学计算或工程计算但在商业计算中要求数字精度比较高故用到类类支持不可变的任意精度的有符号十进制定点数构造器常用方法枚举与注解枚举类的使用枚举的定义当一个类中的对象是有限个并且确定的时候我们称其为枚举类当需要定义一组常量的时候强烈建议使用枚举类枚举类的使用枚举类的理解类的对象只有有限个确定的我们称此类为枚举类当我们需要定义一组常量的时候强烈建议使用枚举类如何定义枚举类方式一之前自定义枚举类方式二之后可以使用关键字定义枚举类方式一春天万物复苏声明对象的属性私有化的构造器目的是为了能够确定类对象的个数通过构造器给对象赋值提供当前枚举类的多个对象春天万物复苏夏天烈日炎炎秋天秋高气爽冬天冰封万里其他诉求获取枚举类对象的属性和方法方法方式二没有重写方法然后默认输出枚举类对象的名称说明定义枚举类默认继承与使用关键字创建枚举类提供当前枚举类的对象多个对象之间使用隔开末尾对象使用结束春天万物复苏夏天烈日炎炎秋天秋高气爽冬天冰封万里声明对象的属性私有化的构造器目的是为了能够确定类对象的个数通过构造器给对象赋值其他诉求获取枚举类对象的属性和方法使用关键字创建的枚举类对象不用重写方法输出是枚举类对象的名称方法类的主要方法方法返回枚举类型的对象数组该方法可以很方便地遍历所有的枚举值可以把一个字符串转为对应的枚举类对象要求字符串必须是枚举类对象的名字如不是会有运行时异常返回当前枚举类对象常量的名称没有重写方法然后默认输出枚举类对象的名称说明定义枚举类默认继承与结果线程的几个状态返回枚举类中对象名为的对象如果没有的枚举类对象则抛异常使用关键字定义的枚举类实现接口的情况情况一实现接口在类中实现抽象方法情况二让枚举类的对象分别实现接口中的抽象方法注解其实就是代码里的特殊标记这些标记可以在编译类加载运行时被读取并执行相应的处理通过使用程序员可以在不改变原有逻辑的情况下在源文件中嵌入一些补充信息代码分析工具开发工具和部署工具可以通过这些补充信息进行验证或者进行部署可以像修饰符一样被使用可用于修饰包类构造器方法成员变量参数局部变量的声明这些信息被保存在的对中在中注解的使用目的比较简单例如标记过时的功能忽略警告等在中注解占据了更重要的角色例如用来配置应用程序的任何切面代替旧版中所遗留的繁冗代码和配置等示例一生成文档相关注解表明开发该类的作者表明该类模块的版本参考转向也就是相关主题从那个版本开始增加的对方法中参数的说明方法的返回值对方法可能抛出的异常进行说明如果方法中没有使用显示抛出异常就不能写示例二在编译时进行格式检查内置的三个基本注解限定重写父类方法该注解只能用于方法用于表示所修饰的元素已经过时通常是因为所修饰的结构危险或存在更好的选择抑制编译器警告如何自定义注解参照定义注解声明为内部定义成员通常使用表示可以指定成员的默认值使用定义如果自定义注解没有成员表明是一个标识作用如果注解有成员在使用注解时需要指明成员的值自定义注解必须配上注解的信息流程使用反射才有意义自定义注解通常都会指明两个元注解中的元注解中的元用于修饰其他定义提供了个标准的类型分别是指定修饰的声明周期默认行为只有声明为声明周期的注解才能通过反射获取用于指定被修饰的能用于那些程序元素表示所修饰的注解在被解析时保留下来被他修饰的注解将具有继承性通过反射获取注解信息中注解的新特性可重复注解类型注解可重复注解上声明成员值为的和等元注解与相同类型注解表示该注解能写在类型变量声明语句中如泛型声明表示该注解能写在使用类型的任何语句中集合出现的背景一方面面向对象语言对事物的体现都是以对象的形式为了方便对多个对象的操作就要对对象进行存储另一方面使用存储对象方面具有一些弊端而集合就像一种容器可以动态地把多个对象的引用放入容器中数组在内存存储方面的特点数组初始化以后长度就确定了数组声明的类型就决定了进行元素初始化时的类型数组在存储数据方面的弊端数组初始化以后长度就不可变了不便于扩展数组中提供的属性和方法少不便于进行添加删除插入等操作且效率不高同时无法直接获取存储元素的个数数组存储的数据是有序的可以重复的存储数据的特点单一集合类可以用于存储数量不等的多个对象还可以保存具有映射关系的关联数组一集合框架概述集合数组都是对多个数据进行存储操作的结构简称容器说明此时的存储主要指的是内存层面的存储不涉及到持久化的存储数据库中数组在存储多个数据方面的特点一旦初始化以后其长度就确定了数组一旦定义好其元素的类型也就确定了我们也就只能操作指定类型的数据了比如数组在存储多个数据方面的缺点一旦初始化以后其长度就不可修改数组中提供的方法非常有限对于添加删除插入数据等操作非常不便同时效率不高获取数组中实际元素的个数的需求数组没有现成的属性或方法可用数组存储数据的特点有序可重复对于无序不可重复的需求不能满足二集合框架接口单列集合用来存储一个一个的对象接口存储有序的可重复的数据动态数组接口存储无序的不可重复的数据接口双列集合用来存储一对的数据将元素添加到集合中获取添加元素的个数清空集合元素只是把其中的元素清除干净了但是这个集合依旧存在判断当前集合是否为空中其他的方法的测定接口中声明方法的测试向接口的实现类的对象中添加数据时要求所在类要重写判断当前集合中是否包含我们在判断时会调用对象所在类的判断形参中的所有元素是否都存在于当前集合中移除某一个元素如果该元素存在并且成功移除了则返回从当前集合中移除中的所有元素求交集将中和当前集合中相同的元素提取出来方法当且仅当当前集合和形参结合中的元素内容和顺序都一样的时候返回返回当前对象的哈希值集合数组数组到集合当你使用创建一个基本数据类型的数组转换成集合的时候这时候集合会将这个数组识别成为一个元素如果想要识别出两个元素的话则需要使用包装类的使用集合元素的便利操作使用迭代器接口内部方法和方法判断是否还有下一个元素指针下移将下移以后集合位置上的元素返回测试中的方法如果还未调用或在上一次调用方法之后已经调用了方法再调用都会报删除集合中的新增了循环增强循环用于遍历集合数组集合数组元素的类型局部变量集合数组对象内部仍然调用的迭代器接口接口存储有序的可重复的数据动态数组三者的异同相同点三个类都实现了的接口存储数据的特点相同存储有序的可重复的数据不同点作为接口的主要实现类线程不安全的效率高底层使用存储数组对于频繁使用插入和删除操作的集合此类比使用效率高底层使用双向链表存储作为接口的古老实现类线程安全的效率低底层使用存储数组源码分析的情况下底层创建了长度为的数组如果此次的添加导致底层的数组容量不够则扩容默认情况下扩容为原来容量的倍同时需要将原有的数组中的数据复制到新的数组中结论建议开发中使用带参的构造器的中变化底层初始化为并没有创建长度为的数组第一次调用的时候底层才创建了长度为的数组并将数据添加到数组中后续的添加与扩容操作与无异源码分析内部声明了类型的和属性默认值为将封装到中创建了对象其中定义为一个双向节点的源码分析个中通过构造器创建对象的时候底层都创建了长度为的数组在扩容方面默认扩容为原来的数组长度的倍接口中的常用方法在位置插入元素从位置开始将中的所有元素添加进来获取指定位置的元素返回在集合中首次出现的位置返回在当前集合中末次出现的位置移除指定位置的元素并返回此元素设置指定位置的元素为返回从到位置的子集合在位置插入元素从位置开始将中的所有元素添加进来获取指定位置的元素返回在集合中首次出现的位置返回在当前集合中末次出现的位置移除指定位置的元素并返回此元素设置指定位置的元素为返回从到位置的子集合在位置插入元素从位置开始将中的所有元素添加进来获取指定位置的元素返回在集合中首次出现的位置如果没有找到的话则返回返回在当前集合中末次出现的位置移除指定位置的元素并返回此元素设置指定位置的元素为返回从到位置的子集合左闭右开常用方法增删改查插长度遍历迭代器方式增强循环普通循环接口中没有额外定义的新的方法使用的都是中声明的过的方法要求向中添加数据其所在类一定要重写和这两个方法重写和尽可能的保持一致相同的对象必须有相同的散列码接口存储无序的不可重复的数据作为接口中的主要实现类线程不安全可以存储值作为的子类在遍历数据的时候可以按照添加的顺序遍历可以按照添加对象的指定属性进行排序一存储无序的不可重复的数据以为例说明无序性不等于随机性存储的数据在底层数组中并非按照数组索引的顺序添加的而是根据数据的哈希值进行添加的不可重复性保证添加的元素按照进行判断的时候不能返回即相同的元素只能有一个二添加元素的过程以为例我们向中添加元素首先调用元素的方法获取方法计算元素的值此值通过某种计算方法算出在底层数组中的存放位置即索引位置判断此数组位置上是否有其他元素如果此位置上没有其他元素的话则直接插入情况一如果此位置上有元素或以链表形式存放的多个元素则比较元素和的值是否相同如果不相同的话则直接插入如果相同的话则需要调用元素的方法返回则可以插入情况二返回则不可以插入情况三对于添加成功的情况二和三元素以链表的形式在指定位置的索引上插入元素放在当前数组中指向原来的数据原来的元素位置不变指向元素总结七上八下底层数组链表的结构的使用的使用作为的子类再添加数据的同时每个数据还维护了两个引用记录此数据的前一个和后一个元素优点对于频繁的便利操作效率高于的使用向中添加数据要求是相同类的对象两种排序方式自然排序和定制排序在自然排序中比较两个对象是否相同的标准为返回值不再是在定制排序中比较两个对象是否相同的标准为返回值不再是失败不能添加不同类的对象排好序的定制排序按照年龄从大到小排序输入的类型不匹配按照年龄排好序的测试在内去除重复的数字值要求尽量简单使用类的特性不可重复性来进行筛选如果我们筛选的目标是自定义类的话我们需要在自定义类的下面重写和方法结构掌握正常通过值进行添加无话可说通过地址值来修改元素则中的对应的地址值中的元素也随之改变但是使用的时候的值已经改变了所以对应位置没有元素删除失败添加一个和都和相同的元素这时候虽然内部结构相同但是存入的值是的的值虽然后来其中元素改变了但是在中存放的地址却没有改变所以和都和相同的元素还是可以添加到中的这个元素虽然和的的值相同但是其中元素不同使用的时候返回的不是一个元素所以也可以添加进去的默认容量的最大支持容量的默认加载因子中链表长度大于该默认值转化为红黑树中红黑树存储的小于该默认值转化为链表桶中的被树化时最小的表容量当桶中的数量大到需要变红黑树时若表容量小于时此时应执行扩容操作这个的值至少是的倍存储元素的数组总是的次幂存储具体元素的集中存储的键值对的数量扩容和结构改变的次数扩容的临界值容量填充因子填充因子一实现类的结构双列数据存储对的数据作为的主要实现类线程不安全效率高可以存储的和保证在遍历元素的时候可以按照添加的顺序实现遍历原因在原有的底层结构上添加了一对指针指向前一个和后一个对于频繁的遍历操作此执行效率高于保证按照添加的对进行操作实现排序遍历此时考虑自然排序和定制排序底层使用红黑树作为古老的实现类线程安全效率低不能存储的和常用来处理配置文件和都是类型的的底层数组链表以前数组链表红黑树面试题的底层实现原理和的异同和的异同二结构的理解中的无序的不可重复的使用存储所有的所在的类需要重写和方法中的无序的可重复的使用存储所有的所在的类需要重写一个键值对构成了一个对象中的无序的不可重复的使用对象存储所有的三的底层实现原理在实例化之后底层创建了长度为的一维数组在执行过几次之后首先调用所在类的计算的值次值经过某种算法计算之后得到数组中的存放位置如果此位置上的数据为空此时的添加成功情况如果此位之上的数据不为空意味着此位之上存在着一个或者多个数据以链表的形式存在比较和已经存在的一个或者多个数据的值如果的值与已经存在的数据的值都不相同此时添加成功情况如果的值和已经存在的某个数据的值相同继续比较调用所在类的如果返回此时添加成功情况如果返回使用替换补充关于情况和情况此时和原来的数据以链表的方式存储在不断的添加过程中会涉及到扩容问题当超出临界值且存放的位置非空时扩容默认的扩容方式扩容为原来的两倍并将原有的数据复制过来相较于在底层实现方面的不同底层没有创建一个长度为的数据底层数组是而非首次调用方法的时候底层创建长度为的数组底层结构只有数组链表中底层结构数组链表红黑树当数组某一个索引位置上的元素以链表的形式存在的个数且当前数组的长度的时候此时此索引位置所有数据改用红黑树存储方便查找的默认容量的默认加载因子扩容的临界值容量填充因子中链表长度大于该默认值转化为红黑树桶中的被树化时最小的表容量四底层实现原理了解源码中能够记录添加的元素的先后顺序五一些操作方法添加删除修改操作将指定的添加到或修改当前的对象中将中的所有的对存放到当前中移除指定的的对并返回清空当前中的所有数据元素查询的相关操作获取指定对应的是否包含指定的是否包含指定的返回中对的个数判断当前是否为空判断当前和参数对象是否相等元视图的操作方法返回所有的构成的集合返回所有的构成的集合返回所有构成的集合总结常用方法增删改查长度遍历元视图的操作方法返回所有的构成的集合返回所有的构成的集合返回所有构成的集合遍历所有遍历所有的遍历所有的元素查询的相关操作获取指定对应的是否包含指定的是否包含指定的返回中对的个数判断当前是否为空判断当前和参数对象是否相等添加删除修改操作将指定的添加到或修改当前的对象中将中的所有的对存放到当前中移除指定的的对并返回清空当前中的所有数据修改操作测试类向中添加要求一定是同一个类创建的对象因为要按照进行排序自然排序定制排序自然排序定制排序传入类型有误测试常用来处理配置文件和都是类型的加载到对应的文件测试排序操作反转中元素的顺序对集合元素进行随机排序根据元素的自然顺序对指定集合元素按升序排序根据指定的产生的顺序对集合元素进行排序将指定集合中的处元素和处元素进行交换查找替换操作根据元素的自然顺序返回给定集合中的最大元素根据指定的顺序返回给定集合中的最大元素返回指定集合中指定元素的出现次数将中的内容复制到中使用新值替换对象的所有旧值类中提供了多个方法该方法可使将指定集合包装成线程同步的集合从而可以解决多线程并发访问集合时的线程安全问题我们在使用操作的时候要注意下面这样会报错正确使用操作的方法面试题负载因子值的大小对有什么影响负载因子的大小决定了的数据密度负载因子越大密度越大发生碰撞的几率越高数组中的链表越容易长造成查询或插入时的比较次数增多性能会下降负载因子越小就越容易触发扩容数据密度也越小意味着发生碰撞的几率越小数组中的链表也就越短查询和插入时比较的次数也越小性能会更高但是会浪费一定的内容空间而且经常扩容也会影响性能建议初始化预设大一点的空间按照其他语言的参考及研究经验会考虑将负载因子设置为此时平均检索长度接近于常数集合掌握要求层次一选择合适的集合类去实现数据的保存调用其内部方法层次二不同的集合底层数据机构为何如何实现数据操作的增删改查等泛型概念所谓泛型就是允许在定义类接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型这个类型参数将在使用时例如继承或实现这个接口用这个类型声明变量创建对象时确定即传入实际的类型参数也称为类型实参在没有泛型之前使用泛型之前的情况存放学生成绩可能存储一些非成绩的对象这时候会报错类型转换异常泛型的使用新增特性在集合中使用泛型总结集合接口或者集合类在时都修改为带泛型的结构在实例化集合类的时候可以指明具体的集合泛型指明完之后在集合类或者接口中凡是定义类或者接口的时候内部结构比如方法构造器属性比如实例化之后注意点泛型的类型必须是类不能是基本数据类型需要用到基本数据类型的位置拿包装类替换如果实例化的时候没有指明泛型的类型默认类型为类型使用泛型之前的情况存放学生成绩问题一类型不安全可能存储一些非成绩的对象问题二强转时会报错类型转换异常集合中使用泛型的情况如果使用泛型的话在我们添加的非法类型的时候就会直接报错编译时就是进行数据类型检查保证数据的安全方式一方式二在集合中泛型使用情况泛型的嵌套泛型在继承方面的使用虽然类是类的父类但是和二者不具备子父类关系二者是并列关系通配符的使用通配符类是类的父类和是没有关系的二者共同的父类是使用通配符定义的变量不能够向内部添加除了意外的任何数据允许读取数据读取数据的类型是有限制条件的通配符的使用可以作为和的父类其中是的子类可以作为和的父类的其中是的父类下面这种情况就会报错因为使用方法调用有限制的通配符只能调用该类以及该类的子类这种情况也会报错使用调用的有限制的通配符只能调用该类以及该类的父类读取数据编译不通过使用声明的有限制的通配符在获取对象的时候只能是的那个类编译不通过使用声明的有限制的通配符在获取对象的时候只能是写入数据编译不通过使用声明的有限制的通配符不能够添加对象编译通过使用声明的有限制的通配符在添加对象的时候只能够添加后面的类以及它的子类使用通配符的话下面这种情况就不会报错通配符定义的变量不能够添加除了之外的任何数据这样会报错允许读取数据读取数据的类型是这样编译不通过此时的和不具备子父类关系编译不通过反证法假设合理的话那么因为中的泛型是所以可以添加数值为的数据但是又由于和指向的是同一个内存地址所以调用的方法同样也添加到了的对象中但是的泛型是类型的这时候就导致中有一些杂类出现使用泛型之前的情况存放学生成绩问题一类型不安全可能存储一些非成绩的对象问题二强转时会报错类型转换异常集合中使用泛型的情况如果使用泛型的话在我们添加的非法类型的时候就会直接报错编译时就是进行数据类型检查保证数据的安全方式一方式二在集合中泛型使用情况泛型的嵌套泛型类泛型接口泛型方法泛型类泛型接口泛型类可能有多个参数此时应将多个参数一起放在尖括号内比如泛型类的构造器如下而下面是错误的实例化后操作原来泛型位置的结构必须与指定的泛型类型一致泛型不同的引用不能相互赋值尽管在编译时和是两种类型但是在运行时只有一个被加载到中泛型不同的引用不能相互赋值这样是错误的泛型如果不指定将被擦除泛型对应的类型均按照处理但不等价于经验泛型要使用一路都用要不用一路都不要用如果泛型类是一个接口或抽象类则不可创建泛型类的对象泛型的简化操作泛型的指定中不能使用基本数据类型可以使用包装类替换在类接口上声明的泛型在本类或本接口中即代表某种类型可以作为非静态属性的类型非静态方法的参数类型非静态方法的返回值类型但在静态方法中不能使用类的泛型异常类不能是泛型的不能使用但是可以参考源码中声明而非泛型参数类型数组父类有泛型子类可以选择保留泛型也可以选择指定泛型类型子类不保留父类的泛型按需实现没有类型擦除具体类型子类保留父类的泛型泛型子类全部保留部分保留子类不保留父类的泛型没有类型等价于具体类型子类保留父类的泛型全部保留部分保留结论子类必须是富二代子类除了指定或保留父类的泛型还可以增加自己的泛型泛型方法实例泛型方法在方法中出现了泛型结构泛型参数和类的泛型参数没有关系换句话说泛型方法所属类是不是泛型都没有关系泛型方法可以声明为静态的原因泛型参数是在调用方法的时候确定的并非在实例化类的时候确定流原理及流的分类类的使用类的一个对象代表一个文件或者一个文件目录文件夹类生命在包下类中涉及到文件或者文件目录的创建删除重命名修改时间文件大小等方法并未涉及到文件读写内容的的操作如果需要读取或者写入文件内容的操作则必须使用流来操作后续类对象常会作为参数传递到流的构造器中指明读取或写入的终点常用构造器如何创建类的实例相对路径相较于某个路径下指明的路径绝对路径包含盘符在内的文件或文件目录的路径说明中如果在开发中使用的是单元测试方法相对路径为当前的下如果使用的方法的话相对路径为当前的工程下路径分隔符构造器一指明确定的文件方式一相对路径相对于当前的方式二绝对路径构造器二没有指明确定的文件是一个文件目录文件夹构造器三常用方法获取功能获取绝对路径获取路径获取名称获取上层文件目录路径若无返回获取文件长度即字节数不能获取目录的长度获取最后一次的修改时间毫秒值下面两个适用于文件目录获取指定目录下的所有文件或者文件目录的名称数组获取指定目录下的所有文件或者文件目录的数组作业输出文件名称输出文件路径下面这个适用于该文件比如为例要想保证返回需要在内存中是存在的在内存中不存在将文件目标改为的文件目标下面这个方法适用于文件判断功能判断是否是文件目录判断是否是文件判断是否存在判断是否可读判断是否可写判断是否隐藏当文件存在的使用有以下几种情况当文件不存在的时候返回值都为当文件为文件目录时类创建功能创建文件若文件存在则不创建返回创建文件目录如果此文件目录存在就不创建了如果此文件目录的上层目录不存在也不创建创建文件目录如果上层文件目录不存在一并创建注意事项如果你创建文件或者文件目录没有写盘符路径那么默认在项目路径下类删除功能删除文件或者文件夹删除注意事项中的删除不走回收站要删除一个文件目录请注意该文件目录内不能包含文件或者文件目录流是的缩写技术是非常实用的技术用于处理设备之间的数据传输如读写文件网络通讯等程序中对于数据的输入输出操作以流的方式进行包下提供了各种流类和接口用以获取不同种类的数据并通过标准的方法输入或输出数据流的分类方式按操作数据单位不同分为字节流字符流按数据流的流向不同分为输入流输出流按流的角色的不同分为节点流处理流抽象基类字节流字符流输入流输出流流体系分类字节输入流字节输出流字符输入流字符输出流抽象基类访问文件访问数组访问管道访问字符串缓冲流转换流对象流打印流推回输入流特殊流字符流的读入方法返回值是读入字符的码实例化类的对象指明要操作的文件提供具体的流数据的输入返回读入的一个字符如果达到文件默认返回流的关闭操作流读入的说明的理解返回读入的一个字符如果达到文件末尾返回异常的处理为了保证流资源可以执行关闭操作需要使用处理读入文件操作一定要存在否则会报对操作升级使用的重载方法返回值是读入的几个字符类的实例化流的实例化读入的操作方式一下面这种写法是错误的因为会涉及到未写入和读取的操作下面这种操作就可以完美的输出文件中的所有内容方式二下面这种方式依旧错误错因和方式一种的原因相同下面这种方式是正确的资源的关闭字符流的输出说明输入操作对应的可以是不存在的并不会报异常对应的硬盘中的文件如果不存在在输出的过程中会自动创建此文件对应的硬盘中的文件如果存在如果流使用的构造器是对原有的文件进行覆盖如果流使用的构造器是不会对原有的文件进行覆盖而是在原有的文件基础追加内容提供类的对象指明写出到的文件提供的对象用于数据的写出使用参数对原数据进行覆盖写出的操作流的资源的关闭字符型总测试创建类的对象指明写入和写出的文件创建输入流和输出流数据的读入和写出操作流的关闭字节流的读入和输出文件的创建流的创建流的读取和写入操作方式一方式二缓冲流的使用四种缓冲流缓冲流的作用提高流的读取和写入速度造文件造流造节点流造缓冲流复制的细节读取写入资源关闭要求先关闭外层的流在关闭内层的流说明关闭外层流的同时内层流也会自动的进行关闭关于内层流的关闭我们可以省略转换流提供了字符流和字节流之间的转换提供了两个转换流将转换为将一个字节的输入流转换为字符的输入流将转换为将一个字符的输出流转换成字节的输出流作用提供字节流和字符流之间的转换解码字节字节数组字符数组字符串编码字符数组字符串字节字节数组以下这种方法调用的是默认编码格式以下这种方式调用的是自定义的编码格式字符集美国标准信息交换码用一个字节的位可以表示拉丁码表欧洲码表用一个字节的位表示中国的中文编码表最多两个字节编码所有字符中国的中文编码表升级融合了更多的中文文字符号最多两个字节编码国际标准码融合了目前人类使用的所有字符为每个字符分配唯一的字符码所有的文字都用两个字节来表示变长的编码方式可用个字节来表示一个字符标准输入输出流和分别代表了系统标准的输入和输出设备默认输入设备是键盘输出设备是显示器的类型是的类型是其是的子类的子类重定向通过类的方法对默认设备进行改变默认是输出到控制台和从控制台中获取如果我们使用或者的话可以改变读入和写出的位置练习将输入的字符都转换成大写的当输入或者的时候退出请输入字符串程序结束打印流实现将基本数据类型的数据格式转化为字符串输出打印流和提供了一系列重载的和方法用于多种数据类型的输出和的输出不会抛出异常和有自动功能打印的所有字符都使用平台的默认字符编码转换为字节在需要写入字符而不是写入字节的情况下应该使用类返回的是的实例数据流为了方便地操作语言的基本数据类型和的数据可以使用数据流作用用于读取或者写出基本数据类型的变量或字符串数据流有两个类用于读取和写出基本数据类型类的数据和分别套接在和子类的流上中的方法中的方法将上述的方法的改为相应的即可张锦昊姓名年龄男性对象流和用于存储和读取基本数据类型数据或对象的处理流它的强大之处就是可以把中的对象写入到数据源中也能把对象从数据源中还原回来序列化用类保存基木类型数据或对象的机制反序列化用类读取基木类型数据或对象的机制和不能序列化和修饰的成员变量对象的序列化对象的序列化机制对象序列化机制允许把内存中的对象转换成平台无关的二进制流从而允许把这种二进制流持久地保存在磁盘上或通过网络将这种二进制流传输到另一个网络节点当其它程序获取了这种二进制流就可以恢复成原来的对象序列化的好处序列化的好处在于可将任何实现了接口的对象转化为字节数据使其在保存和传输时可被还原序列化是远程方法调用过程的参数和返回值都必须实现的机制而是的基础因此序列化机制是平台的基础如果需要让某个对象支持序列化机制则必须让对象所属的类及其属性是可序列化的为了让某个类是可序列化的该类必须实现如下两个接口之一否则会抛出异常凡是实现接口的类都有一个表示序列化版本标识符的静态变量用来表明类的不同版本间的兼容性简言之其目的是以序列化对象进行版本控制有关各版本反序列化时是否兼容如果类没有显示定义这个静态变量它的值是运行时环境根据类的内部细节自动生成的若类的实例变量做了修改可能发生变化故建议显式声明简单来说的序列化机制是通过在运行时判断类的来验证版本一致性的在进行反序列化时会把传来的字节流中的与本地相应实体类的进行比较如果相同就认为是一致的可以进行反序列化否则就会出现序列化版本不一致的异常和不能序列化和修饰的成员变量序列化的过程将内存中的对象保存到磁盘中或者通过网络传输出去使用实现我爱中国张三刷新操作反序列化过程将磁盘文件中的对象还原为内存中的一个对象如果是自定义类的话需要实现接口并设置一个的全局常量除了当前类需要实现接口除外还要保证其内部所有属性也必须是可序列化的随机存取文件流声明在包下但直接继承于类并且它实现了这两个接口也就意味着这个类既可以读也可以写类支持随机访问的方式程序可以直接跳到文件的任意地方来读写文件支持只访问文件的部分内容可以向己存在的文件后追加内容对象包含一个记录指针用以标示当前读写处的位置类对象可以自由移动记录指针获取文件记录指针的当前位置将文件记录指针定位到位置创建类实例需要指定一个参数该参数指定的访问模式以只读方式打开打开以便读取和写入打开以便读取和写入同步文件内容的更新打开以便读取和写入同步文件内容和元数据的更新如果模式为只读则不会创建文件而是会去读取一个已经存在的文件如果读取的文件不存在则会出现异常如果模式为读写如果文件不存在则会去创建文件如果存在则不会创建的使用直接继承与类实现了和接口既可以作为输入流也可以作为输出流如果作为输出流时写出到的文件如果不存在则在执行过程中自动创建如果写出到的文件存在则会对原有文件内容进行覆盖默认情况下从头覆盖中类的使用是从版本开始引入的一套新的可以替代标准的与原来的有同样的作用和目的但是使用的方式完全不同支持面向缓冲区的是面向流的基于通道的操作将以更加高效的方式进行文件的读写操作中提供了两套一套是针对标准输入输出另一套就是网络编程处理本地文件网络编程的客户端的网络编程的服务器端的网络编程中发送端和接收端的早期的只提供了一个类来访问文件系统但类的功能比较有限所提供的方法性能也不高而且大多数方法在出错时仅返回失败并不会提供异常信息为了弥补这种不足引入了接口代表一个平台无关的平台路径描述了目录结构中文件的位置可以看成是类的升级版本实际引用的资源也可以不存在以前的操作符是这样写的但在中我们可以这样写同时在包下还提供了工具类包含了大量静态的工具方法来操作文件则包含了两个返回的静态工厂方法类提供的静态方法用来获取对象用于将多个字符串串连成路径返回指定对应的路径网络编程计算机网络把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大功能强的网络系统从而使众多的计算机可以方便地互相传递信息共享硬件软件数据信息等资源网络编程的目的直接或者间接的通过网络协议与其他计算机实现数据交换进行通讯网络编程的两个主要目的如何精确的定位网络上一台或者多台主机定位主机上特定的应用找到主机后如何可靠高效的进行数据的传输网络通讯中的两个要素和端口号每一个主机在网络上都有唯一的地址唯一的标识上的计算机通信实体本地回环地址主机名地址分类方式和个字节组成个大概亿亿都在北美亚洲亿年初已经用尽以点分十进制表示如位个字节写成个无符号整数每个整数用四个十六进制位表示数之间用冒号分开如地址分类方式公网地址万维网使用和私有地址局域网使用开头的就是私有址址范围即为专门为组织机构内部使用特点不易记忆端口号标识正在计算机上运行的进行程序不同的进程有不同的端口号被规定为一个位的整数端口分类公认端口被预先定义的服务通信占用如占用端口占用端口占用端口注册端口分配给用户进程或应用程序如占用端口占用端口占用端口等动态私有端口端口号与地址组合得出一个网络套接字唯一标识上的计算机通讯实体在中使用类代表分类和万维网和局域网域名域名解析服务器本地回路地址对应着实例化两个方法两个常用方法端口号正在计算机上运行的程序要求不同的进程有不同的端口号范围被规定为一个为整数端口号和地址组合成一个网络套字获取本机获取本机获取域名和本机网络通讯协议网络通信协议计算机网络中实现通信必须有一些约定即通信协议对速率传输代码代码结构传输控制步骤出错控制等制定标准问题网络协议太复杂计算机网络通信涉及内容很多比如指定源地址和目标地址加密解密压缩解压缩差错控制流量控制路由控制如何实现如此复杂的网络协议呢通信协议分层的思想在制定协议时把复杂成份分解成一些简单的成份再将它们复合起来最常用的复合方式是层次方式即同层间可以通信上一层可以调用下一层而与再下一层不发生关系各层互不影响利于系统的开发和扩展和协议使用协议前须先建立连接形成传输数据通道传输前采用三次握手方式点对点通信是可靠的协议进行通信的两个应用进程客户端服务端在连接中可进行大数据量的传输传输完毕需释放已建立的连接效率低四次挥手协议将数据源目的封装成数据包不需要建立连接每个数据报的大小限制在内发送不管对方是否准备好接收方收到也不确认故是不可靠的可以广播发送发送数据结束时无需释放资源开销小速度快网络编程客户端发信息给服务端服务端将数据显示在控制台上创建对象指明服务器端的和端口号获取一个输出流用于输出数据写出数据因为写入的需要时字节流文件所以我们需要使用将字符串转换成字节流你好我是客户端服务端创建一个服务器端的指明自己的端口号调用表示接受来在客户端的获取输入流从输入流中读取数据客户端发送文件给服务器端服务器端将文件保存在本地创建对象获取输出流向服务器端输出获取一个输入流从内存中读取文件向服务器端写数据创建一个服务器端的对象读取客户端发来的数据创建一个输入流将客户端发来的图片写入到本地从客户端发送文件到服务端服务端保存到本地并返回发送成功到服务端并关闭相应的链接创建对象获取输出流向服务器端输出获取一个输入流从内存中读取文件向服务器端写数据停止传送数据接受来自服务器端的反馈好好好创建一个服务器端的对象读取客户端发来的数据创建一个输入流将客户端发来的图片写入到本地给予客户端反馈照片已收到网络编程类和实现了基于协议网络程序数据报通过数据报套接字发送和接收系统不保证数据报一定能够安全送到目的地也不能确定什么时候可以抵达对象封装了数据报在数据报中包含了发送端的地址和端口号以及接收端的地址和端口号协议中每个数据报都给出了完整的地址信息因此无须建立发送方和接收方的连接如同发快递包裹一样我是方式发射的导弹编程统一资源定位符它表示上某资源的地址它是一种具体的即可以用来标识一个资源而且还指明了如何这个资源通过我们可以访问上的各种网络资源比如最常见的站点浏览器通过解析给定的可以在网络上查找相应的文件或其他资源的基本结构由部分组成传输协议主机名端口号文件名片段名参数列表例如片段名即锚点例如看小说直接定位到章节参数列表格式参数名参数值参数名参数值获取该的协议名获取该的主机名获取该的端口号获取该的文件路径获取该的文件名获取该的查询名反射机制概述反射被视为动态语言的关键反射机制允许程序在执行期间借助于取得任何类的内部信息并能直接操作任意对象内部属性和方法加载完类之后在堆内存的方法区中就产生了一个类型的对象一个类只有一个对象这个对象就包含了完整的类的结构信息我们可以通过这个对象看到类的结构这个对象就像一面镜子透过这个镜子看到类的结构所以我们形象的称之为反射正常方式引入需要的包类的名称通过实例化取得实例化对象反射方式实例化对象方法得到完整的包类的名称动态语言是一类在运行时可以改变其结构的语言例如新的函数对象甚至代码可以被引进已有的函数可以被删除或是其他结构上的发化通俗点说就是在运行时代码可以根据某些条件改变自身结构主要动态语言静态语言与动态语言相对应的运行时结构不可变的语言就是静态语言如不是动态语言但可以称之为准动态语言即有一定的动态性我们可以利用反射机制字节码操作获得类似动态语言的特性的动态性让编程的时候更加灵活反射机制提供的功能在运行时判断任意一个对象所属的类在运行时构造任意一个类的对象在运行时判断任意一个类所具有的成员变量和方法在运行时获取泛型信息在运行时调用任意一个对象的成员变量和方法在运行时处理注解生成动态代理反射之前对于类的操作创建类的对象通过对象调用其内部方法在类的外部不可以通过类的对象调用其内部的私有结构比如以及私有的构造器反射之后对的操作通过反射创建类对象通过反射调用对象指定的属性和方法调用属性调用方法通过反射可以调用类私有结构比如私有的构造器方法属性调用私有构造器调用私有属性调用私有方法中国关于类的理解类的加载过程程序经过命令以后会生成一个或多个字节码文件结尾接着我们使用命令对某个字节码文件进行解释运行相当于将某个字节码文件加载到内存中此过程就称为类的加载加载到内存中的类我们就称为运行时类此运行时类就作为的一个实例换句话说实例就对应着一个运行时类加载到内存中的运行时类会缓存一定的时间在此时间内我们可以通过不同的方式来获取此运行时类获取类实例的的方式前三种方式需要掌握方式一调用运行时类的属性方式二通过运行时类的对象调用方式三调用的静态方法方式四使用类加载器类的加载类的加载器作用是把类加载到内存中的引导加载器是自带的加载器负责平台核心库用来装载核心类库该加载类无法直接获取扩展类加载器负责目录下的包或指定目录下的包装入工作库以后的版本中变成系统类加载器负责或指定目录下的类与包装入工作是最常用的加载器获取当前自定类加载器对于自定义类使用系统类加载器进行加载调用系统类加载器的获取扩展类加载器调用扩展类加载器的无法获取引导类加载器引导类加载器主要负责加载的核心类库无法加载自定义类的此时文件默认在当前的下读取配置文件的方式一读取配置文件的方式二使用配置文件默认识别为当前文件的下创建运行时类对象调用此方法创建对应的运行时类的对象内部调用了运行时类的空参构造器要想此方法正常的创建运行时类的对象要求运行时类必须提供空参构造器空参构造器的权限需要能够调用在中要求提供一个的空参构造器原因便于通过反射创建运行时类对象便于子类继承此运行时类时默认调用时保证父类有此构造器体会反射的动态性创建一个指定类的对象指定类的全类名获取运行时类的完整结构属性获取属性结构获取当前运行时类及其父类中声明为访问权限的属性获取当前运行时类当中声明的所有属性不包括父类权限修饰符数据类型变量名方法获取当前运行时类及所有父类中声明为权限的方法获取当前运行时类中声明的所有方法不包含父类中声明的方法权限修饰符返回值类型方法名参数类型形参获取方法声明的注解权限修饰符返回值类型方法名形参列表抛出异常其他类获取构造器结构获取当前运行时类中声明为的构造器获取当前运行时类中声明的所有的构造器获取运行时类的父类获取运行时类的父类获取运行时的带泛型的父类获取运行时类的带泛型的父类的泛型获取泛型参数获取父类获取带泛型父类获取父类的泛型获取运行时类实现的接口获取运行时类所在的包获取运行时类的注解调用运行时类的指定结构创建运行时类的对象获取指定的属性只能获取权限为的设置当前属性的值参数一指明设置那个对象的属性参数二将此属性设置成为多少获取当前属性的值参数一获取那个对象的当前属性值如何操作运行时类中指定的属性创建运行时类的对象获取运行时类中指定的变量名的属性保证当前对象时可访问的获取指定对象的词属性值如何操作运行时类中指定的方法创建运行时类的对象获取某个指定的方法参数指明获取方法的名称参数指明获取方法的形参列表保证当前的方法是可访问的调用参数方法的调用者参数给方法形参赋值的实参的返回值即为对应类中调用方法的返回值中国如何调用静态方法如果没有返回值的话则返回如何调用运行时类中指定的构造器获取指定构造器参数指明构造器的参数列表保证此构造器是可访问的调用构造器创建运行时类对象动态代理代理设计模式的原理使用一个代理将对象包装起来然后用该代理对象取代原始对象任何对原始对象的调用都要通过代理代理对象决定是否以及何时将方法调用转到原始对象上之前的代理机制的操作属于静态代理特征是代理类和目标对象的类都是在编译期间确定下来不利于程序的扩展同时每一个代理类只能为一个接口服务这样一来程序开发中必然产生过多的代理最好可以通过一个代理类完成全部的代理功能静态代理功能代理类用被代理类对象进行实例化代理工厂做一些准备工作代理工厂做一些后续的收尾工作被代理类工厂生产一批运动服创建被代理类的对象创建代理类的对象动态代理被代理类我喜欢吃要想实现动态代理需要解决的问题问题一如何根据加载到内存中的被代理类动态的创建一个代理类及其对象问题二当通过代理类的对象调用方法的时候如何动态的去调用被代理类中同名的方法通过此方法返回一个代理类的对象解决问题一被代理类对象需要使用被代理类的对象进行赋值当我们通过代理类的对象调用方法时就会自动调用如下的方法当被代理类要执行方法的功能就声明在中即为代理类对象调用的方法此方法也就作为了被代理类对象要调用的方法被代理类的对象上述方法的返回值就作为当前类中的返回值创建被代理对象创建代理类对象新特性速度更快代码更少增加了新的语法表达式强大的便于并行最大化减少空指针异常引擎允许在上运行应用表达式是一个匿名函数我们可以把表达式理解为是一段可以传递的代码将代码像数据一样进行传递使用它可以写出更简洁更灵活的代码作为一种更紧凑的代码风格使的语言表达能力得到了提升表达式的使用举例格式操作符或箭头操作符左边形参列表其实就是接口中的抽象方法的形参列表右边体其实就是重写抽象方法中的方法体表达式的使用分为六种情况总结左边形参列表的参数类型可以省略类型推断如果形参列表只有一个参数其一对可以省略右边体应使用一个来包裹如果体只有一条执行语句可能是语句可以省略这一对和关键字表达式的本质作为接口的实例如果一个接口中只声明了一个抽象方法则此接口就称作函数式接口语法格式一无惨无返回值别走跑起来哈哈哈语法格式二需要一个参数但是没有返回值我是一个正常写法我是写法语法格式三数据类型可以省略应为可由编译器推断出称为类型推断我是写法我是写法语法格式四若只需要一个参数的时候参数的小括号可以省略我是写法语法格式五两个或以上的参数多条执行语句并且有返回值语句语句语句语句语法格式六当体只有一条语句的时候与大括号若都有都可以省略函数式接口只包含一个抽象方法的接口称为函数式接口你可以通过表达式来创建该接口的对象若表达式抛出一个受检异常即非运行时异常那么该异常需要在目标接口的抽象方法上进行声明我们可以在一个接口上使用这样做可以检查它是否是一个函数式接口同时也会包含一条声明说明这个接口是一个函数式接口在包下定义了的丰富的函数式接口函数式接口参数类型返回类型用途消费型接口对类型为的对象应用操作包含方法供给型接口无返回值类型为的对象包含方法函数型接口对于类型为的对象应用操作并返回结果结果是型对象包含方法断定性接口确定类型为的对象是否满足某约束并返回值包含方法方法引用与构造器引用方法引用买炸鸡价格为买烤肠价格为方法的使用使用情境当要传递给体的操作已经有实现方法了可以作为使用方法引用方法引用本质上是表达式使用格式类或对象方法名具体使用分为如下三种情况情况对象非静态方法情况类静态方法情况类非静态方法方法引用的使用要求要求接口中的抽象方法的形参列表和返回值类型和方法引用中的方法的形参列表和返回值类型相同针对于情况情况情况一对象实例方法中的中的北京中国中的中的情况二类静态方法中的中的情况三类实例方法中的中的中的方法的方法体调用类型中的这个方法第一个参数为中中的调用者第二个参数为的调用者中的中的中的中的构造器引用一构造器引用和方法引用类似函数式接口的抽象方法的形参列表和构造器的形参列表一致抽象方法的返回值类型即为构造器所属类的类型二数组引用可以把数组看成一个特殊的类则写法和构造器引用一致构造器引用中的的空参构造器中的中的数组引用中的把真正的函数式编程风格引入到中这是目前为止对类库最好的补充因为可以极大提供程序员的生产力让程序员写出高效率干净简洁的代码是中处理集合的关键抽象概念它可以指定你希望对集合进行的操作可以执行非常复杂的查找过滤和映射数据等操作使用也可以使用来并行执行操作简言之提供了一种高效且易于使用的处理数据的方式关注的是数据的运算和有关系集合关注的是数据的存储与内存有关系自己不会存储元素不会改变原对象相反它会返回一个持有结果的新操作是延迟的这意味着他们会等到需要结果的时候才执行执行流程的实例化一系列的中间操作终止操作说明一个中间操作链对数据源的数据进行处理一旦执行终止操作就执行中间操作链并产生结果之后不会再被使用实例化的四种方法通过集合通过数组通过的创建无限流创建方式一通过集合先获取一个集合返回一个顺序流返回一个并行流创建方式二通过数组调用类的返回一个流创建方式三通过的创建方式四创建无限流迭代遍历前个偶数生成的中间操作多个中间操作可以连接起来形成一个流水线除非流水线上触发终止操作否则中间操作不会执行任何的处理而在终止操作时一次性全部处理称为惰性求值筛选与切片方法描述接受从流中排除某些元素筛选通过流生成元素的和去除重复元素截断流使其元素不超过指定数量跳过元素返回一个扔掉了前个元素的流若流中的元素不足个则返回一个空流与互补筛选与切片接收从流中排除某些元素截断流使其元素不超过给定数量一跳过元素返回一个扔掉了前个元素的流若流中元素不足个则返回一筛选通过流所生成元素的和去除重复元素映射方法描述接收一个函数作为参数该函数会被应用到每个元素上并将其映射成一个新的元素接受一个函数作为参数该函数会被应用到每一个元素上产生成一个新的接受一个函数作为参数该函数会被应用到每个元素上产生一个新的接受一个函数作为参数该函数会被应用到每个元素上产生一个新的接受一个函数作为参数将流中的每个值都换成另一个流然后把所有流连接成一个流映射接收一个函数作为参数将元素转换成其他形式或提取信息该函数会被应用到每个元素上并将其映射成一个新的元素练习获取员工姓名长度大于的员工的姓名练习接收一个函数作为参数将流中的每个值都换成另一个流然后把所有流连接成一个流排序方法描述产生一个新流其中按照自然顺序排序产生一个新流其中按照比较器顺序排序自然排序如果一个类中没有实现接口的话不能够使用方法定制排序终止操作匹配与查找方法描述查找是否匹配所有元素检查是否至少匹配一个元素检查是否没有匹配所有元素返回第一个元素返回当前流中的任意的元素返回流中元素总和返回流中的最大值返回流中的最小值内部迭代检查是否匹配所有元素练习是否所有的员工的年龄都大于检查是否至少匹配一个元素练习是否存在员工的年龄大于检查是否没有匹配的元素练习是否存在员工姓雷大返回第一个元素返回当前流中的任意元素返回流中元素的总个数返回流中最大值练习返回最高的工资返回流中最小值练习返回最低工资的员工内部迭代归约方法描述可以将流中元素反复结合起来得到一个值返回可以将流中的元素反复结合起来得到一个值返回可以将流中元素反复结合起来得到一个值返回练习一计算自然数和一可以将流中元素反复结合起来得到一个值返回练习计算公司所有员工年龄的总和收集方法描述将流转换为其他形式接收一个接口的实现用于给中元素做汇总的方法将流转换为其他形式接收一个接口的实现用于给中元素做汇总的方法练习查找年龄大于的员工结果返回一个或类尽可能的避免在开发中遇到空指针异常提供很多有用的方法这样我们就不用显式进行空值检测创建类对象的方法创建一个实例必须非空创建一个空的实例可以为判断容器中是否包含对象判断是否包含对象如果有值就执行接口的实现代码并且该值会作为参数传给它获取容器的对象如果调用对象包含值返回该值否则抛异常如果有值则将其返回否则返回指定的对象如果有值则将其返回否则返回由接口实现提供的对象如果有值则将其返回否则抛出由接口实现提供的异常创建一个实例必须非空创建一个空的实例可以为保证是非空的如果当前返回的内部包装类是非空的话则返回内部的如果内部的大是空的则返回方法中的参数赵丽颖没有的时候我们获取属性的方法为可能会出现空指针异常这是没有类的时候我们采用的方法优化之后的方法使用类的门此时的一定非空迪丽热巴一定非空古力娜扎新特性',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-20 22:40:38',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.1.1"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://s1.ax1x.com/2022/11/27/zUFla6.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://262259.xyz/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" href="https://262259.xyz/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">管理</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://qexo.262259.xyz/" title="博客后端"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://unpkg.com/qexo-static@1.4.0/assets/img/brand/qexo.png" alt="博客后端"/><span class="back-menu-item-text">博客后端</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Nuyoah</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://s2.loli.net/2022/08/16/weL31EHsON5ldDU.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/08/16/weL31EHsON5ldDU.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/08/16/2yRjVx9gFKQaidA.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/08/16/2yRjVx9gFKQaidA.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Gitee/" style="font-size: 1.05rem;">Gitee<sup>1</sup></a><a href="/tags/JAVA/" style="font-size: 1.05rem; font-weight: 500; color: var(--anzhiyu-lighttext)">JAVA<sup>5</sup></a><a href="/tags/JS/" style="font-size: 1.05rem;">JS<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>1</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>7</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>2</sup></a><a href="/tags/hexo/" style="font-size: 1.05rem;">hexo<sup>4</sup></a><a href="/tags/win10/" style="font-size: 1.05rem;">win10<sup>1</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/" style="font-size: 1.05rem;">个人日记<sup>1</sup></a><a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 1.05rem;">人工智能<sup>15</sup></a><a href="/tags/%E5%B7%A5%E4%BD%9C/" style="font-size: 1.05rem;">工作<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%BA%8E%E9%80%BB%E8%BE%91/" style="font-size: 1.05rem;">数字电路于逻辑<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" style="font-size: 1.05rem;">算法实现<sup>12</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">计算机基础<sup>13</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/12/"><span class="card-archive-list-date">十二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/" itemprop="url">JAVA</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JAVA/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JAVA</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JAVA教程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-05-16T06:49:44.000Z" title="发表于 2022-05-16 14:49:44">2022-05-16</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-02-20T14:40:38.254Z" title="更新于 2023-02-20 22:40:38">2023-02-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">61.5k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>237分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为石家庄"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>石家庄</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://s2.loli.net/2022/11/21/Sm8lFrjtzUkihVy.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://262259.xyz/2022/05/16/JAVA%E7%AC%94%E8%AE%B0/"><header><a class="post-meta-categories" href="/categories/JAVA/" itemprop="url">JAVA</a><a href="/tags/JAVA/" tabindex="-1" itemprop="url">JAVA</a><h1 id="CrawlerTitle" itemprop="name headline">JAVA教程</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Nuyoah</span><time itemprop="dateCreated datePublished" datetime="2022-05-16T06:49:44.000Z" title="发表于 2022-05-16 14:49:44">2022-05-16</time><time itemprop="dateCreated datePublished" datetime="2023-02-20T14:40:38.254Z" title="更新于 2023-02-20 22:40:38">2023-02-20</time></header><h1 id="java笔记"><a class="markdownIt-Anchor" href="#java笔记"></a> JAVA笔记</h1>
<h1 id="注释需要注意的地方"><a class="markdownIt-Anchor" href="#注释需要注意的地方"></a> 注释需要注意的地方：</h1>
<pre><code>/**   */这是文档注释，会生成一个html文件来对这个文档进行说明

多行注释中，注释不能嵌套
</code></pre>
<h1 id="编译需要注意的"><a class="markdownIt-Anchor" href="#编译需要注意的"></a> 编译需要注意的</h1>
<pre><code>一个java文件中可以生命多个class但是最多只能有一个class被public修饰而且要求声明为public的类的类名必须与源文件相同

程序入口是main（）方法，格式是固定的

输出语句

   System.out.println(): 输出完之后有换行

   System.out.print()： 输出完之后不换行

编译之后会生成一个或多个字节码文件，字节码文件的文件名与java文件中类名相同
</code></pre>
<p>JDK = JRE + Java的开发工具（javac.exe.java.exe. javadoc.exe）</p>
<p>JRD = JVM + JAVA 核心类库</p>
<p>配置path环境变量目的是为了在cmd运行框中，任何盘之下都可以进行java语法的调用</p>
<h2 id="命名规范"><a class="markdownIt-Anchor" href="#命名规范"></a> <strong>命名规范</strong></h2>
<p>包名：多单词组成时所有字母都小写：xxxyyyzzz</p>
<p>类名，接口名：多单词组成时所有单词的首字母大写：XxxYyyZzz</p>
<p>变量名，方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写</p>
<p>常量名：所有字母都大写，多单词时每个单词用下划线链接</p>
<h2 id="变量分类"><a class="markdownIt-Anchor" href="#变量分类"></a> <strong>变量分类</strong></h2>
<p>基本数据类型：int char bool short long byte float double</p>
<p>引用数据类型：class（类） interface（接口） array(数组)</p>
<p>byte (-128-127); (一个字节) short（2字节）int(4个字节)long（8个字节）</p>
<p>byte b1 = 128;这样会导致编译不通过</p>
<p>声明long型变量的时候必须以“l”或“L”结尾</p>
<p>long a = 134564L</p>
<p>声明float型变量的时候必须以“f”或“F”结尾</p>
<p>使用小数的时候我们通常使用double类型的变量，因为double空间更大，而且不用再最后写一个f或者更F</p>
<h2 id="基本数据类型之间的运算规则"><a class="markdownIt-Anchor" href="#基本数据类型之间的运算规则"></a> <strong>基本数据类型之间的运算规则：</strong></h2>
<p>前提：不包含boolean</p>
<p>\1.   自动类型提升：</p>
<p>当容量小的数据类型的变量与容量打的数据类型的变量做运算的时候</p>
<p>byte，char，short，int，long，float，doouble</p>
<pre><code>short和char类型相加的话为int
</code></pre>
<p>2.当使用long命名变量的时候如果后面不加L的话就相当于使用int型赋值给long型，当让如果你后面赋值的数字超过int类型的大小的话，那么会报错</p>
<pre><code>Long l1 = 241654654654564;这样就会报错

如果定义float类型的变量的时候后面不加F的话而且后面数字还为小数，那么会报错，因为小数默认为double型，double型赋值给int型明显是错误的
</code></pre>
<h2 id="string类型"><a class="markdownIt-Anchor" href="#string类型"></a> <strong>String</strong>类型</h2>
<p>是一个字符串使用双引号</p>
<p>可以和八种数据类型变量做运算，且运算只能是链接运算 +</p>
<p>运算完结果是String类型的</p>
<p><strong>equals方法</strong>（用来比较两个字符串所包含的内容是否相同）</p>
<pre><code>这种方法s1.equals(s2)  相同为True 不同为false
</code></pre>
<h2 id="进制转换"><a class="markdownIt-Anchor" href="#进制转换"></a> <strong>进制转换</strong></h2>
<p>二级制0b开头</p>
<p>八进制以 0 开头</p>
<p>十六进制以 0x开头</p>
<h2 id="源码-反码-补码"><a class="markdownIt-Anchor" href="#源码-反码-补码"></a> <strong>源码 反码 补码</strong></h2>
<p>正数的三个码都和其本身相同，</p>
<p>负数：</p>
<pre><code>源码：该负数的本身

反码：处符号位，剩下的都取反

补码：反码加一

计算机的底层都已补码的方式来存储数据
</code></pre>
<h2 id="逻辑运算符操作对象都是boolean类型的"><a class="markdownIt-Anchor" href="#逻辑运算符操作对象都是boolean类型的"></a> <strong>逻辑运算符：（操作对象都是boolean类型的）</strong></h2>
<p><strong>逻辑</strong>是从左到右全部判断完之后结束</p>
<p><strong>短路</strong>是能判断结果之后就停止</p>
<p>&amp; 逻辑与   &amp;&amp; 短路与</p>
<p>| 逻辑或    || 短路或</p>
<p>！逻辑非</p>
<p>^ 逻辑异或  // a^b 当a和b相同的时候为flase 当ab不同的时候为True</p>
<p>位运算符 需要为int型</p>
<p>&lt;&lt; 左移运算符（单目运算符：左移一位 相当于整体乘2， 被移除的高位丢弃，空缺位补0）</p>
<p>&gt;&gt; 右移运算符（单目运算符：右移一位 相当于整体除以2（最小为0），右移之后，最高位为1，空缺补1，最高位为0，空缺位补零）</p>
<p>&gt;&gt;&gt;被移位二进制最高位无论是0或者1，空缺位都用0补</p>
<p>&amp; 使用二进制一对一，都为1的时候生成数对应的位置才为1，其余为零</p>
<p>| 使用二进制一对一，都为0的时候生成数对应位置才为0，其余为1</p>
<pre><code>^ 使用二进制一对一，对应位置相同的时候才为0，否则为1

## **三元运算符**

（条件表达式）？表达式1：表达式2； 其中表达式1和表达式2数据类型必须相同

如果条件表达式为真的话，运行表达式1，为假的话运行表达式2
</code></pre>
<h2 id="从键盘获取数据"><a class="markdownIt-Anchor" href="#从键盘获取数据"></a> <strong>从键盘获取数据</strong></h2>
<p>这里涉及到导包操作（import）使用Scanner类</p>
<p>步骤</p>
<ol>
<li>
<p>导包：import java.util.Scanner;</p>
</li>
<li>
<p>Scanner的实例化，Scanner = new Scanner(<a target="_blank" rel="noopener" href="http://System.in">System.in</a>);</p>
</li>
<li>
<p>调用Scanner类的相关方法，来获取指定类型的变量</p>
<p>Scanner scan = new Scanner(<a target="_blank" rel="noopener" href="http://System.in">System.in</a>);</p>
<p>Int num = scan.nextInt()</p>
</li>
<li>
<p>除了获取字符串的方法是scan.next()，剩下的全部都是scan,nextXxx()来获取数据</p>
</li>
</ol>
<p>Scanner类型中没有获取单个字符的方法，如果想要获取单个字符串的话可以先使用scan.next()获取完字符串之后，在使用charAt(0)来获取单个字符</p>
<p>String gender = scan.next();</p>
<p>Char genderChar = gender.charAt(0); charAt()方法的参数是字符串的第几个位置的索引</p>
<p>如果用户输入的数据类型和源文件中要求输入的数据类型不同的话，那就要做比较，如果用户输入的数据类型所占字节数比源文件中要求的数据类型多，则会报错</p>
<h2 id="math类中的方法"><a class="markdownIt-Anchor" href="#math类中的方法"></a> Math类中的方法</h2>
<p>\1.   double data = Math.pow(2,3) ==== 将2的3次方运算完之后的数字赋值给data</p>
<p>\2.   double data = Math.sqrt(5)= Math.pow(5,0.5); 将5开方之后的值赋值给data</p>
<p>\3.   double data = Math.random()*90+10;</p>
<p>random()的范围是[0.0, 1.0）左开右闭，取该范围里面的随机数，返回值是double，所以如果你想要得到整数的话，你可以使用类型强制转换成int类型.</p>
<p>random()*90; 获取的是[0, 90)之间的随机数</p>
<p>random()*90+10;获取的是[10, 100)之间的随机数</p>
<p><strong>try catch</strong> <strong>用法</strong></p>
<p>try{逻辑代码块一}catch{处理代码块一}</p>
<p>如果逻辑代码块一出现问题的时候，则执行catch中处理代码块一，如果没有出现问题的话，则执行完逻辑代码块一之后，跳过catch中的代码块，执行下一条语句</p>
<h2 id="数组的使用"><a class="markdownIt-Anchor" href="#数组的使用"></a> <strong>数组的使用</strong></h2>
<ol>
<li>
<p>一维数组的声明和初始化</p>
<ul>
<li>
<p>静态初始化</p>
<ul>
<li>Int[] ids = new int[]{1001,1002,1003}</li>
</ul>
</li>
<li>
<p>动态初始化</p>
<p>String[] names = new String[4];</p>
<p>数组一旦初始化完成其长度就已经确定了</p>
</li>
</ul>
</li>
<li>
<p>数组元素默认初始化值</p>
</li>
<li>
<p>整形的统统为0</p>
</li>
<li>
<p>浮点型的统统为0.0</p>
</li>
<li>
<p>Char类型的统统为Ascii码中的0 （NULL）</p>
</li>
<li>
<p>Boolean类型的统统为false</p>
</li>
<li>
<p>二维数组</p>
<ol>
<li>
<p>Int[][] arr = new int[5][4]</p>
<p>二维数组在动态初始化的时候列数必须填，行数不一定要填写</p>
</li>
<li>
<p>二维数组求长度的时候 用上面的例子 arr.length = 5; 只要是数组就有length方法，arr[0].length = 4;</p>
</li>
<li>
<p>二维数组初始值对于 int[ ] [ ] arr = new int[3] [4]  这样都分配好空间的数组来说 arr[1]代表是地址.arr[1] [2]的初始值和一维数组类型初始值一样，对于 int[ ] [ ] arr = new int[3] []  只给出列，没有给出行的数组来说，arr[1]代表的是null， 内层元素不能调用否则报错</p>
</li>
</ol>
</li>
<li>
<p>数组的方法（引用java.util.Arrays）</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">boolean equals(int[] a, int[] b)</th>
<th style="text-align:center">判断两个数组是否相同</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">String toString(int[] )</td>
<td style="text-align:center">输出数组信息</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">void fill(int[] a, int val)</td>
<td style="text-align:center">将指定值填充到数组之中</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">void sort(int[] a)</td>
<td style="text-align:center">对数组进行排序</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">int binarySearch(int[] a, int key )</td>
<td style="text-align:center">对排序后的数组进行二分查找指定的值key</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>数组异常</p>
<ol>
<li>数组角标越界异常：ArrayIndexOutOfBoundsException</li>
<li>空指针异常：NullPointerException  声明了但是没有复制 int[] a； System.out.print(a[0]) 这样就会报错</li>
</ol>
</li>
</ol>
<h1 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h1>
<p>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做，</p>
<p>面向对象：将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做</p>
<h2 id="java类及类的成员属性方法构造器代码块内部类"><a class="markdownIt-Anchor" href="#java类及类的成员属性方法构造器代码块内部类"></a> Java类及类的成员（属性，方法，构造器；代码块，内部类）</h2>
<p>两个要素：</p>
<pre><code>类：是对一类事物的描述，是抽象的，概念上的定义

对象:是实际存在的该类事物的每个个体，因而也称为实例。
</code></pre>
<p>面向对象的重点就是类的设计，设计类就是设计类的成员，</p>
<pre><code>类：含有 **属性**和**方法**

	属性 = 成员变量 = field = 域，字段

	方法 = 成员方法 = 函数 = method
</code></pre>
<p>创建类的对象 = 类的实例化 = 实例化类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">boolean</span> isMale;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takc</span><span class="params">(String language)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人可以说话，使用的是&quot;</span>+language);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 这里就是创建Person类的对象</span></span><br><span class="line">        <span class="comment">// 调用对象的结构:属性， 方法</span></span><br><span class="line">        <span class="comment">// 调用对象的属性</span></span><br><span class="line">        p1.name = <span class="string">&quot;TOM&quot;</span>;</span><br><span class="line">        p1.isMale = True;</span><br><span class="line">        System.out.println(p1.age);</span><br><span class="line">        <span class="comment">// 调用对象的方法</span></span><br><span class="line">        p1.eat();</span><br><span class="line">        p1.sleep();</span><br><span class="line">        p1.talk(<span class="string">&quot;Chinese&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>类和对象的使用（面向对象思想落地）</p>
<ol>
<li>创建类，设计类的成员</li>
<li>创建类的对象</li>
<li>通过“对象.属性” 或“对象.方法”调用对象的结构</li>
</ol>
</li>
<li>
<p>属性(成员变量) VS 局部变量</p>
<ol>
<li>
<p>相同点：</p>
<ol>
<li>定义变量的格式 ：数据类型 变量名 = 变量值</li>
<li>先声明，后使用</li>
<li>变量都有其对应的作用域</li>
</ol>
</li>
<li>
<p>不同点</p>
<ol>
<li>
<p>在类中声明的位置不同</p>
<p>属性：直接定义在类的一对{}内</p>
<p>局部变量：声明在方法内，方法形参，代码块之内，构造器形参，构造器内部的变量</p>
</li>
<li>
<p>权限修饰符的不同</p>
<p>属性：可以在声明属性的时候，指明其权限，使用权限修饰符</p>
<pre><code>   常用的权限修饰符有：private,public，缺省（不加声明就是默认缺省），protected --&gt;封装性
</code></pre>
<p>局部变量：不可以使用权限修饰符</p>
</li>
<li>
<p>默认初始化值的情况</p>
<p>属性：类的属性，根据其类型，都有默认初始化值</p>
<pre><code>   	整形（byte, short, int , long）； 0
   																																																																																																																																																											
   	浮点型（float,double）； 0.0
   																																																																																																																																																											
   	字符型（char）; 0(或‘\u000’)
   																																																																																																																																																											
   	布尔型（boolean）; false;
</code></pre>
<p>局部变量：没有初始化值</p>
<pre><code>   	意味着：我们再调用局部变量之前，一定要先是赋值
   																																																																																																																																																											
   	特别地：在形参调用时，我们赋值即可
</code></pre>
</li>
<li>
<p>在加载位置不同</p>
<p>属性：加载到堆空间中（非static）</p>
<p>局部变量：加载到栈空间中</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String name; <span class="comment">//  成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">talk</span><span class="params">(String language)</span> <span class="comment">// 这里language就是局部变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        String age; <span class="comment">// 这里age也是局部变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是中国人，我说&quot;</span>+language);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法的使用（method）</p>
<ol>
<li>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">food</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">Getname</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">GetNation</span><span class="params">(String nation)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法的声明</p>
<p>权限修饰符	返回值类型	方法名（形参列表）{</p>
<pre><code>   	方法体；
</code></pre>
<p>}</p>
</li>
<li>
<p>说明：</p>
<ol>
<li>
<p>关于权限修饰符，默认方法的权限是先使用public</p>
<p>Java规定的4种权限修饰符：private, public, 缺省, protected — &gt;封装性</p>
</li>
<li>
<p>返回值类型：   有返回值 VS 没有返回值</p>
<p>如果方法有返回值，则必须在方法声明时，指定返回的类型，同时，方法中（必须）需要使用return关键字来返回指定类型的常量或变量</p>
<p>如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不使用return，但是如果使用的话只能用”return；“表示结束此方法的意思</p>
</li>
<li>
<p>方法名：需要符合方法名的规则和规范</p>
</li>
<li>
<p>形参列表：可以有一个，两个，或多个</p>
<pre><code>数据类型1 形参1 ；  数据类型2  形参2；
</code></pre>
</li>
</ol>
</li>
<li>
<p>return 关键字的使用：</p>
<ol>
<li>适用范围：使用在方法体中</li>
<li>作用：
<ol>
<li>结束方法</li>
<li>针对有返回值类型的方法，使用return返回数据</li>
</ol>
</li>
<li>return 关键字后面不可以使用语句</li>
</ol>
</li>
<li>
<p>方法的使用中，可以调用当前类的属性或方法</p>
</li>
<li>
<p>编译完源程序之后，生成一个或多个字节码文件</p>
<p>编译器使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行，意味着，需要将字节对应的类加载到内存中，涉及到内存解析</p>
<p><strong>所以说，编译的时候不会讲字节加载到内存中，只有在运行的时候才会设计到内存</strong></p>
</li>
<li>
<p>理解“万事万物皆对象”</p>
<ol>
<li>在Java语言范畴中，我们都将功能，结构等封装到类中，通过类的实例化，来调用功能结构
<ol>
<li>Scanner，String等</li>
<li>文件 File</li>
<li>网络资源</li>
</ol>
</li>
<li>涉及到Java语言与前端Html，后端数据库交互时，前后端的结构在Java层面都体现为类，对象</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>内存解析的说明：</p>
<ol>
<li>引用类型的变量，只可能存储两类值，null，或地址值（含变量的类型）</li>
</ol>
</li>
<li>
<p>匿名对象的使用</p>
<ol>
<li>理解：我们创建对象，没有显示的赋给一个变量名，即为匿名对象</li>
<li>特征：匿名对象只能调用一次</li>
<li>使用：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>().name;     <span class="comment">// 这里就是匿名对象， 调用完之后就无法再调用这个对象了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法：</p>
<ul>
<li>
<p>方法的重载(overload)</p>
<ul>
<li>
<p>定义：在同一个类中，允许存在一个以上的同名的方法，只要他们的参数个数或者参数类型不同即可。</p>
<p>两同一不同：相同类，相同方法名，参数列表不同/参数个数不同/参数类型不同</p>
</li>
<li>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p1.say(<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">        p1.say(<span class="string">&quot;zhanng&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的名字是：&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String name, <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我的名字是：&quot;</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，当你传入的参数不同的时候，调用的say方法也不同</p>
</li>
</ul>
</li>
<li>
<p>可变个数的形参</p>
<ul>
<li>
<p>定义：可变形参格式：数据类型 … 变量名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p1.say(<span class="string">&quot;Mr&quot;</span>,<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *运行结果为 </span></span><br><span class="line"><span class="comment">    *	[Ljava.lang.String;@4eec7777</span></span><br><span class="line"><span class="comment">    *   zhang    </span></span><br><span class="line"><span class="comment">    *当使用可变个数形参的时候，传入多个参数的的时候形参就会变成对应的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String ... strs)</span>&#123;</span><br><span class="line">        System.out.println(strs);</span><br><span class="line">        System.out.println(strs[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>具体使用</p>
<ul>
<li>可变个数形参的格式：数据类型 … 变量名</li>
<li>当调用可变个数形参方法时，传入的参数个数可以是 0个， 1个， 2个…</li>
<li>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li>
<li>可变个数的形参变量必须声明在方法的最后一个</li>
<li>可变个数的形参在同一个方法中最多声明一个</li>
</ul>
</li>
</ul>
</li>
<li>
<p>关于变量的赋值：</p>
<ul>
<li>如果变量是基本数据类型，此时赋值的时变量所保存的数据值</li>
<li>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值</li>
</ul>
</li>
<li>
<p>关于程序的退出：</p>
<ul>
<li>使用System.exit(0); 会直接结束程序</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="方法的重写"><a class="markdownIt-Anchor" href="#方法的重写"></a> 方法的重写</h3>
<ol>
<li>
<p>定义：子类可以根据需要对父类中继承来的方法进行改造，也称为方法的重置或者覆盖，在执行程序的时候，子类的方法将覆盖父类的方法。</p>
</li>
<li>
<p>要求：</p>
<ul>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称，参数列表</li>
<li>子列重写的方法的返回值类型不能大于父类被重写的方法的返回值类型
<ul>
<li>父类中返回值类型时void的时候，则子类重写方法的返回值类型只能是void</li>
<li>父类被重写的方法的返回值类型时A类型，则子类重写的方法的返回值类型可以是A类或者A的子类</li>
<li>父类中被重写的方法的返回值类型是基本数据类型，则子类重写方法的返回值类型必须是相同的基本数据类型</li>
</ul>
</li>
<li>子类重写的方法使用权限不能小于父类中被重写的方法的访问权限
<ul>
<li>子列不能重写父类中声明为private权限的方法</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 方法的声明：权限修饰符 返回值类型 方法名(形参列表) throws 异常类型()</span><br></pre></td></tr></table></figure>
<ul>
<li>子类方法抛出的异常，不能大于父类中被重写方法的异常</li>
<li>protected 权限修饰符 在子类中可以用，但是在不同包下不可以用，如果想要在不同包下调用protected权限的变量，我们可以使用extends来继承相应的类</li>
</ul>
</li>
<li>
<p>注意：</p>
<ol>
<li>子类与父类中同名同参数的方法必须同时声明为static（即为重写），或者，同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法</li>
</ol>
</li>
<li>
<p>应用：重写之后，当创建子类对象以后，通过子类对象调用父类中同名的方法时，实际执行的时子类重写父类的方法</p>
<h4 id="重载和重写的区别"><a class="markdownIt-Anchor" href="#重载和重写的区别"></a> 重载和重写的区别</h4>
<ol>
<li>
<p>概念：</p>
<p>重载：在同一个类中可以声明多个方法名相同形参列表不同的方法</p>
<p>重写：子类继承父类之后，可以对父类中同名同参数的方法进行覆盖操作</p>
</li>
<li>
<p>编译和运行</p>
<p>对于重载而言，在方法调用的之前，编译器已经确定了索要调用的方法，这称为“早绑定”，或“静态绑定”</p>
<p>对于多态，只有等到方法调用的时候，编译器才会确定索要调用的具体方法，这成为“完绑定”或“动态绑定”</p>
</li>
</ol>
</li>
</ol>
<h3 id="子类对象实例化的过程"><a class="markdownIt-Anchor" href="#子类对象实例化的过程"></a> 子类对象实例化的过程</h3>
<ol>
<li>
<p>从结果上看：</p>
<p>子类继承父类之后，就获取了父类中声明的属性或方法</p>
<p>创建子类对象，在对空间中，就会加载所有父类中声明的属性</p>
</li>
<li>
<p>从过程上来看，当我们通过子类的构造器创建子类对象上来看，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了。java.lang.Object类中空参构造器为止，正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用</p>
</li>
<li>
<p>明确，虽然创建子类对象时，调用了父类的构造器，但自始至终就创建过一个对象，即为new的子类对象</p>
</li>
</ol>
<h3 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h3>
<ol>
<li>
<p>代码块的作用，用来初始化类和对象</p>
</li>
<li>
<p>代码块如果有修饰的话，只能使用static</p>
</li>
<li>
<p>分类：静态代码块  VS非静态代码块</p>
</li>
<li>
<p>静态代码块：</p>
<ol>
<li>内部可以有输出语句</li>
<li>随着类的加载而运行，而且只执行一次</li>
<li>作用初始化类的信息</li>
<li>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li>
<li>静态代码块的执行要优先于非静态代码块</li>
<li>静态代码块内只能调用静态的属性，静态的方法，不能调用非静态的结构</li>
</ol>
</li>
<li>
<p>非静态代码块：</p>
<ol>
<li>内部可以有输出语句</li>
<li>随着对象的创建而运行，创建几个对象执行几次</li>
<li>作用初始化类的信息</li>
<li>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</li>
<li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li>
</ol>
</li>
<li>
<p>使用方法：</p>
<ol>
<li>
<p>我们想要给一个属性的赋值的之前需要做一下其他的工作，这时候不能够进行如下方法赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="comment">// 这样的赋值是错误的</span></span><br><span class="line">    <span class="comment">// a = 0</span></span><br><span class="line">    <span class="comment">// 我们想要在这个赋值之前需要做一下别的工作，这时候我们需要代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">// 作别的工作</span></span><br><span class="line">        ...;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>执行的先后顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由父即子 静态线性：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Root静态初始化模块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Root普通初始化模块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Root</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Root无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mid</span> <span class="keyword">extends</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid静态初始化模块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid普通初始化模块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Left</span> <span class="keyword">extends</span> <span class="title class_">Mid</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Left静态初始化模块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Left普通初始化模块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Left</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Left无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Left</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Left</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后结果为：</p>
<p>Root静态初始化模块<br />
Mid静态初始化模块<br />
Left静态初始化模块<br />
Root普通初始化模块<br />
Root无参构造器<br />
Mid普通初始化模块<br />
Mid无参构造器<br />
Left普通初始化模块<br />
Left无参构造器</p>
<p>如果我们在一个子类的对象中调用static模块的话</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由父即子 静态线性：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Root静态初始化模块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Root普通初始化模块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Root</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Root无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mid</span> <span class="keyword">extends</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid静态初始化模块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid普通初始化模块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Left</span> <span class="keyword">extends</span> <span class="title class_">Mid</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Left静态初始化模块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Left普通初始化模块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Left</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Left无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是初始化函数的部分&quot;</span>);</span><br><span class="line">        <span class="type">Left</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Left</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后结果为：</p>
<p>Root静态初始化模块<br />
Mid静态初始化模块<br />
Left静态初始化模块<br />
这是初始化函数的部分<br />
Root普通初始化模块<br />
Root无参构造器<br />
Mid普通初始化模块<br />
Mid无参构造器<br />
Left普通初始化模块<br />
Left无参构造器</p>
</li>
</ol>
<h3 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类：</h3>
<p>使用方法：inner class一般在定义的他的 类或语句块之间，在外部引用他的时候必须给出完整名称。inner class类名不能和外部类相同</p>
<ol>
<li>
<p>在JAVA中我们允许，一个类定义于另一个类的内部，前者成为<mark class="hl-label orange">内部类</mark> ，后者称为<mark class="hl-label blue">外部类</mark> 。</p>
</li>
<li>
<p>分类：</p>
<ol>
<li>成员内部类（static成员内部类，和非static成员内部类）</li>
<li>局部内部类（不谈修饰符），匿名内部类</li>
</ol>
</li>
<li>
<p>成员内部类</p>
<ol>
<li>一方面，可以作为外部类的成员：
<ol>
<li>调用外部类的结构</li>
<li>可以被static修饰</li>
<li>可以被四种不同的权限修饰符</li>
</ol>
</li>
<li>另一方面作为一个类
<ol>
<li>类可以定义属性，方法，构造器等</li>
<li>可以被final修饰，表示此类不能够别继承。言外之意，不适用final，就可以被继承</li>
<li>可以使用abstract修饰</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员内部类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;卡拉是一条狗&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非静态成员内部类</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bird</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是一只小小鸟&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">BB</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">CC</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>
<p>关注问题</p>
<ol>
<li>
<p>如何实现内部类的对象</p>
</li>
<li>
<p>如何在成员内部类中区分调用外部类的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    System.out.println(name); <span class="comment">// 方法的形参</span></span><br><span class="line">    System.out.println(<span class="built_in">this</span>.name); <span class="comment">// 内部类的属性</span></span><br><span class="line">    System.out.println(Person.<span class="built_in">this</span>.name); <span class="comment">// 外部类的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开发中局部内部类的使用</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建Dog实例（静态成员内部类）</span></span><br><span class="line">        Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line">        dog.show();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Bird实例（非静态的成员内部类）：</span></span><br><span class="line">        <span class="comment">// Person.Bird bird = new Person.Bird(); //这样是错误的，因为Bird内部类不是static不能通过Person直接调用，需要实例化Person的对象，然后通过实例化的Person的对象来调用这个内部类</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        </span><br><span class="line">        Person.<span class="type">Brid</span> <span class="variable">bird</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Bird</span>;</span><br><span class="line">        bird.sing(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>总结：</p>
<p>成员内部类和局部内部类，在编译之后都会出现字节码文件</p>
<p>格式：</p>
<p>成员内部类：外部类$内部类名.class</p>
<p>局部内部类：外部类$数字  内部类名.class</p>
</li>
<li>
<p>注意：</p>
<ol>
<li>在局部内部类的方法中（比如说show）如果调用局部内部类所声明的方法（比如method）中的局部变量（比如说num）要求此局部变量声明为final</li>
<li>jdk7 及以前的版本，要求此局部变量声明为final的</li>
<li>jdk8 及以后的版本，可以省略final的声明</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">// 这样是错误的</span></span><br><span class="line">                <span class="comment">// num = 20</span></span><br><span class="line">                <span class="comment">// 这样是正确的</span></span><br><span class="line">                System.out.println(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<h3 id="object类的使用"><a class="markdownIt-Anchor" href="#object类的使用"></a> Object类的使用</h3>
<ol>
<li>
<p>object类是所有Java类的根父类</p>
</li>
<li>
<p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</p>
</li>
<li>
<p>Object类中的功能(属性，方法)就具有通用性</p>
<ul>
<li>属性：无</li>
<li>方法：euqals() / toString() / getClass() / hashCode() /  clone() / finalize() / wait() / notify() / notifyAll()</li>
</ul>
</li>
<li>
<p>equals() 方法的使用：</p>
<ul>
<li>
<p>回顾： == 运算符：</p>
<ol>
<li>
<p>可以使用在基本数据类型变量和引用数据类型变量中</p>
</li>
<li>
<p>如果可以比较的是基本数据类型变量，比较两个变量保存是数据是否相等。（不一定要类型相同）</p>
<p>如果比较的是引用数据类型变量，则比较的是两个数据地址值是否相等，即两个引用是否指向一个对象实体</p>
</li>
</ol>
</li>
<li>
<p>equals()方法的使用：</p>
<ol>
<li>
<p>是一个方法，而并非一个运算符</p>
</li>
<li>
<p>只能适用于引用数据类型</p>
</li>
<li>
<p>Object类中euqals()的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">euqals</span><span class="params">(Object obj)</span>:&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就说明Object类中定义的equals()方法和 == 是相同的。比较两个对象的地址值是否相等，即两个引用是否指向同一个数据对象</p>
</li>
<li>
<p>像String，Data,File,包装类都重写的Object中的euqals的方法，重写后，比较的不是两个引用的地址值是否相同，而是比较两个对象的实体内容是否相同</p>
</li>
<li>
<p>通常情况下，我们自定义类如果使用equals()的话，也通常是比较两个对象的实体内容是否相同，那么，我们就需要对Object类中euqals()进行重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Customer 类中有两个属性，1.name, 2.age</span></span><br><span class="line"><span class="comment">// 重写Customer中的equals()方法</span></span><br><span class="line"><span class="comment">// 比较两个对象的属性是否相同</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Customer)&#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">cus</span> <span class="operator">=</span> (Customer)obj;</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">this</span>.age == obj.age) &amp;&amp; (<span class="built_in">this</span>.name.equals(cust.name)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Object类中toString()的使用</p>
<ol>
<li>当我们输出一个对象的引用的时候，默认调用的是他的的toString()方法</li>
<li>Object中toString()方法</li>
<li>hashCode()计算该类在堆空间的值， 使用Integer类的toHexString转换成16进制</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>像String，Data，File，包装类等都重写了Object类中toSting()方法，使得在调用对象的toString()时，返回“实体内容”信息</li>
<li>自定义类也可以重写toString()方法，当调用此方法的时候，返回对象的“实体内容”</li>
</ol>
</li>
<li>
<p>Java中的Junit单元测试：</p>
<p>步骤：</p>
<ol>
<li>
<p>选中当前工程 - 右键选择，build path - add libraries - JUit 4 - 下一步</p>
</li>
<li>
<p>创建Java类，进行单元测试</p>
<p>此时Java类要求，①此类时public的，②此类提供公共的无参构造器</p>
</li>
<li>
<p>此类中声明单元测试方法</p>
<p>此时的单元测试方法，防范权限是public，没有返回值，没有形参</p>
</li>
<li>
<p>此时单元测试方法以后，就可以在方法体内测试相关的代码</p>
</li>
<li>
<p>此单元测试方法上需要声明注解@Test，在单元测试类中导入，import org.junit.Test</p>
</li>
<li>
<p>写完代码以后，就可以对单元格进行测试了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ObjectTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeometricTest</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2.3</span>);</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2.3</span>,<span class="string">&quot;white&quot;</span>,<span class="number">2.0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;颜色是否相等：&quot;</span>+circle1.getColor().equals(circle2.getColor()));</span><br><span class="line">        System.out.println(circle1.equals(circle2));</span><br><span class="line">        System.out.println(circle1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testEuqals</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2.3</span>);</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2.3</span>, <span class="string">&quot;white&quot;</span>, <span class="number">2.0</span>);</span><br><span class="line">        System.out.println(circle1.equals(circle2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>包装类的使用：</p>
<p>针对八种基本类型定义相应的引用类型 — 包装类(封装类)</p>
<p>有了类的特点，就可以调用类中的方法，Java才是真正的面向对象</p>
<p>Java提供了8中基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征</p>
<p>前六个是数值型的，由共同的父类Number</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td>Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td>Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td>Integer</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td>Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td>Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td>Double</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td>Character</td>
</tr>
</tbody>
</table>
<p><strong>包装类中核心部分</strong></p>
<ul>
<li>
<p>基本数据类型，包装类，与String类之间的转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrapperTest</span> &#123;</span><br><span class="line">    <span class="comment">// 基本数据类型的转换  -----&gt;  包装类，调用包装类的对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 下面这种方法就会报错，因为基本数据类型没有方法可言</span></span><br><span class="line">        <span class="comment">// System.out.println(num1.toString())</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换成引用数据类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(num1);</span><br><span class="line">        System.out.println(<span class="string">&quot;in1.toString&quot;</span>); <span class="comment">//  ----&gt; 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Integer in2 = new Integer(&quot;123abc&quot;) 这样就会报错</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">12.3f</span>);</span><br><span class="line">        <span class="type">Float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="string">&quot;12.3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> b1;</span><br><span class="line">        Boolean b2;</span><br><span class="line">        System.out.println(b1);  <span class="comment">// false  b1是基础类型</span></span><br><span class="line">        System.out.println(b2); <span class="comment">// null   b2是一个类</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 包装类  -----&gt; 基本数据类型 ，调用包装类的xxxValue()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">13</span>);</span><br><span class="line">        <span class="comment">// 调用包装类.xxxValue就可以将包装类转换成对应的数据类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> in1.intValue();</span><br><span class="line">        System.out.println(i1+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新特性：不强制要求上述转换方法了，有自动转换的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 5.0 新特性，自动装箱与拆箱：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 理论上说，method的参数是对象，但是你直接填入基本数据类型也不会报错</span></span><br><span class="line">    <span class="comment">// 基本数据类型 ----- &gt; 包装类的对象</span></span><br><span class="line">    method(num1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动装箱：  基本数据类型 --- &gt; 包装类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> num2; </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">b2</span> <span class="operator">=</span> b1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动拆箱： 包装类 --- &gt; 基本数据类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> in1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本数据类型，包装类 ----&gt; String类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型，包装类 ---- &gt; String类型， 调用String重载的valueOf(Xxx xxx)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 方式一：连接运算</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> num1+<span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式二：调用String的valueOf(Xxx xxx)方法</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">12.3f</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(f1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String类型 ---- &gt; 基本数据类型，包装类，调用parsexxx，可以将对应的String转换为对应的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用包装类的parsexxx()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseint(str1);</span><br><span class="line">    System.out.println(num1); <span class="comment">// ===》 123</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> Boolean.parseBoolean(str2);</span><br><span class="line">    System.out.println(b1); <span class="comment">// ====&gt; true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>clone() ：创建并复制该对象， p2 = p1.clone()</li>
<li>equals(), 比较两个对象是否相等</li>
<li>finalize(), 垃圾回收，当该对象没有变量指向它的时候，就会自动调用这个方法</li>
</ul>
</li>
<li>
<p>注意：</p>
<ol>
<li>
<p>自动类型提升：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="literal">true</span> ? Integer(<span class="number">1</span>) : Double(<span class="number">2.0</span>);</span><br><span class="line"><span class="comment">// 这里面就存在着自动类型提升的一部分，因为是要给o1赋值的，所以编译器需要事先确定好赋值的类型，一个是Integer 一个是Double 所以需要自动类型提升</span></span><br><span class="line">System.out.println(o1); <span class="comment">// =======》 1.0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Integer内部的IntegerCache结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);   <span class="comment">// ====== false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[]，保存了-128~127范围内整数，如果我们使用自动装箱的方式，给Integer赋值的范围在-182~127内时，可以直接使用数组中的元素，不用再去new了</span></span><br><span class="line">    <span class="comment">// 提高效率</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n); <span class="comment">// ====== true</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;  <span class="comment">// 相当于new了一个Integer对象</span></span><br><span class="line">    System.out.println(x == y); <span class="comment">// ==== false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="vector可扩展数组"><a class="markdownIt-Anchor" href="#vector可扩展数组"></a> Vector可扩展数组</h3>
<p>Vector在使用的时候可以给定数组长度，达到预期长度，减少扩展次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line">v.addElement(Object obj);</span><br><span class="line">v.elementAt(Object obj);</span><br></pre></td></tr></table></figure>
<h2 id="面向对象的三大特称封装性继承性多态性抽象性"><a class="markdownIt-Anchor" href="#面向对象的三大特称封装性继承性多态性抽象性"></a> 面向对象的三大特称（封装性，继承性，多态性（抽象性））</h2>
<h3 id="面向对象的特征一封装和隐藏"><a class="markdownIt-Anchor" href="#面向对象的特征一封装和隐藏"></a> 面向对象的特征一：封装和隐藏</h3>
<p>高内聚 低耦合</p>
<p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</p>
<p>低耦合：仅对外暴露少量的方法用于自己使用</p>
<p>隐藏对象内部的复杂性，之对外公开简单的接口。便于外界调用，从而提高系统的可扩展性，可维护性。通俗的说，把该隐藏的隐藏，该暴露的暴露出来，这就是封装性的设计思想</p>
<ol>
<li>
<p>问题的引入：</p>
<ul>
<li>当我们创建一个类的对象之后，我们可以通过“对象.属性”的方式。对对象属性进行赋值，这里赋值操作要受到属性的数据类型和存储范围的制约，但是除此之外，没有其他制约条件。但是在实际问题中，我们往往需要给属性赋值加入额外的限制条件，这个条件就不能再属性声明时体现，我们只能通过方法来进行限制条件的添加，同时我们需要避免用户在使用“对象.属性”的方式，对属性进行赋值，则需要将属性，声明为私有的<strong>private</strong>   —&gt; 此时，针对属性就体现了封装</li>
</ul>
</li>
<li>
<p>封装性的<strong>体现</strong>：</p>
<ul>
<li>我们将类的属性xxx私有化（private）,同时提供公共的（public）方法来获取(getXxx)和设置(setXxx)，该变量的值</li>
<li>拓展：封装性的体现①如上②不对外暴露私有的方法③单例模式……</li>
</ul>
</li>
<li>
<p>封装性的体现，需要权限修饰符来配合</p>
<ol>
<li>
<p>java规定的4种权限修饰符（从小到大）private, 缺省, protected, publi</p>
</li>
<li>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">类内部</th>
<th style="text-align:center">同一个包</th>
<th style="text-align:center">不同包的子类</th>
<th style="text-align:center">同一个工程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">（缺省）</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>四种权限可以用来修饰类及类的内部结构：属性，方法，构造器，内部类</p>
</li>
<li>
<p>具体的，四种权限都可以用来修饰类的内部结构，属性，方法，构造器，内部类</p>
<p>修饰类的话只能使用：缺省，public</p>
</li>
<li>
<p>总结：Java提供了4中权限修饰符来修饰类的内部结构，体现类及类的内部结构在被调用时的可见性大小</p>
</li>
</ol>
</li>
<li>
<p>类的结构三：构造器（或构造方法，constructor）的使用</p>
<p>construct：建设，建造。construction</p>
<ul>
<li>构造器的作用：创建对象，初始化对象信息</li>
<li>说明
<ul>
<li>如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器</li>
<li>定义构造器的格式：权限修饰符 类名（形参列表）{}</li>
<li>一个类中定义的多个构造器，彼此构成重载</li>
<li>一旦我们显示的定义类的构造器后，系统不再提供默认的空参构造器</li>
<li>一个类中至少有一个构造器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>总结：属性赋值的先后顺序</p>
<ol>
<li>默认初始化</li>
<li>显式初始化</li>
<li>构造器中赋值</li>
<li>通过“对象.方法” 或“对象.属性”赋值
<ul>
<li>以上操作先后顺序 1,2,3,4</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="继承性"><a class="markdownIt-Anchor" href="#继承性"></a> 继承性</h3>
<ol>
<li>继承性的好处
<ul>
<li>减少了代码的冗余。提高了代码的复用性</li>
<li>便于功能的扩展</li>
<li>为了以后多态性的使用，提供了前提</li>
</ul>
</li>
<li>继承性的格式：class A extends B{}
<ul>
<li>A：子类，派生类，subclass</li>
<li>B：父类，超类，基类，superclass
<ul>
<li>体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。特别的，父类中声明为private的属性和方法，子类继承父类之后，仍然认为获取了父类中私有的结构。只是应为封装性的影响，使得子类不能调用父类中的结构而已</li>
<li>子类继承父类之后，还可以声明自己特有的属性和方法，实现功能的扩展
<ul>
<li>子类和父类的关系不同于，子集和集合的关系</li>
<li>extends 扩展，延展</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Java中关于继承性的规定</li>
<li>一个类中可以背多个子类继承</li>
<li>Java中类的单继承性，一个类只能有一个父类</li>
<li>子父类是相对的概念</li>
<li>子类解释继承的父类，称为直接父类，间接继承的父类称为间接父类</li>
<li>子类继承父类之后，就获取了直接父类以及所有间接父类中声明的属性和方法</li>
<li>如果我们没有显式的声明一个类的父类的话，则此继承于java.lang.Object类</li>
<li>所有的Java类除（java.lang.Object类之外）都直接或间接的继承于java.lang.Object类</li>
<li>意味着，所有的java类具有java.lang.Object类中所有声明的功能</li>
</ol>
<h3 id="多态性"><a class="markdownIt-Anchor" href="#多态性"></a> 多态性</h3>
<ol>
<li>
<p>理解多态性：</p>
<p>如果想要调用子类种的方法的话，你需要在父类中也有这个方法，在子类重写之后你调用的这个方法在父类种也可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 如果Man 和 Woman 是Person的子类</span><br><span class="line">Person p = new Man()   // 这就是多态性</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>何为多态性</p>
<p>对象的多态性，父类的引用指向子类的对象（或子类的对象赋给父类引用）</p>
</li>
<li>
<p>多态性的使用：虚拟方法调用</p>
<p>有了对象的多态性以后，我们在编译期只能调用父类中声明的方法，但在运行期，我们执行的是子类重写父类的方法</p>
<p>总结：编译，看左边，运行，看右边</p>
</li>
<li>
<p>多态性使用前提</p>
<ol>
<li>类的继承关系</li>
<li>方法的重写</li>
</ol>
</li>
<li>
<p>对象的多态性，只适用于方法，不适用与属性</p>
</li>
<li>
<p>虚拟方法的调用</p>
<ol>
<li>
<p>正常方法调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">e.getinfo();</span><br><span class="line"><span class="type">Student</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">e.getinfo();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>虚拟方法调用（多态情况下）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类中定义了与父类同名同参数的方法，在多态情况下，此时父类方法称为虚拟方法，父类根据赋给它不同子类的对象，动态调用属于子类的该方法。这样方法的调用在编译期是无法确定的,是运行时行为</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">e.getinfo(); <span class="comment">// 调用Student类的getinfo()方法</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>多态性使用的时候不能调用子类特有的方法和属性</p>
<p>有了对象的多态性之后内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法，子类特有的属性和方法不能够调用</p>
</li>
<li>
<p>如何才能调用子类特有的属性和方法？</p>
<p>向下转型，使用强制类型转换符</p>
<p>Man m1 = (Man)p2;</p>
<p>但是在使用强制类型转换的时候，可能会出现ClassCastException的异常，这时候我们可以使用instanceof关键字来规避这个错误</p>
</li>
</ol>
<h2 id="其他关键字thissuper-static-finalabstractinterface"><a class="markdownIt-Anchor" href="#其他关键字thissuper-static-finalabstractinterface"></a> 其他关键字this，super， static ,final,abstract,interface</h2>
<h3 id="this关键字的使用"><a class="markdownIt-Anchor" href="#this关键字的使用"></a> this关键字的使用：</h3>
<ol>
<li>
<p>this可以用来修饰：属性，方法，构造器</p>
</li>
<li>
<p>this修饰属性和方法：</p>
<p>this理解为当前对象</p>
<p>在类方法中，我们可以使用“this.属性”或者“this.方法”的方式，调用当前对象属性或方法。但是通常情况下，我们选择省略&quot;this.&quot;，特殊情况下，如果方法的形参和类的属性同名这时候我们就需要使用this关键字，表明此变量是属性，而非形参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">text</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 前面使用this来表示前面的age是属性，后面的age是形参</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>this调用构造器</p>
<ol>
<li>我们在类的构造器中，可以显式的使用“this(形参列表)”方式，调用本类中其他的构造器</li>
<li>构造器中不能通过&quot;this(形参列表)&quot;方式调用自己</li>
<li>如果一个类中有n个构造器，则最多有n-1个构造器啊使用“this(形参列表)”</li>
<li>规定：“this（形参列表）“必须声明在当前构造器的首行</li>
<li>构造器内部，最多只能声明一个”this(形参列表)“,用来调用其他的构造器</li>
</ol>
</li>
</ol>
<h3 id="package关键字的使用"><a class="markdownIt-Anchor" href="#package关键字的使用"></a> package关键字的使用</h3>
<ol>
<li>
<p>为了更好的实现项目中类的管理，提供包的概念</p>
</li>
<li>
<p>使用package声明类或接口所属的包，声明在源文件首行</p>
</li>
<li>
<p>包，属于标识符，遵循标识符的命名规则。规范（xxxyyyzzz），“见名知意”</p>
</li>
<li>
<p>每“.”一次，就代表一层文件目录</p>
</li>
<li>
<p>补充，</p>
<ol>
<li>同一个包下，不能命名同名的接口，类；</li>
<li>不同包下，可以命名同命的接口，类</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>java.lang</th>
<th>包含一些java语言常用的核心类，如String，Math，Integer，System和Thread，提供常用功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="http://java.net">java.net</a></td>
<td>包含执行与网络相关的操作的类和接口</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://java.io">java.io</a></td>
<td>提供多种输入输出功能的类</td>
</tr>
<tr>
<td>Java.util</td>
<td>包含一些实用的工具类，如 定义系统特征，接口集合框架类，使用与日期日历相关的函数</td>
</tr>
<tr>
<td>java.text</td>
<td>包含了一些java格式化相关的类</td>
</tr>
<tr>
<td>java.sql</td>
<td>包含了java进行jdbc数据库编程的相关类/接口</td>
</tr>
<tr>
<td>java.awt</td>
<td>包含了构成了抽象窗口工具集（abstract window toolkits）的多个类，这些类用来构建和管理应用程序的图像化界面（GUI）</td>
</tr>
</tbody>
</table>
<h3 id="import关键字的使用"><a class="markdownIt-Anchor" href="#import关键字的使用"></a> import关键字的使用</h3>
<p>import导入：</p>
<ol>
<li>
<p>在源文件中显示的使用import结构导入指定包下面的类，接口</p>
</li>
<li>
<p>声明在包的声明和类的声明之间</p>
</li>
<li>
<p>如果需要导入多个结构，则并列写出即可</p>
</li>
<li>
<p>可使用“xxx.*”的方法，表示可以导入xxx包下的所有结构</p>
</li>
<li>
<p>如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p>
</li>
<li>
<p>如果使用的类或接口是本包下定义的，则可以省略import结构</p>
</li>
<li>
<p>如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中import 是关键字，project1是包名，&quot;.&quot;后面的是包中的类名</span></span><br><span class="line"><span class="keyword">import</span> project1.First;</span><br><span class="line"><span class="comment">// 全类名的显示方式</span></span><br><span class="line">project1.<span class="type">First</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">project1</span>.First();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用“xxx.*”方式表明可以调用xxx包下面的所有结构。但如果使用的是xxx包下面的子结构，则仍需要显示导入</p>
</li>
<li>
<p>import static：导入的指定类或接口中的静态结构（不是类）：属性，或方法</p>
</li>
</ol>
<h3 id="super关键字的使用"><a class="markdownIt-Anchor" href="#super关键字的使用"></a> super关键字的使用</h3>
<p>super关键字：</p>
<ol>
<li>super理解为：父类的</li>
<li>super可以用来调用：属性，方法，构造器</li>
<li>super的使用：调用属性或方法
<ol>
<li>我们可以在子类的方法或构造器中，通过使用“super.属性”或“super.方法”的方式，显示调用父类中声明的属性或方法，但是通常情况下，我们习惯省略super</li>
<li>特殊情况：当子类和父类中定义了同名的属性的时候，我们想要在子类中调用父类声明的属性的时候，则必须显式的使用“super.属性”的方式，表明调用的是父类中声明的属性</li>
<li>特殊情况：当子类重写了父类中的方法之后，我们想要在子类的方法中调用父类的中被重写的方法的时候，则必须显式的使用“super.方式”的方法，表明调用的是父类中被重写的方法</li>
</ol>
</li>
<li>super调用构造器
<ol>
<li>我们可以在子类的构造器中显示的使用“super（形参列表）”的方式，调用父类中声明的指定的构造器</li>
<li>“super(形参列表)”的使用，必须声明在子类构造器的首行！！！！</li>
<li>我们在类的构造器中，针对与“this(形参列表)”或“super(形参列表)”，只能二选一，不能同时出现</li>
<li>在构造器的首行，没有显式的声明“this(形参列表)”或“super(形参列表)”，则默认调用的是父类中空参的构造器</li>
<li>在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表)”，调用父类中的构造器</li>
</ol>
</li>
</ol>
<h3 id="instanceof关键字的使用"><a class="markdownIt-Anchor" href="#instanceof关键字的使用"></a> instanceof关键字的使用</h3>
<ol>
<li>
<p>用法：  a instanceof A：判断对象a是否是类A的实例，如果是，返回True，如果不是返回False,</p>
<p>要求a 所属类与A必须是子类或者父类的关系，否则编译会出现错误</p>
</li>
<li>
<p>目的：为了在多态的时候使用类型强制转换的时候不出现错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Woman)&#123; <span class="comment">// 这样的话我们就不会出现多态中类型转换出现的错误了</span></span><br><span class="line">    <span class="type">Woman</span> <span class="variable">w1</span> <span class="operator">=</span> (Woman)p2;</span><br><span class="line">    p2.goShopping();</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类B是类A的父类：</p>
<p>a instanceof A 返回true，则a instanceof B 返回true</p>
<p>练习</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题一：编译时通过，运行时不通过</span></span><br><span class="line"><span class="comment">// 举例一： 同子类不能互相转换</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line"><span class="type">Man</span> <span class="variable">m3</span> <span class="operator">=</span> (Man)p3;</span><br><span class="line"><span class="comment">// 举例二： 要想使用类的强制类型转换必须是多态之间的</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Man</span> <span class="variable">m4</span> <span class="operator">=</span> (Man)p4;</span><br><span class="line"><span class="comment">// 问题二：编译时通过，运行时也通过：</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题三：编译不通过：</span></span><br><span class="line"><span class="type">Man</span> <span class="variable">m5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();  <span class="comment">// 逻辑语法都不符合， 直接报错</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="static关键字的使用"><a class="markdownIt-Anchor" href="#static关键字的使用"></a> static关键字的使用：</h3>
<p>目的：为了减少统一变量的空间，例如所有中国人的国籍都是“中国”，这时候我们建立一个中国人的类，这个国籍变量就可以设置为static，就是所有的中国人的实例都共用这一个变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 静态变量在这时候就可以使用了：</span></span><br><span class="line">        Chinese.nation = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>();</span><br><span class="line">        c1.name = <span class="string">&quot;阿里&quot;</span>;</span><br><span class="line">        c1.age = <span class="number">40</span>;</span><br><span class="line">        c1.nation = <span class="string">&quot;China&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>();</span><br><span class="line">        c2.name = <span class="string">&quot;百度&quot;</span>;</span><br><span class="line">        c2.age = <span class="number">50</span>;</span><br><span class="line">        System.out.println(c2.nation);  <span class="comment">// 这行代码输出的是 China</span></span><br><span class="line">        </span><br><span class="line">        c2.nation = <span class="string">&quot;CHN&quot;</span>;</span><br><span class="line">        </span><br><span class="line">       	System.out.println(c1.nation);   <span class="comment">// 这行代码输出的是 CHN</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span>	String nation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>static：静态的，随着类的加载而加载</li>
<li>static用来修饰。属性，方法，代码块，内部类。</li>
<li>使用static修饰属性：静态变量
<ul>
<li>属性，按是否使用static修饰，分为 静态属性 VS 非静态属性(实例变量)
<ul>
<li>实例变量：我们创建了类的多个对象，每个对象都有一套属于自己的非静态属性。修改其中一个的非静态属性，不会影响其它对象里面的属性</li>
<li>静态变量：我们创建了类的多个对象，多个对象共享一套非静态属性。当通过某一个对象修改非静态属性，会导致其他对象调用此静态对象的时候，是修改过的</li>
</ul>
</li>
<li>static修饰属性的其他说明：
<ul>
<li>静态变量随着类的加载而加载，可以通过“类.静态变量”的方式进行调用</li>
<li>静态变量的加载要早于对象的创建。</li>
<li>由于类只会加载一次，则静态变量在内存中也只会存在一份</li>
</ul>
</li>
</ul>
</li>
<li>使用static修饰方法：静态方法
<ul>
<li>随着类的加载而加载，可以通过“类.静态方法”的方式调用</li>
<li>静态方法种只能调用静态的方法或属性</li>
<li>非静态方法种既可以调用静态方法也可以调用非静态方法或属性</li>
</ul>
</li>
<li>static注意点
<ul>
<li>在静态方法种不能使用this关键字，super关键字</li>
<li>关于静态属性和静态方法的使用。可以从生命周期的角度去理解</li>
</ul>
</li>
<li>开发中，如何确定一个属性是否要声明为static的？
<ul>
<li>属性可以被多个方法共享，不会随着对象的的不同而不同</li>
<li>操作静态属性的方法，通常设置为static</li>
<li>工具类种的方法习惯上声明为static， 这样就可以直接通过类名来调用，不需要在实例化了</li>
</ul>
</li>
</ol>
<h3 id="final关键字的使用"><a class="markdownIt-Anchor" href="#final关键字的使用"></a> final关键字的使用：</h3>
<p>Final:最终的</p>
<ol>
<li>
<p>final可以用来修饰的结构：类，方法，变量</p>
</li>
<li>
<p>final 用来修饰一个类：此类不能被其他的类所继承。不想在扩充功能了</p>
<p>比如说：String类，System类，StringBuffer类</p>
</li>
<li>
<p>final 用来修饰方法：表明此方法不能够被重写</p>
<p>比如：Object类中的getClass()</p>
</li>
<li>
<p>final用来修饰变量，此时的“变量”就称为常量</p>
</li>
</ol>
<h3 id="抽象类与抽象方法abstract关键字"><a class="markdownIt-Anchor" href="#抽象类与抽象方法abstract关键字"></a> 抽象类与抽象方法（abstract关键字）</h3>
<p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它<mark class="hl-label blue">没有具体的实例</mark> ，这样的类叫做抽象类。</p>
<p>abstract关键字的使用</p>
<p>abstract可以用来修饰的结构：类，方法；</p>
<p>abstract修饰类：</p>
<ol>
<li>使用abstract修饰的类，不能够创建实例</li>
<li>但是抽象类中有构造器，虽然不能够实例化，但是实例化子类的时候还是可以调用的</li>
<li>在开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作，如果没有子类的话abstract修饰类就没有意义了</li>
</ol>
<p>abstract修饰方法：</p>
<ol>
<li>抽象方法只有声明，没有方法体</li>
<li>包含抽象方法的类，一定是一个抽象类，因为抽象方法没有方法体，如果包含抽象方法的类不是抽象类的话，那么就可以通过类的实例化来调用抽象方法了，这样做显然是不合适的，所以<mark class="hl-label red">包含抽象方法的类一定是抽象类</mark> ，反之抽象类中不一定包含抽象方法</li>
<li>如果子类重写了父类中所有的抽象方法后，此类方法可以实例化</li>
<li>如果子类没有重写父类的所有抽象方法，那么此子类也是一个抽象类，需要使用abstract修饰</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractTest</span> &#123;</span><br><span class="line"><span class="comment">//    如果一个类是抽象类的话，直接这样实例化是会报错的</span></span><br><span class="line"><span class="comment">//    Person p = new Person();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人走路&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    定义抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果父类中有抽象方法的话并且子类中没有重写父类中的抽象方法的话，那么子类必须使用</span></span><br><span class="line"><span class="comment">// abstract修饰，否则会报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="comment">//    虽然父类使用abstract修饰之后不能够直接使用构造器调用，但是子类可以调用父类的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    如果子类重写了父类中所有的抽象方法的话，那么子类就可以不适用abstract修饰了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生说话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>abstract使用上的注意点：</p>
<ol>
<li>abstract不能用来修饰属性，构造器等结构</li>
<li>abstract不能用来修饰<mark class="hl-label blue">私有方法</mark> 和<mark class="hl-label blue">静态方法</mark> 和<mark class="hl-label blue">final的方法</mark> ，因为使用abstract修饰的方法必定会被子类重写，但是私有化方法子类又不能重写，这样会导致矛盾，静态方法在子类中虽然能够构造同名同参数的方法，但是不认为这两个方法是同一个，final修饰的方法，不能够被重写</li>
</ol>
<h4 id="匿名类"><a class="markdownIt-Anchor" href="#匿名类"></a> 匿名类：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        这是匿名对象，实名类，但是实例化对象的时候没有对象名字，称为匿名对象</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">student</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        非匿名的类非匿名的对象</span></span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">        method1(worker);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      非匿名类，匿名对象</span></span><br><span class="line">        method1(<span class="keyword">new</span> <span class="title class_">Worker</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        创建了一个匿名子类对象 因为子类是匿名的，所以我们只用父类对象即可</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是抽象类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        method1(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        创建匿名子类匿名对象</span></span><br><span class="line">        method1(<span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是匿名子类匿名对象&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(student s)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">        p.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工人想要发表声明&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后运行结果为：</p>
<p>工人想要发表声明<br />
工人想要发表声明<br />
我是抽象类<br />
我是匿名子类匿名对象</p>
<h4 id="多态的应用"><a class="markdownIt-Anchor" href="#多态的应用"></a> 多态的应用</h4>
<p>模版方法设计模式：</p>
<p>应用场景：当我们在构造一些功能的时候，功能内部一部分是确定的，一部分是不确定的，这时候我们可以把不确定的哪一部分暴露出去，让子类去实现。</p>
<p>换句话说：我们在设计一个算法的时候，整体步骤很固定，通用，这些步骤已经在父类中写好了。但是某些部分易变，易变的部分，可以抽象出来，供不同的子类实现，这就是一种模板形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">SubTemplate</span> <span class="variable">subTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubTemplate</span>();</span><br><span class="line">        subTemplate.spendTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">spendTime</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        code(); <span class="comment">// 这里就是不确定的部分，易变的部分</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span>+(start-end));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">code</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Math.sqrt(i) ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">                sub++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h3 id="接口interface"><a class="markdownIt-Anchor" href="#接口interface"></a> 接口（interface）</h3>
<p>再生产模式中，我们通常需要从几个类中派生出一个子类，继承他们所有的属性和方法，但是JAVA不支持多重继承。有了接口，就可以 得到多重继承的效果</p>
<p>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如:鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。<br />
接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。<mark class="hl-label blue">继承是一个"是不是"的关系，而接口实现则是"能不能"的关系。</mark> <br />
接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。</p>
<p>接口的使用：</p>
<ol>
<li>接口使用interface来定义</li>
<li>Java中，接口和类是并行的两个结构</li>
<li>如何定义接口，定义接口中的成员：
<ol>
<li>JDK7及以前只能：定义全局常量和抽象方法
<ol>
<li>全局常量：public static final的，但是可以省略不写</li>
<li>抽象方法：public abstract的</li>
</ol>
</li>
<li>JDK8：除了可以定义全局常量和抽象方法之外还可以定义静态方法（public static void 方法名），默认方法（public default void 方法名）
<ol>
<li>接口中定义的静态方法只能接口自己调用</li>
<li>实现类中可以调用接口中的默认方法，如果实现类重写了接口中的方法的话，调用的时候仍会调用重写的方法</li>
<li>如果子类（或实现类）继承父类和实现的接口中同名同参数的默认方法，那么子类在没有重写此方法的时候，默认调用的是父类中的同名同参数的方法 —&gt; 类优先原则</li>
<li>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在类没有重写这个方法的时候，报错：—&gt;接口冲突
<ol>
<li>解决方法：我们需要在类中重写此方法</li>
</ol>
</li>
<li>调用接口中的默认方法：
<ol>
<li>如果要调用接口中的静态方法直接通过 <mark class="hl-label blue">接口.静态方法</mark> 这种方式来进行调用</li>
<li>如果想要调用接口中的默认方法的话，需要通过<mark class="hl-label blue">接口.super.默认方法</mark> 这种方法来进行调用</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>接口中不能定义构造器！ 意味着接口不能够实例化</li>
<li>在JAVA中，接口通过让类实现（implements）的方式来使用
<ol>
<li>如果实现类覆盖了接口 中的所有抽象方法，则此实现类可以实例化</li>
<li>如果实现类没有覆盖接口中的所有抽象方法，则次实现类仍未一个抽象类</li>
</ol>
</li>
<li>Java类可以实现多个接口 —&gt;弥补了Java单继承的局限性
<ol>
<li>格式：class AA extends BB implements CC,DD,EE…</li>
</ol>
</li>
<li>接口和接口之间可以继承，也可以多继承</li>
<li>接口的具体使用，体现多态性</li>
<li>接口实际上可以看做一种规范</li>
</ol>
<p>接口的使用：</p>
<ol>
<li>接口的使用上也满足多态性</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(Flyable.MAX_SPEED);</span><br><span class="line">        System.out.println(Flyable.MIN_SPEED);</span><br><span class="line"></span><br><span class="line">        <span class="type">Plane</span> <span class="variable">plane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Plane</span>();</span><br><span class="line">        plane.fly();</span><br><span class="line"></span><br><span class="line">        <span class="type">Bullet</span> <span class="variable">bullet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bullet</span>();</span><br><span class="line">        bullet.fly();</span><br><span class="line">        bullet.attack();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="comment">// 全局常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">7900</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MIN_SPEED</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 省略前面的修饰词也可以</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过引擎起飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶员减速停止&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AttackAble</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现多个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bullet</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>,AttackAble&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子弹飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子弹停&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子弹攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口应用的<mark class="hl-label blue">代理模式</mark> ：</p>
<p>代理模式：是JAVA开发中使用较多的一种设计模式，代理设计就是为了其他对象提供一种代理以控制这个对象的访问</p>
<p>接口报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pX</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 这时候会报错，因为x不明确，不知道是调用父类的还是接口中的</span></span><br><span class="line">       	<span class="comment">// System.out.println(x);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面这种方法不会报错</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.x);</span><br><span class="line">        System.out.println(A.x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().pX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口排错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">P1ayable</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bounceab1e</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Ro1lable</span> <span class="keyword">extends</span> <span class="title class_">Playable</span>,Bounceable&#123;</span><br><span class="line">    <span class="type">Ball</span> <span class="variable">ba11</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ba11</span>( <span class="string">&quot;PingPang&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ba11</span> <span class="keyword">implements</span> <span class="title class_">Rollable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ba11</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里重写的是将两个接口中的play方法都重写了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里就有问题了 因为ball这个字符，在接口中定义过是一个final型的 变量，不能够从新赋值</span></span><br><span class="line">        ball = <span class="keyword">new</span> <span class="title class_">Ba11</span>( <span class="string">&quot;Footba11&quot;</span>);</span><br><span class="line">		system.out.print1n( bal1.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式：</h2>
<p>设计模式：设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模免去我们自己再思考和摸索。式就像是经典的棋谱,不同的棋局，我们用不同的棋谱，”套路”</p>
<ol>
<li>
<p>单例模式：所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法，如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的<mark class="hl-label blue">构造器的访问权限设置为private</mark> ,这样，就<mark class="hl-label blue">不能用new操作符在类的外部产生类的对象了</mark> ，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *单例设计模式：</span></span><br><span class="line"><span class="comment"> * 1. 单例设计模式，就是采用一定的方法保证在整个软件系统中该类只有一个实例对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 实现方法：</span></span><br><span class="line"><span class="comment"> * 		饿汉式 VS 懒汉式</span></span><br><span class="line"><span class="comment"> *      饿汉式</span></span><br><span class="line"><span class="comment"> *      1. 私有化类的构造器，目的就是为了防止在 该类外面创建这个类的实例</span></span><br><span class="line"><span class="comment"> *      2. 在该类内部创建类的对象(静态)</span></span><br><span class="line"><span class="comment"> *      3. 提供公共的方法（静态）来调用这个类中创建的对象</span></span><br><span class="line"><span class="comment"> *      懒汉式</span></span><br><span class="line"><span class="comment"> *      1. 私有化类的构造器，目的就是为了防止在 该类外面创建这个类的实例</span></span><br><span class="line"><span class="comment"> *      2. 声明当前类的对象，没有初始化， 设置为null</span></span><br><span class="line"><span class="comment"> *      3. 声明public static的返回当前类的方法</span></span><br><span class="line"><span class="comment"> *          3.1 在该方法中进行 类的声明</span></span><br><span class="line"><span class="comment"> *          3.2 在声明前需要 判断一下该对象是否为null，如果是的话在进行实例化，如果不是的话直接返回</span></span><br><span class="line"><span class="comment"> *      饿汉式：坏处：对象一开始就存在，存在时间过长</span></span><br><span class="line"><span class="comment"> *      懒汉式：好处：什么时候使用是么时候在开始创建，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bank</span> <span class="variable">instance1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="type">Bank</span> <span class="variable">instance2</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 私有化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在该类内部创建类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供公共的方法返回类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> Order.getInstance();</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order2</span> <span class="operator">=</span> Order.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(order1 == order2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">// 1.私有化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 声明当前类的对象，没有初始化</span></span><br><span class="line">    <span class="comment">// 4. 此对象需要声明为static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 3. 声明public static的返回当前类的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>单例模式的应用场景：</p>
<p>网站的计数器，一般也是单例模式实现，否则难以同步。<br />
应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。<br />
项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。<br />
Application也是单例的典型应用<br />
Windows的Task Manager(任务管理器)就是很典型的单例模式<br />
Windows的Recycle Bin(回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</p>
</li>
</ul>
</li>
<li>
<p>创建型模式：共5种:工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
</li>
<li>
<p>结构型模式，共7种:适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
</li>
<li>
<p>行为型模式，共11种:策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式<br />
状态模式、访问者模式、中介者模式、解释器模式。</p>
</li>
</ol>
<h2 id="main函数的使用方发"><a class="markdownIt-Anchor" href="#main函数的使用方发"></a> main函数的使用方发</h2>
<p>main() 方法的使用说明：</p>
<p>public static void main(String[] args)</p>
<ol>
<li>
<p>mian()方法作为程序入口</p>
</li>
<li>
<p>mian()方法也是一个普通的静态方法</p>
</li>
<li>
<p>mian()方法也可以作为我们与<mark class="hl-label blue">控制台</mark> 的交互方法。传入参数为args数组中的元素</p>
<p>操作方法：运行时：java “TOM” “123” “ture” “false”</p>
<p>这样的操作 就是把后面这四个元素放到String类型的数组 args中</p>
</li>
</ol>
<h2 id="赋值的先后顺序"><a class="markdownIt-Anchor" href="#赋值的先后顺序"></a> 赋值的先后顺序</h2>
<p>对象赋值可使用的位置，</p>
<ol>
<li>默认初始化</li>
<li>显示初始化</li>
<li>在代码中赋值</li>
<li>在构造器中初始化</li>
<li>有对象之后可以通过“对象.属性”或“对象.方法”的方式，进行赋值</li>
</ol>
<p>执行先后顺序为 1-&gt; 2 /3(不分先后谁在前谁先赋值) -&gt;4 -&gt; 5</p>
<ul>
<li>默认初始化： 在你创建变量的时候就会初始化赋值，例如在创建变量的时候会默认赋值，例如，int型默认值为0，浮点型默认型为0.0，bool型默认为true</li>
<li>显示初始化：我们手动的给他赋值，例如a = 10</li>
<li>在代码块中赋值 字面意思</li>
</ul>
<h1 id="每天一考"><a class="markdownIt-Anchor" href="#每天一考"></a> 每天一考</h1>
<ol>
<li>
<p>如何实现向下转型？需要注意什么？如何解决此问题</p>
<p>向下转型的目的就是使父类对象能够调用子类的方法</p>
<p>使用强转符：（）</p>
<p>Person p = new Man()</p>
<p>Man m = (Man)p</p>
<p>如果转换失败的话会报ClassCastException异常，为了避免这个错误，我们在进行强制类型转换之前，先进行instanceof 判断一下被转换目标</p>
<p>if (p instanceof Man){</p>
<p>Man m = (Man)p;</p>
<p>}</p>
</li>
<li>
<mark class="hl-label 区别：blue">和equals()</mark> ： 
<p>可用于基础数据类型，也可用于引用数据类型，用于基础数据类型的时候比较的是两个数据的值相等就返回true，如果是引用数据类型的话，就是要比较这两个引用数据类型地址是否相等</p>
<p>equals：是一个方法，只能比较引用数据类型，在没有重写的时候，和==的用法是相同的，都是比较地址，如果重写之后就能够比较引用数据变量内的具体的值</p>
</li>
<li>
<p>8种数据类型及其对应的包装类：</p>
<p>int Integer</p>
<p>char Character</p>
</li>
<li>
<p>基本数据类型，包装类，String三者之间如何转换</p>
<p>基本数据类型，和包装类，使用自动装箱和拆箱</p>
<p>前两者和String之间的</p>
<p>基本数据类型， 包装类–&gt;String：使用String中的方法 valueOf(xxx)</p>
<p>String --&gt; 基本数据类型，包装类：使用包装类种的方法 parseXxx(String s)</p>
</li>
<li>
<p>对多态性的理解：</p>
<p>实现代码的通用性</p>
<p>抽象类和接口肯定体现了多态性。(抽象类和接口不能实例化)</p>
<p>多态性是运行时行为</p>
</li>
<li>
<p>static修饰的属性，相较于实例变量，有哪些特别之处：</p>
<ol>
<li>随着类的加载而加载</li>
<li>早于对象的创建</li>
<li>只要权限允许，可以通过“对象.static 属性”的方式进行调用</li>
<li>存在于方法区的静态域中</li>
</ol>
</li>
<li>
<p>final可以用来修饰那些结构，分别表示什么意思：</p>
<ol>
<li>
<p>final可以用来修饰的结构：类，方法，变量</p>
</li>
<li>
<p>final 用来修饰一个类：此类不能被其他的类所继承。不想在扩充功能了</p>
<p>比如说：String类，System类，StringBuffer类</p>
</li>
<li>
<p>final 用来修饰方法：表明此方法不能够被重写</p>
<p>比如：Object类中的getClass()</p>
</li>
<li>
<p>final用来修饰变量，此时的“变量”就称为常量</p>
</li>
</ol>
</li>
<li>
<p>类的属性赋值位置有哪些？先后顺序为什么</p>
<ol>
<li>默认初始化</li>
<li>显示赋值</li>
<li>代码块赋值</li>
<li>构造器赋值</li>
<li>“对象.属性”或者 “对象.方法” 赋值</li>
</ol>
</li>
<li>
<p>小结:一叶知秋<br />
publicstaticvoidmain(String[] args){//方法体}<br />
权限修饰符: private缺省protected pubilc ----&gt;封装性<br />
修饰符: static \ final \ abstract \native可以用来修饰方法返回值类型:无返回值/有返回值–&gt;return<br />
方法名:需要满足标识符命名的规则、规范;“见名知意”<br />
形参列表:重载vs重写;参数的值传递机制;体现对象的多态性方法体:来体现方法的功能</p>
<p>方法体:来体现方法的功能</p>
</li>
</ol>
<h1 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/1iYqI5AftVeCvHN.png" alt="image-20220425093701784" /></p>
<h2 id="异常体系结构"><a class="markdownIt-Anchor" href="#异常体系结构"></a> 异常体系结构：</h2>
<p>java.lang.Throwable:</p>
<ol>
<li>java.lang.Error:重大错误异常，一般不编写针对性的代码进行处理</li>
<li>java.lang.Exception：可以进行异常处理
<ol>
<li>编译时异常（checked）
<ul>
<li>IOException
<ul>
<li>FileNotFoundException</li>
</ul>
</li>
<li>ClassNotFoundException</li>
</ul>
</li>
<li>运行时异常（unchecked）
<ul>
<li>NullPointerException</li>
<li>ArrayIndexOutOfBoundsException</li>
<li>ClassCastException</li>
<li>NumberFormatException</li>
<li>InputMismatException</li>
<li>ArithmeticException</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>异常实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="comment">// NullPointerException 空指针异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">// ArrayIndexOutOfBoundsException  数据越界</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">// ClassCastException  类型转换失败</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"><span class="comment">//    NumberFormatException  数据转化失败</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">// InputMismatchException 输入的类型和我们想要的类型不相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">// ArithmeticException 算数异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        System.out.println(a/b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常处理机制"><a class="markdownIt-Anchor" href="#异常处理机制"></a> 异常处理机制</h2>
<p>JAVA处理异常的情况，是将异常处理的程序代码集中在一起，与正常的程序代码分开，是程序简洁，优雅，并易于维护</p>
<p>异常的处理：抓抛模型</p>
<p>过程一：“抛”：程序在正常执行的时候，一旦出现异常，就会在异常代码处生成一个对应的异常类的对象，并将这个对象抛出。一旦抛出对象之后，其后代吗就不再执行</p>
<p>关于异常对象的产生：</p>
<ul>
<li>系统自动生成的异常对象</li>
<li>手动生成一个异常对象，并抛出（throw）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.regist(-<span class="number">1001</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( id &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 这里的作用是当id输入有误的时候停止程序运行</span></span><br><span class="line">            <span class="comment">// 使用这种方式只能让用户知道id输入错误，但是后面的程序依旧会执行</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;id输入不合法&quot;);</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用这种方法当id输入不合法的时候会自动抛出一个异常，让该语句之后的语句都不再执行</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;ID输入不合法！&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过称二：“抓”：可以理解为异常的处理方式① try - catch - finally,②throws</p>
<h3 id="方式一try-catch-finally"><a class="markdownIt-Anchor" href="#方式一try-catch-finally"></a> 方式一：try - catch - finally</h3>
<p>try{<br />
// 可能出现异常的代码<br />
}catch(异常类型1,变量名1){<br />
// 处理方法1<br />
}catch(异常类型2,变量名2){<br />
// 处理方法2<br />
}catch(异常类型3,变量名3){<br />
// 处理方法3<br />
}<br />
…<br />
finally{<br />
// 一定会执行的代码<br />
}</p>
<p>说明：</p>
<ol>
<li>finally是可选的</li>
<li>使用try将可能的出现错误的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应的异常类，根据此对象的类型，去catch中匹配</li>
<li>一旦try中异常对象匹配到某一个catch时，就进入catch中进行异常处理，一旦处理完成就跳出当前的try - catch结构（在没有写finally的情况下），继续执行其后面的代码</li>
<li>catch中异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓，如果有子父类的关系则要求子类一定要声明在父类上面，否则报错</li>
<li>catch中常用的异常处理方式①String getMessage()  ②printStackTrace()</li>
<li>在try结构中声明的变量，再出了try结构以后就不能够再调用了</li>
<li>try - catch  - finally结构可以相互嵌套</li>
</ol>
<p>体会1：使用try - catch - finally处理编译时异常的时候，使得在编译时不报错，但是运行的时候可能会报错。相当于我们使用try-catch - finally将一个编译时可能出现的异常，延迟到运行时出现</p>
<p>体会2：开发中，由于运行时异常比较常见，所以我们通常不针对运行时异常编写try - catch - finally了，针对编译时异常，我们一定要考虑异常的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空指针异常&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IndexOutOfBoundsException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;索引超范围异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<mark class="hl-label blue">finally的使用：</mark> 
<ol>
<li>finally是可选的</li>
<li>finally中声明的是一定会执行的代码，即使catch中又出现异常了，try中有return语句，catch中有return语句的情况，如果出现以上几种情况的话，try - catch 结构后面的语句就不会运行了，如果有finally语句的话，即使出现上面的情况的话，finally里面的语句也会被执行</li>
<li>像数据库，输入输出流，网络编程Socket等资源中，JVM是不能够自动回收的，我们需要自己手动的进行资源的释放。此时资源的释放，就需要声明在finally中</li>
</ol>
<h3 id="方式二throws-异常类型"><a class="markdownIt-Anchor" href="#方式二throws-异常类型"></a> 方式二：throws + 异常类型</h3>
<ol>
<li>
<p>&quot;throws + 异常类型&quot;写在方法的声明处，指明此方法执行时，可能会抛出的异常类型，一旦方法体执行的时，出现异常，仍会在异常代码处生成一个异常的对象，此对象满足throws后异常类型时，就会被抛出，异常后面的代码不会再执行！！！</p>
</li>
<li>
<p>体会：try - catch - finally真正的将异常给处理掉了。</p>
<pre><code> 	 throws的方式只是将异常抛给了方法的调用者。并没有真正的将异常处理掉
</code></pre>
</li>
<li>
<p>开发中如何选择try - catch - finally 还是throws 方式来处理异常</p>
<ul>
<li>如果父类中的方法没有进行throws方式来进行处理异常， 那么子类重写该方法的时候也不能使用throws方式来处理异常，但是如果子类中重写的方法真的有异常的话，只能使用try-catch-finally的方式来进行处理</li>
<li>在执行方法a的时候，又先后调用了另外几个方法，这几个方法是递进关系执行的，我们建议这几个方法使用throws方式来进行处理，而执行方法a可以使用try- catch-finally来进行处理</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当main函数调用method2的时候 这个异常就必须在这个函数这处理了，因为这是最后一个函数了。必须要在这个函数中解决这个问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// method2 调用者method1 的时候有两种情况</span></span><br><span class="line">    <span class="comment">// 情况一：使用try - catch - finally 来处理这个异常</span></span><br><span class="line">    <span class="comment">// 情况二：使用throws 方法将这个问题在抛出，不解决，谁调用method2谁解决这个问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最上面throw后面的异常，是这个方法中可能出现的异常情况，但是只是抛出异常不处理，谁调用这个函数谁处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line">        <span class="keyword">while</span>( data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)data);</span><br><span class="line">            data = fis.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法重写规则之一"><a class="markdownIt-Anchor" href="#方法重写规则之一"></a> 方法重写规则之一：</h3>
<p>子类重写的方法抛出的异常类型不能大于父类被重写的方法抛出的异常类型</p>
<h2 id="自定义异常类"><a class="markdownIt-Anchor" href="#自定义异常类"></a> 自定义异常类</h2>
<ol>
<li>
<p>继承与现有的异常结构：RuntimeException, Exception</p>
</li>
<li>
<p>提供全局常量：serialVersionUID</p>
</li>
<li>
<p>提供重载的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">4648468498468487L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);f</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="异常的测试"><a class="markdownIt-Anchor" href="#异常的测试"></a> 异常的测试</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EcmDef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> ecm(a, b);</span><br><span class="line">            System.out.println(<span class="string">&quot;结果为&quot;</span>+result);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据类型不一致&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;缺少命令行参数&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除零&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NegativeException e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ecm</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NegativeException</span>(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i/j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>throw 和 throws的区别：</p>
<ul>
<li>throw是生成一个异常的方式</li>
<li>throws是异常处理的一个方式</li>
</ul>
<p>世界上最遥远的距离，是我在if里你在else里，似乎一直相伴又永远分离;</p>
<p>世界上最痴心的等待，是我当case你是switch，或许永远都选不上自己;</p>
<p>世界上最真情的相依,是你在try我在catch。无论你发神马脾气，我都默默承受，静静处理。到那时，再来期待我们的finally。</p>
<h2 id="面试题"><a class="markdownIt-Anchor" href="#面试题"></a> 面试题</h2>
<p>final、 finally、finalize三者的区别?</p>
<mark class="hl-label blue">类似</mark> :
<p>throw和throws<br />
Collection和Collections<br />
String . stringBuffer、StringBuilder</p>
<p>ArrayList . LinkedList<br />
HashMap . LinkedHashMap</p>
<p>重写、重载</p>
<mark class="hl-label blue">结构不相似的</mark> :
<p>抽象类、接口</p>
<p>==  、 equals()</p>
<p>sleep(). wait()</p>
<h1 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h1>
<p>程序，进程，线程</p>
<ul>
<li>程序：
<ul>
<li>是为了完成特定的任务，用某种语言编写的一组指令的集合。即一段静态的代码，静态对象</li>
</ul>
</li>
<li>进程：
<ul>
<li>是进程的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身产生，存在和消亡的过程。–生命周期</li>
<li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
</li>
<li>线程：
<ul>
<li>进程可以进一步细化为线程，是一个程序内部的一条执行路径</li>
<li>如果一个进程同一时间<mark class="hl-label blue">并行</mark> 执行多个线程，就是支持多线程的</li>
</ul>
</li>
</ul>
<p>并行和并发：</p>
<p>并行：多个cpu同时执行多个任务， 多个人做不同的事情</p>
<p>并发：一个cpu同时执行多个任务，多个人做同一件事情</p>
<p>使用多线程的优点：</p>
<p>背景: 以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢?</p>
<p>多线程程序的优点:<br />
1. 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。<br />
2. 提高计算机系统CPU的利用率<br />
3. 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</p>
<p>创建多线程的方法：</p>
<ol>
<li>
<p>通过实现Thread的子类来进行创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span> extend Thread&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThreadTest</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">myThread</span> <span class="variable">mythrad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">myThread</span>();</span><br><span class="line">     	<span class="comment">// 创建一个线程   </span></span><br><span class="line">        mythread.start();</span><br><span class="line">        mythread.getName();</span><br><span class="line">        print(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>创建一个继承与Thread类的子类</p>
</li>
<li>
<p>重写Thread中的run方法 – &gt;将此线程中需要执行的操作放在run方法中</p>
</li>
<li>
<p>创建Thread类的子类对象</p>
</li>
<li>
<p>通过此对象调用start（）方法来创建新线程</p>
<ul>
<li>
<p>启动当前线程</p>
</li>
<li>
<p>调用当前线程中的run方法</p>
</li>
<li>
<p>问题1：我们不能够直接通过<mark class="hl-label blue">对象.run</mark> 的方法来启用多线程</p>
<ul>
<li>问题2：如果我们想要在启用一个线程的话，不能够通过已经start后的线程来开启，会报错：
<ul>
<li>​	我们需要从新创建一个线程对象来进行下一个线程的调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果一个线程中的东西我们只想执行一次的话，我们可以创建一个匿名对象：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Trhead</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		 <span class="comment">// 需要执行的代码：</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span> ; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(i)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.pirntln(Thread.currentThread.getName())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">MThread</span> <span class="variable">mThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MThread</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mThread);</span><br><span class="line">    t1.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>通过实现Runable这个接口来实现</p>
<ol>
<li>创建一个实现了Runable接口的类</li>
<li>实现类去实现Runable中的抽象方法：run()</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象的调用start()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mThread</span> <span class="keyword">implements</span> <span class="title class_">Runable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>比较创建线程的两种方式：</p>
<ol>
<li>开发中优先选择：实现Runable接口的方式</li>
<li>原因：
<ol>
<li>实现方式没有类的单继承性的局限性</li>
<li>实现的方式更适合来处理多个线程有共享数据的情况</li>
</ol>
</li>
<li>联系：Thread类实现了Runable方法：public class Thread implements Runable</li>
<li>相同点：两种方式都需要重写run()，将线程执行的逻辑声明在run()中</li>
<li>以上两种方式，要想启动线程，都是要调用Thread类中的start()方法来进行调用的</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="thread类的有关方法"><a class="markdownIt-Anchor" href="#thread类的有关方法"></a> Thread类的有关方法</h2>
<ol>
<li>void start：启动线程</li>
<li>run：线程在被调度的实行的操作</li>
<li>String getName（）：返回线程的名称</li>
<li>void setName（String Name）：设置该线程的方法</li>
<li>static Thread currentThread（）：返回当前线程，	在Thread子类中就是this，通常使用与主线程和Runnable实现类</li>
<li>static void yield():线程让步
<ol>
<li>暂停当前线程，把执行机会让给优先级相同或者更高的线程</li>
<li>若队列中没有同优先级的线程，则忽略此方法</li>
</ol>
</li>
<li>join（）：当某个执行流中调用其他线程的join方法，调用线程将会被堵塞，知道join（）方法加入的join线程执行完毕之后自己在开始执行</li>
<li>static void sleep(long millis)
<ol>
<li>让当前的线程在指定时间段之内放弃对CPU的控制，使得其他的线程有机会被执行，时间到后从新排队</li>
<li>抛出InterruptedException异常</li>
</ol>
</li>
<li>stop（）：强制结束线程生命进程，不推荐使用</li>
<li>boolean isAlive（）， 返回bool值，判断线程是否还活着</li>
</ol>
<h2 id="线程的调度"><a class="markdownIt-Anchor" href="#线程的调度"></a> 线程的调度</h2>
<ol>
<li>时间片：</li>
<li>抢占式：
<ol>
<li>高优先级的线程抢占CPU</li>
</ol>
</li>
</ol>
   <mark class="hl-label blue">JAVA的调度方法</mark> 
<ol>
<li>同优先线程组成先进先出队列（先到先服务），使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ol>
<p>优先级的方法：</p>
<ol>
<li>getPriority():返回线程优先级</li>
<li>setPriority(int newPriority):改变线程的优先级</li>
</ol>
<ul>
<li>MAX_PRIORITY: 10</li>
<li>MIN_PRIORITY: 1</li>
<li>NORM_PRIORITY: 5</li>
</ul>
<p>一般的时候线程的优先级都为 NORM_PRIORITY ，这个我们可以自己设置</p>
<p>说明：</p>
<ol>
<li>线程创建的时候继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</li>
</ol>
<h2 id="线程的生命周期"><a class="markdownIt-Anchor" href="#线程的生命周期"></a> 线程的生命周期</h2>
<p>一个完整的生命周期有以下几种状态：</p>
<ol>
<li>新建：当一个Thread类或者其子类的对象被声明创建的时候，新生的状态处于新建状态。</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时他已经具备了运行条件，只是还没有被分配到CPU资源</li>
<li>运行：当就绪的线程被调度并获得CPU资源的时候，便进入了运行状态，run()方法定义了线程的操作和功能</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时终止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作，或线程被提前强制性终止，或出现异常导致结束</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/uoSwHCMXq5hj61t.png" alt="image-20220517084219625" /></p>
<h2 id="线程的同步线程安全"><a class="markdownIt-Anchor" href="#线程的同步线程安全"></a> 线程的同步（线程安全）</h2>
<ol>
<li>
<p>问题：</p>
<p>多个线程的不确定性，引起执行结果的不稳定</p>
<p>多个线程对账本的<mark class="hl-label blue">共享</mark> ，会造成操作的不完整性，会破坏数据</p>
</li>
<li>
<p>原因：</p>
<p>某个线程在操作共享数据的时候，在还没有操作完的时候，其他线程也参与进来，这就会导致线程的安全问题</p>
</li>
<li>
<p>解决方案：</p>
<p>当一个线程在操作公共数据的时候，其他线程不能够参与进来，直到这个线程完成了对公共数据的操作之后，其他线程才能进来，这种情况，即使这个线程发生了阻塞，别的线程也不能进来操作</p>
</li>
<li>
<p>在Java中我们通过同步机制来解决线程安全问题</p>
<ul>
<li>
<p>方式1：同步代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>操纵共享数据的代码，就是要被同步的代码 ------&gt; 不能够包多，也不能包少</li>
<li>共享数据：多个线程共同操作的数据</li>
<li>同步监视器：俗称 锁。任何一个类的对象都可以充当锁
<ul>
<li>要求：多个线程必须公用同一把锁</li>
</ul>
</li>
<li>补充：
<ul>
<li>在实现Runable接口中创建多线程的方法中，我们可以考虑使用this充当同步监视器</li>
<li>在继承Tread类中创建多线程方法中，我们可以考虑使用 类.class 来充当同步监视器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>方式2：同步方法：</p>
<ul>
<li>使用同步方法来解决实现Runable接口的线程安全问题·</li>
<li>同步方法仍然涉及到同步监视器，只是不需要我们显示的声明</li>
<li>非静态方法（实现Runable接口的方法），同步监视器是this</li>
<li>静态方法（继承Thread类的方法），同步监视器是当前类本身</li>
<li>实现方法，直接使用synchronized 修饰监视器即可</li>
</ul>
</li>
<li>
<p>方式3：Lock锁 — JDK5.0新增方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">window</span> <span class="keyword">implements</span> <span class="title class_">Runable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.实例化ReentrantLock对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 2.调用锁定方法Lock()</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(InterruputedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;票数&quot;</span>+ticket);</span><br><span class="line">                ticket--;     </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 3.调用解锁方法 unlock()</span></span><br><span class="line">            lock.unlock(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>面试题：</p>
<p>​	synchronzied 与 Lock的异同？</p>
<p>相同：</p>
<ul>
<li>两者都可以解决线程安全问题</li>
</ul>
<p>不同：</p>
<ul>
<li>Lock需要手动的启用同步(Lock())，同时结束同步也需要手动实现(unlock())</li>
<li>synchronized机制在执行完全相同的代码以后，自动释放同步监视器</li>
</ul>
<p>优先使用方式：</p>
<p>Lock -&gt; 同步代码块（已经进入方法体，分配了相应的资源）  -&gt; 同步方法(在方法体之外 )</p>
<p>​</p>
</li>
</ul>
</li>
<li>
<p>同步操作的方式</p>
<ol>
<li>解决了线程的安全问题 ----好处</li>
<li>弊端：操作同步代码的时候，只能有一个线程参与，其他线程等待，这相当于一个单线程的问题，效率比较低</li>
</ol>
</li>
<li>
<p>解决懒汉式的线程安全问题：（懒汉式：单例化类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span>()&#123;</span><br><span class="line">    <span class="comment">// 私有化类的构造器，不能够从外面新建类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;&#125;; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Bank <span class="title function_">getInsance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Banc.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>线程的死锁问题：</p>
<p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</p>
<p>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态,无法继续</p>
<ul>
<li>解决方法：
<ul>
<li>专门的算法、原则</li>
<li>尽量减少同步资源的定义</li>
<li>尽量避免嵌套同步</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="线程的通信"><a class="markdownIt-Anchor" href="#线程的通信"></a> 线程的通信</h2>
<p>使线程交替运行，让每一个线程都有机会抢到运行的代码</p>
<p>线程通信的三个方法：</p>
<ul>
<li>
<p>wait():一旦执行此方法，当前线程就被进入阻塞状态，并释放同步监视器。</p>
</li>
<li>
<p>notify():一旦执行此方法，就会唤醒wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个</p>
</li>
<li>
<p>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程</p>
</li>
<li>
<p>这三个方法只能够出现在同步代码块中</p>
</li>
<li>
<p>这三个方法调用者必须是同步代码块或同步方法中的同步监视器</p>
</li>
<li>
<p>这三个方法是定义在java.lang.Object类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="comment">// 释放前几个线程 防止线程的阻塞</span></span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;number = :&quot;</span>+number);</span><br><span class="line">            number++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 调用wait方法的线程进入阻塞状态,这时候下一个线程就可以进入，实现线程的交替</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>sleep() 和wait()的异同？</p>
<ol>
<li>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</li>
<li>不同点：
<ul>
<li>两个方法声明位置不同：Thread类中声明sleep()，Object类中声明wait()</li>
<li>调用的位置不同：sleep()可以在任何需要的场景下调用，wait()必须在同步代码快中使用</li>
<li>关于是否释放同步监视器：如果两个方法都是用在同步代码块或同步方法中</li>
</ul>
</li>
</ol>
<p>经典例题：生产者和消费者问题：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程通信的应用：生产者消费者问题</span></span><br><span class="line"><span class="comment"> * 生产者(Producer)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，</span></span><br><span class="line"><span class="comment"> * 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，</span></span><br><span class="line"><span class="comment"> * 店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产;</span></span><br><span class="line"><span class="comment"> * 如果店中没有产品了，店员会告诉消费者等一下，</span></span><br><span class="line"><span class="comment"> * 如果店中有产品了再通知消费者来取走产品。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> * 1. 是否有多线程问题：是，生产者线程，消费者线程,有可能在生产者生产第10个产品的时候，</span></span><br><span class="line"><span class="comment"> *         消费者抢到的线程，消费了第10个产品，最后生产者生产完第10个产品之后</span></span><br><span class="line"><span class="comment"> *         计数却为9</span></span><br><span class="line"><span class="comment"> * 2. 是否有共享数据？ 是， 店员（产品）</span></span><br><span class="line"><span class="comment"> * 3. 如何解决线程安全问题？ 同步机制，三种方法</span></span><br><span class="line"><span class="comment"> * 4. 是否涉及线程的通信？ 是</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> productNumber;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produceProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(productNumber &lt; <span class="number">20</span>)&#123;</span><br><span class="line">            productNumber++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:开始生产&quot;</span>+productNumber+<span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            <span class="comment">// 当我们生产一个产品之后就可以通知消费者来消费产品了，可以使用notify</span></span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consumeProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(productNumber &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:开始消费&quot;</span>+productNumber+<span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            productNumber--;</span><br><span class="line">            <span class="comment">// 当我们消费了一个产品的时候 就可以通知生产者来进行生产了</span></span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 有 wait，我们就要考虑使用notify</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始生产产品...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clerk.produceProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Clerk clerk)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始消费产品...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clerk.consumeProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line">        p1.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(clerk);</span><br><span class="line">        c1.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="jdk50新增线程方式"><a class="markdownIt-Anchor" href="#jdk50新增线程方式"></a> JDK5.0新增线程方式</h2>
<p>新增方式一：实现Callable接口，实现call方法</p>
<ul>
<li>相比于run方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助FutureTrue类，比如说获取返回结果
<ul>
<li>Future接口
<ul>
<li>可以对具体的Runable， Callable任务的执行结果进行取消，查询是否完成，获取结果等。</li>
<li>
<mark class="hl-label blue">FutureTask是Future接口的唯一实现类</mark> 
</li>
<li>FutureTask 同时实现了Runable，Future接口。它既可以作为Runable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
</li>
</ul>
</li>
</ul>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个实现Callable接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">// 2. 实现call方法，将此线程需要执行的操作声明在call（）中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">void</span> <span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="comment">// 3. 创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">// 4.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()方法</span></span><br><span class="line">        <span class="comment">// 启用线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 6.获取Callable中call方法的返回值</span></span><br><span class="line">         	<span class="comment">//  get()返回值为FutureTask构造器参数Callable实现类重写的call()的返回值 </span></span><br><span class="line">            <span class="type">Obejct</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么Callable接口方式创建多线程比实现Runable接口创建多线程的方式强大？</p>
<ol>
<li>call（）可以有返回值</li>
<li>call（）可以抛出异常，被外面的操作捕获，获取异常信息</li>
<li>Callable是支持泛型的</li>
</ol>
<p>新增方式二：使用线程池</p>
<ol>
<li>
<p>背景：</p>
<p>经常创建和销毁，使用量特别大的资源，比如并发下的线程，对性能影响很大</p>
</li>
<li>
<p>思路：</p>
<p>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创造销毁，实现重复利用，类似生活中的公共交通问题</p>
</li>
<li>
<p>好处：</p>
<ul>
<li>提高反应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复线程池中的线程，不需要每次都创建）</li>
<li>便于线程的管理
<ul>
<li>corePoolSize:核心池的大小</li>
<li>maximumPoolSize:最大线程数</li>
<li>keepAliveTime:线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
</li>
<li>
<p>方法：</p>
<p>ExecutorService：真正的线程池接口、常见的子类ThreadPoolExecutor</p>
<ul>
<li>void execute(Runable commend):执行命令。没有返回值，一般用来执行Runable</li>
<li><T>Future<T> submit(Callable<T> task):执行任务，有返回值，一般又来执行Callable</li>
<li>void shutdown():关闭连接池</li>
</ul>
<p>Executors:工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p>
<ul>
<li>Executors.newCachedThreadPool():创建一个可根据需要创建新线程的线程</li>
<li>Exscutors.newFixedThreadPool(n);创建一个可重用固定线程数的线程池</li>
<li>Executors.newSingleThreadExecutor():创建一个只有一个线程的线程池</li>
<li>Executors.newScheduledThreadPool(n):创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>	java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 提供指定数量的线程池，返回值是一个接口对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可以将这个接口强制转换为类对象，通过这个类的对象来调用各个属性</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPollExecutor) service;</span><br><span class="line">        service1.setCorePoolSize(<span class="number">15</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  2. 执行指定的线程操作， 需要提供实现Runable接口或者Callable接口的对象</span></span><br><span class="line">        <span class="comment">// 适用于Runable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>);</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 适用于Callable </span></span><br><span class="line">        <span class="comment">// service.submit();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="常用类"><a class="markdownIt-Anchor" href="#常用类"></a> 常用类</h1>
<h2 id="字符串相关的类"><a class="markdownIt-Anchor" href="#字符串相关的类"></a> 字符串相关的类</h2>
<h3 id="string对象的特性"><a class="markdownIt-Anchor" href="#string对象的特性"></a> String对象的特性</h3>
<pre><code>  /*
  String:字符串，使用一对“”括起来表示
  1. String声明为final的 ，表示不可以被继承
  2. String实现了Serializable接口：表示该类型是可序列化的
  实现了Comparable接口：表示该类型是可以比较大小的
  3. String内部定义了 final char[] value用于存储字符串的数据
  4. String：代表了不可变的字符序列。简称不可变性
  体现： 1.当对字符串进行从新赋值的时候，需要重新指定区域赋值，不能够对原有的value进行赋值
  2. 当进行字符串的拼接操作的时候，也需要重新指定区域赋值，不能够对原有的value进行赋值
  3. 当调用String的replace方法修改指定字符串的时候，也需要重新指定区域赋值，不能够对原有的value进行赋值
  5. 通过字面量方式（区别于new）给一个字符串赋值，此时字符串值声明在，字符串常量池中，
  6. 字符串常量池中是不会出现相同内容的字符串的
  */
  @Test
  public void test1()&#123;
  String s1 = &quot;abc&quot;; // 字面量的定义方式
  String s2 = &quot;abc&quot;;
</code></pre>
<p>System.out.println(s1 == s2); // 比较s1和s2的地址值，返回值是true</p>
<p>s1 = “hello”;</p>
<p>System.out.println(s1);<br />
System.out.println(s2);</p>
<p>String s3 = “abc”;<br />
s3 += “def”;<br />
System.out.println(s3);<br />
System.out.println(s2);</p>
<p>String s4 = “abc”;<br />
String s5 = s4.replace(‘a’, ‘b’);<br />
System.out.println(s4);<br />
System.out.println(s5);</p>
<p>}</p>
<h3 id="string对象的创建"><a class="markdownIt-Anchor" href="#string对象的创建"></a> String对象的创建：</h3>
<p>面试题：String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？</p>
<p>两个：一个是堆空间中new结构，另一个是char[]对应的常量池中的数据&quot;abc&quot;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original);</span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = Arrays.copyof(value,value.length);</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> startIndex,<span class="type">int</span> count);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">// 通过字面量定义的 的方式：此时的s1和s2的数据javaEE生命在方法取中的字符串常量池中</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 通过new + 构造器的方式：此时s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的value值</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      System.out.println(s1 == s2); <span class="comment">// ture</span></span><br><span class="line">      System.out.println(s1 == s3); <span class="comment">// false</span></span><br><span class="line">      System.out.println(s1 == s4); <span class="comment">// false</span></span><br><span class="line">      System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>常量和常量的拼接结果在常量池，并且常量池中不会出现相同内容的常量</li>
<li>在字符串拼接的时候，只要其中有一个是变量，结果就在堆中</li>
<li>如果拼接的结果是调用intern()方法，返回值就在常量池中</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;<span class="type">string</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span> ;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + <span class="string">&quot;world&quot;</span> ;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> (s1 + s2).intern();</span><br><span class="line">System.out.println(s3==s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3==s5);<span class="comment">//false</span></span><br><span class="line">System.out.print1n(s4==s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3==s6);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="string常用方法"><a class="markdownIt-Anchor" href="#string常用方法"></a> String常用方法：</h3>
<ol>
<li>int Length():返回字符串的长度:return value.Length</li>
<li>char charAt(int index):返回某索引处的字符return value[index]</li>
<li>boolean isEmpty():判断是否是空字符串: return value.length == 0</li>
<li>String toLowercase():使用默认语言环境，将 String中的所有字符转换为小写</li>
<li>String toupperCase():使用默认语言环境，将String中的所有字符转换为大写</li>
<li>String trim():返回字符串的副本，忽略前导空白和尾部空白</li>
<li>boolean equals(object obj):比较字符串的内容是否相同</li>
<li>boolean equalsIgnoreCase(String anotherString):与equals方法类似，忽略大小写</li>
<li>String concat(String str):将指定字符串连接到此字符串的结尾。等价于用+”</li>
<li>int compareTo(String anotherString):比较两个字符串的大小, 返回值是0</li>
<li>String substring(int beginIndex):返回一个新的字符串，它是此字符串的从beginIndex开始截取</li>
<li>string substring(int beginIndex,int endIndex) :返回一个新字符串，它是此字符串从beginIndex开始截取，到endIndex结束不包括endIndex</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    System.out.println(s1.length());  <span class="comment">// 10</span></span><br><span class="line">    System.out.println(s1.charAt(<span class="number">2</span>)); <span class="comment">// l</span></span><br><span class="line">    System.out.println(s1.isEmpty()); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s1.toupperCase()); <span class="comment">// HELLOWORLD</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;  HelloWorld  &quot;</span>;</span><br><span class="line">    System.out.pirntln(<span class="string">&quot;----&quot;</span> + s2 + <span class="string">&quot;----&quot;</span>);  		<span class="comment">//---- HelloWorld ----</span></span><br><span class="line">    System.out.println(<span class="string">&quot;----&quot;</span> + s2.trim() + <span class="string">&quot;----&quot;</span>);   <span class="comment">//----HelloWorld----</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line">    System.out.println(s1.compareTo(s1)); <span class="comment">//如果返回值是0表明两个字符串相同，如果是负数的话表明前一个字符串小，正数的话，表明前一个字符串大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="13">
<li>
<p>boolean endsWith(String suffix):测试此字符串是否以指定的后缀结束</p>
</li>
<li>
<p>boolean startsWith(String prefix):测试此字符串是否以指定的前缀开始</p>
</li>
<li>
<p>boolean startsWith(String prefix，int toffset):测试此字符串从指定索引开始的子字符串是否以指定前缀开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> str1.endWith(<span class="string">&quot;rld&quot;</span>); <span class="comment">// 返回值是boolean类型</span></span><br><span class="line">    System.out.println(b1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> str1.startsWith(<span class="string">&quot;He&quot;</span>);</span><br><span class="line">    System.out.println(b2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> str1.startWith(<span class="string">&quot;ll&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    System.out.println(b3);   <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>boolean contains(CharSequence s):当且仅当此字符串包含指定的char值序列时，返回true</p>
</li>
<li>
<p>int indexOf(String str):返回指定子字符串在此字符串中第一次出现处的索引​</p>
</li>
<li>
<p>int indexOf(String str, int fromIndex):返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</p>
</li>
<li>
<p>int lastIndexOf(String str):返回指定子字符串在此字符串中最右边出现处的索引</p>
<ol>
<li>indexof和lastIndexOf方法如果未找到都是返回-1</li>
</ol>
</li>
<li>
<p>int lastIndexOf(String str, int fromIndex):返回指定子字符串在此字符串中最后次出现处的索引，从指定的索引开始反向搜索</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;OwO&quot;</span></span><br><span class="line">    System.out.println(str1.contains(str2)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    System.out.println(str1.indexOf(<span class="string">&quot;lo&quot;</span>)); <span class="comment">// 3 返回第一个字符的位置</span></span><br><span class="line"></span><br><span class="line">    System.out.println(str1.indexOf(<span class="string">&quot;lo&quot;</span>, <span class="number">5</span>)); <span class="comment">// 从第5个位置开始找lo</span></span><br><span class="line"></span><br><span class="line">    System.out.println(str1.lastIndexOf(<span class="string">&quot;or&quot;</span>)); <span class="comment">// 从字符串的后面开始进行寻找，返回第一个字符出现的位置</span></span><br><span class="line">    System.out.println(str1.lastIndexOf(<span class="string">&quot;or&quot;</span>, <span class="number">6</span>)); <span class="comment">// 从索引为6的位置开始向前寻找 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="21">
<li>
<p>String replace(char oldChar, char newChar):返回一个新的字符串，它是通过用newChar替换此字符串中出现的所有oldChar得到的。</p>
</li>
<li>
<p>String replace(CharSequence target, CharSequence replacement):使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串</p>
</li>
<li>
<p>String replaceAll(String regex，String replacement):使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串。</p>
</li>
<li>
<p>String replaceFirst(String regex，String replacement):使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;河北地质大学，真大！&quot;</span>; </span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str1.replace(<span class="string">&#x27;大&#x27;</span>, <span class="string">&#x27;小&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.prinln(str1); <span class="comment">//河北地质大学，真大！</span></span><br><span class="line">    System.out.prinln(str2); <span class="comment">//河北地质小学，真小！</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str1.replace(<span class="string">&quot;河北&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    System.out.println(str3);   <span class="comment">// 中国地质大学，真大！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>boolean matches(String regex):告知此字符串是否匹配给定的正则表达式.</p>
</li>
<li>
<p>Stringsplit(String regex):根据给定正则表达式的匹配拆分此字符串。</p>
</li>
<li>
<p>Stringsplit(String regex, int limit):根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p>
</li>
</ol>
<h3 id="string与基本数据类型的转换"><a class="markdownIt-Anchor" href="#string与基本数据类型的转换"></a> String与基本数据类型的转换</h3>
<p>String 与基本数据类型， 包装类之间的转换。</p>
<p>String —&gt; 基本数据类型，包装类 ：调用包装类中的parseXxx（str）</p>
<p>基本数据类型，包装类 ------&gt;String：调用String中的valueOf方法 或者+&quot;&quot;</p>
<h3 id="string与字符数组转换"><a class="markdownIt-Anchor" href="#string与字符数组转换"></a> String与字符数组转换</h3>
<p>String 与 char[]:之间的转化</p>
<p>String ----&gt; char[]：调用了String中的toCharArray()</p>
<p>char[] ----&gt; String：调用了String类型的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] charArray = str1.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charArray.length; i++)&#123;</span><br><span class="line">    System.out.println(charArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    System.out.prinln(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string与字节数组进行转换"><a class="markdownIt-Anchor" href="#string与字节数组进行转换"></a> String与字节数组进行转换</h3>
<p>String与byte[]之间的转换</p>
<p>编码: String --&gt; byte[]:调用string的getBytes()解码: byte[] --&gt; String:调用String的构造器</p>
<p>编码:字符串–&gt;字节（看得懂—&gt;看不懂的二进制数据)</p>
<p>解码:编码的逆过程，字节–&gt;字符串(看不懂的二进制数据—&gt;看得懂)</p>
<p>说明:解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123中国&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytes = str1.getBytes(); <span class="comment">//使用默认是字符集进行转换， utf-8一个汉子占三个字节</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Array.toString(bytes));  </span><br><span class="line">    <span class="comment">// [97，98，99，49，50，51，-28，-72，-83，-27， -101，-67]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] gbks = str1.getBytes(<span class="string">&quot;gbk&quot;</span>);  <span class="comment">// 使用utf-8进行编码 一个汉字占两个字节</span></span><br><span class="line">    System.out.println(Array.toString(gbks));</span><br><span class="line">    <span class="comment">// [97，98，99,49，50，51，-42，-48，-71，-6]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">string</span>(bytes);<span class="comment">//使用默认的字符集，进行解码。</span></span><br><span class="line">    System.out.println(str2);  </span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);</span><br><span class="line">    System.out.println(str3);<span class="comment">//出现乱码。原因:编码集和解码集不一致</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbk, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">    System.out.println(str4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="stringbuffer-和-stringbuilder的使用"><a class="markdownIt-Anchor" href="#stringbuffer-和-stringbuilder的使用"></a> StringBuffer 和 StringBuilder的使用</h3>
<p>String、StringBuffer.StringBuilder三者的异同?</p>
<p>String:不可变的字符序列;底层使用char[]存储</p>
<p>StringBuffer:可变的字符序列;线程安全的，效率低;底层使用char[]存储</p>
<p>StringBuilder:可变的字符序列;jdk5.0新增的，线程不安全的，效率高;底层使用char[]存储</p>
<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char[ ] value = new char[0];</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">string</span>(<span class="string">&quot;abc&quot;</span> ); <span class="comment">//char[] value = new char[]&#123; &#x27; a &#x27; , &#x27; b&#x27; , &#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); <span class="comment">//char[] value = new char[16];底层创建了一个长度为16的字符数组</span></span><br><span class="line"></span><br><span class="line">System.out.println(sb1.Length());<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">sb1.append( <span class="string">&#x27;a&#x27;</span> ); <span class="comment">//value[e] = &#x27;a &#x27; ;</span></span><br><span class="line"></span><br><span class="line">sb1.append( <span class="string">&#x27;b&#x27;</span>); <span class="comment">//value[1] = &#x27;b &#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">stringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">//char[] value = new char[ &quot;abc &quot;.Length() + 16]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    sb1.setCharAt(<span class="number">0</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">    System.out.println(sb1); <span class="comment">// mbc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题1．System.out.printLn(sb2.Length());//3</p>
<p>问题2．</p>
<ul>
<li>扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</li>
<li>默认情况下，扩容为原来容量的2倍＋2，同时将原有数组中的元素复制到新的数组中。</li>
</ul>
<p>指导意义：开发中建议使用StringBuffer(int capacity) 或者StringBuilder(int capacity)</p>
  <mark class="hl-label blue">常用方法</mark> 
<p>StringBuffer的常用方法:</p>
<p>StringBuffer append(xxx):提供了很多的append()方法，用于进行字符串拼接</p>
<p>StringBuffer delete(int start,int end):删除指定位置的内容<br />
StringBuffer replace(int start, int end，String str):把[start,end)位置替换为str</p>
<p>StringBuffer insert(int offset， xxx):在指定位置插入xxx</p>
<p>StringBuffer reverse() :把当前字符序列逆转</p>
<p>public int indexof (String str)</p>
<p>public string substring(int start,int end)public int length()</p>
<p>public char charAt(int n )</p>
<p>public void setCharAt(int n ,char ch)</p>
<p>总结:</p>
<p>增: append(xxx)</p>
<p>删:delete(int start,int end)</p>
<p>改: setCharAt(int n ,char ch) / replace(int start，int end,String str)</p>
<p>查: charAt(int n )</p>
<p>插: insert(int offset, xxx)长度:Length();</p>
<p>遍历: for() + charAt() / tostring()</p>
<h2 id="日期和事件api"><a class="markdownIt-Anchor" href="#日期和事件api"></a> 日期和事件API</h2>
<h3 id="jdk8-以前"><a class="markdownIt-Anchor" href="#jdk8-以前"></a> JDK8 以前</h3>
<p>System类提供的public static long currentTimeMillis() 用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。<mark class="hl-label blue">此方法适用于计算时间差</mark> </p>
<p>计算世界时间的主要标准有:</p>
<blockquote>
<p>UTC(Coordinated Universal Time)</p>
<p>GMT(Greenwich Mean Time)</p>
<p>CST(Central Standard Time)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. System类中的currentTimeMillis()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差</span></span><br><span class="line">    <span class="comment">// 这个被称为时间戳</span></span><br><span class="line">    System.out.println(time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java.util.Date类</p>
<p>表示特定的时间，精确到毫秒</p>
<p>构造器:</p>
<blockquote>
<p>Date():使用无参构造器创建的对象可以获取本地当前时间。</p>
<p>Date(long date)</p>
</blockquote>
<p>常用方法</p>
<blockquote>
<p>getTime(): 返回自1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数。</p>
<p>toString():把此 Date对象转换为以下形式的 String: dow mon dd hh:mm:ss zzz yyyy其中: dow是一周中的某一天(Sun,Mon,Tue,Wed,Thu, Fri, Sat)，zzz是时间标准。</p>
<p>其它很多方法都过时了</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    java.util.Date类</span></span><br><span class="line"><span class="comment">        java.sql.Date类</span></span><br><span class="line"><span class="comment">    1. 两个构造器的使用</span></span><br><span class="line"><span class="comment">        &gt; 构造器一：Date(): 创建一个对应当前时间的Date对象</span></span><br><span class="line"><span class="comment">        &gt; 构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line"><span class="comment">    2. 两个方法的使用</span></span><br><span class="line"><span class="comment">        &gt; toString(): 显示当前的年月日时分秒</span></span><br><span class="line"><span class="comment">        &gt; getTime(): 获取当前Date对象对应的毫秒数。（时间戳）</span></span><br><span class="line"><span class="comment">    3. java.sql.Date对应着数据库中的日期类型的变量</span></span><br><span class="line"><span class="comment">        &gt; 如何实例化</span></span><br><span class="line"><span class="comment">        &gt; 如何将java.util.Date对象转换成java.sql.Date对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 构造器一：Date</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date1.toString()); <span class="comment">// Sat Jun 04 20:26:55 CST 2022</span></span><br><span class="line"></span><br><span class="line">        System.out.println(date1.getTime());  <span class="comment">// 1654345723604</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1654345723604L</span>);</span><br><span class="line">        System.out.println(date2.toString());  <span class="comment">//Sat Jun 04 20:28:43 CST 2022</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建java.sql.Date对象</span></span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">1654345723604L</span>);</span><br><span class="line">        System.out.println(date3); <span class="comment">// 2022-06-04</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如何将java.util.Date对象转换成java.sql.Date对象</span></span><br><span class="line"><span class="comment">         情况一： 父类强转化成子类，这种方法只限于父类时候子类的构造器创建的时候，父类才能强转成子类</span></span><br><span class="line"><span class="comment">                Date date4 = new java.sql.Date(1654345723604L);</span></span><br><span class="line"><span class="comment">                java.sql.Date date5 = (java.sql.Date) date4;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="comment">//        情况二：</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">date7</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date6.getTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  <mark class="hl-label blue">java.text.SimpleDateFormat类</mark> 
<blockquote>
<p>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</p>
<p>它允许进行  格式化:日期→文本、   解析:文本→日期</p>
<p>格式化:<br />
SimpleDateFormat() :默认的模式和语言环境创建对象</p>
<p>public SimpleDateFormat(String pattern):该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用:</p>
<p>public String format(Date date):方法格式化时间对象date</p>
<p>解析:</p>
<p>public Date parse(String source):从给定字符串的开始解析文本，以生成一个日期。</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    SimpleDateFormat的使用：SimpleDateFormat对日期Date类的格式化和解析</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    两个操作：</span></span><br><span class="line"><span class="comment">        1. 格式化： 日期 --&gt; 字符串</span></span><br><span class="line"><span class="comment">        2. 解析： 字符串 --&gt; 日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleDateFormat</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        格式化 日期 --&gt; 字符串</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date);  <span class="comment">//Sun Jun 05 16:38:56 CST 2022</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">        System.out.println(format); <span class="comment">// 2022/6/5 下午4:41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        解析：字符串--&gt; 日期</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2023/6/5 下午4:41&quot;</span>;</span><br><span class="line">        <span class="comment">// 这里面的str参数的格式一定要符合sdf中的参数的格式</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> sdf.parse(str);</span><br><span class="line">        System.out.println(date1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ********************</span></span><br><span class="line">        <span class="comment">// 如果我们想要自定义日期的格式的话，我们可以使用另外一种SimpleDateFormat的构造函数</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//      格式化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">format2</span> <span class="operator">=</span> sdf2.format(date);</span><br><span class="line">        System.out.println(format2);  <span class="comment">// 2022-06-05 04:57:28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        解析</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> sdf2.parse(<span class="string">&quot;2022-06-05 04:57:28&quot;</span>);</span><br><span class="line">        System.out.println(date2); <span class="comment">// Sun Jun 05 04:57:28 CST 2022</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
  <mark class="hl-label blue">java.util.Calendar(日历)类</mark> 
<blockquote>
<p>Calendar是一个抽象基类，主要完成日期字段之间相互操作的功能。</p>
<p>获取Calendar实例的方法</p>
<blockquote>
<p>使用Calendar.getlnstance()方法</p>
<p>调用了它的子类GregorianCalendar的构造器</p>
</blockquote>
<p>一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND</p>
<blockquote>
<p>public void set(int field,int value)</p>
<p>public void add(int field,int amount)</p>
<p>public final Date getTime()</p>
<p>public final void setTime(Date date)</p>
</blockquote>
<p>注意:</p>
<blockquote>
<p>获取月份时:一月是0，二月是1，以此类推，12月是11</p>
<p>获取星期时:周日是1，周二是2，。。。。周六是7让天下没有难学的技</p>
</blockquote>
</blockquote>
<h3 id="jdk8以后"><a class="markdownIt-Anchor" href="#jdk8以后"></a> JDK8以后</h3>
  <mark class="hl-label blue">新方法出现的背景</mark> 
<blockquote>
<p>Calendar 和Date的缺陷：</p>
<blockquote>
<p>可变性:像日期和时间这样的类应该是不可变的。</p>
</blockquote>
<blockquote>
<p>偏移性:Date中的年份是从1900开始的，而月份都从O开始。</p>
</blockquote>
<blockquote>
<p>格式化:格式化只对Date有用，Calendar则不行。</p>
</blockquote>
<blockquote>
<p>此外，它们也不是线程安全的;不能处理闰秒等。</p>
</blockquote>
</blockquote>
  <mark class="hl-label blue">新方法的优势</mark> 
<blockquote>
<p>Java8吸收了Joda-Time的精华，以一个新的开始为Java创建优秀的API。</p>
<p>新的 java.time 中包含了<mark class="hl-label blue">所有</mark> 关于:</p>
<blockquote>
<p>本地日期(LocalDate)</p>
<p>本地时间(LocalTime)、</p>
<p>本地日期时间(LocalDateTime)、</p>
<p>时区(ZonedDateTime)</p>
<p>持续时间（Duration）的类</p>
</blockquote>
<p>历史悠久的 Date类新增了tolnstant()方法，用于把 Date转换成新的表示形式。这些新增的本地化时间П期API大大简化了日期时间和本地化的管理。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">now()/* now(Zoneld zone)</td>
<td style="text-align:center">静态方法，根据当前时间创建对象/指定时区的对象</td>
</tr>
<tr>
<td style="text-align:center">of()</td>
<td style="text-align:center">静态方法，根据指定日期/时间创建对象</td>
</tr>
<tr>
<td style="text-align:center">getDayOfMonth(getDayOfYear()</td>
<td style="text-align:center">获得月份天数(1-31)/获得年份天数(1-366)</td>
</tr>
<tr>
<td style="text-align:center">getDayofWeek()</td>
<td style="text-align:center">获得星期几(返回一个 DayOfWeek枚举值)</td>
</tr>
<tr>
<td style="text-align:center">getMonth()</td>
<td style="text-align:center">获得月份,返回一个Month 枚举值</td>
</tr>
<tr>
<td style="text-align:center">getMonthvalue()/getYear()</td>
<td style="text-align:center">获得月份(1-12)/获得年份</td>
</tr>
<tr>
<td style="text-align:center">getHouro/getMinute0getSecond()</td>
<td style="text-align:center">获得当前对象对应的小时、分钟、秒</td>
</tr>
<tr>
<td style="text-align:center">withDayOfMonth()/ withDayOfYear()/withMonth() / <br />withYear()</td>
<td style="text-align:center">将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td>
</tr>
<tr>
<td style="text-align:center">plusDays(0), plusWeeks(),<br />plusMonths(). plusYears(),plusHours()</td>
<td style="text-align:center">向当前对象添加几天、几周、几个月、几年、几小时</td>
</tr>
<tr>
<td style="text-align:center">minusMonths()/minusWeeks()<br />minusDays()/minusYears()/minusHours()</td>
<td style="text-align:center">从当前对象减去几月、几周、几天、几年、几小时</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*LocalDate, LocalTime, localDateTime 的使用*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">// now():获取当前的日期，时间，日期+时间</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDate);  <span class="comment">// 2022-06-05</span></span><br><span class="line">    System.out.println(localTime);  <span class="comment">// 20:17:38.535561</span></span><br><span class="line">    System.out.println(localDateTime);  <span class="comment">// 2022-06-05T20:17:38.535561</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// of 设置指定的年月日时分秒，是没有偏移量的</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2023</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">36</span>);</span><br><span class="line">    System.out.println(localDateTime1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getXxx</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfMonth());  <span class="comment">// 5</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfWeek());   <span class="comment">// SUNDAY</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfYear());   <span class="comment">// 156</span></span><br><span class="line">    System.out.println(localDateTime.getMinute());      <span class="comment">// 36</span></span><br><span class="line">    System.out.println(localDateTime.getMonth());       <span class="comment">// JUNE</span></span><br><span class="line">    System.out.println(localDateTime.getMonthValue());  <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可变性</span></span><br><span class="line">    <span class="comment">// withXxx 修改操作,修改后的数据返回，不会再当前数据上进行修改</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> localDate.withDayOfMonth(<span class="number">10</span>);</span><br><span class="line">    System.out.println(localDate1);  <span class="comment">// 2022-06-10</span></span><br><span class="line">    System.out.println(localDate);  <span class="comment">// 2022-06-05</span></span><br><span class="line">    <span class="comment">// 不可变性</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> localDateTime.plusMonths(<span class="number">3</span>);</span><br><span class="line">    System.out.println(localDateTime);  <span class="comment">// 2022-06-06T08:38:54.314172</span></span><br><span class="line">    System.out.println(localDateTime2); <span class="comment">// 2022-09-06T08:38:54.314172 在原先的基础上加上了三个月</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可变性</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime3</span> <span class="operator">=</span> localDateTime.minusDays(<span class="number">5</span>);</span><br><span class="line">    System.out.println(localDateTime);  <span class="comment">// 2022-06-06T08:41:01.993118100</span></span><br><span class="line">    System.out.println(localDateTime3); <span class="comment">// 2022-06-01T08:41:01.993118100  在原先的基础上减去了5天</span></span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<p>​</p>
<h3 id="瞬时instant类"><a class="markdownIt-Anchor" href="#瞬时instant类"></a> 瞬时：instant类</h3>
<p>Instant：时间线上的一个瞬时点，这个可能被用来记录应用程序中的事件时间戳</p>
<p>在处理时间和日期的时候，我们通常会想到年月日时分秒，这种记录时间的方法，这只是时间的一个模型，是面向人类的，第二种通用模式是面向机器的，或者说是连续处理的。在此模型中时间线中的一个点表示为一个很大的数，这也有利于计算机的处理。<mark class="hl-label blue">在UNIX中，这个数从1970年开始，以秒为单位；同样的，在java中也是从1970年开始，但是以毫秒为单位</mark> </p>
<mark class="hl-label red">java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。</mark> Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。
<pre><code>  1秒 = 1000毫秒 = $10^6$微妙 = $10^9$纳秒
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">now()</td>
<td style="text-align:center">静态方法，返回默认UTC时区的Instant类的对象</td>
</tr>
<tr>
<td style="text-align:center">ofEpochMilli(long epochMilli)</td>
<td style="text-align:center">静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象</td>
</tr>
<tr>
<td style="text-align:center">atOffset(ZoneOffset offset)</td>
<td style="text-align:center">结合即时的偏移来创建一个 OffsetDateTime</td>
</tr>
<tr>
<td style="text-align:center">toEpochMilli()</td>
<td style="text-align:center">返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  /*</span><br><span class="line">      instant 的实现</span><br><span class="line">  */</span><br><span class="line">  @Test</span><br><span class="line">  public void test2()&#123;</span><br><span class="line">      // now():获取本初子午线对应的标准时间</span><br><span class="line">      Instant instant = Instant.now();</span><br><span class="line">      System.out.println(instant);  // 2022-06-06T01:07:48.803375600Z</span><br><span class="line">  </span><br><span class="line">      // 添加时间的偏移量</span><br><span class="line">      OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));</span><br><span class="line">      System.out.println(offsetDateTime);  // 2022-06-06T09:07:48.803375600+08:00</span><br><span class="line">  </span><br><span class="line">      // 获取当前时间到1970年1月1日0时0分0秒开始的毫秒数</span><br><span class="line">      long milli = instant.toEpochMilli();</span><br><span class="line">      System.out.println(milli);  // 1654477841232</span><br><span class="line">  </span><br><span class="line">      // ofEpochMilli() 通过给定的毫秒数获取指定时间</span><br><span class="line">      Instant instant1 = Instant.ofEpochMilli(1654477841232L);</span><br><span class="line">      System.out.println(instant1);  // 2022-06-06T01:10:41.232Z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​<br />
​</p>
<h3 id="格式化与解析日期或时间"><a class="markdownIt-Anchor" href="#格式化与解析日期或时间"></a> 格式化与解析日期或时间</h3>
<p>java.time.format.Date.TimeFormatter 类：该类提供了三种格式化方法</p>
<p>方式一：预定义的标准格式</p>
<blockquote>
<p>ISO_LOCAL_DATE_TIME;</p>
<p>ISO_LOCAL_DATE;</p>
<p>ISO_LOCAL_TIME</p>
</blockquote>
<p>方式二：本地化相关格式：</p>
<blockquote>
<p>ofLocalizedDateTime()</p>
<blockquote>
<p>FormatStyle.LONG</p>
<p>FormatStyle.MEDIUM</p>
<p>FormatStyle.SHORT : 适用于LocalDateTime</p>
</blockquote>
<p>ofLocalizedDate()</p>
<blockquote>
<p>FormatStyle.FUL</p>
<p>FormatStyle.LONG</p>
<p>FormatStyle.MEDIUM</p>
<p>FormatStyle.SHORT: 适用于LocalDate</p>
</blockquote>
</blockquote>
<p>自定义格式：如ofPattern(&quot;yyyy-MM-dd hh-mm-ss &quot;)</p>
<p>方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ofPattern(String pattern)</td>
<td style="text-align:center">静态方法，返回一个指定字符串格式的DateTimeFormatter</td>
</tr>
<tr>
<td style="text-align:center">format(TemporaAccessor t)</td>
<td style="text-align:center">格式化一个日期，时间，返回字符串</td>
</tr>
<tr>
<td style="text-align:center">parse(CharSequence text)</td>
<td style="text-align:center">将指定格式的字符串序列解析为一个日期，时间</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"> ```java</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     DateTimeFormatter:格式化或解析日期，时间</span></span><br><span class="line"><span class="comment">     类似于SimpleDateFormat</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">// 创建类的三种方法</span></span><br><span class="line"> <span class="comment">// 方法一：预定义的标准格式ISO_LOCAL_DATE_TIME; ISO_LOCAL_DATE;ISO_LOCAL_TIME</span></span><br><span class="line">         <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">         <span class="comment">//格式化 日期--&gt; 字符串</span></span><br><span class="line">         <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">         <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> formatter.format(localDateTime);</span><br><span class="line">         System.out.println(localDateTime); <span class="comment">// 2022-06-06T09:39:46.721840900</span></span><br><span class="line">         System.out.println(str);  <span class="comment">// 2022-06-06T09:39:46.7218409 由于是标准形式结果差不多</span></span><br><span class="line">         <span class="comment">// 解析：字符串---&gt; 日期</span></span><br><span class="line">         <span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> formatter.parse(<span class="string">&quot;2022-06-06T09:39:46.7218409&quot;</span>);</span><br><span class="line">         System.out.println(parse);  <span class="comment">// &#123;&#125;,ISO resolved to 2022-06-06T09:39:46.721840900</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 方法二：</span></span><br><span class="line"> <span class="comment">//        ofLocalizedDateTime</span></span><br><span class="line"> <span class="comment">//        FormatStyle.LONG/ FormatStyle.MEDIUM /FormatStyle.SHORT : 适用于LocalDateTime</span></span><br><span class="line">         <span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">         <span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM);</span><br><span class="line">         <span class="type">DateTimeFormatter</span> <span class="variable">formatter3</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 格式化</span></span><br><span class="line"> <span class="comment">//        String str1 = formatter1.format(localDateTime);</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> formatter2.format(localDateTime);</span><br><span class="line">         <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> formatter3.format(localDateTime);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">//        System.out.println(str1);</span></span><br><span class="line">         System.out.println(str2); <span class="comment">// 2022年6月6日 上午9:50:40</span></span><br><span class="line">         System.out.println(str3); <span class="comment">// 2022/6/6 上午9:50</span></span><br><span class="line">         <span class="comment">//        ofLocalizedDate0</span></span><br><span class="line">         <span class="comment">//        FormatStyle.FULL/ FormatStyle.LONG/ FormatStyle.MEDIUM /FormatStyle.SHORT: 适用于LocalDate</span></span><br><span class="line">         <span class="type">DateTimeFormatter</span> <span class="variable">formatter4</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG);</span><br><span class="line"></span><br><span class="line">         <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> formatter4.format(LocalDate.now());</span><br><span class="line">         System.out.println(str4);  <span class="comment">// 2022年6月6日</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 方法三：自定义格式：如ofPattern(&quot;yyyy-MM-dd hh-mm-ss&quot;)</span></span><br><span class="line">         <span class="type">DateTimeFormatter</span> <span class="variable">formatter5</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 格式化</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> formatter5.format(LocalDateTime.now());</span><br><span class="line">         System.out.println(str5);  <span class="comment">// 2022-06-06 10:01:59</span></span><br><span class="line">         <span class="comment">// 解析</span></span><br><span class="line">         <span class="type">TemporalAccessor</span> <span class="variable">parse1</span> <span class="operator">=</span> formatter5.parse(<span class="string">&quot;2022-06-06 10:01:59&quot;</span>);</span><br><span class="line">         System.out.println(parse1); <span class="comment">// &#123;MicroOfSecond=0, MilliOfSecond=0, NanoOfSecond=0, HourOfAmPm=10, SecondOfMinute=59, MinuteOfHour=1&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​</p>
<h3 id="其他api"><a class="markdownIt-Anchor" href="#其他api"></a> 其他API</h3>
<p>Zoneld:该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris</p>
<p>ZonedDate Time:一个在ISO-8601日历系统时区的目期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。</p>
<blockquote>
<p>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如Asia/Shanghai等</p>
</blockquote>
<p>Clock:使用时区提供对当前即时、日期和时间的访问的时钟。</p>
<p>持续时间:Duration，用于计算两个“时间”间隔<br />
日期间隔:Period，用于计算两个“日期”间隔<br />
TemporalAdjuster :时间校正器。有时我们可能需要获取例如:将日期调整到“下一个工作日”等操作。<br />
TemporalAdjusters :该类通过静态方法</p>
<blockquote>
<p>(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster的实现。</p>
</blockquote>
<p>​<br />
​</p>
<h3 id="与传统的日期处理相互转换"><a class="markdownIt-Anchor" href="#与传统的日期处理相互转换"></a> 与传统的日期处理相互转换</h3>
<table>
<thead>
<tr>
<th style="text-align:center">类</th>
<th style="text-align:center">To遗留类</th>
<th style="text-align:center">From遗留类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">java.time.Instant与java.util.Date</td>
<td style="text-align:center">Date.from(instant)</td>
<td style="text-align:center">date.tolnstant()</td>
</tr>
<tr>
<td style="text-align:center">java.time.Instant与java.sql.Timestamp</td>
<td style="text-align:center">Timestamp.from(instant)</td>
<td style="text-align:center">timestamp tolnstant()</td>
</tr>
<tr>
<td style="text-align:center">java.time.ZonedDate Time与<br/>java.util.GregorianCalendar</td>
<td style="text-align:center">GregorianCalendar.from(zonedDateTime)</td>
<td style="text-align:center">cal.toZonedDateTime()</td>
</tr>
<tr>
<td style="text-align:center">java.time.LocalDate java.sqI.Time</td>
<td style="text-align:center">Date.valueOf(localDate)</td>
<td style="text-align:center">date.toLocalDate()</td>
</tr>
<tr>
<td style="text-align:center">java.time.Local Time与java.sql.Time</td>
<td style="text-align:center">Date.valueOf(localDate)</td>
<td style="text-align:center">date.toLocalTime()</td>
</tr>
<tr>
<td style="text-align:center">java.time.LocalDate Time与<br/>java.sql.Timestamp</td>
<td style="text-align:center">Timestamp.valueOf(localDateTime)</td>
<td style="text-align:center">timestamp.toLocalDateTime()</td>
</tr>
<tr>
<td style="text-align:center">java.time.Zoneld与java.util. TimeZone</td>
<td style="text-align:center">Timezone.getTimeZone(id)</td>
<td style="text-align:center">timeZone.toZoneld()</td>
</tr>
<tr>
<td style="text-align:center">java.time.format.Date TimeFormatter与java.text.DateFormat</td>
<td style="text-align:center">formatter.toFormat()</td>
<td style="text-align:center">无</td>
</tr>
</tbody>
</table>
<p>​</p>
<h2 id="java比较器"><a class="markdownIt-Anchor" href="#java比较器"></a> JAVA比较器</h2>
<p>一：说明：java中的 对象，正常情况下，只能比较==  或者!=。不能够使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小，如何实现？使用两个接口中的任意一个：comparable 或 comparator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Comparable接口的使用举例： 自然排序</span></span><br><span class="line"><span class="comment">  1. 像String，包装类实现了Comparable接口，重写了CompareTo（obj）方法，给出比较两个对象的方法</span></span><br><span class="line"><span class="comment">  2. 像String、包装类重写compareTo()方法以后，进行了从小到大的排列</span></span><br><span class="line"><span class="comment">  3. 重写compareTo(obj)的规则:</span></span><br><span class="line"><span class="comment">  如果当前对象this大于形参对象obj，则返回正整数，</span></span><br><span class="line"><span class="comment">  如果当前对象this小于形参对象obj，则返回负整数，</span></span><br><span class="line"><span class="comment">  如果当前对象this等于形参对象obj，则返回零。</span></span><br><span class="line"><span class="comment">  4. 对于自定义类来说，如果你想要进行排序的话，则需要实现Comparable接口，重写CompareTo(obj)方法</span></span><br><span class="line"><span class="comment">  在CompareTo中指明应该如何排序</span></span><br><span class="line"><span class="comment">  如果方法返回正整数，则表示大于;</span></span><br><span class="line"><span class="comment">  如果返回0，表示相等;</span></span><br><span class="line"><span class="comment">  返回负整数，表示小于。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;DD&quot;</span>, <span class="string">&quot;BB&quot;</span>&#125;;</span><br><span class="line">	Arrays.sort(arr);</span><br><span class="line">	System.out.println(Arrays.toString(arr));  <span class="comment">// [AA, BB, CC, DD, MM]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Comparator接口的使用：定制排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Comparator接口的使用:定制排序</span></span><br><span class="line"><span class="comment">1.背景:</span></span><br><span class="line"><span class="comment">当元素的类型没有实现java.Lang.Comparable接口而又不方便修改代码，</span></span><br><span class="line"><span class="comment">或者实现了java.Lang.comparable接口的排序规则不适合当前的操作，</span></span><br><span class="line"><span class="comment">那么可以考虑使用Comparator的对象来排序</span></span><br><span class="line"><span class="comment">2.重写compare(object o1,object o2)方法，比较o1和o2的大小:</span></span><br><span class="line"><span class="comment">如果方法返回正整数，则表示o1大于o2;</span></span><br><span class="line"><span class="comment">如果返回0，表示相等;</span></span><br><span class="line"><span class="comment">返回负整数，表示o1小于o2。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">	String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;DD&quot;</span>, <span class="string">&quot;BB&quot;</span>&#125;;</span><br><span class="line">	Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((o1 <span class="keyword">instanceof</span> String) &amp;&amp; (o2 <span class="keyword">instanceof</span> String))&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String) o1;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> (String) o2;</span><br><span class="line">        <span class="keyword">return</span> -s1.compareTo(s2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	System.out.println(Arrays.toString(arr)); <span class="comment">// [MM, DD, CC, BB, AA]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二：Comparable接口和Comparator的使用比较</p>
<p>Comparable接口的方式一旦确定，保证Comparable接口实现类的对象在任何位置都可以比较大小</p>
<p>Comparator接口属于临时性的比较</p>
<h2 id="system类math类biginteger与bigdecimal"><a class="markdownIt-Anchor" href="#system类math类biginteger与bigdecimal"></a> System类，Math类，BigInteger与BigDecimal</h2>
<h3 id="system类"><a class="markdownIt-Anchor" href="#system类"></a> System类</h3>
<ul>
<li>
<p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p>
</li>
<li>
<p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</p>
</li>
<li>
<p>成员变量</p>
</li>
</ul>
<blockquote>
<p>System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</p>
</blockquote>
<ul>
<li>成员方法</li>
</ul>
<blockquote>
<p>native long currentTimeMillis():</p>
<p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
<p>void exit(int status):<br />
该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。<mark class="hl-label red">使用该方法可以在图形界面编程中实现程序的退出功能等。</mark> </p>
<p>void gc():<br />
该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p>
<p>String getProperty(String key):<br />
该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示:</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">属性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">java.version</td>
<td style="text-align:center">java运行时环境版本</td>
</tr>
<tr>
<td style="text-align:center">java.home</td>
<td style="text-align:center">java的安装目录</td>
</tr>
<tr>
<td style="text-align:center"><a target="_blank" rel="noopener" href="http://os.name">os.name</a></td>
<td style="text-align:center">操作系统的名称</td>
</tr>
<tr>
<td style="text-align:center">os.version</td>
<td style="text-align:center">操作系统的版本</td>
</tr>
<tr>
<td style="text-align:center"><a target="_blank" rel="noopener" href="http://user.name">user.name</a></td>
<td style="text-align:center">用户账户的名称</td>
</tr>
<tr>
<td style="text-align:center">user,home</td>
<td style="text-align:center">用户主目录</td>
</tr>
<tr>
<td style="text-align:center">user.dir</td>
<td style="text-align:center">用户当前的工作目录</td>
</tr>
</tbody>
</table>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">javaVersion</span> <span class="operator">=</span> System.getProperty( <span class="string">&quot;java.version&quot;</span> );</span><br><span class="line">    System.out.println( <span class="string">&quot;java的version:&quot;</span> +javaVersion);</span><br><span class="line">    <span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> System.getProperty( <span class="string">&quot;java.home&quot;</span> );</span><br><span class="line">    System.out.println( <span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line">    <span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span> );</span><br><span class="line">    System. out.println( <span class="string">&quot;os的name: &quot;</span> +osName) ;</span><br><span class="line">    <span class="type">String</span> <span class="variable">osVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">    System.out.println( <span class="string">&quot;os的version:&quot;</span> +osVersion);</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> System.getProperty( <span class="string">&quot;user.name&quot;</span> );</span><br><span class="line">    System.out.println( <span class="string">&quot;user的name : &quot;</span> + userName) ;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userHome</span> <span class="operator">=</span> System.getProperty( <span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">    System.out.println( <span class="string">&quot;user的home : &quot;</span> + userHome);</span><br><span class="line">    <span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty( <span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">    System.out.println( <span class="string">&quot;user的dir:&quot;</span> + userDir) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java的version:17.0.1</span></span><br><span class="line"><span class="comment">java的home:G:\JAVA</span></span><br><span class="line"><span class="comment">os的name: Windows 10</span></span><br><span class="line"><span class="comment">os的version:10.0</span></span><br><span class="line"><span class="comment">user的name : Mr.zhang</span></span><br><span class="line"><span class="comment">user的home : C:\Users\Mr.zhang</span></span><br><span class="line"><span class="comment">user的dir:E:\JavaProject\CommonClasses\DateTime</span></span><br><span class="line"><span class="comment">*/</span>         </span><br></pre></td></tr></table></figure>
<h3 id="math类"><a class="markdownIt-Anchor" href="#math类"></a> Math类</h3>
<p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p>
<ol>
<li>abs绝对值</li>
<li>acos,asin,atan,cos,sin,tan三角函数sqrt平方根</li>
<li>pow(double a,doble b)a的b次幂log自然对数</li>
<li>expe为底指数</li>
<li>max(double a,double b)min(double a,double b)</li>
<li>random()返回0.0到1.0的随机数</li>
<li>long round(double a)double型数据a转换为long型（四舍五入)toDegrees(double angrad)弧度—&gt;角度</li>
<li>toRadians(double angdeg)角度—&gt;弧度<br />
​</li>
</ol>
<h3 id="biginteger类"><a class="markdownIt-Anchor" href="#biginteger类"></a> BigInteger类</h3>
<p>Integer类作为int的包装类，能存储的最大整型值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，Long类也是有限的，最大为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>63</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{63}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</p>
<p>java.math包的BigInteger<mark class="hl-label red">可以表示不可变的任意精度的整数</mark> 。BigInteger提供所有Java的基本整数操作符的对应物，并提供java.lang.Math 的所有相关方法。另外，BigInteger还提供以下运算:模算术、GCD计算、质数测试、素数生成、位操作以及一些其他操作。</p>
<p>构造器</p>
<p>Biglnteger(String val):根据字符串构建Biglnteger对象</p>
<p>常用方法：</p>
<p>public Biglnteger abs():返回此 BigInteger的绝对值的 BigInteger。</p>
<p>BigInteger add(BigInteger val):返回其值为(this + val)的 Biglnteger</p>
<p>BigInteger subtract(BigInteger val):返回其值为(this - val)的 BigInteger</p>
<p>BigInteger multiply(BigInteger val):返回其值为(this * val)的 BigInteger</p>
<p>BigInteger divide(BigInteger val):返回其值为(this / val)的 BigInteger。整数相除只保留整数部分。</p>
<p>BigInteger remainder(BigInteger val):返回其值为(this % val)的 BigInteger。</p>
<p>Biglnteger[]divideAndRemainder(BigInteger val):返回包含(this / val)后跟(this % val)的两个 BigInteger的数组。</p>
<p>BigInteger pow(int exponent):返回其值为(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><msup><mi>s</mi><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">this^{exponent}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7935559999999999em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span></span></span></span>)的 BigInteger。<br />
​</p>
<h3 id="bigdecimal类"><a class="markdownIt-Anchor" href="#bigdecimal类"></a> BigDecimal类</h3>
<p>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中要求数字精度比较高，故用到java.math.BigDecimal类。</p>
<p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p>
<p>构造器</p>
<p>public BigDecimal(double val)public BigDecimal(String val)</p>
<p>常用方法</p>
<p>public BigDecimal add(BigDecimal augend)</p>
<p>public BigDecimal subtract(BigDecimal subtrahend)</p>
<p>public BigDecimal multiply(BigDecimal multiplicand)</p>
<p>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</p>
<h1 id="枚举与注解"><a class="markdownIt-Anchor" href="#枚举与注解"></a> 枚举与注解</h1>
<h2 id="枚举类的使用"><a class="markdownIt-Anchor" href="#枚举类的使用"></a> 枚举类的使用</h2>
<p>枚举的定义：当一个类中的对象是<mark class="hl-label red">有限个，并且确定的</mark> 时候我们称其为枚举类</p>
<p>当需要定义一组常量的时候，强烈建议使用枚举类</p>
<p>枚举类的使用:</p>
<blockquote>
<p>枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</p>
<p>当我们需要定义一组常量的时候，强烈建议使用枚举类</p>
</blockquote>
<p>如何定义枚举类</p>
<blockquote>
<p>方式一：jdk5.0之前，自定义枚举类</p>
<p>方式二：jdk5.0之后，可以使用enum关键字定义枚举类</p>
</blockquote>
<p>方式一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">        System.out.println(spring);  <span class="comment">// Season&#123;seasonName=&#x27;春天&#x27;, seasonDesc=&#x27;万物复苏&#x27;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 声明Season对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    <span class="comment">// 2. 私有化的构造器，目的是为了能够确定类对象的个数</span></span><br><span class="line">    <span class="comment">// 通过构造器给对象赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName, String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供当前枚举类的多个对象 public static final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;万物复苏&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;烈日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰封万里&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 其他诉求：获取枚举类对象的属性和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season1.SUMMER;</span><br><span class="line">        System.out.println(summer);  <span class="comment">// SUMMER 没有重写toString方法，然后默认输出枚举类对象的名称</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明定义枚举类默认继承与java.lang.Enum</span></span><br><span class="line">        System.out.println(Season1.class.getSuperclass());  <span class="comment">// class java.lang.Enum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用enum关键字创建枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 提供当前枚举类的对象，多个对象之间使用“,”隔开，末尾对象使用&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;万物复苏&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;烈日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰封万里&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 声明Season1对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String Season1Name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String Season1Desc;</span><br><span class="line">    <span class="comment">// 2. 私有化的构造器，目的是为了能够确定类对象的个数</span></span><br><span class="line">    <span class="comment">// 通过构造器给对象赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String Season1Name, String Season1Desc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.Season1Desc = Season1Desc;</span><br><span class="line">        <span class="built_in">this</span>.Season1Name = Season1Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 其他诉求：获取枚举类对象的属性和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeason1Name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Season1Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeason1Desc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Season1Desc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    使用enum关键字创建的枚举类对象 不用重写toString方法，输出是枚举类对象的名称</span></span><br><span class="line"><span class="comment">//    toString方法</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public String toString() &#123;</span></span><br><span class="line"><span class="comment">//        return &quot;Season1&#123;&quot; +</span></span><br><span class="line"><span class="comment">//                &quot;Season1Name=&#x27;&quot; + Season1Name + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">//                &quot;, Season1Desc=&#x27;&quot; + Season1Desc + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">//                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Enum类的主要方法</p>
<blockquote>
<p>values()方法:返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</p>
<p>valueOf(String str):可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常:lllegalArgumentException。</p>
<p>toString():返回当前枚举类对象常量的名称</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season1.SUMMER;</span><br><span class="line">        <span class="comment">// toString</span></span><br><span class="line">        System.out.println(summer);  <span class="comment">// SUMMER 没有重写toString方法，然后默认输出枚举类对象的名称</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明定义枚举类默认继承与java.lang.Enum</span></span><br><span class="line">        System.out.println(Season1.class.getSuperclass());  <span class="comment">// class java.lang.Enum</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// values()</span></span><br><span class="line">        <span class="keyword">for</span> (Season1 value : Season1.values()) &#123;</span><br><span class="line">            System.out.println(value);  <span class="comment">// 结果 SPRING SUMMER AUTUMN WINTER</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread.State value : Thread.State.values()) &#123;</span><br><span class="line">            System.out.println(value); <span class="comment">// NEW RUNNABLE BLOCKED WAITING TIMED_WAITING TERMINATED 线程的几个状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// valueOf(String objName) : 返回枚举类中对象名为objName的对象，</span></span><br><span class="line">        <span class="comment">// 如果没有objName的枚举类对象，则抛异常IllegalArgumentException</span></span><br><span class="line">        <span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line">        System.out.println(winter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用enum关键字定义的枚举类实现接口的情况</p>
<ul>
<li>情况一：实现接口，在enum类中实现抽象方法</li>
<li>情况二：让枚举类的对象分别实现接口中的抽象方法</li>
</ul>
<h2 id="注解annotation"><a class="markdownIt-Anchor" href="#注解annotation"></a> 注解（Annotation）</h2>
<p>Annotation其实就是代码里的<mark class="hl-label red">特殊标记</mark> ,这些标记可以在编译,类加载,运行时被读取,并执行相应的处理。通过使用Annotation,程序员可以在不改变原有逻辑的情况下,在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p>
<p>Annotation可以像修饰符一样被使用,可用于修饰包,类,构造器,方法,成员变量,参数,局部变量的声明,这些信息被保存在Annotation的“name=value”对中。</p>
<p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</p>
<p>示例一：生成文档相关注解</p>
<blockquote>
<p>@author 表明开发该类的作者</p>
<p>@version 表明该类模块的版本</p>
<p>@see 参考转向也就是相关主题</p>
<p>@since 从那个版本开始增加的</p>
<p>@param 对方法中参数的说明</p>
<p>@return 方法的返回值</p>
<p>@exception 	对方法可能抛出的异常进行说明，如果方法中没有使用throws显示抛出异常，就不能写</p>
</blockquote>
<p>示例二：在编译时进行格式检查JDK内置的三个基本注解</p>
<blockquote>
<p>@Override:限定重写父类方法，该注解只能用于方法</p>
<p>@Deprecated：用于表示所修饰的元素已经过时。通常是因为所修饰的结构危险，或存在更好的选择</p>
<p>@SuppressWarnings：抑制编译器警告</p>
</blockquote>
<p>3．如何自定义注解:参照@Suppresswarnings定义</p>
<ul>
<li>
<p>注解声明为:@interface</p>
</li>
<li>
<p>内部定义成员，通常使用value表示</p>
</li>
<li>
<p>可以指定成员的默认值，使用default定义</p>
</li>
<li>
<p>如果自定义注解没有成员，表明是一个标识作用。</p>
</li>
<li>
<p>如果注解有成员，在使用注解时，需要指明成员的值。</p>
</li>
<li>
<mark class="hl-label red">自定义注解必须配上注解的信息流程（使用反射）才有意义</mark>   
</li>
<li>
<p>自定义注解通常都会指明两个元注解：Retention， Target</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>JDK中的元注解：</p>
<ul>
<li>
<p>JDK中的元Annotation 用于<mark class="hl-label red">修饰</mark> 其他Annotation定义</p>
</li>
<li>
<p>JDK5.0提供了4个标准的meta-annotation类型，分别是：</p>
<blockquote>
<p>Retention ：指定修饰Annotation的声明周期</p>
<blockquote>
<p>SOURCE</p>
<p>CLASS（默认行为）</p>
<p>RUNTIME：只有声明为RUNTIME声明周期的注解，才能通过反射获取。</p>
</blockquote>
<p>Target ：用于指定被修饰的Annotation能用于那些程序元素</p>
<p>Documented：表示所修饰的注解在被javadoc解析时保留下来</p>
<p>Inherited：被他修饰的Annotation注解将具有继承性</p>
</blockquote>
</li>
<li>
<p>通过反射获取注解信息</p>
</li>
</ul>
<p>JDK 8 中注解的新特性：可重复注解，类型注解</p>
<blockquote>
<p>可重复注解：</p>
<blockquote>
<p>MyAnnotation上声明@Repeatable，成员值为MyAnnotations.calss</p>
<p>MyAnnotation的Target和Retention等元注解与MyAnnotations相同</p>
</blockquote>
<p>类型注解：</p>
<blockquote>
<p>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量声明语句中（如：泛型声明）</p>
<p>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中</p>
</blockquote>
</blockquote>
<h1 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h1>
<h2 id="出现的背景"><a class="markdownIt-Anchor" href="#出现的背景"></a> 出现的背景</h2>
<p>一方面，面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有<mark class="hl-label red">一些弊端</mark> ，而Java集合就像一种容器，可以<mark class="hl-label red">动态</mark> 地把多个对象的引用放入<mark class="hl-label red">容器</mark> 中。</p>
<blockquote>
<p>数组在内存存储方面的特点:</p>
<blockquote>
<p>数组初始化以后，长度就确定了。</p>
<p>数组声明的类型，就决定了进行元素初始化时的类型</p>
</blockquote>
<p>数组在存储数据方面的弊端:</p>
<blockquote>
<p>数组初始化以后，长度就不可变了，不便于扩展</p>
<p>数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数</p>
<p>数组存储的数据是有序的、可以重复的。----&gt;存储数据的特点单一</p>
</blockquote>
</blockquote>
<p>Java集合类可以用于存储数量不等的多个对象，还可以保存具有映射关系的关联数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一，集合框架概述</span></span><br><span class="line"><span class="comment"> * 1.集合，数组都是对多个数据进行存储操作的结构，简称java容器</span></span><br><span class="line"><span class="comment"> *      说明:此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中</span></span><br><span class="line"><span class="comment"> * 2. 数组在存储多个数据方面的特点:</span></span><br><span class="line"><span class="comment"> *      1. 一旦初始化以后，其长度就确定了。</span></span><br><span class="line"><span class="comment"> *      2. 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。比如: String[ ] arr;int[ ] arr1;0bject[] arr2;</span></span><br><span class="line"><span class="comment"> * 3. 数组在存储多个数据方面的缺点:</span></span><br><span class="line"><span class="comment"> *      1. 一旦初始化以后，其长度就不可修改。</span></span><br><span class="line"><span class="comment"> *      2. 数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</span></span><br><span class="line"><span class="comment"> *      3. 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</span></span><br><span class="line"><span class="comment"> *      4. 数组存储数据的特点:有序、可重复。对于无序、不可重复的需求，不能满足。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 二， 集合框架</span></span><br><span class="line"><span class="comment"> *      /--------Collection接口：单列集合，用来存储一个一个的对象</span></span><br><span class="line"><span class="comment"> *          /------List接口：存储有序的，可重复的数据。 ---&gt;&quot;动态数组&quot;</span></span><br><span class="line"><span class="comment"> *          /-----ArrayList,LinkedList, Vector</span></span><br><span class="line"><span class="comment"> *      /-------Set接口：存储无序的，不可重复的数据</span></span><br><span class="line"><span class="comment"> *          /-----HashSet, LinkedHashSet, TreeSet</span></span><br><span class="line"><span class="comment"> *      /--------Map接口：双列集合，用来存储一对（key-value）的数据</span></span><br><span class="line"><span class="comment"> *          /-----HashMap, LinkedHashMap, TreeMap, Hashtable, Properties</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="collection"><a class="markdownIt-Anchor" href="#collection"></a> Collection</h2>
<mark class="hl-label size">add</mark> 
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// add(Object e) 将元素e添加到集合中</span></span><br><span class="line">       coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">       coll.add(<span class="number">123</span>);</span><br><span class="line">       coll.add(<span class="keyword">new</span> <span class="title class_">Date</span>());  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// size()：获取添加元素的个数</span></span><br><span class="line">       System.out.println(coll.size());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// addAll()</span></span><br><span class="line">       <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       coll1.add(<span class="string">&quot;DD&quot;</span>);</span><br><span class="line">       coll1.add(<span class="string">&quot;EE&quot;</span>);</span><br><span class="line">       coll.addAll(coll1);</span><br><span class="line"></span><br><span class="line">       System.out.println(coll.size()); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">       System.out.println(coll);  <span class="comment">// [AA, BB, CC, 123, Tue Jun 07 21:07:46 CST 2022, DD, EE]</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// clear():清空集合元素，只是把其中的元素清除干净了，但是这个集合依旧存在</span></span><br><span class="line">    	coll.clear();</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// isEmpty(): 判断当前集合是否为空</span></span><br><span class="line">    	coll.isEmpty();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Collection中其他的方法的测定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Collection接口中声明方法的测试</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">向Collection接口的实现类的对象中添加数据obj时，要求obj，所在类要重写equals</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Zhang&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">true</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. contains(Object obj) 判断当前集合中是否包含obj</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> coll.contains(<span class="number">123</span>);</span><br><span class="line">    System.out.println(contains);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Zhang&quot;</span>))); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 我们在判断时会调用obj对象所在类的equals();</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">21</span>))); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. containsAll(Collection coll1) 判断形参coll1中的所有元素是否都存在于当前集合中</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">    System.out.println(coll.containsAll(coll1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.remove(Object obj) 移除某一个元素</span></span><br><span class="line">    <span class="comment">// 如果该元素存在并且成功移除了，则返回ture</span></span><br><span class="line">    System.out.println(coll.remove(<span class="number">123</span>));  <span class="comment">// ture</span></span><br><span class="line">    System.out.println(coll);  <span class="comment">// [456, Zhang, true, Person&#123;name=&#x27;Tom&#x27;, age=21&#125;]</span></span><br><span class="line">    System.out.println(coll.remove(<span class="number">369</span>));  <span class="comment">// false</span></span><br><span class="line">    System.out.println(coll);  <span class="comment">// [456, Zhang, true, Person&#123;name=&#x27;Tom&#x27;, age=21&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.removeAll(Collection coll2) 从当前集合中移除coll2中的所有元素</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">21</span>), <span class="number">456</span>);</span><br><span class="line">    coll.removeAll(coll2);</span><br><span class="line">    System.out.println(coll);   <span class="comment">// [Zhang, true]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Zhang&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">true</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">21</span>));</span><br><span class="line">    <span class="comment">// 求交集，</span></span><br><span class="line">    <span class="comment">// 5. retainAll(Collection coll1) 将coll1中和当前集合中相同的元素提取出来</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>);</span><br><span class="line">    coll.retainAll(coll1);</span><br><span class="line">    System.out.println(coll);  <span class="comment">// [123, 456]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. equals(Object obj)方法，当且仅当当前集合和形参结合中的元素内容和顺序都一样的时候返回true</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll2.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">21</span>));</span><br><span class="line">    coll2.add(<span class="number">123</span>);</span><br><span class="line">    coll2.add(<span class="number">456</span>);</span><br><span class="line">    coll2.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Zhang&quot;</span>));</span><br><span class="line">    coll2.add(<span class="literal">true</span>);</span><br><span class="line">    System.out.println(coll.equals(coll2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Zhang&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">true</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.hashCode():返回当前对象的哈希值</span></span><br><span class="line">    System.out.println(coll.hashCode());  <span class="comment">// -1001820203</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.集合 ---&gt; 数组：toArray()</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : coll.toArray()) &#123;</span><br><span class="line">        System.out.println(o);  <span class="comment">// 123 456 Zhang true Person&#123;name=&#x27;Tom&#x27;, age=21&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组到集合</span></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">    System.out.println(strings);  <span class="comment">// [AA, BB, CC]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当你使用创建一个基本数据类型的数组转换成集合的时候，这时候集合会将这个数组识别成为一个元素</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">    System.out.println(arr1.size());  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果想要识别出两个元素的话，则需要使用包装类</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">122</span>, <span class="number">456</span>&#125;);</span><br><span class="line">    System.out.println(arr2.size());  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iterator的使用"><a class="markdownIt-Anchor" href="#iterator的使用"></a> Iterator的使用</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">集合元素的便利操作，使用迭代器Iterator接口</span></span><br><span class="line"><span class="comment">内部方法：hasNext() 和 next()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Zhang&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">true</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasNext() 判断是否还有下一个元素</span></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">// next(), ①指针下移 ②将下移以后集合位置上的元素返回</span></span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试Iterator中的remove方法</span></span><br><span class="line"><span class="comment">// 如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Zhang&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">true</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除集合中的Tom</span></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="foreach"><a class="markdownIt-Anchor" href="#foreach"></a> foreach</h3>
<p>jdk5.0新增了foreach循环（增强for循环），用于遍历集合，数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Zhang&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">true</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for( 集合(数组)元素的类型 局部变量 ：集合(数组)对象)</span></span><br><span class="line">    <span class="comment">// 内部仍然调用的迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="list接口"><a class="markdownIt-Anchor" href="#list接口"></a> List接口</h3>
<p>List接口：存储有序的，可重复的数据。 —&gt;“动态数组”</p>
<ul>
<li>
<p>ArrayList</p>
</li>
<li>
<p>LinkedList</p>
</li>
<li>
<p>Vector</p>
</li>
</ul>
<p>ArrayList，LinkedList，Vector三者的异同</p>
<p>相同点：三个类都实现了List的接口，存储数据的特点相同：存储有序的，可重复的数据</p>
<p>不同点：</p>
<ul>
<li>ArrayList：作为list接口的主要实现类。线程不安全的，效率高， 底层使用Object[] elementData存储（数组）</li>
<li>LinkedList：对于频繁使用插入和删除操作的集合，此类比使用ArrayList效率高，底层使用双向链表存储</li>
<li>Vector：作为list接口的古老实现类；线程安全的，效率低，底层使用Object[] elementData存储（数组）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ArrayList源码分析：</span></span><br><span class="line"><span class="comment"> *      jdk7的情况下：</span></span><br><span class="line"><span class="comment"> *          ArrayList list = new ArrayList(); // 底层创建了长度为10的Object[] 数组elementData</span></span><br><span class="line"><span class="comment"> *          list.add(123);  // elementData[0] = new Integer(123);</span></span><br><span class="line"><span class="comment"> *          ...</span></span><br><span class="line"><span class="comment"> *          list.add(11);   // 如果此次的添加导致底层的elementData数组容量不够。则扩容</span></span><br><span class="line"><span class="comment"> *          默认情况下：扩容为原来容量的1.5倍， 同时需要将原有的数组中的数据复制到新的数组中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</span></span><br><span class="line"><span class="comment"> *     jdk8的中ArrayList变化</span></span><br><span class="line"><span class="comment"> *          ArrayList list = new ArrayList(); // 底层Object elementData初始化为&#123;&#125;， 并没有创建长度为10的数组</span></span><br><span class="line"><span class="comment"> *          list.add(123); // 第一次调用add()的时候，底层才创建了长度为10的数组，并将数据123添加到elementData数组中</span></span><br><span class="line"><span class="comment"> *          ...</span></span><br><span class="line"><span class="comment"> *          后续的添加与扩容操作与jdk 7 无异</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  LinkedList源码分析：</span></span><br><span class="line"><span class="comment"> *      LinkList list = new LinkList(); // 内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line"><span class="comment"> *      list.add(123);  // 将123封装到Node中，创建了Node对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      其中Node定义为一个双向节点</span></span><br><span class="line"><span class="comment"> *  Vector的源码分析：jdk7个jdk8中通过Vector()构造器创建对象的时候，底层都创建了长度为10的数组，在扩容方面，</span></span><br><span class="line"><span class="comment"> *      默认扩容为原来的数组长度的2倍</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  List接口中的常用方法</span></span><br><span class="line"><span class="comment"> *      void add(int index, object ele):在index位置插入eLe元素</span></span><br><span class="line"><span class="comment"> *      boolean addAll(int index, collection eles): 从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line"><span class="comment"> *      Object get(int index):获取指定index位置的元素</span></span><br><span class="line"><span class="comment"> *      int indexOf(object obj):返回obj在集合中首次出现的位置</span></span><br><span class="line"><span class="comment"> *      int lastIndexOf(object obj):返回obj在当前集合中末次出现的位置</span></span><br><span class="line"><span class="comment"> *      Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line"><span class="comment"> *      Object set(int index，object ele):设置指定index位置的元素为eLe</span></span><br><span class="line"><span class="comment"> *      List sublist(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    void add(int index, object ele):在index位置插入eLe元素</span></span><br><span class="line"><span class="comment">    boolean addAll(int index, collection eles): 从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line"><span class="comment">    Object get(int index):获取指定index位置的元素</span></span><br><span class="line"><span class="comment">    int indexOf(object obj):返回obj在集合中首次出现的位置</span></span><br><span class="line"><span class="comment">    int lastIndexOf(object obj):返回obj在当前集合中末次出现的位置</span></span><br><span class="line"><span class="comment">    Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line"><span class="comment">    Object set(int index，object ele):设置指定index位置的元素为eLe</span></span><br><span class="line"><span class="comment">    List sublist(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="number">456</span>);</span><br><span class="line">        list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">21</span>));</span><br><span class="line">        list.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);  <span class="comment">// [123, 456, AA, Person&#123;name=&#x27;Tom&#x27;, age=21&#125;, 456]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//void add(int index, object ele):在index位置插入eLe元素</span></span><br><span class="line">        list.add(<span class="number">1</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        System.out.println(list);  <span class="comment">// [123, BB, 456, AA, Person&#123;name=&#x27;Tom&#x27;, age=21&#125;, 456]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean addAll(int index, collection eles): 从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>);</span><br><span class="line">        list.addAll(list1);</span><br><span class="line">        System.out.println(list.size()); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object get(int index):获取指定index位置的元素</span></span><br><span class="line">        System.out.println(list.get(<span class="number">5</span>));  <span class="comment">// 456</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int indexOf(object obj):返回obj在集合中首次出现的位置，如果没有找到的话则返回-1</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="number">456</span>)); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;CC&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int lastIndexOf(object obj):返回obj在当前集合中末次出现的位置</span></span><br><span class="line">        System.out.println(list); <span class="comment">// [123, BB, 456, AA, Person&#123;name=&#x27;Tom&#x27;, age=21&#125;, 456, 123, 456, 789]</span></span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="number">456</span>)); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        System.out.println(list);   <span class="comment">// [123, BB, 456, AA, Person&#123;name=&#x27;Tom&#x27;, age=21&#125;, 456, 123, 456, 789]</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(obj);    <span class="comment">// 123</span></span><br><span class="line">        System.out.println(list);   <span class="comment">// [BB, 456, AA, Person&#123;name=&#x27;Tom&#x27;, age=21&#125;, 456, 123, 456, 789]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object set(int index，object ele):设置指定index位置的元素为eLe</span></span><br><span class="line">        list.set(<span class="number">1</span>, <span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// [BB, CC, AA, Person&#123;name=&#x27;Tom&#x27;, age=21&#125;, 456, 123, 456, 789]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  List sublist(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> list.subList(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 左闭右开</span></span><br><span class="line">        System.out.println(list2); <span class="comment">// [AA, Person&#123;name=&#x27;Tom&#x27;, age=21&#125;]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>常用方法：</p>
<ul>
<li>增：add(Object obj)</li>
<li>删：remove(int index) / remove(Object obj)</li>
<li>改：set(int index, Object ele)</li>
<li>查：get(int index)</li>
<li>插：add(int index, Object obj)</li>
<li>长度：size()</li>
<li>遍历：①Iterator迭代器方式 ②增强for循环， ③普通循环</li>
</ul>
<h3 id="set接口"><a class="markdownIt-Anchor" href="#set接口"></a> set接口</h3>
<p>set中没有额外定义的新的方法，使用的都是Collection中声明的过的方法</p>
<p>要求：</p>
<p>​	向Set中添加数据，其所在类一定要重写equals和hashCode这两个方法</p>
<p>​	重写hashCode() 和equals() 尽可能的保持一致：相同的对象，必须有相同的散列码</p>
<p>set接口：<mark class="hl-label red">存储无序的，不可重复的数据</mark> </p>
<ul>
<li>hashSet：作为set接口中的主要实现类，线程不安全；可以存储null值
<ul>
<li>LinkedHashSet：作为hashSet的子类；在遍历数据的时候，可以按照添加的顺序遍历</li>
</ul>
</li>
<li>TreeSet：可以按照添加对象的指定属性，进行排序</li>
</ul>
<p>hashSet</p>
<p>一：Set：存储无序的，不可重复的数据，以Hashset为例说明</p>
<p>​	无序性 :不等于随机性， 存储的数据，在底层数组中并非按照数组索引的顺序添加的，而是根据数据的哈希值进行添加的</p>
<p>​	不可重复性：保证添加的元素按照equals()进行判断的时候，不能返回true，即：相同的元素只能有一个</p>
<p>二：添加元素的过程，以HashSet为例</p>
<p>​	我们向HashSet中添加元素a，首先调用元素a的HashSet方法获取hashCode()方法，计算元素a的hash值此Hash值通过某种计算方法，算出在HashSet底层数组中的存放位置(即：索引位置)，判断此数组位置上是否有其他元素：</p>
<p>​		如果此位置上没有其他元素的话，则直接插入    -----情况一</p>
<p>​		如果此位置上有元素b（或以链表形式存放的多个元素），则比较元素a和b的hash值是否相同</p>
<p>​			如果不相同的话则直接插入，</p>
<p>​			如果相同的话，则需要调用元素a的equals方法：</p>
<p>​				equals返回false ，则a可以插入      ---- 情况二</p>
<p>​				equals返回true，则a不可以插入       ---- 情况三</p>
<p>对于添加成功的情况二和三；元素a以链表的形式在指定位置的索引上插入。</p>
<p>jdk7：元素a放在当前数组中，指向原来的数据</p>
<p>jdk8：原来的元素位置不变，指向元素a</p>
<p>总结：七上八下</p>
<p>HashSet底层：数组 + 链表的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    set.add(<span class="number">123</span>);</span><br><span class="line">    set.add(<span class="number">456</span>);</span><br><span class="line">    set.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">    set.add(<span class="number">129</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkHashSet的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkHashSet的使用</span></span><br><span class="line"><span class="comment">// LinkHashSet作为HashSet的子类，再添加数据的同时，每个数据还维护了两个引用，记录此数据的前一个和后一个元素</span></span><br><span class="line"><span class="comment">// 优点：对于频繁的便利操作，LinkedHashSet效率高于HashSet</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">    set.add(<span class="number">123</span>);</span><br><span class="line">    set.add(<span class="number">456</span>);</span><br><span class="line">    set.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">    set.add(<span class="number">129</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TreeSet的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 向TreeSet中添加数据，要求是相同类的对象</span></span><br><span class="line"><span class="comment">    2. 两种排序方式：自然排序（Comparable）和定制排序（Comparator）</span></span><br><span class="line"><span class="comment">    3. 在自然排序中，比较两个对象是否相同的标准为：compareTo()返回值0， 不再是equals</span></span><br><span class="line"><span class="comment">    4. 在定制排序中, 比较两个对象是否相同的标准为，compare()返回值0， 不再是equals</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"><span class="comment">//        失败，不能添加不同类的对象</span></span><br><span class="line"><span class="comment">//        set.add(123);</span></span><br><span class="line"><span class="comment">//        set.add(456);</span></span><br><span class="line"><span class="comment">//        set.add(&quot;AA&quot;);</span></span><br><span class="line"></span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="number">23</span>);</span><br><span class="line">        set.add(<span class="number">13</span>);</span><br><span class="line">        set.add(<span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next()); <span class="comment">// 13 , 23 ,123 ,1234 排好序的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定制排序</span></span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="comment">// 按照年龄从大到小排序</span></span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">                    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) o1;</span><br><span class="line">                    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> (Person) o2;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(p1.getAge(), p2.getAge());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(com);</span><br><span class="line"></span><br><span class="line">        set1.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        set1.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Mak&quot;</span>, <span class="number">6</span>));</span><br><span class="line">        set1.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Ao&quot;</span>, <span class="number">24</span>));</span><br><span class="line">        set1.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Fc&quot;</span>, <span class="number">56</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> set1.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator1.next());</span><br><span class="line"><span class="comment">//            按照年龄排好序的</span></span><br><span class="line"><span class="comment">//            Person&#123;name=&#x27;Mak&#x27;, age=6&#125;</span></span><br><span class="line"><span class="comment">//            Person&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br><span class="line"><span class="comment">//            Person&#123;name=&#x27;Ao&#x27;, age=24&#125;</span></span><br><span class="line"><span class="comment">//            Person&#123;name=&#x27;Fc&#x27;, age=56&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>测试：在List内去除重复的数字值，要求尽量简单</p>
<p>使用HashSet类的特性：不可重复性，来进行筛选，如果我们筛选的目标是自定义类的话，我们需要在自定义类的下面重写HashCode 和 equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title function_">duplicateList</span><span class="params">(List list)</span> &#123;</span><br><span class="line">	<span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">	set.addAl1(list);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(set);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>));list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>));</span><br><span class="line">    <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> duplicateList(list);</span><br><span class="line">    <span class="keyword">for</span> (object integer : list2) &#123;i</span><br><span class="line">    	System.out.print1n(integer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Set结构掌握：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">(&#123;</span></span><br><span class="line"><span class="params">    HashSet set = new Hashset()</span>;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>( id: <span class="number">1001</span>,name: <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>( id: <span class="number">1002</span>,name: <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正常通过hashCode值进行添加，无话可说</span></span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过地址值来修改元素，则set中的对应的地址值中的元素也随之改变</span></span><br><span class="line">    <span class="comment">// 但是使用remove的时候p1的Hash值已经改变了，所以p1对应位置没有元素，删除失败</span></span><br><span class="line">    p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">    set.remove(p1);</span><br><span class="line">    system.out.println(set);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加一个id和name都和p1相同的元素， 这时候虽然内部结构相同，</span></span><br><span class="line">    <span class="comment">// 但是p1存入的HashCode值是&quot;1001, &quot;AA&quot;&quot;的HashCode的值，</span></span><br><span class="line">    <span class="comment">// 虽然后来其中元素改变了，但是在set中存放的地址却没有改变</span></span><br><span class="line">    <span class="comment">// 所以id 和name都和p1相同的元素，还是可以添加到HashSet中的</span></span><br><span class="line">    set.add( <span class="keyword">new</span> <span class="title class_">Person</span>( id: <span class="number">1001</span>,name: <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个元素虽然和p1的HashCode的值相同，但是其中元素不同，</span></span><br><span class="line">    <span class="comment">// 使用equals的时候返回的不是一个元素，所以也可以添加进去</span></span><br><span class="line">    set.add ( <span class="keyword">new</span> <span class="title class_">Person</span>( id: <span class="number">1001</span>，name: <span class="string">&quot;AA&quot;</span> ));</span><br><span class="line">    System.out.print1n(set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h2>
<p>DEFAULT_INITIAL_CAPACITY : 	HashMap的默认容量，16</p>
<p>MAXIMUM_CAPACITY : 	HashMap的最大支持容量，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>DEFAULT_LOAD_FACTOR:	HashMap的默认加载因子</p>
<p>TREEIFY_THRESHOLD:	Bucket中链表长度大于该默认值，转化为红黑树</p>
<p>UNTREEIFY_THRESHOLD: 	Bucket中红黑树存储的Node小于该默认值，转化为链表</p>
<p>MIN_TREEIFY_CAPACITY:	桶中的Node被树化时最小的hash表容量。(当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。)</p>
<p>table:存储元素的数组，总是2的n次幂</p>
<p>entrySet:存储具体元素的集</p>
<p>size: HashMap中存储的键值对的数量</p>
<p>modCount: HashMap扩容和结构改变的次数。</p>
<p>threshold:扩容的临界值，=容量*填充因子</p>
<p>loadFactor:填充因子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一，Map实现类的结构</span></span><br><span class="line"><span class="comment"> *      /-----Map:双列数据。存储Key-Value对的数据</span></span><br><span class="line"><span class="comment"> *          /----HashMap:作为Map的主要实现类；线程不安全，效率高；可以存储null的key和value</span></span><br><span class="line"><span class="comment"> *              /----LinkedHashMap：保证在遍历map元素的时候，可以按照添加的顺序实现遍历。</span></span><br><span class="line"><span class="comment"> *                  原因：在原有的HashMap底层结构上，添加了一对指针，指向前一个和后一个，</span></span><br><span class="line"><span class="comment"> *                  对于频繁的遍历操作，此执行效率高于HashMap</span></span><br><span class="line"><span class="comment"> *          /----TreeMap：保证按照添加的Key-Value对进行操作，实现排序遍历，此时考虑自然排序和定制排序，</span></span><br><span class="line"><span class="comment"> *                      底层使用红黑树</span></span><br><span class="line"><span class="comment"> *          /----Hashtable: 作为古老的实现类；线程安全，效率低；不能存储null的key和value</span></span><br><span class="line"><span class="comment"> *              /----Properties:常用来处理配置文件，key和value都是String类型的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *      HashMap的底层：数组 + 链表 (jdk7以前)</span></span><br><span class="line"><span class="comment"> *      数组 + 链表 + 红黑树 (jdk8)</span></span><br><span class="line"><span class="comment"> *  面试题：</span></span><br><span class="line"><span class="comment"> *      1. HashMap的底层实现原理？</span></span><br><span class="line"><span class="comment"> *      2. HashMap和 Hashtable 的异同？</span></span><br><span class="line"><span class="comment"> *      3. CurrentHashMap 和 Hashtable 的异同？</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  二，Map结构的理解</span></span><br><span class="line"><span class="comment"> *      Map中的key：无序的，不可重复的，使用Set存储所有的key ---&gt; key所在的类需要重写equals()和hashCode()方法</span></span><br><span class="line"><span class="comment"> *      Map中的value：无序的，可重复的，使用Collection存储所有的value ---&gt; value所在的类需要重写equals()</span></span><br><span class="line"><span class="comment"> *          一个键值对：key-value构成了一个Entry对象。</span></span><br><span class="line"><span class="comment"> *      Map中的entry：无序的，不可重复的，使用Set对象存储所有的entry</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> * 三，HashMap的底层实现原理？</span></span><br><span class="line"><span class="comment"> *      HashMap map = new HashMap():</span></span><br><span class="line"><span class="comment"> *      在实例化之后，底层创建了长度为16的一维数组Entry[] table</span></span><br><span class="line"><span class="comment"> *      ...在执行过几次put之后...</span></span><br><span class="line"><span class="comment"> *      map.put(key1, value1):</span></span><br><span class="line"><span class="comment"> *      首先，调用key1所在类的hashCode() 计算key1的hash值，次hash值经过某种算法计算之后，得到Entry数组中的存放位置</span></span><br><span class="line"><span class="comment"> *          如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1</span></span><br><span class="line"><span class="comment"> *          如果此位之上的数据不为空(意味着，此位之上存在着一个或者多个数据(以链表的形式存在)),比较key1和已经存在的一个或者多个数据的Hash值</span></span><br><span class="line"><span class="comment"> *              如果key1的hash值与已经存在的数据的hash值都不相同，此时key1-value1添加成功。 ----情况2</span></span><br><span class="line"><span class="comment"> *              如果key1的hash值和已经存在的某个数据(key2 - value2)的hash值相同，继续比较：调用key1所在类的equals(key2)</span></span><br><span class="line"><span class="comment"> *                  如果equals()返回false：此时key1-value1添加成功。 ----情况3</span></span><br><span class="line"><span class="comment"> *                  如果equals()返回true：使用value1替换value2</span></span><br><span class="line"><span class="comment"> *      补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      在不断的添加过程中，会涉及到扩容问题，当超出临界值(且存放的位置非空)时，扩容，默认的扩容方式：扩容为原来的两倍，并将原有的数据复制过来。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *      jdk8 相较于 jdk7在底层实现方面的不同：</span></span><br><span class="line"><span class="comment"> *          1. new HashMap():底层没有创建，一个长度为16的数据</span></span><br><span class="line"><span class="comment"> *          2. jdk8底层数组是：Node[], 而非Entry</span></span><br><span class="line"><span class="comment"> *          3. 首次调用put()方法的时候，底层创建长度为16的数组</span></span><br><span class="line"><span class="comment"> *          4. jdk7底层结构只有：数组+链表，jdk8中底层结构：数组 + 链表 + 红黑树、</span></span><br><span class="line"><span class="comment"> *      当数组某一个索引位置上的元素以链表的形式存在的个数 &gt; 8 且当前数组的长度 &gt; 64的时候</span></span><br><span class="line"><span class="comment"> *          此时此索引位置所有数据改用红黑树存储，方便查找</span></span><br><span class="line"><span class="comment"> *          </span></span><br><span class="line"><span class="comment"> *      DEFAULT_INITIAL__CAPACITY : HashMap的默认容量，16</span></span><br><span class="line"><span class="comment"> *      DEFAULT_LOAD_FACTOR: HashMap的默认加载因子:0.75</span></span><br><span class="line"><span class="comment"> *      threshold:扩容的临界值，=容量*填充因子:16* 0.75 =&gt;12</span></span><br><span class="line"><span class="comment"> *      TREEIFY_THRESHOLD: Bucket中链表长度大于该默认值，转化为红黑树:8</span></span><br><span class="line"><span class="comment"> *      MIN_TREETFY_CAPACITY:桶中的Node被树化时最小的hash表容量:64</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> * 四，LinkedHashMap底层实现原理(了解)</span></span><br><span class="line"><span class="comment"> *      源码中:</span></span><br><span class="line"><span class="comment"> *      static class Entry&lt;K,V&gt; extends HashMap. Node&lt;K,V&gt; &#123;</span></span><br><span class="line"><span class="comment"> *          Entry&lt;K,V&gt; before, after;//能够记录添加的元素的先后顺序</span></span><br><span class="line"><span class="comment"> *          Entry(int hash，K key, v value，Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment"> *              super( hash,key, value, next);</span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> * 五：一些操作方法：</span></span><br><span class="line"><span class="comment"> *  添加，删除，修改操作</span></span><br><span class="line"><span class="comment"> *      Object put(Object key, Object value): 将指定的key - value添加到（或修改）当前的map对象中</span></span><br><span class="line"><span class="comment"> *      void putAll(Map m): 将m中的所有的key-value对存放到当前map中</span></span><br><span class="line"><span class="comment"> *      Object remove(Object key): 移除指定的key的key-value对，并返回value</span></span><br><span class="line"><span class="comment"> *      void clear(),  清空当前map中的所有数据</span></span><br><span class="line"><span class="comment"> *  元素查询的相关操作：</span></span><br><span class="line"><span class="comment"> *      Object get(Object key): 获取指定key对应的value</span></span><br><span class="line"><span class="comment"> *      boolean containsKey(Object key):  是否包含指定的key</span></span><br><span class="line"><span class="comment"> *      boolean containValue(Object value):  是否包含指定的value</span></span><br><span class="line"><span class="comment"> *      int size();     返回map中key-value对的个数</span></span><br><span class="line"><span class="comment"> *      boolean isEmpty():  判断当前map是否为空</span></span><br><span class="line"><span class="comment"> *      boolean equals(Object obj): 判断当前map和参数对象obj是否相等</span></span><br><span class="line"><span class="comment"> *  元视图的操作方法</span></span><br><span class="line"><span class="comment"> *      Set keySet() : 返回所有的key构成的set集合</span></span><br><span class="line"><span class="comment"> *      Collection values(): 返回所有的value构成的集合</span></span><br><span class="line"><span class="comment"> *      Set entrySet(): 返回所有key - value构成的set集合</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> * 总结：常用方法</span></span><br><span class="line"><span class="comment"> * 增: put(Object key, Object value)</span></span><br><span class="line"><span class="comment"> * 删: remove(Object key);</span></span><br><span class="line"><span class="comment"> * 改: put(Object key, Object value)</span></span><br><span class="line"><span class="comment"> * 查: get(Object key)</span></span><br><span class="line"><span class="comment"> * 长度: size()</span></span><br><span class="line"><span class="comment"> * 遍历: keySet()/ values() / entrySet</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    元视图的操作方法</span></span><br><span class="line"><span class="comment">    Set keySet() : 返回所有的key构成的set集合</span></span><br><span class="line"><span class="comment">    Collection values(): 返回所有的value构成的集合</span></span><br><span class="line"><span class="comment">    Set entrySet(): 返回所有key - value构成的set集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;AA&quot;</span>, <span class="number">741</span>);</span><br><span class="line">        map.put(<span class="string">&quot;BB&quot;</span>, <span class="number">852</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有key</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的value</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator1.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的key-value</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set1</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> set1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator2.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    元素查询的相关操作：</span></span><br><span class="line"><span class="comment">    Object get(Object key): 获取指定key对应的value</span></span><br><span class="line"><span class="comment">    boolean containsKey(Object key):  是否包含指定的key</span></span><br><span class="line"><span class="comment">    boolean containValue(Object value):  是否包含指定的value</span></span><br><span class="line"><span class="comment">    int size();     返回map中key-value对的个数</span></span><br><span class="line"><span class="comment">    boolean isEmpty():  判断当前map是否为空</span></span><br><span class="line"><span class="comment">    boolean equals(Object obj): 判断当前map和参数对象obj是否相等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;AA&quot;</span>, <span class="number">741</span>);</span><br><span class="line">        map.put(<span class="string">&quot;BB&quot;</span>, <span class="number">852</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object get(Object key)</span></span><br><span class="line">        System.out.println(map.get(<span class="number">123</span>)); <span class="comment">// 456</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//containsKey(Object key)</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;AA&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// containsValue</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="number">456</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    添加，删除，修改操作</span></span><br><span class="line"><span class="comment">    Object put(Object key, Object value): 将指定的key - value添加到（或修改）当前的map对象中</span></span><br><span class="line"><span class="comment">    void putAll(Map m): 将m中的所有的key-value对存放到当前map中</span></span><br><span class="line"><span class="comment">    Object remove(Object key): 移除指定的key的key-value对，并返回value</span></span><br><span class="line"><span class="comment">    void clear(),  清空当前map中的所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;AA&quot;</span>, <span class="number">741</span>);</span><br><span class="line">        map.put(<span class="string">&quot;BB&quot;</span>, <span class="number">852</span>);</span><br><span class="line">        <span class="comment">// 修改操作</span></span><br><span class="line">        map.put(<span class="string">&quot;AA&quot;</span>, <span class="number">963</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(map);  <span class="comment">// &#123;AA=963, BB=852, 123=456&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map1.put(<span class="string">&quot;CC&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;DD&quot;</span>, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        map.putAll(map1);</span><br><span class="line"></span><br><span class="line">        System.out.println(map);  <span class="comment">// &#123;AA=963, BB=852, CC=123, DD=123, 123=456&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove(Object key)</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map.remove(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        System.out.println(value);  <span class="comment">// 123</span></span><br><span class="line">        System.out.println(map);   <span class="comment">// &#123;AA=963, BB=852, DD=123, 123=456&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear()</span></span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(map.size());  <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Treemap测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向TreeMap中添加key - value, 要求key一定是同一个类创建的对象</span></span><br><span class="line"><span class="comment">// 因为要按照key进行排序：自然排序， 定制排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自然排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line">    treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>), <span class="number">98</span>);</span><br><span class="line">    treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Json&quot;</span>, <span class="number">13</span>), <span class="number">95</span>);</span><br><span class="line">    treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Zhang&quot;</span>, <span class="number">14</span>), <span class="number">96</span>);</span><br><span class="line">    treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Li&quot;</span>, <span class="number">15</span>), <span class="number">97</span>);</span><br><span class="line">    treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Wang&quot;</span>, <span class="number">16</span>), <span class="number">98</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object obj : treeMap.entrySet()) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定制排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">                <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) o1;</span><br><span class="line">                <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> (Person) o2;</span><br><span class="line">                <span class="keyword">return</span> p1.getAge() - p2.getAge();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入类型有误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>), <span class="number">98</span>);</span><br><span class="line">    treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Json&quot;</span>, <span class="number">13</span>), <span class="number">95</span>);</span><br><span class="line">    treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Zhang&quot;</span>, <span class="number">14</span>), <span class="number">96</span>);</span><br><span class="line">    treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Li&quot;</span>, <span class="number">15</span>), <span class="number">97</span>);</span><br><span class="line">    treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Wang&quot;</span>, <span class="number">16</span>), <span class="number">98</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object obj : treeMap.entrySet()) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>properties测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// Properties: 常用来处理配置文件。key和value都是String类型的</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">    pros.load(fis); <span class="comment">// 加载到对应的文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;; password = &quot;</span> + password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Collections测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序操作</span></span><br><span class="line"><span class="comment"> * reverse(List):反转List中元素的顺序</span></span><br><span class="line"><span class="comment"> * shuffle(List):对List集合元素进行随机排序</span></span><br><span class="line"><span class="comment"> * sort(List):根据元素的自然顺序对指定 List集合元素按升序排序</span></span><br><span class="line"><span class="comment"> * sort(List，Comparator):根据指定的Comparator产生的顺序对List集合元素进行排序swap(List，int,int):将指定 list集合中的i处元素和j处元素进行交换</span></span><br><span class="line"><span class="comment"> * 查找替换操作</span></span><br><span class="line"><span class="comment"> * Object max(Collection):根据元素的自然顺序，返回给定集合中的最大元素Object max(Collection，Comparator):根据Comparator指定的顺序，返回给定集合中的最大元素</span></span><br><span class="line"><span class="comment"> * object min(Collection)</span></span><br><span class="line"><span class="comment"> * Object min(Collection，Comparator)</span></span><br><span class="line"><span class="comment"> * int frequency(Collection，Object):返回指定集合中指定元素的出现次数void copy(List dest,List src):将src中的内容复制到dest中</span></span><br><span class="line"><span class="comment"> * boolean replaceAll(List list，Object oldVal，Object newVal):使用新值替换List 对象的所有旧值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Collections类中提供了多个synchronizedXxx()方法，该方法可使将指定集合包装成线程同步的集合，</span></span><br><span class="line"><span class="comment"> *      从而可以解决多线程并发访问集合时的线程安全问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="number">987</span>);</span><br><span class="line">        list.add(<span class="number">852</span>);</span><br><span class="line">        list.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们在使用copy操作的时候 要注意：</span></span><br><span class="line">        <span class="comment">// 下面这样会报错：IndexOut0fBoundsException( &quot;Source does not fit in dest&quot;)</span></span><br><span class="line"><span class="comment">//        List dest = new ArrayList();</span></span><br><span class="line"><span class="comment">//        Collections.copy(dest, list);</span></span><br><span class="line">        <span class="comment">// 正确使用copy操作的方法：</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">dest</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[list.size()]);</span><br><span class="line"></span><br><span class="line">        System.out.println(dest.size());</span><br><span class="line">        Collections.copy(dest, list);</span><br><span class="line">        System.out.println(dest);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>面试题：负载因子值的大小，对HashMap有什么影响</p>
<p>负载因子的大小决定了HashMap的数据密度。</p>
<p>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入时的比较次数增多，性能会下降。</p>
<p>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。</p>
<p>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。</p>
<h2 id="集合掌握要求"><a class="markdownIt-Anchor" href="#集合掌握要求"></a> 集合掌握要求</h2>
<p>层次一：选择合适的集合类去实现数据的保存，调用其内部方法</p>
<p>层次二：不同的集合底层数据机构为何？如何实现数据操作的：增删改查等</p>
<h1 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h1>
<h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2>
<p>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参)。</p>
<p>在没有泛型之前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 使用泛型之前的情况</span></span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">// 存放学生成绩</span></span><br><span class="line">    list.add(<span class="number">82</span>);</span><br><span class="line">    list.add(<span class="number">92</span>);</span><br><span class="line">    list.add(<span class="number">85</span>);</span><br><span class="line">    list.add(<span class="number">96</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可能存储一些非成绩的对象</span></span><br><span class="line">    list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这时候会报错：ClassCastException类型转换异常</span></span><br><span class="line">    <span class="keyword">for</span> (Object obj : list)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) obj;</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型的使用"><a class="markdownIt-Anchor" href="#泛型的使用"></a> 泛型的使用</h2>
<ol>
<li>
<p>jdk5.0新增特性</p>
</li>
<li>
<p>在集合中使用泛型：<br />
总结：</p>
<ol>
<li>集合接口或者集合类在jdk5.0时都修改为带泛型的结构</li>
<li>在实例化集合类的时候，可以指明具体的集合泛型</li>
<li>指明完之后，在集合类或者接口中凡是定义类或者接口的时候，内部结构（比如：方法， 构造器，属性）<br />
比如：add(E e) -----&gt; 实例化之后：add(Integer e)</li>
<li>注意点：泛型的类型必须是类，不能是基本数据类型，需要用到基本数据类型的位置，拿包装类替换</li>
<li>如果实例化的时候没有指明泛型的类型，默认类型为java.lang.Object类型</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 使用泛型之前的情况</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">// 存放学生成绩</span></span><br><span class="line">        list.add(<span class="number">82</span>);</span><br><span class="line">        list.add(<span class="number">92</span>);</span><br><span class="line">        list.add(<span class="number">85</span>);</span><br><span class="line">        list.add(<span class="number">96</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 问题一：类型不安全， 可能存储一些非成绩的对象</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object obj : list)&#123;</span><br><span class="line">            <span class="comment">// 问题二：强转时会报错：ClassCastException类型转换异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) obj;</span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 集合中使用泛型的情况</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">86</span>);</span><br><span class="line">        list.add(<span class="number">96</span>);</span><br><span class="line">        list.add(<span class="number">75</span>);</span><br><span class="line">        list.add(<span class="number">89</span>);</span><br><span class="line">        <span class="comment">// 如果使用泛型的话，在我们添加的非法类型的时候就会直接报错</span></span><br><span class="line">        <span class="comment">// 编译时就是进行数据类型检查，保证数据的安全</span></span><br><span class="line">        <span class="comment">// list.add(&quot;AAA&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式一</span></span><br><span class="line">        <span class="comment">//for(Integer score : list)&#123;</span></span><br><span class="line">        <span class="comment">//    int stuScore = (int) score;</span></span><br><span class="line">        <span class="comment">//    System.out.println(stuScore);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二:</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (<span class="type">int</span>) iterator.next();</span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中泛型使用情况</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Double&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;Tom&quot;</span>, <span class="number">88.0</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Jerry&quot;</span>, <span class="number">98.0</span>);</span><br><span class="line">        map.put(<span class="string">&quot;LiHua&quot;</span>, <span class="number">90.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 泛型的嵌套</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Double&gt;&gt; entry =  map.entrySet();</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Double&gt;&gt; iterator = entry.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String, Double&gt; next = iterator.next();</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> next.getKey();</span><br><span class="line">            <span class="type">Double</span> <span class="variable">value</span> <span class="operator">=</span> next.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>泛型在继承方面的使用</p>
<p>​	虽然类A是类B的父类，但是G<A> 和 G<B>二者不具备子父类关系，二者是并列关系</p>
</li>
<li>
<p>通配符的使用：</p>
<p>通配符: ?</p>
<p>类A是类B的父类， G<A> 和 G<B> 是没有关系的，二者共同的父类是：G&lt;?&gt;</p>
<p>使用通配符定义的变量，不能够向内部添加除了null意外的任何数据</p>
<p>允许读取数据，读取数据的类型是Object</p>
</li>
<li>
<p>有限制条件的通配符的使用<br />
? extends Person:<br />
G&lt;? extends A&gt; 可以作为G<A> 和 G<B>的父类， 其中B是A的子类<br />
? super Person:<br />
G&lt;? extends B&gt; 可以作为G<A> 和 G<B> 的父类的， 其中B是A的父类</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">    List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">    List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list1 = list4;</span><br><span class="line">    <span class="comment">// 下面这种情况就会报错，因为使用extends方法调用有限制的通配符，只能调用该类以及该类的子类</span></span><br><span class="line">    <span class="comment">// list1 = list5;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这种情况也会报错，使用super调用的有限制的通配符，只能调用该类以及该类的父类</span></span><br><span class="line">    <span class="comment">// list2 = list3;</span></span><br><span class="line">    list2 = list4;</span><br><span class="line">    list2 = list5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    list1 = list3;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> list1.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 编译不通过 使用extends 声明的有限制的通配符， 在获取对象的时候只能是extends的那个类</span></span><br><span class="line">    <span class="comment">// Student s = list1.get(0);</span></span><br><span class="line"></span><br><span class="line">    list2 = list4;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list2.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 编译不通过,使用super声明的有限制的通配符，在获取对象的时候只能是Object</span></span><br><span class="line">    <span class="comment">// Person person = list2.get(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据：</span></span><br><span class="line">    <span class="comment">// 编译不通过 使用extend声明的有限制的通配符，不能够添加对象</span></span><br><span class="line">    <span class="comment">// list1.add(new Student());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译通过, 使用super声明的有限制的通配符，在添加对象的时候只能够添加super后面的类以及它的子类</span></span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Object&gt; list = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; list3 = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 使用通配符的话，下面这种情况就不会报错</span></span><br><span class="line">    list3 = list2;</span><br><span class="line">    list3 = list;</span><br><span class="line"></span><br><span class="line">    list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    list2.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list2.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    list2.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    list3 = list2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符定义的变量不能够添加除了null之外的任何数据</span></span><br><span class="line">    <span class="comment">// list3.add(&quot;DD&quot;); 这样会报错</span></span><br><span class="line">    list3.add(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span>(Object obj : list3)&#123;</span><br><span class="line">        <span class="comment">// 允许读取数据，读取数据的类型是Object</span></span><br><span class="line">        System.out.println(obj); <span class="comment">// AA BB CC null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    obj = str;</span><br><span class="line"></span><br><span class="line">    Object[] arr1 = <span class="literal">null</span>;</span><br><span class="line">    String[] arr2 = <span class="literal">null</span>;</span><br><span class="line">    arr1 = arr2;</span><br><span class="line">    <span class="comment">//        这样编译不通过</span></span><br><span class="line">    <span class="comment">//        Date date = new Date();</span></span><br><span class="line">    <span class="comment">//        str = date;</span></span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 此时的list1和list2不具备子父类关系</span></span><br><span class="line">    <span class="comment">// 编译不通过</span></span><br><span class="line">    <span class="comment">// list1 = list2</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        反证法：</span></span><br><span class="line"><span class="comment">        假设list1 = list2 合理的话</span></span><br><span class="line"><span class="comment">        那么 list1.add(123); 因为 list1中的泛型是Object 所以list1可以添加数值为123的数据</span></span><br><span class="line"><span class="comment">        但是 又由于list1 和 list2 指向的是同一个内存地址，所以list1调用的add方法，同样也添加到了</span></span><br><span class="line"><span class="comment">        list2的对象中，但是list2的泛型是Sting类型的，这时候就导致，list2中有一些杂类出现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 使用泛型之前的情况</span></span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">// 存放学生成绩</span></span><br><span class="line">    list.add(<span class="number">82</span>);</span><br><span class="line">    list.add(<span class="number">92</span>);</span><br><span class="line">    list.add(<span class="number">85</span>);</span><br><span class="line">    list.add(<span class="number">96</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题一：类型不安全， 可能存储一些非成绩的对象</span></span><br><span class="line">    <span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object obj : list)&#123;</span><br><span class="line">        <span class="comment">// 问题二：强转时会报错：ClassCastException类型转换异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) obj;</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 集合中使用泛型的情况</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    list.add(<span class="number">86</span>);</span><br><span class="line">    list.add(<span class="number">96</span>);</span><br><span class="line">    list.add(<span class="number">75</span>);</span><br><span class="line">    list.add(<span class="number">89</span>);</span><br><span class="line">    <span class="comment">// 如果使用泛型的话，在我们添加的非法类型的时候就会直接报错</span></span><br><span class="line">    <span class="comment">// 编译时就是进行数据类型检查，保证数据的安全</span></span><br><span class="line">    <span class="comment">// list.add(&quot;AAA&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一</span></span><br><span class="line">    <span class="comment">//for(Integer score : list)&#123;</span></span><br><span class="line">    <span class="comment">//    int stuScore = (int) score;</span></span><br><span class="line">    <span class="comment">//    System.out.println(stuScore);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二:</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (<span class="type">int</span>) iterator.next();</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在集合中泛型使用情况</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Double&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>, <span class="number">88.0</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jerry&quot;</span>, <span class="number">98.0</span>);</span><br><span class="line">    map.put(<span class="string">&quot;LiHua&quot;</span>, <span class="number">90.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛型的嵌套</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Double&gt;&gt; entry =  map.entrySet();</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Double&gt;&gt; iterator = entry.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Double&gt; next = iterator.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> next.getKey();</span><br><span class="line">        <span class="type">Double</span> <span class="variable">value</span> <span class="operator">=</span> next.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;----&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型类泛型接口泛型方法"><a class="markdownIt-Anchor" href="#泛型类泛型接口泛型方法"></a> 泛型类，泛型接口，泛型方法</h2>
<h3 id="泛型类泛型接口"><a class="markdownIt-Anchor" href="#泛型类泛型接口"></a> 泛型类，泛型接口</h3>
<ol>
<li>
<p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如:&lt;E1,E2,E3&gt;</p>
</li>
<li>
<p>泛型类的构造器如下: public GenericClass(){}。而下面是错误的: public GenericClass<E>(){}</p>
</li>
<li>
<p>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</p>
</li>
<li>
<p>泛型不同的引用不能相互赋值。</p>
<p>尽管在编译时ArrayList&lt; String &gt;和ArrayList&lt; Integer &gt;是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">ArrayList&lt;Integer&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 泛型不同的引用不能相互赋值</span></span><br><span class="line">list1 = list2; <span class="comment">// 这样是错误的</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。</p>
<p>​	经验:泛型要使用一路都用。要不用，一路都不要用。</p>
</li>
<li>
<p>如果泛型类是一个接口或抽象类，则不可创建泛型类的对象。</p>
</li>
<li>
<p>jdk1.7，泛型的简化操作:ArrayList<Fruit> flist = new ArrayList&lt;&gt;();</p>
</li>
<li>
<p>泛型的指定中不能使用基本数据类型，可以使用包装类替换。</p>
</li>
<li>
<p>在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。</p>
</li>
<li>
<p>异常类不能是泛型的</p>
</li>
<li>
<p>不能使用new E]。但是可以:E]elements =(E)new Object[capacity]:</p>
<p>​	参考: ArrayList源码中声明:Object[]elementData，而非泛型参数类型数组。</p>
</li>
<li>
<p>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型:<br />
子类不保留父类的泛型:按需实现</p>
</li>
</ol>
<blockquote>
<p>没有类型擦除</p>
<p>具体类型</p>
</blockquote>
<p>子类保留父类的泛型:泛型子类</p>
<blockquote>
<p>全部保留</p>
<p>部分保留</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fathre</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1 没有类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123; <span class="comment">// 等价于 class Son1 extend Father&lt;Object o1, Object o2&gt;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 具体类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1.全部保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt;&#123;&#125;</span><br><span class="line"><span class="comment">// 2. 部分保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>结论:子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加 自己的泛型</p>
<h3 id="泛型方法"><a class="markdownIt-Anchor" href="#泛型方法"></a> 泛型方法</h3>
<p>实例：</p>
<p>泛型方法：在方法中出现了泛型结构，泛型参数和类的泛型参数没有关系。</p>
<p>换句话说，泛型方法所属类是不是泛型都没有关系</p>
<p>泛型方法：可以声明为静态的，原因，泛型参数是在调用方法的时候确定的，并非在实例化类的时候确定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] arr)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="io流原理及流的分类"><a class="markdownIt-Anchor" href="#io流原理及流的分类"></a> IO流原理及流的分类</h1>
<h2 id="file类的使用"><a class="markdownIt-Anchor" href="#file类的使用"></a> File类的使用</h2>
<ol>
<li>File类的一个对象，代表一个文件或者一个文件目录（文件夹）</li>
<li>File类生命在Java.io包下</li>
<li>File类中涉及到文件或者文件目录的创建，删除，重命名，修改时间，文件大小等方法，并未涉及到文件读写内容的的操作，如果需要读取或者写入文件内容的操作，则必须使用IO流来操作</li>
<li>后续FIle类对象常会作为参数传递到流的构造器中，指明读取或写入的“终点”</li>
</ol>
<h3 id="常用构造器"><a class="markdownIt-Anchor" href="#常用构造器"></a> 常用构造器</h3>
<ol>
<li>
<p>如何创建File类的实例<br />
File(String filePath)<br />
File(String parentPath, String childPath)<br />
File(File parentFile, String childPath)</p>
</li>
<li>
<p>相对路径：相较于某个路径下，指明的路径。<br />
绝对路径：包含盘符在内的文件或文件目录的路径</p>
<p>说明：</p>
<p>IDEA中：如果在开发中使用的是单元测试方法，相对路径为当前的Module下。</p>
<p>如果使用的main方法的话，相对路径为当前的工程下</p>
</li>
<li>
<p>路径分隔符<br />
windows：\<br />
unix: /</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 构造器一:指明确定的文件</span></span><br><span class="line">    <span class="comment">// 方式一： 相对路径</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>); <span class="comment">// 相对于当前的module</span></span><br><span class="line">    <span class="comment">// 方式二：绝对路径</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaProject\\IOModel\\ho.txt&quot;</span>);</span><br><span class="line">    System.out.println(file); <span class="comment">// hello.txt</span></span><br><span class="line">    System.out.println(file1); <span class="comment">// E:\JavaProject\IOModel\ho.txt</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器二：没有指明确定的文件，是一个文件目录（文件夹）</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaProject&quot;</span>,<span class="string">&quot;child&quot;</span>);</span><br><span class="line">    System.out.println(file3);  <span class="comment">// E:\JavaProject\child</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器三：</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file3, <span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line">    System.out.println(file4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用方法"><a class="markdownIt-Anchor" href="#常用方法"></a> 常用方法</h3>
<mark class="hl-label red">获取功能：</mark> 
<ul>
<li>public string getAbsolutePath():获取绝对路径public string getPath() :获取路径</li>
<li>public string getName() :获取名称</li>
<li>public string getParent():获取上层文件目录路径。若无，返回nuLl</li>
<li>public long length() :获取文件长度（即:字节数）。不能获取目录的长度。</li>
<li>public long lastModified():获取最后一次的修改时间，毫秒值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaProject\\IOModel\\hi.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(file1.getAbsoluteFile());  <span class="comment">// E:\JavaProject\IOModel\hello.txt</span></span><br><span class="line">        System.out.println(file1.getPath());  <span class="comment">// hello.txt</span></span><br><span class="line">        System.out.println(file1.getName()); <span class="comment">// hello.txt</span></span><br><span class="line">        System.out.println(file1.getParentFile()); <span class="comment">// null</span></span><br><span class="line">        System.out.println(file1.length());  <span class="comment">// 0</span></span><br><span class="line">        System.out.println(file1.lastModified()); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(file2.getAbsoluteFile()); <span class="comment">// E:\JavaProject\IOModel\hi.txt</span></span><br><span class="line">        System.out.println(file2.getPath());  <span class="comment">// E:\JavaProject\IOModel\hi.txt</span></span><br><span class="line">        System.out.println(file2.getName()); <span class="comment">// hi.txt</span></span><br><span class="line">        System.out.println(file2.getParentFile());  <span class="comment">// E:\JavaProject\IOModel</span></span><br><span class="line">        System.out.println(file2.length());  <span class="comment">// 6</span></span><br><span class="line">        System.out.println(file2.lastModified()); <span class="comment">//  1655178923369</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<mark class="hl-label red">下面两个适用于文件目录</mark> 
<ul>
<li>public string[ ] list():获取指定目录下的所有文件或者文件目录的名称数组</li>
<li>public File[] listFiles():获取指定目录下的所有文件或者文件目录的File数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">text1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\Mr.zhang\\Desktop&quot;</span>,<span class="string">&quot;Java作业&quot;</span>);</span><br><span class="line">    String[] list = file.list();</span><br><span class="line">    <span class="keyword">for</span>(String name : list)&#123;</span><br><span class="line">        System.out.println(name);  <span class="comment">// 输出文件名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span>(File file1 : files)&#123;</span><br><span class="line">        System.out.println(file1);  <span class="comment">// 输出文件路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<mark class="hl-label red">下面这个适用于该文件</mark> 
<ul>
<li>
<p>public boolean renameTo(File dest)</p>
<p>比如：file1.renameTo(file2)为例要想保证返回ture。需要file1在内存中是存在的，file2在内存中不存在</p>
<p>将file1文件目标改为file2的文件目标</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaProject\\IOModel\\hi.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\Mr.zhang\\Desktop\\hello.txt&quot;</span>);</span><br><span class="line">    System.out.println(file.renameTo(file2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
 <mark class="hl-label red">下面这个方法适用于文件判断功能</mark> 
<ul>
<li>
<p>public boolean isDirectory():判断是否是文件目录</p>
</li>
<li>
<p>public boolean isFile():判断是否是文件</p>
</li>
<li>
<p>public boolean exists():判断是否存在</p>
</li>
<li>
<p>public boolean canRead():判断是否可读</p>
</li>
<li>
<p>public boolean canWrite():判断是否可写</p>
</li>
<li>
<p>public boolean isHidden():判断是否隐藏</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 当文件存在的使用有以下几种情况， 当文件不存在的时候，返回值都为false</span></span><br><span class="line">    System.out.println(file.isDirectory()); <span class="comment">// false</span></span><br><span class="line">    System.out.println(file.isFile());    <span class="comment">// true</span></span><br><span class="line">    System.out.println(file.exists());      <span class="comment">// true</span></span><br><span class="line">    System.out.println(file.canRead());     <span class="comment">// true</span></span><br><span class="line">    System.out.println(file.canWrite());    <span class="comment">// ture</span></span><br><span class="line">    System.out.println(file.isHidden());    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当文件为文件目录时：</span></span><br><span class="line">    file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaProject\\IOModel&quot;</span>);</span><br><span class="line">    System.out.println(file.isDirectory()); <span class="comment">// true</span></span><br><span class="line">    System.out.println(file.isFile());    <span class="comment">// false</span></span><br><span class="line">    System.out.println(file.exists());      <span class="comment">// true</span></span><br><span class="line">    System.out.println(file.canRead());     <span class="comment">// true</span></span><br><span class="line">    System.out.println(file.canWrite());    <span class="comment">// ture</span></span><br><span class="line">    System.out.println(file.isHidden());    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<mark class="hl-label red">File类创建功能</mark> 
<ul>
<li>public boolean createNewFile():创建文件。若文件存在，则不创建，返回false</li>
<li>public boolean mkdir() :创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</li>
<li>public boolean mkdirs():创建文件目录。如果上层文件目录不存在，一并创建</li>
</ul>
<p>注意事项:如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下。</p>
<mark class="hl-label red">File类删除功能</mark> 
<ul>
<li>
<p>public boolean delete():删除文件或者文件夹删除注意事项:</p>
<p>Java中的删除不走回收站。</p>
<p>要删除一个文件目录，请注意该文件目录内<mark class="hl-label red">不能包含</mark> 文件或者文件目录</p>
</li>
</ul>
<h2 id="io流"><a class="markdownIt-Anchor" href="#io流"></a> IO流</h2>
<p>IO是Input/Output的缩写，I/O技术是非常实用的技术，<mark class="hl-label red">用于处理设备之间的数据传输</mark> 。如读/写文件，网络通讯等。</p>
<p>Java程序中，对于数据的输入/输出操作以<mark class="hl-label red">“流(stream)”</mark> 的方式进行。</p>
<p>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过<mark class="hl-label red">标准的方法</mark> 输入或输出数据。</p>
<ol>
<li>
<p>流的分类方式：</p>
<p>按操作数据单位不同分为:字节流(8 bit)，字符流(16 bit)</p>
<p>按数据流的流向不同分为:输入流，输出流</p>
<p>按流的角色的不同分为:节点流，处理流</p>
<table>
<thead>
<tr>
<th style="text-align:center">抽象基类</th>
<th style="text-align:center">字节流</th>
<th style="text-align:center">字符流</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">输入流</td>
<td style="text-align:center">InputStream</td>
<td style="text-align:center">Reader</td>
</tr>
<tr>
<td style="text-align:center">输出流</td>
<td style="text-align:center">OutputStream</td>
<td style="text-align:center">Writer</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>IO流体系：</p>
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">字节输入流</th>
<th style="text-align:center">字节输出流</th>
<th style="text-align:center">字符输入流</th>
<th style="text-align:center">字符输出流</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">抽象基类</td>
<td style="text-align:center">InputStream</td>
<td style="text-align:center">OutputStream</td>
<td style="text-align:center">Reader</td>
<td style="text-align:center">Writer</td>
</tr>
<tr>
<td style="text-align:center">访问文件</td>
<td style="text-align:center">FileInputStream</td>
<td style="text-align:center">FileOutputStream</td>
<td style="text-align:center">FileReader</td>
<td style="text-align:center">FileWriter</td>
</tr>
<tr>
<td style="text-align:center">访问数组</td>
<td style="text-align:center">ByteArrayInputStream</td>
<td style="text-align:center">ByteArrayOutputStream</td>
<td style="text-align:center">CharArrayReader</td>
<td style="text-align:center">CharArrayWriter</td>
</tr>
<tr>
<td style="text-align:center">访问管道</td>
<td style="text-align:center">PipedInputStream</td>
<td style="text-align:center">PipedOutputStream</td>
<td style="text-align:center">PipedReader</td>
<td style="text-align:center">PipedWriter</td>
</tr>
<tr>
<td style="text-align:center">访问字符串</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">StringReader</td>
<td style="text-align:center">StringWriter</td>
</tr>
<tr>
<td style="text-align:center">缓冲流</td>
<td style="text-align:center">BufferedInputStream</td>
<td style="text-align:center">BufferedInputStream</td>
<td style="text-align:center">BufferedReader</td>
<td style="text-align:center">BufferedWriter</td>
</tr>
<tr>
<td style="text-align:center">转换流</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">InputStreamReader</td>
<td style="text-align:center">OutputStreamWriter</td>
</tr>
<tr>
<td style="text-align:center">对象流</td>
<td style="text-align:center">ObjectInputStream</td>
<td style="text-align:center">ObjectOutputStream</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">FilterInputStream</td>
<td style="text-align:center">FilterOutputStream</td>
<td style="text-align:center">FilterReader</td>
<td style="text-align:center">FilterReader</td>
</tr>
<tr>
<td style="text-align:center">打印流</td>
<td style="text-align:center"></td>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center"></td>
<td style="text-align:center">PrintWriter</td>
</tr>
<tr>
<td style="text-align:center">推回输入流</td>
<td style="text-align:center">PushbackInputStream</td>
<td style="text-align:center"></td>
<td style="text-align:center">PushbackReader</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">特殊流</td>
<td style="text-align:center">DataInputStream</td>
<td style="text-align:center">DataOutputStream</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="字符流的读入"><a class="markdownIt-Anchor" href="#字符流的读入"></a> 字符流的读入</h3>
<p>read 方法，返回值是读入字符的ASCII码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 1.实例化File类的对象，指明要操作的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt	&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.提供具体的流</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.数据的输入</span></span><br><span class="line">        <span class="comment">// read():返回读入的一个字符，如果达到文件默认，返回-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fr.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)data);</span><br><span class="line">            data = fr.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           	<span class="comment">// 4.流的关闭操作</span></span><br><span class="line">   			fr.close(); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流读入的说明：</p>
<ol>
<li>read()的理解，返回读入的一个字符，如果达到文件末尾，返回-1</li>
<li>异常的处理：为了保证流资源可以执行关闭操作，需要使用try-catch-finally处理</li>
<li>读入文件操作一定要存在，否则会报FileNotFoundException</li>
</ol>
<p>对read()操作升级，使用read的重载方法</p>
<p>read(char[]) 返回值是读入的几个字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.File类的实例化</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.读入的操作</span></span><br><span class="line">            <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 方式一：</span></span><br><span class="line">                <span class="comment">// 下面这种写法是错误的，因为会涉及到未写入和读取的操作</span></span><br><span class="line"><span class="comment">//                for( int i = 0; i &lt; cbuf.length; i++)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                <span class="comment">// 下面这种操作就可以完美的输出文件中的所有内容</span></span><br><span class="line"><span class="comment">//                for(int i = 0; i &lt; len; i++)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 方式二：</span></span><br><span class="line">                <span class="comment">// 下面这种方式依旧错误，错因和方式一种的原因相同</span></span><br><span class="line"><span class="comment">//                String str = new String(cbuf);</span></span><br><span class="line"><span class="comment">//                System.out.println(str);</span></span><br><span class="line">                <span class="comment">// 下面这种方式是正确的：</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf, <span class="number">0</span>, len);</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//4.资源的关闭</span></span><br><span class="line">                fr.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符流的输出"><a class="markdownIt-Anchor" href="#字符流的输出"></a> 字符流的输出</h3>
<p>说明：</p>
<ol>
<li>
<p>输入操作，对应的file可以是不存在的，并不会报异常</p>
<ol>
<li>File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</li>
<li>File对应的硬盘中的文件如果存在:
<ol>
<li>如果流使用的构造器是:Filewriter(file,false) / FiLewriter(file):对原有的文件进行覆盖</li>
<li>如果流使用的构造器是:Filewriter(file,true)，不会对原有的文件进行覆盖，而是在原有的文件基础追加内容</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> Throws IOException&#123;</span><br><span class="line">    <span class="comment">// 1. 提供File类的对象，指明写出到的文件：</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.提供FileWriter的对象，用于数据的写出, 使用false参数对原数据进行覆盖</span></span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.写出的操作</span></span><br><span class="line">    fw.writer(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">    fw.writer(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 流的资源的关闭</span></span><br><span class="line">    fw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<mark class="hl-label red">字符型总测试</mark> 
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReaderWriter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建File类的对象，指明写入和写出的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建输入流和输出流</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据的读入和写出操作</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf, <span class="number">0</span>, len);</span><br><span class="line">            fw.write(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 流的关闭</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="字节流的读入和输出"><a class="markdownIt-Anchor" href="#字节流的读入和输出"></a> 字节流的读入和输出</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPicture</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;wallhaven-72vwpo.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;picture2.jpg&quot;</span>);</span><br><span class="line">		<span class="comment">// 流的创建</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">		<span class="comment">// 流的读取和写入操作</span></span><br><span class="line">        <span class="comment">// 方式一</span></span><br><span class="line">        <span class="comment">// fos.write(fis.readAllBytes());</span></span><br><span class="line">        <span class="comment">// 方式二：</span></span><br><span class="line">        <span class="type">byte</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缓冲流的使用"><a class="markdownIt-Anchor" href="#缓冲流的使用"></a> 缓冲流的使用</h3>
<p>四种缓冲流：</p>
<ol>
<li>BufferedInputStream</li>
<li>BufferedOutputStream</li>
<li>BufferedReader</li>
<li>BufferedWirter</li>
</ol>
<p>缓冲流的作用：提高流的读取和写入速度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BufferTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;wallhaven-72vwpo.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;picture2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.造流</span></span><br><span class="line">        <span class="comment">// 2.1 造节点流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">// 2.2 造缓冲流</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 复制的细节：读取，写入</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 资源关闭</span></span><br><span class="line">        <span class="comment">// 要求：先关闭外层的流，在关闭内层的流</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明：关闭外层流的同时，内层流也会自动的进行关闭，关于内层流的关闭，我们可以省略</span></span><br><span class="line">        <span class="comment">//            fos.close();</span></span><br><span class="line">        <span class="comment">//            fis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转换流"><a class="markdownIt-Anchor" href="#转换流"></a> 转换流</h3>
<p>提供了字符流和字节流之间的转换</p>
<ol>
<li>Java提供了两个转换流</li>
</ol>
<p>​	InputStreamReader：将InputStream转换为Reader：将一个字节的输入流转换为字符的输入流</p>
<p>​	OutputStreamWriter：将Writer转换为OutputStream：将一个字符的输出流转换成字节的输出流</p>
<ol start="2">
<li>
<p>作用：提供字节流和字符流之间的转换</p>
</li>
<li>
<p>解码：字节，字节数组 —&gt; 字符数组，字符串</p>
<p>编码：字符数组，字符串 —&gt; 字节，字节数组</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InputStreamReaderTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 以下这种方法调用的是默认编码格式</span></span><br><span class="line">        <span class="comment">/// isr = new InputStreamReader(fis);</span></span><br><span class="line">        <span class="comment">// 以下这种方式调用的是自定义的编码格式</span></span><br><span class="line">        isr = <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                isr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>
<p>字符集：</p>
<p>ASCIl:美国标准信息交换码。</p>
<p>​	用一个字节的7位可以表示。</p>
<p>ISO8859-1:拉丁码表。欧洲码表</p>
<p>​	用一个字节的8位表示。<br />
GB2312:中国的中文编码表。最多两个字节编码所有字符</p>
<p>GBK:中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</p>
<p>Unicode:国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</p>
<p>UTF-8:变长的编码方式，可用1-4个字节来表示一个字符。</p>
</li>
</ol>
<h3 id="标准输入输出流"><a class="markdownIt-Anchor" href="#标准输入输出流"></a> 标准输入输出流</h3>
<p>System.in和System.out分别代表了系统标准的输入和输出设备</p>
<p>默认输入设备是:键盘，输出设备是:显示器</p>
<p>System.in的类型是InputStream</p>
<p>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</p>
<p>重定向:通过System类的setIn，setOut方法对默认设备进行改变。默认是输出到控制台，和从控制台中获取，如果我们使用setIn或者setOut的话，可以改变读入和写出的位置</p>
<blockquote>
<p>public static void setIn(InputStream in)</p>
<p>public static void setOut(PrintStream out)</p>
</blockquote>
<p>练习：将输入的字符都转换成大写的，当输入e或者exit的时候退出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入字符串&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;e&quot;</span>.equals(data) || <span class="string">&quot;exit&quot;</span>.equals(data))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(data.toUpperCase(Locale.ROOT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打印流"><a class="markdownIt-Anchor" href="#打印流"></a> 打印流</h3>
<p>实现将基本数据类型的数据格式转化为字符串输出</p>
<p>打印流: PrintStream和PrintWriter</p>
<blockquote>
<p>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</p>
<p>PrintStream和PrintWriter的输出不会抛出IOException异常</p>
<p>PrintStream和PrintWVriter有自动flush功能</p>
<p>PrintStream打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用PrintWriter类。</p>
<p>System.out返回的是PrintStream的实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\JavaProject\\IOModel\\IO\\test.txt&quot;</span>);</span><br><span class="line">        ps = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fos);</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.setOut(ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">255</span>; i++)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) i);</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">50</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ps != <span class="literal">null</span>)&#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据流"><a class="markdownIt-Anchor" href="#数据流"></a> 数据流</h3>
<p>为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。</p>
<p>作用：用于读取或者写出基本数据类型的变量或字符串</p>
<p>数据流有两个类:(用于读取和写出基本数据类型、String类的数据)</p>
<blockquote>
<p>DatalnputStream和 DataOutputStream</p>
<p>分别“套接”在InputStream和 OutputStream子类的流上</p>
</blockquote>
<p>DatalnputStream中的方法</p>
<blockquote>
<p>boolean readBoolean()	byte readByte()</p>
<p>char readChar()	float readFloat()</p>
<p>double readDouble()	short readShort()</p>
<p>long readLong()	int readlnt()</p>
<p>String readUTF()	void readFully(byte[] b)</p>
</blockquote>
<p>DataOutputStream中的方法：</p>
<blockquote>
<p>将上述的方法的read改为相应的write即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\JavaProject\\IOModel\\IO\\test.txt&quot;</span>);</span><br><span class="line">        dos = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fos);</span><br><span class="line">        dos.writeUTF(<span class="string">&quot;张锦昊&quot;</span>);</span><br><span class="line">        dos.writeInt(<span class="number">21</span>);</span><br><span class="line">        dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dis = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;\n年龄：&quot;</span>+age+<span class="string">&quot;\n男性：&quot;</span>+isMale);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(dis != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              dis.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象流"><a class="markdownIt-Anchor" href="#对象流"></a> 对象流</h3>
<p>ObjectInputStream和OjbectOutputSteam</p>
<p>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p>
<mark class="hl-label red">序列化</mark> :用ObjectOutputStream类保存基木类型数据或对象的机制
<mark class="hl-label red">反序列化</mark> :用ObjectInputStream类读取基木类型数据或对象的机制
<p>ObjectOutputStream和IObjectInputStream不能序列化static和ltransient修饰的成员变量</p>
<mark class="hl-label red">对象的序列化：</mark> 
<ol>
<li>
<p>对象的序列化机制：</p>
<p>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象|</p>
</li>
<li>
<p>序列化的好处：序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据使其在保存和传输时可被还原</p>
</li>
<li>
<p>序列化是 RMI (Remote Method Invoke-远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础</p>
</li>
<li>
<p>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出NotSerializableException异常</p>
<blockquote>
<p>Serializable<br />
Externalizable</p>
</blockquote>
</li>
<li>
<p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量:</p>
</li>
</ol>
<blockquote>
<p>private static final long serialVersionUID;</p>
<p>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</p>
<p>如果类没有显示定义这个静态变量[它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，seriaVersionUID可能发生变化。故建议，显式声明。</p>
</blockquote>
<ol start="6">
<li>
<p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的</p>
<p>serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)</p>
</li>
<li>
<p>ObjectOutputStream 和ObjectInputStream 不能序列化static和transient修饰的成员变量</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">序列化的过程，将内存中的java对象保存到磁盘中，或者通过网络传输出去</span></span><br><span class="line"><span class="comment">使用ObjectOutputStream实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">text</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Object.dat&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱中国&quot;</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>));</span><br><span class="line">        oos.flush(); <span class="comment">// 刷新操作</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反序列化过程：将磁盘文件中的对象还原为内存中的一个java对象</span></span><br><span class="line"><span class="comment">如果是自定义类的话需要实现Serializable接口，并设置一个serialVersionUID的全局常量</span></span><br><span class="line"><span class="comment">除了当前类需要实现Serializable接口除外，还要保证其内部所有属性也必须是可序列化的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">text1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj1;</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj2;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机存取文件流"><a class="markdownIt-Anchor" href="#随机存取文件流"></a> 随机存取文件流</h3>
<p>RandomAccessFile声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了Datalnput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。</p>
<p>RandomAccessFile类支持“随机访问”的方式，程序可以直接跳到文件的任意地方来读、写文件</p>
<blockquote>
<p>支持只访问文件的部分内容</p>
<p>可以向己存在的文件后追加内容</p>
</blockquote>
<p>RandomAccessFile对象包含一个记录指针，用以标示当前读写处的位置。</p>
<p>RandomAccessFile类对象可以自由移动记录指针:</p>
<blockquote>
<p>long getFilePointer():获取文件记录指针的当前位置</p>
<p>void seek(long pos):将文件记录指针定位到pos位置</p>
</blockquote>
<p>创建RandomAccessFile类实例需要指定一个mode参数，该参数指定RandomAccessFile的访问模式:</p>
<blockquote>
<p>r:以只读方式打开</p>
<p>rw:打开以便读取和写入</p>
<p>rwd:打开以便读取和写入;同步文件内容的更新</p>
<p>rws:打开以便读取和写入;同步文件内容和元数据的更新</p>
</blockquote>
<p>如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  RandomAccessFile的使用</span></span><br><span class="line"><span class="comment"> *  1. 直接继承与Java.lang.Object类 实现了DataInput和DataOutPut接口</span></span><br><span class="line"><span class="comment"> *  2. RandomAccessFile 既可以作为输入流也可以作为输出流</span></span><br><span class="line"><span class="comment"> *  3. 如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建如果写出到的文件存在，则	*	会对原有文件内容进行覆盖。(默认情况下，从头覆盖)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;wallhaven-72vwpo.jpg&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;picture1.jpg&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = raf.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            raf1.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (raf != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="nio2中path-pathsfiles类的使用"><a class="markdownIt-Anchor" href="#nio2中path-pathsfiles类的使用"></a> NIO.2中Path， Paths，Files类的使用</h3>
<p>Java NIO (New lO，Non-Blocking lO)是从Java 1.4版本开始引入的一套新的IOAPI，可以替代标准的Java lO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</p>
<p>JavaAPI中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<blockquote>
<p>java.nio.channels.Channel</p>
<blockquote>
<p>FileChannel:处理本地文件</p>
<p>SocketChannel:TCP网络编程的客户端的Channel</p>
<p>ServerSocketChannel:TCP网络编程的服务器端的Channel</p>
<p>DatagramChannel:UDP网络编程中发送端和接收端的Channel</p>
</blockquote>
</blockquote>
<p>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</p>
<p>NIO.2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。<mark class="hl-label red">Path可以看成是File类的升级版本</mark> ，实际引用的资源也可以不存在。</p>
<p>以前的IO操作符是这样写的：</p>
<p>import java.io.File;</p>
<p>File file = new File(“index.html”);</p>
<p>但在Java7中，我们可以这样写:</p>
<p>import java.nio.file.Path;</p>
<p>import java.nio.file.Paths;</p>
<p>Path path = Patts.get(“index.html”);</p>
<p>同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件; Paths则包含了两个返回Path的静态工厂方法。</p>
<p>Paths类提供的静态get()方法用来获取Path 对象:</p>
<blockquote>
<p>static Path get(String first, String … more):用于将多个字符串串连成路径</p>
<p>static Path get(URI uri):返回指定uri对应的Path路径</p>
</blockquote>
<h1 id="网络编程"><a class="markdownIt-Anchor" href="#网络编程"></a> 网络编程</h1>
<ol>
<li>
<p>计算机网络</p>
<p>把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。</p>
</li>
<li>
<p>网络编程的目的：</p>
<p>直接或者间接的通过网络协议与其他计算机实现数据交换，进行通讯</p>
</li>
<li>
<p>网络编程的两个主要目的：</p>
<p>如何精确的定位网络上一台或者多台主机，定位主机上特定的应用</p>
<p>找到主机后如何可靠高效的进行数据的传输</p>
</li>
</ol>
<h2 id="网络通讯中的两个要素"><a class="markdownIt-Anchor" href="#网络通讯中的两个要素"></a> 网络通讯中的两个要素</h2>
<h3 id="ip和端口号"><a class="markdownIt-Anchor" href="#ip和端口号"></a> IP和端口号</h3>
<p>IP：每一个主机在网络上都有唯一的IP地址(InetAddress)</p>
<ol>
<li>唯一的标识Internet上的计算机（通信实体)</li>
<li>本地回环地址(hostAddress): 127.0.0.1 主机名(hostName): localhost</li>
<li>IP地址分类方式1:IPV4和 IPV6</li>
</ol>
<blockquote>
<p>IPV4:4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。以点分十进制表示，如192.168.0.1</p>
<p>IPV6:128位（16个字节)，写成8个无符号整数，每个整数用四个十六进制位表示，数之间用冒号(:）分开，如:3ffe:3201:1401:1280:c8ff:fe4d:db39:1984</p>
</blockquote>
<ol start="4">
<li>IP地址分类方式2:公网地址(万维网使用)和私有地址(局域网使用)。192.168开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用</li>
<li>特点:不易记忆</li>
</ol>
<p>端口号：标识正在计算机上运行的进行（程序）</p>
<p>不同的进程有不同的端口号</p>
<p>被规定为一个16位的整数0~65535。</p>
<p>端口分类:</p>
<blockquote>
<p>公认端口:0~1023。被预先定义的服务通信占用（如:HTTP占用端口80，FTP占用端口21，Telnet占用端口23)</p>
<p>注册端口:1024~49151。分配给用户进程或应用程序。（如: Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。</p>
<p>动态/私有端口:49152~65535。</p>
</blockquote>
<p>端口号与IP地址组合得出一个网络套接字：Socket</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	    1. IP唯一标识 Internet上的计算机(通讯实体)</span></span><br><span class="line"><span class="comment"> *      2. 在java中使用InetAddress类代表IP</span></span><br><span class="line"><span class="comment"> *      3. IP分类，IPv4 和 IPv6； 万维网和局域网</span></span><br><span class="line"><span class="comment"> *      4. 域名： www.baidu.com</span></span><br><span class="line"><span class="comment"> *      5. DNS域名解析服务器</span></span><br><span class="line"><span class="comment"> *      6. 本地回路地址：127.0.0.1 对应着localhost</span></span><br><span class="line"><span class="comment"> *      7. 实例化InetAddress：两个方法：getName(String host), getLocalHost()</span></span><br><span class="line"><span class="comment"> *          两个常用方法：getHostName() / getHostAddress()</span></span><br><span class="line"><span class="comment"> *      8. 端口号：正在计算机上运行的程序</span></span><br><span class="line"><span class="comment"> *          要求：不同的进程有不同的端口号</span></span><br><span class="line"><span class="comment"> *          范围：被规定为一个16为整数0~65535</span></span><br><span class="line"><span class="comment"> *      9. 端口号和IP地址组合成一个网络套字：Scoket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;zjhinsist.github.io&quot;</span>);</span><br><span class="line">        System.out.println(inet);</span><br><span class="line"></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.10.14&quot;</span>);</span><br><span class="line">        System.out.println(inet1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取本机</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        System.out.println(inet2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取本机</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet3</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(inet3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取域名和本机</span></span><br><span class="line">        System.out.println(inet.getHostAddress());</span><br><span class="line">        System.out.println(inet.getHostName());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络通讯协议"><a class="markdownIt-Anchor" href="#网络通讯协议"></a> 网络通讯协议</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/KyYC93d6HwAElxB.png" alt="image-20220618174613339" /></p>
<p>网络通信协议</p>
<p>计算机网络中实现通信必须有一些约定，即通信协议，<mark class="hl-label red">对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准。</mark> </p>
<p>问题:网络协议太复杂</p>
<p>计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢</p>
<p>通信协议分层的思想</p>
<p>在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即<mark class="hl-label red">同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系</mark> 。各层互不影响，利于系统的开发和扩展。</p>
<mark class="hl-label red">TCP和UDP</mark> 
<p>TCP协议:</p>
<blockquote>
<p>使用TCP协议前，须先建立TCP连接，形成传输数据通道</p>
<p>传输前，采用“三次握手”方式，点对点通信，是可靠的</p>
<p>TCP协议进行通信的两个应用进程:客户端、服务端。</p>
<p>在连接中可进行大数据量的传输</p>
<p>传输完毕，需释放已建立的连接，效率低(“四次挥手”)</p>
</blockquote>
<p>UDP协议:</p>
<blockquote>
<p>将数据、源、目的封装成数据包，不需要建立连接</p>
<p>每个数据报的大小限制在64K内</p>
<p>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</p>
<p>可以广播发送</p>
<p>发送数据结束时无需释放资源，开销小，速度快</p>
</blockquote>
<h2 id="tcp网络编程"><a class="markdownIt-Anchor" href="#tcp网络编程"></a> TCP网络编程</h2>
<ol>
<li>
<p>客户端发信息给服务端，服务端将数据显示在控制台上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建Socket对象，指明服务器端的IP和端口号</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.01&quot;</span>);</span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet, <span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// 2. 获取一个输出流，用于输出数据</span></span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 写出数据</span></span><br><span class="line">        <span class="comment">// 因为os写入的需要时字节流文件，所以我们需要使用getBytes将字符串转换成字节流</span></span><br><span class="line">        os.write(<span class="string">&quot;你好，我是客户端&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (os != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个服务器端的ServerSocket， 指明自己的端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// 2. 调用accept() 表示接受来在客户端的socket</span></span><br><span class="line">        socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">// 3. 获取输入流</span></span><br><span class="line">        inputStream = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4. 从输入流中读取数据</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>客户端发送文件给服务器端，服务器端将文件保存在本地</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建Socket对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inetAddress, <span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// 2. 获取输出流， 向服务器端输出</span></span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3. 获取一个输入流，从内存中读取文件</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;wallhaven-72vwpo.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 向服务器端写数据</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (os != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个服务器端的对象</span></span><br><span class="line">        ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// 2. 读取客户端发来的数据</span></span><br><span class="line">        socket = ss.accept();</span><br><span class="line">        <span class="comment">// 3. 创建一个输入流</span></span><br><span class="line">        inputStream = socket.getInputStream();</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;picture.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 将客户端发来的图片写入到本地</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ss != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ss.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从客户端发送文件到服务端，服务端保存到本地。并返回发送成功到服务端。并关闭相应的链接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建Socket对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inetAddress, <span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// 2. 获取输出流， 向服务器端输出</span></span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3. 获取一个输入流，从内存中读取文件</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;wallhaven-72vwpo.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 向服务器端写数据</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止传送数据</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受来自服务器端的反馈</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">while</span>((len = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;好好好&quot;</span>);</span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (os != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (baos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个服务器端的对象</span></span><br><span class="line">        ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// 2. 读取客户端发来的数据</span></span><br><span class="line">        socket = ss.accept();</span><br><span class="line">        <span class="comment">// 3. 创建一个输入流</span></span><br><span class="line">        inputStream = socket.getInputStream();</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;picture.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 将客户端发来的图片写入到本地</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给予客户端反馈</span></span><br><span class="line">        outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;照片已收到&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ss != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ss.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outputStream != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="udp网络编程"><a class="markdownIt-Anchor" href="#udp网络编程"></a> UDP网络编程</h2>
<p>类 DatagramSocket和 DatagramPacket实现了基于UDP协议网络程序。</p>
<p>UDP数据报通过数据报套接字DatagramSocket发送和接收，<mark class="hl-label red">系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</mark> </p>
<p>DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</p>
<p>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sender</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是UDP方式发射的导弹&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,<span class="number">0</span>, data.length,address,<span class="number">8899</span>);</span><br><span class="line"></span><br><span class="line">        socket.send(packet);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>)&#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8899</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>,buffer.length);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), packet.getLength()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="url编程"><a class="markdownIt-Anchor" href="#url编程"></a> URL编程</h2>
<p>URL(Uniform Resource Locator):统一资源定位符，它表示Internet上某资源的地址。</p>
<p>它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p>
<p>通过URL我们可以访问 Internet上的各种网络资源，比如最常见的www，ftp站点。浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源。</p>
<p>URL的基本结构由5部分组成:</p>
<blockquote>
<p>&lt;传输协议&gt;:/&lt;主机名&gt;:&lt;端口号&gt;&lt;文件名&gt;#片段名?参数列表&gt;</p>
<p>例如:<br />
http;😕/192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123&gt;</p>
<p>#片段名:即锚点，例如看小说，直接定位到章节</p>
</blockquote>
<blockquote>
<p>参数列表格式:参数名=参数值&amp;参数名=参数值…</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?username=Tom&quot;</span>);</span><br><span class="line">        System.out.println(url.getProtocol());  <span class="comment">// 获取该URL的协议名</span></span><br><span class="line">        System.out.println(url.getHost());      <span class="comment">// 获取该URL的主机名</span></span><br><span class="line">        System.out.println(url.getPort());      <span class="comment">// 获取该URL的端口号</span></span><br><span class="line">        System.out.println(url.getPath());      <span class="comment">// 获取该URL的文件路径</span></span><br><span class="line">        System.out.println(url.getFile());      <span class="comment">// 获取该URL的文件名</span></span><br><span class="line">        System.out.println(url.getQuery());     <span class="comment">// 获取该URL的查询名</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="反射机制"><a class="markdownIt-Anchor" href="#反射机制"></a> 反射机制</h1>
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>Reflection(反射)被视为动态语言的关键，反射机制允许程序在执行期间，借助于Reflection API取得任何类的内部信息，并能直接操作，任意对象内部属性和方法。</p>
<p>加载完类之后，在堆内存的方法区中就产生了一个class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。<mark class="hl-label red">这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为:反射。</mark> </p>
<p>正常方式：引入需要的包类的名称 ----&gt;  通过new实例化 -----&gt; 取得实例化对象</p>
<p>反射方式：实例化对象  ----&gt;  getClass() 方法  -----&gt;   得到完整的包类的名称</p>
<ol>
<li>动态语言<br />
是一类在运行时可以改变其结构的语言:例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的发化。<mark class="hl-label red">通俗点说就是在运行时代码可以根据某些条件改变自身结构。</mark> .</li>
</ol>
<p>主要动态语言:Object-C、C#、JavaScript、PHP、Python、Erlang。</p>
<ol start="2">
<li>
<p>静态语言</p>
<p>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</p>
</li>
<li>
<p>Java不是动态语言，但Java可以称之为“<mark class="hl-label red">准动态语言</mark> ”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。</p>
<p>Java的动态性让编程的时候更加灵活!</p>
</li>
</ol>
<p>Java反射机制提供的功能</p>
<blockquote>
<p>在运行时判断任意一个对象所属的类</p>
<p>在运行时构造任意一个类的对象</p>
<p>在运行时判断任意一个类所具有的成员变量和方法</p>
<p>在运行时获取泛型信息</p>
<p>在运行时调用任意一个对象的成员变量和方法</p>
<p>在运行时处理注解</p>
<p>生成动态代理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射之前对于Person类的操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建Person类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通过对象调用其内部方法</span></span><br><span class="line">    p1.age = <span class="number">18</span>;</span><br><span class="line">    System.out.println(p1.toString());</span><br><span class="line"></span><br><span class="line">    p1.show();</span><br><span class="line">    <span class="comment">// 在Person类的外部，不可以通过Person类的对象，调用其内部的私有结构</span></span><br><span class="line">    <span class="comment">// 比如：name, showNation(), 以及私有的构造器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射之后，对Person的操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        <span class="comment">// 1. 通过反射创建Person类对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">        System.out.println(p.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.通过反射调用，对象指定的属性和方法</span></span><br><span class="line">        <span class="comment">// 调用属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.set(p, <span class="number">10</span>);</span><br><span class="line">        System.out.println(p.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        show.invoke(p);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*********************************&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过反射，可以调用Person类私有结构，比如：私有的构造器，方法，属性</span></span><br><span class="line">        <span class="comment">// 调用私有构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line">        cons1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) cons1.newInstance(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用私有属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(p1,<span class="string">&quot;MM&quot;</span>);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用私有方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">showNation</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class);</span><br><span class="line">        showNation.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nation</span> <span class="operator">=</span> (String) showNation.invoke(p1,<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        System.out.println(nation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于java.lang.Class类的理解</span></span><br><span class="line"><span class="comment">1.类的加载过程:</span></span><br><span class="line"><span class="comment">程序经过javac.exe命令以后，会生成一个或多个字节码文件(.cLass结尾)。</span></span><br><span class="line"><span class="comment">接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件</span></span><br><span class="line"><span class="comment">加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，</span></span><br><span class="line"><span class="comment">就作为CLass的一个实例。</span></span><br><span class="line"><span class="comment">2. 换句话说：Class实例就对应着一个运行时类</span></span><br><span class="line"><span class="comment">3. 加载到内存中的运行时类，会缓存一定的时间，在此时间内，我们可以通过不同的方式</span></span><br><span class="line"><span class="comment">来获取此运行时类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 获取Class类实例的的方式</span></span><br><span class="line"><span class="comment">// 前三种方式需要掌握</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方式一：调用运行时类的属性：.class</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">    System.out.println(clazz);</span><br><span class="line">    <span class="comment">// 方式二：通过运行时类的对象，调用getClass()</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">    System.out.println(clazz1);</span><br><span class="line">    <span class="comment">// 方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java1.Person&quot;</span>);</span><br><span class="line">        System.out.println(clazz2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方式四：使用类加载器：ClassLoader</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectionTest.class.getClassLoader();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clazz3 = classLoader.loadClass(<span class="string">&quot;java1.Person&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(clazz3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的加载"><a class="markdownIt-Anchor" href="#类的加载"></a> 类的加载</h2>
<p>ClassLoader：类的加载器，作用是把类（class）加载到内存中的</p>
<blockquote>
<p>Bootstap ClassLoader:引导加载器，是JVM自带的加载器，负责java平台核心库，用来装载核心类库，该加载类无法直接获取</p>
<p>Extension ClassLoader：扩展类加载器：负责jre/lib/ext目录下的jar包，或指定目录下的jar包装入工作库，JDK1.9以后的版本中ExtClassLoader 变成PlatFormClassLoader</p>
<p>System ClassLoader: 系统类加载器：负责java -classpath 或指定目录下的类与jar包装入工作，是最常用的加载器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前自定类ClassLoaderTest加载器</span></span><br><span class="line">    <span class="comment">// 对于自定义类，使用系统类加载器进行加载</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);</span><br><span class="line">    <span class="comment">// 调用系统类加载器的getParent(): 获取扩展类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> classLoader.getParent();</span><br><span class="line">    System.out.println(classLoader1);</span><br><span class="line">    <span class="comment">// 调用扩展类加载器的getParent(): 无法获取引导类加载器</span></span><br><span class="line">    <span class="comment">// 引导类加载器主要负责加载java的核心类库，无法加载自定义类的</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> classLoader1.getParent();</span><br><span class="line">    System.out.println(classLoader2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时文件默认在当前的module下</span></span><br><span class="line">    <span class="comment">// 读取配置文件的方式一：</span></span><br><span class="line">    <span class="comment">//        try &#123;</span></span><br><span class="line">    <span class="comment">//            fis = new FileInputStream(new File(&quot;jdbc.properties&quot;));</span></span><br><span class="line">    <span class="comment">//        &#125; catch (FileNotFoundException e) &#123;</span></span><br><span class="line">    <span class="comment">//            throw new RuntimeException(e);</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        try &#123;</span></span><br><span class="line">    <span class="comment">//            properties.load(fis);</span></span><br><span class="line">    <span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line">    <span class="comment">//            throw new RuntimeException(e);</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置文件的方式二：使用ClassLoader</span></span><br><span class="line">    <span class="comment">// 配置文件默认识别为当前文件的src下</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        properties.load(is);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">account</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;account&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name: &quot;</span>+name+<span class="string">&quot;\nage: &quot;</span>+age+<span class="string">&quot;\naccount: &quot;</span>+account+<span class="string">&quot;\npassword: &quot;</span>+password);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建运行时类对象"><a class="markdownIt-Anchor" href="#创建运行时类对象"></a> 创建运行时类对象</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    newInstance: 调用此方法，创建对应的运行时类的对象，内部调用了运行时类的空参构造器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    要想此方法正常的创建运行时类的对象，要求：</span></span><br><span class="line"><span class="comment">    1.运行时类必须提供空参构造器</span></span><br><span class="line"><span class="comment">    2.空参构造器的权限需要能够调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在javabean中要求提供一个public的空参构造器。原因：</span></span><br><span class="line"><span class="comment">    1. 便于通过反射，创建运行时类对象</span></span><br><span class="line"><span class="comment">    2. 便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    System.out.println(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">体会反射的动态性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (num)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            classPath = <span class="string">&quot;java1.Person&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> getInstance(classPath);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个指定类的对象。</span></span><br><span class="line"><span class="comment">classPath: 指定类的全类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(classPath).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取运行时类的完整结构"><a class="markdownIt-Anchor" href="#获取运行时类的完整结构"></a> 获取运行时类的完整结构</h2>
<p>属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取属性结构</span></span><br><span class="line">    <span class="comment">// getFields() :获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getDeclaredFields: 获取当前运行时类当中声明的所有属性，不包括父类</span></span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">        <span class="comment">// 权限修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifier</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">        System.out.print(Modifier.toString(modifier)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据类型</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">type</span> <span class="operator">=</span> f.getType();</span><br><span class="line">        System.out.print(type.getName() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变量名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fName</span> <span class="operator">=</span> f.getName();</span><br><span class="line">        System.out.println(fName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getMethods(): 获取当前运行时类及所有父类中声明为public权限的方法</span></span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getDeclaredMethods(): 获取当前运行时类中声明的所有方法，不包含父类中声明的方法</span></span><br><span class="line">    Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method method : declaredMethods)&#123;</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@Xxx</span></span><br><span class="line"><span class="comment">权限修饰符 返回值类型 方法名（参数类型1 形参1....） throws XxxException&#123;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method method : declaredMethods)&#123;</span><br><span class="line">        <span class="comment">// 1. 获取方法声明的注解</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 权限修饰符</span></span><br><span class="line">        System.out.print(Modifier.toString(method.getModifiers()) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回值类型</span></span><br><span class="line">        System.out.print(method.getReturnType().getName() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.方法名：</span></span><br><span class="line">        System.out.print(method.getName());</span><br><span class="line">        System.out.print(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="comment">// 5. 形参列表</span></span><br><span class="line">        Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (!(parameterTypes == <span class="literal">null</span> &amp;&amp; parameterTypes.length == <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i == parameterTypes.length)&#123;</span><br><span class="line">                    System.out.print(parameterTypes[i].getName() + <span class="string">&quot;args_&quot;</span> + i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(parameterTypes[i].getName() + <span class="string">&quot;args_&quot;</span> + i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 抛出异常</span></span><br><span class="line">        Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();</span><br><span class="line">        <span class="keyword">if</span> (!(exceptionTypes == <span class="literal">null</span> &amp;&amp; exceptionTypes.length == <span class="number">0</span>))&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;throws &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; exceptionTypes.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i == exceptionTypes.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.print(exceptionTypes[i].getName());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(exceptionTypes[i].getName() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取构造器结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getConstructors: 获取当前运行时类中声明为public的构造器</span></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : constructors)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getDeclaredConstructors: 获取当前运行时类中声明的所有的构造器</span></span><br><span class="line"></span><br><span class="line">    Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : declaredConstructors)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取运行时类的父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getSuperclass:获取运行时类的父类</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> clazz.getSuperclass();</span><br><span class="line">    System.out.println(superclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getGenericSuperclass: 获取运行时的带泛型的父类</span></span><br><span class="line">    <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">    System.out.println(genericSuperclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取运行时类的带泛型的父类的泛型</span></span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">    <span class="comment">// 获取泛型参数</span></span><br><span class="line">    Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">    System.out.println(actualTypeArguments[<span class="number">0</span>].getTypeName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取父类</span></span><br><span class="line"><span class="comment">class com.hgu.myssm.basedao.BaseDAO</span></span><br><span class="line"><span class="comment">获取带泛型父类</span></span><br><span class="line"><span class="comment">com.hgu.myssm.basedao.BaseDAO&lt;com.hgu.book.pojo.Book&gt;</span></span><br><span class="line"><span class="comment">获取父类的泛型</span></span><br><span class="line"><span class="comment">com.hgu.book.pojo.Book</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//    获取运行时类实现的接口</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span>(Class c : interfaces)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取运行时类所在的包</span></span><br><span class="line">    <span class="type">Package</span> <span class="variable">aPackage</span> <span class="operator">=</span> clazz.getPackage();</span><br><span class="line">    System.out.println(aPackage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取运行时类的注解</span></span><br><span class="line">    Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">    <span class="keyword">for</span>(Annotation a : annotations)&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用运行时类的指定结构"><a class="markdownIt-Anchor" href="#调用运行时类的指定结构"></a> 调用运行时类的指定结构</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line">    <span class="comment">// 获取指定的属性,只能获取权限为public的</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">id</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前属性的值</span></span><br><span class="line">    <span class="comment">// set() :参数一：指明设置那个对象的属性， 参数二：将此属性设置成为多少</span></span><br><span class="line">    id.set(p, <span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取当前属性的值</span></span><br><span class="line"><span class="comment">    get() : 参数一：获取那个对象的当前属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pId</span> <span class="operator">=</span> (<span class="type">int</span>) id.get(p);</span><br><span class="line">    System.out.println(pId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如何操作运行时类中指定的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">    <span class="comment">// 创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line">    <span class="comment">// 1. getDeclaredField(String name) 获取运行时类中指定的变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 保证当前对象时可访问的</span></span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 3. 获取指定对象的词属性值</span></span><br><span class="line">    name.set(p, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如何操作运行时类中指定的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">    <span class="comment">// 创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     1. 获取某个指定的方法</span></span><br><span class="line"><span class="comment">     getDeclaredMethod():参数1：指明获取方法的名称， 参数2：指明获取方法的形参列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 保证当前的方法是可访问的</span></span><br><span class="line">    show.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      3. 调用invoke(): 参数1：方法的调用者， 参数2：给方法形参赋值的实参</span></span><br><span class="line"><span class="comment">        invoke()的返回值即为 对应类中调用方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    show.invoke(p, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************************如何调用静态方法********************&quot;</span>);</span><br><span class="line">    <span class="comment">// private static void showDesc</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">showDesc</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">    showDesc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 如果showDesc没有返回值的话，则invoke返回null</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> showDesc.invoke(Person.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如何调用运行时类中指定的构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 获取指定构造器</span></span><br><span class="line"><span class="comment">    getDeclaredConstructor() :参数：指明构造器的参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// private Person(String name)</span></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 调用构造器创建运行时类对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h2>
<p>代理设计模式的原理:</p>
<p>使用一个代理将对象包装起来,然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p>
<p>之前的代理机制的操作，属于静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。<mark class="hl-label orange">最好可以通过一个代理类完成全部的代理功能。</mark> </p>
<h3 id="静态代理功能"><a class="markdownIt-Anchor" href="#静态代理功能"></a> 静态代理功能</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClothFactory</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClothFactory factory; <span class="comment">// 用被代理类对象进行实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyClothFactory</span><span class="params">(ClothFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些准备工作&quot;</span>);</span><br><span class="line">        factory.produceCloth();</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些后续的收尾工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nike工厂生产一批运动服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建被代理类的对象</span></span><br><span class="line">        <span class="type">NikeClothFactory</span> <span class="variable">nike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NikeClothFactory</span>();</span><br><span class="line">        <span class="comment">// 创建代理类的对象，</span></span><br><span class="line">        <span class="type">ProxyClothFactory</span> <span class="variable">proxyClothFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyClothFactory</span>(nike);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态代理-2"><a class="markdownIt-Anchor" href="#动态代理-2"></a> 动态代理</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    String <span class="title function_">getBelief</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBelief</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃：&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要想实现动态代理，需要解决的问题</span></span><br><span class="line"><span class="comment">问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</span></span><br><span class="line"><span class="comment">问题二：当通过代理类的对象调用方法的时候，如何动态的去调用被代理类中同名的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 通过此方法，返回一个代理类的对象，解决问题一：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object obj)</span>&#123;<span class="comment">// obj被代理类对象</span></span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>();</span><br><span class="line"></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj; <span class="comment">// 需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当我们通过代理类的对象，调用方法a时，就会自动调用如下的方法，invoke()</span></span><br><span class="line">    <span class="comment">// 当被代理类要执行方法a的功能就声明在invoke() 中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">// obj:被代理类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ReturnValue</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line">        <span class="comment">// 上述方法的返回值就作为当前类中invoke() 的返回值</span></span><br><span class="line">        <span class="keyword">return</span> ReturnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建被代理对象</span></span><br><span class="line">        <span class="type">SuperMan</span> <span class="variable">superMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">        <span class="comment">// 创建代理类对象</span></span><br><span class="line">        <span class="type">Human</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line"></span><br><span class="line">        proxyInstance.getBelief();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java8新特性"><a class="markdownIt-Anchor" href="#java8新特性"></a> Java8新特性</h1>
<ul>
<li>速度更快</li>
<li>代码更少(增加了新的语法：lambda表达式)</li>
<li>强大的Stream API</li>
<li>便于并行</li>
<li>最大化减少空指针异常 Optional</li>
<li>Nashorn 引擎，允许在JVM上运行JS应用</li>
</ul>
<h2 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> Lambda表达式</h2>
<p>Lambda是一个<mark class="hl-label orange">匿名函数</mark> ，我们可以把Lambda表达式理解为<mark class="hl-label orange">是一段可以传递的代码</mark> （将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Lambda表达式的使用</span></span><br><span class="line"><span class="comment"> *  1. 举例： (o1, o2) -&gt; Integer.compare(o1, o2)</span></span><br><span class="line"><span class="comment"> *  2. 格式：</span></span><br><span class="line"><span class="comment"> *      -&gt; : lambda操作符 或箭头操作符</span></span><br><span class="line"><span class="comment"> *      -&gt;左边 : 形参列表 （其实就是接口中的抽象方法的形参列表）</span></span><br><span class="line"><span class="comment"> *      -&gt;右边 : lambda 体：（其实就是重写抽象方法中的方法体）</span></span><br><span class="line"><span class="comment"> *  3. lambda表达式的使用：（分为六种情况）</span></span><br><span class="line"><span class="comment"> *      总结：</span></span><br><span class="line"><span class="comment"> *      -&gt;左边 ： lambda形参列表的参数类型可以省略（类型推断），如果lambda形参列表只有一个参数，其一对() 可以省略</span></span><br><span class="line"><span class="comment"> *      -&gt;右边 ： lambda体应使用一个&#123;&#125;来包裹；如果lambda体只有一条执行语句（可能是return语句），可以省略这一对&#123;&#125;和return关键字</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  4. lambda表达式的本质：作为接口的实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  5. 如果一个接口中，只声明了一个抽象方法，则此接口就称作函数式接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> LambdaTest1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Mr.zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest1</span> &#123;</span><br><span class="line">    <span class="comment">// 语法格式一：无惨无返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;别走，跑起来&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        r1.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************lambda**************&quot;</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">        r2.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式二：需要一个参数但是没有返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;我是一个正常写法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        con1.accept(<span class="string">&quot;我是lambda写法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式三：数据类型可以省略，应为可由编译器推断出，称为“类型推断”</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;我是lambda写法1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con2 = (s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con2.accept(<span class="string">&quot;我是lambda写法2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式四：Lambda若只需要一个参数的时候，参数的小括号可以省略</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; con2 = s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con2.accept(<span class="string">&quot;我是lambda写法1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式五：Lambda两个或以上的参数，多条执行语句，并且有返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;语句1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;语句2&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(com1.compare(<span class="number">12</span>, <span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;语句1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;语句2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(com2.compare(<span class="number">13</span>, <span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式六：当lambda体只有一条语句的时候，return 与大括号若都有，都可以省略</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(com1.compare(<span class="number">12</span>, <span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">        System.out.println(com2.compare(<span class="number">13</span>, <span class="number">12</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数式接口"><a class="markdownIt-Anchor" href="#函数式接口"></a> 函数式接口</h2>
<mark class="hl-label orange">只包含一个抽象方法的接口，称为函数式接口。</mark> 
<p>你可以通过Lambda表达式来创建该接口的对象。（若Lambda表达式抛出一个受检异常(即:非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明)。</p>
<p>我们可以在一个接口上使用<mark class="hl-label 注解">@Functionallnterface</mark> ，这样做可以检查它是否是一个函数式接口。同时 javadoc也会包含一条声明，说明这个接口是一个函数式接口。</p>
<mark class="hl-label orange">在java.util.function包下定义了Java8的丰富的函数式接口</mark> 
<table>
<thead>
<tr>
<th style="text-align:center">函数式接口</th>
<th style="text-align:center">参数类型</th>
<th style="text-align:center">返回类型</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Consumer<T><br />消费型接口</td>
<td style="text-align:center">T</td>
<td style="text-align:center">void</td>
<td style="text-align:center">对类型为T的对象应用操作，包含方法，<br />void accept（T t）</td>
</tr>
<tr>
<td style="text-align:center">Supplier<T><br />供给型接口</td>
<td style="text-align:center">无</td>
<td style="text-align:center">T</td>
<td style="text-align:center">返回值类型为T的对象，包含方法，T.get()</td>
</tr>
<tr>
<td style="text-align:center">Function&lt;T, R&gt;<br />函数型接口</td>
<td style="text-align:center">T</td>
<td style="text-align:center">R</td>
<td style="text-align:center">对于类型为T的对象，应用操作，并返回结果。<br />结果是R型对象，包含方法：R apply（T t）</td>
</tr>
<tr>
<td style="text-align:center">Predicate<T><br />断定性接口</td>
<td style="text-align:center">T</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">确定类型为T的对象，是否满足某约束，并返回<br />Boolean值。包含方法：boolean test(T t)</td>
</tr>
</tbody>
</table>
<h2 id="方法引用与构造器引用"><a class="markdownIt-Anchor" href="#方法引用与构造器引用"></a> 方法引用与构造器引用</h2>
<h3 id="方法引用"><a class="markdownIt-Anchor" href="#方法引用"></a> 方法引用：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest2</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        happyTime(<span class="number">500</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Double&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Double aDouble)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;买炸鸡,价格为：&quot;</span> + aDouble);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">        happyTime(<span class="number">400</span>, money -&gt; System.out.println(<span class="string">&quot;买烤肠，价格为：&quot;</span> + money));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">happyTime</span><span class="params">(<span class="type">double</span> money, Consumer&lt;Double&gt; con)</span>&#123;</span><br><span class="line">        con.accept(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法的使用</span></span><br><span class="line"><span class="comment">    1. 使用情境：当要传递给lambda体的操作，已经有实现方法了，可以作为使用方法引用</span></span><br><span class="line"><span class="comment">    2. 方法引用，本质上是lambda表达式</span></span><br><span class="line"><span class="comment">    3. 使用格式：类(或对象) :: 方法名</span></span><br><span class="line"><span class="comment">    4. 具体使用分为如下三种情况：</span></span><br><span class="line"><span class="comment">        情况1     对象 :: 非静态方法</span></span><br><span class="line"><span class="comment">        情况2     类 :: 静态方法</span></span><br><span class="line"><span class="comment">        情况3     类 :: 非静态方法</span></span><br><span class="line"><span class="comment">    5. 方法引用的使用要求：</span></span><br><span class="line"><span class="comment">        要求接口中的抽象方法的形参列表和返回值类型，和方法引用中的方法的形参列表和返回值类型相同（针对于情况1，情况2）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况一： 对象 :: 实例方法</span></span><br><span class="line">    <span class="comment">// Consumer中的void accept(T t)</span></span><br><span class="line">    <span class="comment">// PrintStream中的void println(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; cons1 = str -&gt; System.out.println(str);</span><br><span class="line">        cons1.accept(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> System.out;</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; cons2 = ps :: println;</span><br><span class="line">        cons2.accept(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Supplier 中的T get()</span></span><br><span class="line">    <span class="comment">// Employee 中的String getName()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;String&gt; sup = () -&gt; person.getName();</span><br><span class="line">        System.out.println(sup.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;String&gt; sup2 = person :: getName;</span><br><span class="line">        System.out.println(sup2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况二：类 :: 静态方法</span></span><br><span class="line">    <span class="comment">// Comparator中的int compare(T t1, T t2);</span></span><br><span class="line">    <span class="comment">// Integer 中的 int compare(T t1, T t2);</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com1 = (t1, t2) -&gt; Integer.compare(t1, t2);</span><br><span class="line">        System.out.println(com1.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; com2 = Integer :: compare;</span><br><span class="line">        System.out.println(com2.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        Function&lt;Double, Long&gt; fun = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double d)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.round(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">aDouble</span> <span class="operator">=</span> <span class="number">12.0</span>;</span><br><span class="line">        System.out.println(fun.apply(aDouble));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Double, Long&gt; fun1 = d -&gt; Math.round(d);</span><br><span class="line">        System.out.println(fun1.apply(aDouble));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Double, Long&gt; fun2 = Math::round;</span><br><span class="line">        System.out.println(fun2.apply(aDouble));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况三：类::实例方法</span></span><br><span class="line">    <span class="comment">// Comparator中的int compare(T t1, T t2)</span></span><br><span class="line">    <span class="comment">// String 中的 int t1.compareTo(t2)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Comparator 中的compare方法 的方法体调用 String类型中的compareTo这个方法</span></span><br><span class="line">        Comparator&lt;String&gt; com1 = (s1, s2) -&gt; s1.compareTo(s2);</span><br><span class="line">        System.out.println(com1.compare(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个参数为String中compareTo中的调用者，第二个参数为compareTo的调用者</span></span><br><span class="line">        Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class="line">        System.out.println(com2.compare(<span class="string">&quot;abd&quot;</span>, <span class="string">&quot;abc&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line">    <span class="comment">// String中的boolean t1.equals(t2)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span> &#123;</span><br><span class="line">        BiPredicate&lt;String, String&gt; bp = (s1, s2) -&gt; s1.equals(s2);</span><br><span class="line">        System.out.println(bp.test(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BiPredicate&lt;String, String&gt; bp1 = String :: equals;</span><br><span class="line">        System.out.println(bp1.test(<span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;ABC&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function 中的R apply(T t)</span></span><br><span class="line">    <span class="comment">// Employee 中的String getName()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test8</span><span class="params">()</span> &#123;</span><br><span class="line">        Function&lt;Person, String&gt; fun = p -&gt; p.getName();</span><br><span class="line">        System.out.println(fun.apply(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Person, String&gt; fun2 = Person::getName;</span><br><span class="line">        System.out.println(fun2.apply(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">16</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造器引用"><a class="markdownIt-Anchor" href="#构造器引用"></a> 构造器引用：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  一，构造器引用</span></span><br><span class="line"><span class="comment"> *      和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致</span></span><br><span class="line"><span class="comment"> *      抽象方法的返回值类型即为构造器所属类的类型</span></span><br><span class="line"><span class="comment"> *  二，数组引用</span></span><br><span class="line"><span class="comment"> *      可以把数组看成一个特殊的类，则写法和构造器引用一致</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorRefTest</span> &#123;</span><br><span class="line">    <span class="comment">// 构造器引用：</span></span><br><span class="line">    <span class="comment">// Supplier 中的T get()</span></span><br><span class="line">    <span class="comment">// Person的空参构造器</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        Supplier&lt;Person&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Person <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Person&gt; sup1 = () -&gt; <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Person&gt; sup2 = Person :: <span class="keyword">new</span>;</span><br><span class="line">        System.out.println(sup2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function中的R apply(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Function&lt;Integer, Person&gt; fun = id -&gt; <span class="keyword">new</span> <span class="title class_">Person</span>(id);</span><br><span class="line">        System.out.println(fun.apply(<span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Integer, Person&gt; fun1 = Person :: <span class="keyword">new</span>;</span><br><span class="line">        System.out.println(fun1.apply(<span class="number">18</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BiFunction中的 R apply(T t, U u)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        BiFunction&lt;String, Integer, Person&gt; bf = (s, i) -&gt; <span class="keyword">new</span> <span class="title class_">Person</span>(s, i);</span><br><span class="line">        System.out.println(bf.apply(<span class="string">&quot;Tom&quot;</span>, <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BiFunction&lt;String, Integer, Person&gt; bf1 = Person::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(bf1.apply(<span class="string">&quot;Jerry&quot;</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组引用</span></span><br><span class="line">    <span class="comment">// Function中的R apply(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        Function&lt;Integer, String[]&gt; fun = length -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">        String[] strings = fun.apply(<span class="number">10</span>);</span><br><span class="line">        System.out.println(strings);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*********************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Integer, String[]&gt; fun1 = String[] :: <span class="keyword">new</span>;</span><br><span class="line">        String[] strings1 = fun1.apply(<span class="number">5</span>);</span><br><span class="line">        System.out.println(strings1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="streamapi"><a class="markdownIt-Anchor" href="#streamapi"></a> StreamAPI</h2>
<p>Stream API ( java.util.stream)把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
<p>Stream是 Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。<mark class="hl-label API对集合数据进行操作，就类似于使用SQL执行的数据库查询">使用Stream</mark> 。也可以使用Stream API来并行执行操作。简言之，Stream API提供了一种高效且易于使用的处理数据的方式。</p>
<ol>
<li>
<p>Stream关注的是数据的运算，和CPU有关系<br />
集合关注的是数据的存储，与内存有关系</p>
</li>
<li>
<p>Stream自己不会存储元素</p>
<p>Stream 不会改变原对象，相反它会返回一个持有结果的新Stream<br />
Stream 操作是延迟的这意味着他们会等到需要结果的时候才执行</p>
</li>
<li>
<p>Stream  执行流程<br />
Stream的实例化<br />
一系列的中间操作<br />
终止操作</p>
</li>
<li>
<p>说明：<br />
一个中间操作链，对数据源的数据进行处理<br />
一旦执行终止操作，就执行中间操作链，并产生结果，之后不会再被使用</p>
</li>
</ol>
<h3 id="streamapi实例化的四种方法"><a class="markdownIt-Anchor" href="#streamapi实例化的四种方法"></a> StreamAPI实例化的四种方法</h3>
<ol>
<li>通过集合</li>
<li>通过数组</li>
<li>通过Stream的of</li>
<li>创建无限流</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamAPITest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Stream方式一：通过集合</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先获取一个集合</span></span><br><span class="line">        List&lt;Person&gt; persons = PersonData.getPersons();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// default Stream&lt;E&gt; stream() : 返回一个顺序流</span></span><br><span class="line">        Stream&lt;Person&gt; stream = persons.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// default Stream&lt;E&gt; parallelStream(): 返回一个并行流</span></span><br><span class="line">        Stream&lt;Person&gt; stream1 = persons.parallelStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Stream方式二：通过数组</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">// 调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class="line">        <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        Person[] arr2 = <span class="keyword">new</span> <span class="title class_">Person</span>[]&#123;p1, p2&#125;;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Person&gt; stream1 = Arrays.stream(arr2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Stream方式三：通过Stream的of（）</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Stream方式四：创建无限流</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//迭代</span></span><br><span class="line">        <span class="comment">//public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed,final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">        <span class="comment">// 遍历前10个偶数</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>, t-&gt;t+<span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成</span></span><br><span class="line">        <span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">        Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stream的中间操作"><a class="markdownIt-Anchor" href="#stream的中间操作"></a> Stream的中间操作</h3>
<p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理!而在终止操作时一次性全部处理,称为“惰性求值”。</p>
<ol>
<li>
<p>筛选与切片</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">filter(Predicate p)</td>
<td style="text-align:center">接受Lambda，从流中排除某些元素</td>
</tr>
<tr>
<td style="text-align:center">distinct()</td>
<td style="text-align:center">筛选，通过流生成元素的hashCode() 和 equals()去除重复元素</td>
</tr>
<tr>
<td style="text-align:center">limit(long maxSize)</td>
<td style="text-align:center">截断流，使其元素不超过指定数量</td>
</tr>
<tr>
<td style="text-align:center">skip(long n)</td>
<td style="text-align:center">跳过元素，返回一个扔掉了前n个元素的流，若流中的元素不足<br />n个，则返回一个空流，与limit互补</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1-筛选与切片</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Person&gt; persons = PersonData.getPersons();</span><br><span class="line">    <span class="comment">// filter(Predicate p)—接收Lambda ,从流中排除某些元素。</span></span><br><span class="line">    Stream&lt;Person&gt; stream = persons.stream();</span><br><span class="line">    stream.filter(p -&gt; p.getAge() &gt; <span class="number">20</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*********************&quot;</span>);</span><br><span class="line">    <span class="comment">// limit(n)—截断流，使其元素不超过给定数量。</span></span><br><span class="line">    persons.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">    <span class="comment">// skip(n)一跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个,则返回一</span></span><br><span class="line">    persons.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// distinct()—筛选，通过流所生成元素的 hashcode()和equals()去除重复元素</span></span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    persons.stream().distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>映射</li>
</ol>
<p>​</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">map(Function f)</td>
<td style="text-align:center">接收一个函数作为参数，该函数会被应用到每个<br />元素上，并将其映射成一个新的元素</td>
</tr>
<tr>
<td style="text-align:center">map  ToDouble(ToDoubleFunction f)</td>
<td style="text-align:center">接受一个函数作为参数，该函数会被应用到每一个元素<br />上，产生成一个新的DoubleStream</td>
</tr>
<tr>
<td style="text-align:center">map  ToInt(ToIntFunction f)</td>
<td style="text-align:center">接受一个函数作为参数，该函数会被应用到每个元素<br />上产生一个新的IntStream</td>
</tr>
<tr>
<td style="text-align:center">map   ToLong(ToLongFunction  f)</td>
<td style="text-align:center">接受一个函数作为参数，该函数会被应用到每个元素<br />上产生一个新的LongStream</td>
</tr>
<tr>
<td style="text-align:center">flatMap(Function f)</td>
<td style="text-align:center">接受一个函数作为参数，将流中的每个值都换成另<br />一个流，然后把所有流连接成一个流</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamAPITest1</span> &#123;</span><br><span class="line">    <span class="comment">// 映射</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上并将其映射成一个新的元素。</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;DD&quot;</span>);</span><br><span class="line">        list.stream().map(str -&gt; str.toLowerCase()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//练习1:获取员工姓名长度大于3的员工的姓名。</span></span><br><span class="line">        List&lt;Person&gt; persons = PersonData.getPersons();</span><br><span class="line">        Stream&lt;String&gt; nameStream = persons.stream().map(Person::getName);</span><br><span class="line">        nameStream.filter(name -&gt; name.length() &gt; <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//练习2</span></span><br><span class="line">        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest1::fromStringToStream);</span><br><span class="line">        streamStream.forEach( s -&gt;&#123;</span><br><span class="line">            s.forEach(System.out::println);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</span></span><br><span class="line">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);</span><br><span class="line">        characterStream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title function_">fromStringToStream</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        ArrayList&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Character c : str.toCharArray()) &#123;</span><br><span class="line">            list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>排序</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sorted()</td>
<td style="text-align:center">产生一个新流，其中按照自然顺序排序</td>
</tr>
<tr>
<td style="text-align:center">sorted(Comparator com)</td>
<td style="text-align:center">产生一个新流，其中按照比较器顺序排序</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// sorted() - 自然排序</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">36</span>, <span class="number">25</span>, <span class="number">2</span>, -<span class="number">5</span>, <span class="number">17</span>, <span class="number">32</span>);</span><br><span class="line">    Stream&lt;Integer&gt; sorted = list.stream().sorted();</span><br><span class="line">    sorted.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一个类中没有实现Comparable接口的话，不能够使用sorted方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sorted(Computer com) - 定制排序</span></span><br><span class="line">    List&lt;Person&gt; list1 = PersonData.getPersons();</span><br><span class="line">    list1.stream().sorted((p1, p2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> -Integer.compare(p1.getAge(), p2.getAge());</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="终止操作"><a class="markdownIt-Anchor" href="#终止操作"></a> 终止操作</h3>
<ol>
<li>匹配与查找</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">allMatch(Predicate  p)</td>
<td style="text-align:center">查找是否匹配所有元素</td>
</tr>
<tr>
<td style="text-align:center">anyMatch(Predicate  p)</td>
<td style="text-align:center">检查是否至少匹配一个元素</td>
</tr>
<tr>
<td style="text-align:center">noneMatch(Predicate  p)</td>
<td style="text-align:center">检查是否没有匹配所有元素</td>
</tr>
<tr>
<td style="text-align:center">findFirst()</td>
<td style="text-align:center">返回第一个元素</td>
</tr>
<tr>
<td style="text-align:center">findAny()</td>
<td style="text-align:center">返回当前流中的任意的元素</td>
</tr>
<tr>
<td style="text-align:center">count()</td>
<td style="text-align:center">返回流中元素总和</td>
</tr>
<tr>
<td style="text-align:center">max(Comparator  c)</td>
<td style="text-align:center">返回流中的最大值</td>
</tr>
<tr>
<td style="text-align:center">min(Comparator  c)</td>
<td style="text-align:center">返回流中的最小值</td>
</tr>
<tr>
<td style="text-align:center">forEach(Consumer  c)</td>
<td style="text-align:center">内部迭代</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Person&gt; persons = PersonData.getPersons();</span><br><span class="line">        <span class="comment">//allMatch(Predicate p)——检查是否匹配所有元素。</span></span><br><span class="line">        <span class="comment">// 练习:是否所有的员工的年龄都大于18</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> persons.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">        System.out.println(allMatch);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//anyMatch(Predicate p)——检查是否至少匹配一个元素。练习:是否存在员工的年龄大于21</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> persons.stream().anyMatch(e -&gt; e.getAge() &gt; <span class="number">21</span>);</span><br><span class="line">        System.out.println(anyMatch);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//noneMatch(Predicate p)——检查是否没有匹配的元素。练习:是否存在员工姓“雷</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> persons.stream().noneMatch(e -&gt; e.getName().startsWith(<span class="string">&quot;大&quot;</span>));</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//findFirst——返回第一个元素</span></span><br><span class="line">        Optional&lt;Person&gt; first = persons.stream().findFirst();</span><br><span class="line">        System.out.println(first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//findAny——返回当前流中的任意元素</span></span><br><span class="line">        Optional&lt;Person&gt; any = persons.parallelStream().findAny();</span><br><span class="line">        System.out.println(any);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//count——返回流中元素的总个数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> persons.stream().filter(e -&gt; e.getAge() &gt; <span class="number">18</span>).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//max(Comparator c)—返回流中最大值    练习:返回最高的工资:</span></span><br><span class="line">        Stream&lt;Integer&gt; integerStream = persons.stream().map(e -&gt; e.getAge());</span><br><span class="line">        Optional&lt;Integer&gt; max = integerStream.max(Integer::compare);</span><br><span class="line">        System.out.println(max);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// min(Comparator c)—返回流中最小值   练习：返回最低工资的员工</span></span><br><span class="line">        Optional&lt;Person&gt; min = persons.stream().min((e1, e2) -&gt; Double.compare(e1.getAge(), e2.getAge()));</span><br><span class="line">        System.out.println(min);</span><br><span class="line">        <span class="comment">//forEach(Consumer  c)-- 内部迭代</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>归约</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">reduce(T  iden, BinaryOperator  b)</td>
<td style="text-align:center">可以将流中元素反复结合起来，得到一个值，返回T</td>
</tr>
<tr>
<td style="text-align:center">reduce(BinaryOperator   b)</td>
<td style="text-align:center">可以将流中的元素反复结合起来<br />得到一个值，返回Optional<T></td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// reduce(T  identity, BinaryOperator  b)可以将流中元素反复结合起来，得到一个值，返回T</span></span><br><span class="line">    <span class="comment">// 练习一：计算1 - 10自然数和</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce(BinaryOperator)一可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;</span></span><br><span class="line">    <span class="comment">// 练习2:计算公司所有员工年龄的总和</span></span><br><span class="line">    List&lt;Person&gt; persons = PersonData.getPersons();</span><br><span class="line">    Stream&lt;Integer&gt; stream = persons.stream().map(Person::getAge);</span><br><span class="line">    Optional&lt;Integer&gt; sum1 = stream.reduce(Integer::sum);</span><br><span class="line">    System.out.println(sum1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>收集</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">collect(Collector   c)</td>
<td style="text-align:center">将流转换为其他形式，接收一个Collector接口的实现<br />用于给Stream中元素做汇总的方法</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/04/5SpxCi6Un7kBIeu.png" alt="image-20220626212718997" /></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// collect(Collector c)将流转换为其他形式，接收一个Collector接口的实现用于给Stream中元素做汇总的方法</span></span><br><span class="line">    <span class="comment">// 练习1：查找年龄大于20的员工，结果返回一个list或set</span></span><br><span class="line">    List&lt;Person&gt; persons = PersonData.getPersons();</span><br><span class="line">    List&lt;Person&gt; collect = persons.stream().filter(p -&gt; p.getAge() &gt; <span class="number">20</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    collect.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;**************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;Person&gt; collect1 = persons.stream().filter(p -&gt; p.getAge() &gt; <span class="number">20</span>).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">    collect1.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="optional类"><a class="markdownIt-Anchor" href="#optional类"></a> Optional类</h3>
<p>尽可能的避免在开发中遇到空指针异常</p>
<p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>创建Optional类对象的方法:</p>
<blockquote>
<p>Optional.of(T t)∶创建一个 Optional实例，t必须非空;</p>
<p>Optional.empty():创建一个空的Optional实例</p>
<p>Optional.ofNullable(T t): t可以为null</p>
</blockquote>
<p>判断Optional容器中是否包含对象:</p>
<blockquote>
<p>boolean isPresent():判断是否包含对象</p>
<p>void ifPresent(Consumer&lt;? super T&gt; consumer):如果有值，就执行Consumer<br />
接口的实现代码，并且该值会作为参数传给它。</p>
</blockquote>
<p>获取Optional容器的对象:</p>
<blockquote>
<p>T  get():如果调用对象包含值，返回该值，否则抛异常</p>
<p>T  orElse(T other):如果有值则将其返回，否则返回指定的other对象。</p>
<p>T  orElseGet(Supplier&lt;? extends T&gt; other):如果有值则将其返回，否则返回由<br />
Supplier接口实现提供的对象。</p>
<p>T  orElse Throw(Supplier&lt;? extends X&gt;exceptionSupplier):如果有值则将其返<br />
回，否则抛出由Supplier接口实现提供的异常。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalTest</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Optional.of(T t) :创建一个Optional实例，t必须非空;</span></span><br><span class="line"><span class="comment">    Optional.empty() :创建一个空的Optional实例</span></span><br><span class="line"><span class="comment">    Optional.ofNullable(T t): t可以为null</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">        <span class="comment">// of(T t):保证t是非空的</span></span><br><span class="line">        Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">        girl = <span class="literal">null</span>;</span><br><span class="line">        Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);</span><br><span class="line">        System.out.println(optionalGirl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// orElse(T t):如果当前Optional返回的内部包装类是非空的话，则返回内部的t</span></span><br><span class="line">        <span class="comment">// 如果内部的大是空的，则返回orElse()方法中的参数</span></span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl1</span> <span class="operator">=</span> optionalGirl.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;赵丽颖&quot;</span>));</span><br><span class="line">        System.out.println(girl1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有Optional的时候我们获取属性的方法为</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGirlName</span><span class="params">(Boy boy)</span>&#123;</span><br><span class="line">        <span class="comment">// 可能会出现空指针异常</span></span><br><span class="line">        <span class="keyword">return</span> boy.getGirl().getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这是没有Optional类的时候我们采用的方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">GirlName</span> <span class="operator">=</span> getGirlName(boy);</span><br><span class="line">        System.out.println(GirlName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化之后的GetGirlName方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGirlName1</span><span class="params">(Boy boy)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (boy != <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> boy.getGirl();</span><br><span class="line">            <span class="keyword">if</span>( girl != <span class="literal">null</span> )&#123;</span><br><span class="line">                <span class="keyword">return</span> girl.getName()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Optional类的getGirlName():</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGirlName2</span><span class="params">( Boy boy)</span>&#123;</span><br><span class="line">        Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class="line">        <span class="comment">// 门此时的boy一定非空</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">boy1</span> <span class="operator">=</span> boyOptional.orElse(<span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;迪丽热巴&quot;</span>)));</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> boy1.getGirl();</span><br><span class="line">        Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);</span><br><span class="line">        <span class="comment">// girl1一定非空</span></span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl1</span> <span class="operator">=</span> optionalGirl.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;古力娜扎&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> girl1.getName( );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java91011新特性"><a class="markdownIt-Anchor" href="#java91011新特性"></a> Java9，10，11新特性</h1>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">Nuyoah</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://262259.xyz/2022/05/16/JAVA%E7%AC%94%E8%AE%B0/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://262259.xyz/2022/05/16/JAVA%E7%AC%94%E8%AE%B0/')">JAVA教程</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://s2.loli.net/2022/08/16/weL31EHsON5ldDU.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/08/16/weL31EHsON5ldDU.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/08/16/2yRjVx9gFKQaidA.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/08/16/2yRjVx9gFKQaidA.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://262259.xyz/2022/05/16/JAVA%E7%AC%94%E8%AE%B0/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JAVA教程&amp;url=http://262259.xyz/2022/05/16/JAVA%E7%AC%94%E8%AE%B0/&amp;pic=https://s2.loli.net/2022/11/21/Sm8lFrjtzUkihVy.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://262259.xyz" target="_blank">Nuyoah</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JAVA/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JAVA<span class="tagsPageCount">5</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/11/11/PRhut51DVxg9XBc.jpg?_r_=02db7499-72ba-2304-866d-b5c2b561abcc" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%BA%8E%E9%80%BB%E8%BE%91/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/10/CpDf8cx6TQdS49b.jpg?_r_=34459a43-4fab-376f-f8e0-08759cda2e16" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数字电路于逻辑</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/05/%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/21/jHkgUWLVo2lnuYF.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">爬虫教程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2022/12/29/JDBC%E6%95%99%E7%A8%8B/" title="JDBC教程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/12/29/oFUefWrVSE1Zi9C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-12-29</div><div class="title">JDBC教程</div></div></a></div><div><a href="/2023/01/31/Javaweb%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/" title="Javaweb查询分页问题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/19/MkDHwvYu5p8XLBy.jpg?_r_=a38cb606-c4b8-437c-1fd7-f7dd5653a06b" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-01-31</div><div class="title">Javaweb查询分页问题</div></div></a></div><div><a href="/2023/01/22/JavaWeb/" title="JavaWeb"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/21/Sm8lFrjtzUkihVy.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-01-22</div><div class="title">JavaWeb</div></div></a></div><div><a href="/2022/09/16/Java%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/" title="Java邮件发送"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/21/Sm8lFrjtzUkihVy.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-09-16</div><div class="title">Java邮件发送</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display: none">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Nuyoah</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/zjhinsist" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2152889763@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text"> JAVA笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">2.</span> <span class="toc-text"> 注释需要注意的地方：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text"> 编译需要注意的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">3.1.</span> <span class="toc-text"> 命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text"> 变量分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">3.3.</span> <span class="toc-text"> 基本数据类型之间的运算规则：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text"> String类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.5.</span> <span class="toc-text"> 进制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81"><span class="toc-number">3.6.</span> <span class="toc-text"> 源码 反码 补码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%98%AFboolean%E7%B1%BB%E5%9E%8B%E7%9A%84"><span class="toc-number">3.7.</span> <span class="toc-text"> 逻辑运算符：（操作对象都是boolean类型的）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E9%94%AE%E7%9B%98%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">3.8.</span> <span class="toc-text"> 从键盘获取数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#math%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.9.</span> <span class="toc-text"> Math类中的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.10.</span> <span class="toc-text"> 数组的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text"> 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%99%A8%E4%BB%A3%E7%A0%81%E5%9D%97%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text"> Java类及类的成员（属性，方法，构造器；代码块，内部类）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 方法的重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.1.1.</span> <span class="toc-text"> 重载和重写的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 子类对象实例化的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">4.1.3.</span> <span class="toc-text"> 代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.1.4.</span> <span class="toc-text"> 内部类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.1.5.</span> <span class="toc-text"> Object类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%8F%AF%E6%89%A9%E5%B1%95%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.6.</span> <span class="toc-text"> Vector可扩展数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E7%A7%B0%E5%B0%81%E8%A3%85%E6%80%A7%E7%BB%A7%E6%89%BF%E6%80%A7%E5%A4%9A%E6%80%81%E6%80%A7%E6%8A%BD%E8%B1%A1%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text"> 面向对象的三大特称（封装性，继承性，多态性（抽象性））</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%80%E5%B0%81%E8%A3%85%E5%92%8C%E9%9A%90%E8%97%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 面向对象的特征一：封装和隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 继承性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 多态性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%85%B3%E9%94%AE%E5%AD%97thissuper-static-finalabstractinterface"><span class="toc-number">4.3.</span> <span class="toc-text"> 其他关键字this，super， static ,final,abstract,interface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text"> this关键字的使用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#package%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text"> package关键字的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text"> import关键字的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.4.</span> <span class="toc-text"> super关键字的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.5.</span> <span class="toc-text"> instanceof关键字的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.6.</span> <span class="toc-text"> static关键字的使用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.7.</span> <span class="toc-text"> final关键字的使用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95abstract%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.3.8.</span> <span class="toc-text"> 抽象类与抽象方法（abstract关键字）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="toc-number">4.3.8.1.</span> <span class="toc-text"> 匿名类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.8.2.</span> <span class="toc-text"> 多态的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3interface"><span class="toc-number">4.3.9.</span> <span class="toc-text"> 接口（interface）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text"> 设计模式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%8F%91"><span class="toc-number">4.5.</span> <span class="toc-text"> main函数的使用方发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.6.</span> <span class="toc-text"> 赋值的先后顺序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AF%8F%E5%A4%A9%E4%B8%80%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text"> 每天一考</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text"> 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text"> 异常体系结构：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text"> 异常处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80try-catch-finally"><span class="toc-number">6.2.1.</span> <span class="toc-text"> 方式一：try - catch - finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8Cthrows-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.2.</span> <span class="toc-text"> 方式二：throws + 异常类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99%E4%B9%8B%E4%B8%80"><span class="toc-number">6.2.3.</span> <span class="toc-text"> 方法重写规则之一：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text"> 自定义异常类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">6.4.</span> <span class="toc-text"> 异常的测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">6.5.</span> <span class="toc-text"> 面试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text"> 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#thread%E7%B1%BB%E7%9A%84%E6%9C%89%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text"> Thread类的有关方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">7.2.</span> <span class="toc-text"> 线程的调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">7.3.</span> <span class="toc-text"> 线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">7.4.</span> <span class="toc-text"> 线程的同步（线程安全）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">7.5.</span> <span class="toc-text"> 线程的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk50%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F"><span class="toc-number">7.6.</span> <span class="toc-text"> JDK5.0新增线程方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text"> 常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-number">8.1.</span> <span class="toc-text"> 字符串相关的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">8.1.1.</span> <span class="toc-text"> String对象的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">8.1.2.</span> <span class="toc-text"> String对象的创建：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.3.</span> <span class="toc-text"> String常用方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.4.</span> <span class="toc-text"> String与基本数据类型的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.5.</span> <span class="toc-text"> String与字符数组转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E4%B8%8E%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.6.</span> <span class="toc-text"> String与字节数组进行转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stringbuffer-%E5%92%8C-stringbuilder%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.1.7.</span> <span class="toc-text"> StringBuffer 和 StringBuilder的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E4%BA%8B%E4%BB%B6api"><span class="toc-number">8.2.</span> <span class="toc-text"> 日期和事件API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk8-%E4%BB%A5%E5%89%8D"><span class="toc-number">8.2.1.</span> <span class="toc-text"> JDK8 以前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk8%E4%BB%A5%E5%90%8E"><span class="toc-number">8.2.2.</span> <span class="toc-text"> JDK8以后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9E%AC%E6%97%B6instant%E7%B1%BB"><span class="toc-number">8.2.3.</span> <span class="toc-text"> 瞬时：instant类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%90%E6%97%A5%E6%9C%9F%E6%88%96%E6%97%B6%E9%97%B4"><span class="toc-number">8.2.4.</span> <span class="toc-text"> 格式化与解析日期或时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96api"><span class="toc-number">8.2.5.</span> <span class="toc-text"> 其他API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.2.6.</span> <span class="toc-text"> 与传统的日期处理相互转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text"> JAVA比较器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#system%E7%B1%BBmath%E7%B1%BBbiginteger%E4%B8%8Ebigdecimal"><span class="toc-number">8.4.</span> <span class="toc-text"> System类，Math类，BigInteger与BigDecimal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#system%E7%B1%BB"><span class="toc-number">8.4.1.</span> <span class="toc-text"> System类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#math%E7%B1%BB"><span class="toc-number">8.4.2.</span> <span class="toc-text"> Math类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#biginteger%E7%B1%BB"><span class="toc-number">8.4.3.</span> <span class="toc-text"> BigInteger类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bigdecimal%E7%B1%BB"><span class="toc-number">8.4.4.</span> <span class="toc-text"> BigDecimal类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.</span> <span class="toc-text"> 枚举与注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text"> 枚举类的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3annotation"><span class="toc-number">9.2.</span> <span class="toc-text"> 注解（Annotation）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">10.</span> <span class="toc-text"> 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">10.1.</span> <span class="toc-text"> 出现的背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collection"><span class="toc-number">10.2.</span> <span class="toc-text"> Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iterator%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.2.1.</span> <span class="toc-text"> Iterator的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach"><span class="toc-number">10.2.2.</span> <span class="toc-text"> foreach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.2.3.</span> <span class="toc-text"> List接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.2.4.</span> <span class="toc-text"> set接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-number">10.3.</span> <span class="toc-text"> Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%8E%8C%E6%8F%A1%E8%A6%81%E6%B1%82"><span class="toc-number">10.4.</span> <span class="toc-text"> 集合掌握要求</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text"> 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.</span> <span class="toc-text"> 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.2.</span> <span class="toc-text"> 泛型的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">11.3.</span> <span class="toc-text"> 泛型类，泛型接口，泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.3.1.</span> <span class="toc-text"> 泛型类，泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">11.3.2.</span> <span class="toc-text"> 泛型方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#io%E6%B5%81%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text"> IO流原理及流的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#file%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">12.1.</span> <span class="toc-text"> File类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">12.1.1.</span> <span class="toc-text"> 常用构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">12.1.2.</span> <span class="toc-text"> 常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%B5%81"><span class="toc-number">12.2.</span> <span class="toc-text"> IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E8%AF%BB%E5%85%A5"><span class="toc-number">12.2.1.</span> <span class="toc-text"> 字符流的读入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-number">12.2.2.</span> <span class="toc-text"> 字符流的输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E8%AF%BB%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">12.2.3.</span> <span class="toc-text"> 字节流的读入和输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">12.2.4.</span> <span class="toc-text"> 缓冲流的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">12.2.5.</span> <span class="toc-text"> 转换流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">12.2.6.</span> <span class="toc-text"> 标准输入输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">12.2.7.</span> <span class="toc-text"> 打印流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">12.2.8.</span> <span class="toc-text"> 数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-number">12.2.9.</span> <span class="toc-text"> 对象流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">12.2.10.</span> <span class="toc-text"> 随机存取文件流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nio2%E4%B8%ADpath-pathsfiles%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">12.2.11.</span> <span class="toc-text"> NIO.2中Path， Paths，Files类的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text"> 网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A6%81%E7%B4%A0"><span class="toc-number">13.1.</span> <span class="toc-text"> 网络通讯中的两个要素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ip%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">13.1.1.</span> <span class="toc-text"> IP和端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE"><span class="toc-number">13.1.2.</span> <span class="toc-text"> 网络通讯协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">13.2.</span> <span class="toc-text"> TCP网络编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">13.3.</span> <span class="toc-text"> UDP网络编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#url%E7%BC%96%E7%A8%8B"><span class="toc-number">13.4.</span> <span class="toc-text"> URL编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">14.</span> <span class="toc-text"> 反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">14.1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">14.2.</span> <span class="toc-text"> 类的加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.3.</span> <span class="toc-text"> 创建运行时类对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="toc-number">14.4.</span> <span class="toc-text"> 获取运行时类的完整结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="toc-number">14.5.</span> <span class="toc-text"> 调用运行时类的指定结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">14.6.</span> <span class="toc-text"> 动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-number">14.6.1.</span> <span class="toc-text"> 静态代理功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-2"><span class="toc-number">14.6.2.</span> <span class="toc-text"> 动态代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">15.</span> <span class="toc-text"> Java8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">15.1.</span> <span class="toc-text"> Lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.2.</span> <span class="toc-text"> 函数式接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">15.3.</span> <span class="toc-text"> 方法引用与构造器引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">15.3.1.</span> <span class="toc-text"> 方法引用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">15.3.2.</span> <span class="toc-text"> 构造器引用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#streamapi"><span class="toc-number">15.4.</span> <span class="toc-text"> StreamAPI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#streamapi%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">15.4.1.</span> <span class="toc-text"> StreamAPI实例化的四种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stream%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">15.4.2.</span> <span class="toc-text"> Stream的中间操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">15.4.3.</span> <span class="toc-text"> 终止操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#optional%E7%B1%BB"><span class="toc-number">15.4.4.</span> <span class="toc-text"> Optional类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java91011%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">16.</span> <span class="toc-text"> Java9，10，11新特性</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/30/LocalDate%E4%B8%8ELocalTime%E4%B8%8ELocalDateTime%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/" title="LocalDate与LocalTime与LocalDateTime的区别与联系"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/11/PRhut51DVxg9XBc.jpg?_r_=02db7499-72ba-2304-866d-b5c2b561abcc" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LocalDate与LocalTime与LocalDateTime的区别与联系"/></a><div class="content"><a class="title" href="/2025/12/30/LocalDate%E4%B8%8ELocalTime%E4%B8%8ELocalDateTime%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/" title="LocalDate与LocalTime与LocalDateTime的区别与联系">LocalDate与LocalTime与LocalDateTime的区别与联系</a><time datetime="2025-12-30T14:29:30.000Z" title="发表于 2025-12-30 22:29:30">2025-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/17/HttpServletRequest%E4%B8%ADInputStream%E8%AF%BB%E5%8F%96%E9%97%AE%E9%A2%98/" title="HttpServletRequest中InputStream读取问题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/10/An5KBXLNYlODop3.jpg?_r_=2c4d7584-e768-bb6c-3a0a-5ad27f948644" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HttpServletRequest中InputStream读取问题"/></a><div class="content"><a class="title" href="/2025/02/17/HttpServletRequest%E4%B8%ADInputStream%E8%AF%BB%E5%8F%96%E9%97%AE%E9%A2%98/" title="HttpServletRequest中InputStream读取问题">HttpServletRequest中InputStream读取问题</a><time datetime="2025-02-17T13:21:05.000Z" title="发表于 2025-02-17 21:21:05">2025-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/23/contains%E5%92%8Cfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB/" title="contains和for循环的区别"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/19/v4brSR2Dn3BjXpt.jpg?_r_=e0547e9c-26e6-a1ca-6f51-0d079d6c85a3" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="contains和for循环的区别"/></a><div class="content"><a class="title" href="/2024/11/23/contains%E5%92%8Cfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB/" title="contains和for循环的区别">contains和for循环的区别</a><time datetime="2024-11-23T13:08:43.000Z" title="发表于 2024-11-23 21:08:43">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/27/%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/" title="文件的上传和下载"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s3.bmp.ovh/imgs/2022/11/08/3b73e41bdfc1757c.png?_r_=72c3578e-ffe7-8573-6764-dc218b3f49ff" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文件的上传和下载"/></a><div class="content"><a class="title" href="/2024/10/27/%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/" title="文件的上传和下载">文件的上传和下载</a><time datetime="2024-10-27T01:50:10.000Z" title="发表于 2024-10-27 09:50:10">2024-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/15/SpringSecurity%E5%A4%8D%E4%B9%A0/" title="SpringSecurity"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/10/1dfka8LsM9ZKpVc.jpg?_r_=46ac48e8-86c9-d59d-624d-fef0a432f8c9" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringSecurity"/></a><div class="content"><a class="title" href="/2024/10/15/SpringSecurity%E5%A4%8D%E4%B9%A0/" title="SpringSecurity">SpringSecurity</a><time datetime="2024-10-15T00:39:29.000Z" title="发表于 2024-10-15 08:39:29">2024-10-15</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" href="/docs/">文档</a><a class="footer-item" title="源码" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu">源码</a><a class="footer-item" title="更新日志" href="/update/">更新日志</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Nuyoah" target="_blank">Nuyoah</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">88</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">10</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://262259.xyz/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" href="https://262259.xyz/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s1.ax1x.com/2022/11/27/zUFla6.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">管理</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://qexo.262259.xyz/" title="博客后端"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://unpkg.com/qexo-static@1.4.0/assets/img/brand/qexo.png" alt="博客后端"/><span class="back-menu-item-text">博客后端</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Gitee/" style="font-size: 0.88rem;">Gitee<sup>1</sup></a><a href="/tags/JAVA/" style="font-size: 0.88rem; font-weight: 500; color: var(--anzhiyu-lighttext)">JAVA<sup>5</sup></a><a href="/tags/JS/" style="font-size: 0.88rem;">JS<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>1</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>7</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>2</sup></a><a href="/tags/hexo/" style="font-size: 0.88rem;">hexo<sup>4</sup></a><a href="/tags/win10/" style="font-size: 0.88rem;">win10<sup>1</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/" style="font-size: 0.88rem;">个人日记<sup>1</sup></a><a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 0.88rem;">人工智能<sup>15</sup></a><a href="/tags/%E5%B7%A5%E4%BD%9C/" style="font-size: 0.88rem;">工作<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%BA%8E%E9%80%BB%E8%BE%91/" style="font-size: 0.88rem;">数字电路于逻辑<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" style="font-size: 0.88rem;">算法实现<sup>12</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">计算机基础<sup>13</sup></a></div></div><hr/></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开/关闭中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版/本站右键菜单</div></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Nuyoah 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.262259.xyz/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.262259.xyz/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.262259.xyz/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>